<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>zig/WindowsSdk.zig - source view</title>
    <link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAgklEQVR4AWMYWuD7EllJIM4G4g4g5oIJ/odhOJ8wToOxSTXgNxDHoeiBMfA4+wGShjyYOCkG/IGqWQziEzYAoUAeiF9D5U+DxEg14DRU7jWIT5IBIOdCxf+A+CQZAAoopEB7QJwBCBwHiip8UYmRdrAlDpIMgApwQZNnNii5Dq0MBgCxxycBnwEd+wAAAABJRU5ErkJggg==">
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style>
      body{
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        margin: 0;
        line-height: 1.5;
      }

      pre > code {
        display: block;
        overflow: auto;
        line-height: normal;
        margin: 0em;
      }
      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #005C7A;
      }
      .tok-comment {
          color: #545454;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #005C5C;
      }
      .tok-number {
          color: #005C5C;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }
      pre {
        counter-reset: line;
      }
      pre .line:before {
        counter-increment: line;
        content: counter(line);
        display: inline-block;
        padding-right: 1em;
        width: 2em;
        text-align: right;
        color: #999;
      }
      
      .line {
        width: 100%;
        display: inline-block;
      }
      .line:target {
        border-top: 1px solid #ccc;
        border-bottom: 1px solid #ccc;
        background: #fafafa;
      }

      @media (prefers-color-scheme: dark) {
        body{
            background:#222;
            color: #ccc;
        }
        pre > code {
            color: #ccc;
            background: #222;
            border: unset;
        }
        .line:target {
            border-top: 1px solid #444;
            border-bottom: 1px solid #444;
            background: #333;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
</head>
<body>
<pre><code><span class="line" id="L1">windows10sdk: ?Windows10Sdk,</span>
<span class="line" id="L2">windows81sdk: ?Windows81Sdk,</span>
<span class="line" id="L3">msvc_lib_dir: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L4"></span>
<span class="line" id="L5"><span class="tok-kw">const</span> WindowsSdk = <span class="tok-builtin">@This</span>();</span>
<span class="line" id="L6"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);</span>
<span class="line" id="L7"><span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);</span>
<span class="line" id="L8"></span>
<span class="line" id="L9"><span class="tok-kw">const</span> windows = std.os.windows;</span>
<span class="line" id="L10"><span class="tok-kw">const</span> RRF = windows.advapi32.RRF;</span>
<span class="line" id="L11"></span>
<span class="line" id="L12"><span class="tok-kw">const</span> WINDOWS_KIT_REG_KEY = <span class="tok-str">&quot;SOFTWARE\\Microsoft\\Windows Kits\\Installed Roots&quot;</span>;</span>
<span class="line" id="L13"></span>
<span class="line" id="L14"><span class="tok-comment">// https://learn.microsoft.com/en-us/windows/win32/msi/productversion</span>
</span>
<span class="line" id="L15"><span class="tok-kw">const</span> version_major_minor_max_length = <span class="tok-str">&quot;255.255&quot;</span>.len;</span>
<span class="line" id="L16"><span class="tok-comment">// note(bratishkaerik): i think ProductVersion in registry (created by Visual Studio installer) also follows this rule</span>
</span>
<span class="line" id="L17"><span class="tok-kw">const</span> product_version_max_length = version_major_minor_max_length + <span class="tok-str">&quot;.65535&quot;</span>.len;</span>
<span class="line" id="L18"></span>
<span class="line" id="L19"><span class="tok-comment">/// Find path and version of Windows 10 SDK and Windows 8.1 SDK, and find path to MSVC's `lib/` directory.</span></span>
<span class="line" id="L20"><span class="tok-comment">/// Caller owns the result's fields.</span></span>
<span class="line" id="L21"><span class="tok-comment">/// After finishing work, call `free(allocator)`.</span></span>
<span class="line" id="L22"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">find</span>(allocator: std.mem.Allocator) <span class="tok-kw">error</span>{ OutOfMemory, NotFound, PathTooLong }!WindowsSdk {</span>
<span class="line" id="L23">    <span class="tok-kw">if</span> (builtin.os.tag != .windows) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotFound;</span>
<span class="line" id="L24"></span>
<span class="line" id="L25">    <span class="tok-comment">//note(dimenus): If this key doesn't exist, neither the Win 8 SDK nor the Win 10 SDK is installed</span>
</span>
<span class="line" id="L26">    <span class="tok-kw">const</span> roots_key = RegistryWtf8.openKey(windows.HKEY_LOCAL_MACHINE, WINDOWS_KIT_REG_KEY) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L27">        <span class="tok-kw">error</span>.KeyNotFound =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotFound,</span>
<span class="line" id="L28">    };</span>
<span class="line" id="L29">    <span class="tok-kw">defer</span> roots_key.closeKey();</span>
<span class="line" id="L30"></span>
<span class="line" id="L31">    <span class="tok-kw">const</span> windows10sdk: ?Windows10Sdk = blk: {</span>
<span class="line" id="L32">        <span class="tok-kw">const</span> windows10sdk = Windows10Sdk.find(allocator) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L33">            <span class="tok-kw">error</span>.Windows10SdkNotFound,</span>
<span class="line" id="L34">            <span class="tok-kw">error</span>.PathTooLong,</span>
<span class="line" id="L35">            <span class="tok-kw">error</span>.VersionTooLong,</span>
<span class="line" id="L36">            =&gt; <span class="tok-kw">break</span> :blk <span class="tok-null">null</span>,</span>
<span class="line" id="L37">            <span class="tok-kw">error</span>.OutOfMemory =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory,</span>
<span class="line" id="L38">        };</span>
<span class="line" id="L39">        <span class="tok-kw">const</span> is_valid_version = windows10sdk.isValidVersion();</span>
<span class="line" id="L40">        <span class="tok-kw">if</span> (!is_valid_version) <span class="tok-kw">break</span> :blk <span class="tok-null">null</span>;</span>
<span class="line" id="L41">        <span class="tok-kw">break</span> :blk windows10sdk;</span>
<span class="line" id="L42">    };</span>
<span class="line" id="L43">    <span class="tok-kw">errdefer</span> <span class="tok-kw">if</span> (windows10sdk) |*w| w.free(allocator);</span>
<span class="line" id="L44"></span>
<span class="line" id="L45">    <span class="tok-kw">const</span> windows81sdk: ?Windows81Sdk = blk: {</span>
<span class="line" id="L46">        <span class="tok-kw">const</span> windows81sdk = Windows81Sdk.find(allocator, &amp;roots_key) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L47">            <span class="tok-kw">error</span>.Windows81SdkNotFound =&gt; <span class="tok-kw">break</span> :blk <span class="tok-null">null</span>,</span>
<span class="line" id="L48">            <span class="tok-kw">error</span>.PathTooLong =&gt; <span class="tok-kw">break</span> :blk <span class="tok-null">null</span>,</span>
<span class="line" id="L49">            <span class="tok-kw">error</span>.VersionTooLong =&gt; <span class="tok-kw">break</span> :blk <span class="tok-null">null</span>,</span>
<span class="line" id="L50">            <span class="tok-kw">error</span>.OutOfMemory =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory,</span>
<span class="line" id="L51">        };</span>
<span class="line" id="L52">        <span class="tok-comment">// no check</span>
</span>
<span class="line" id="L53">        <span class="tok-kw">break</span> :blk windows81sdk;</span>
<span class="line" id="L54">    };</span>
<span class="line" id="L55">    <span class="tok-kw">errdefer</span> <span class="tok-kw">if</span> (windows81sdk) |*w| w.free(allocator);</span>
<span class="line" id="L56"></span>
<span class="line" id="L57">    <span class="tok-kw">const</span> msvc_lib_dir: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = MsvcLibDir.find(allocator) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L58">        <span class="tok-kw">error</span>.MsvcLibDirNotFound =&gt; <span class="tok-null">null</span>,</span>
<span class="line" id="L59">        <span class="tok-kw">error</span>.OutOfMemory =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory,</span>
<span class="line" id="L60">    };</span>
<span class="line" id="L61">    <span class="tok-kw">errdefer</span> allocator.free(msvc_lib_dir);</span>
<span class="line" id="L62"></span>
<span class="line" id="L63">    <span class="tok-kw">return</span> WindowsSdk{</span>
<span class="line" id="L64">        .windows10sdk = windows10sdk,</span>
<span class="line" id="L65">        .windows81sdk = windows81sdk,</span>
<span class="line" id="L66">        .msvc_lib_dir = msvc_lib_dir,</span>
<span class="line" id="L67">    };</span>
<span class="line" id="L68">}</span>
<span class="line" id="L69"></span>
<span class="line" id="L70"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">free</span>(self: *<span class="tok-kw">const</span> WindowsSdk, allocator: std.mem.Allocator) <span class="tok-type">void</span> {</span>
<span class="line" id="L71">    <span class="tok-kw">if</span> (self.windows10sdk) |*w10sdk| {</span>
<span class="line" id="L72">        w10sdk.free(allocator);</span>
<span class="line" id="L73">    }</span>
<span class="line" id="L74">    <span class="tok-kw">if</span> (self.windows81sdk) |*w81sdk| {</span>
<span class="line" id="L75">        w81sdk.free(allocator);</span>
<span class="line" id="L76">    }</span>
<span class="line" id="L77">    <span class="tok-kw">if</span> (self.msvc_lib_dir) |msvc_lib_dir| {</span>
<span class="line" id="L78">        allocator.free(msvc_lib_dir);</span>
<span class="line" id="L79">    }</span>
<span class="line" id="L80">}</span>
<span class="line" id="L81"></span>
<span class="line" id="L82"><span class="tok-comment">/// Iterates via `iterator` and collects all folders with names starting with `optional_prefix`</span></span>
<span class="line" id="L83"><span class="tok-comment">/// and similar to SemVer. Returns slice of folder names sorted in descending order.</span></span>
<span class="line" id="L84"><span class="tok-comment">/// Caller owns result.</span></span>
<span class="line" id="L85"><span class="tok-kw">fn</span> <span class="tok-fn">iterateAndFilterBySemVer</span>(</span>
<span class="line" id="L86">    iterator: *std.fs.Dir.Iterator,</span>
<span class="line" id="L87">    allocator: std.mem.Allocator,</span>
<span class="line" id="L88">    <span class="tok-kw">comptime</span> optional_prefix: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L89">) <span class="tok-kw">error</span>{ OutOfMemory, VersionNotFound }![][]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L90">    <span class="tok-kw">var</span> dirs_filtered_list = std.ArrayList([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>).init(allocator);</span>
<span class="line" id="L91">    <span class="tok-kw">errdefer</span> {</span>
<span class="line" id="L92">        <span class="tok-kw">for</span> (dirs_filtered_list.items) |filtered_dir| allocator.free(filtered_dir);</span>
<span class="line" id="L93">        dirs_filtered_list.deinit();</span>
<span class="line" id="L94">    }</span>
<span class="line" id="L95"></span>
<span class="line" id="L96">    <span class="tok-kw">var</span> normalized_name_buf: [std.fs.MAX_NAME_BYTES + <span class="tok-str">&quot;.0+build.0&quot;</span>.len]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L97">    <span class="tok-kw">var</span> normalized_name_fbs = std.io.fixedBufferStream(&amp;normalized_name_buf);</span>
<span class="line" id="L98">    <span class="tok-kw">const</span> normalized_name_w = normalized_name_fbs.writer();</span>
<span class="line" id="L99">    iterate_folder: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) : (normalized_name_fbs.reset()) {</span>
<span class="line" id="L100">        <span class="tok-kw">const</span> maybe_entry = iterator.next() <span class="tok-kw">catch</span> <span class="tok-kw">continue</span> :iterate_folder;</span>
<span class="line" id="L101">        <span class="tok-kw">const</span> entry = maybe_entry <span class="tok-kw">orelse</span> <span class="tok-kw">break</span> :iterate_folder;</span>
<span class="line" id="L102"></span>
<span class="line" id="L103">        <span class="tok-kw">if</span> (entry.kind != .directory)</span>
<span class="line" id="L104">            <span class="tok-kw">continue</span> :iterate_folder;</span>
<span class="line" id="L105"></span>
<span class="line" id="L106">        <span class="tok-comment">// invalidated on next iteration</span>
</span>
<span class="line" id="L107">        <span class="tok-kw">const</span> subfolder_name = blk: {</span>
<span class="line" id="L108">            <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> optional_prefix) |prefix| {</span>
<span class="line" id="L109">                <span class="tok-kw">if</span> (!std.mem.startsWith(<span class="tok-type">u8</span>, entry.name, prefix)) <span class="tok-kw">continue</span> :iterate_folder;</span>
<span class="line" id="L110">                <span class="tok-kw">break</span> :blk entry.name[prefix.len..];</span>
<span class="line" id="L111">            } <span class="tok-kw">else</span> <span class="tok-kw">break</span> :blk entry.name;</span>
<span class="line" id="L112">        };</span>
<span class="line" id="L113"></span>
<span class="line" id="L114">        { <span class="tok-comment">// check if subfolder name looks similar to SemVer</span>
</span>
<span class="line" id="L115">            <span class="tok-kw">switch</span> (std.mem.count(<span class="tok-type">u8</span>, subfolder_name, <span class="tok-str">&quot;.&quot;</span>)) {</span>
<span class="line" id="L116">                <span class="tok-number">0</span> =&gt; normalized_name_w.print(<span class="tok-str">&quot;{s}.0.0+build.0&quot;</span>, .{subfolder_name}) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>, <span class="tok-comment">// 17 =&gt; 17.0.0+build.0</span>
</span>
<span class="line" id="L117">                <span class="tok-number">1</span> =&gt; <span class="tok-kw">if</span> (std.mem.indexOfScalar(<span class="tok-type">u8</span>, subfolder_name, <span class="tok-str">'_'</span>)) |underscore_pos| blk: { <span class="tok-comment">// 17.0_9e9cbb98 =&gt; 17.0.1+build.9e9cbb98</span>
</span>
<span class="line" id="L118">                    <span class="tok-kw">var</span> subfolder_name_tmp_copy_buf: [std.fs.MAX_NAME_BYTES]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L119">                    <span class="tok-kw">const</span> subfolder_name_tmp_copy = subfolder_name_tmp_copy_buf[<span class="tok-number">0</span>..subfolder_name.len];</span>
<span class="line" id="L120">                    <span class="tok-builtin">@memcpy</span>(subfolder_name_tmp_copy, subfolder_name);</span>
<span class="line" id="L121"></span>
<span class="line" id="L122">                    subfolder_name_tmp_copy[underscore_pos] = <span class="tok-str">'.'</span>; <span class="tok-comment">// 17.0_9e9cbb98 =&gt; 17.0.9e9cbb98</span>
</span>
<span class="line" id="L123">                    <span class="tok-kw">var</span> subfolder_name_parts = std.mem.splitScalar(<span class="tok-type">u8</span>, subfolder_name_tmp_copy, <span class="tok-str">'.'</span>); <span class="tok-comment">// [ 17, 0, 9e9cbb98 ]</span>
</span>
<span class="line" id="L124"></span>
<span class="line" id="L125">                    <span class="tok-kw">const</span> first = subfolder_name_parts.first(); <span class="tok-comment">// 17</span>
</span>
<span class="line" id="L126">                    <span class="tok-kw">const</span> second = subfolder_name_parts.next().?; <span class="tok-comment">// 0</span>
</span>
<span class="line" id="L127">                    <span class="tok-kw">const</span> third = subfolder_name_parts.rest(); <span class="tok-comment">// 9e9cbb98</span>
</span>
<span class="line" id="L128"></span>
<span class="line" id="L129">                    <span class="tok-kw">break</span> :blk normalized_name_w.print(<span class="tok-str">&quot;{s}.{s}.1+build.{s}&quot;</span>, .{ first, second, third }) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>; <span class="tok-comment">// [ 17, 0, 9e9cbb98 ] =&gt; 17.0.1+build.9e9cbb98</span>
</span>
<span class="line" id="L130">                } <span class="tok-kw">else</span> normalized_name_w.print(<span class="tok-str">&quot;{s}.0+build.0&quot;</span>, .{subfolder_name}) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>, <span class="tok-comment">// 17.0 =&gt; 17.0.0+build.0</span>
</span>
<span class="line" id="L131">                <span class="tok-kw">else</span> =&gt; normalized_name_w.print(<span class="tok-str">&quot;{s}+build.0&quot;</span>, .{subfolder_name}) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>, <span class="tok-comment">// 17.0.0 =&gt; 17.0.0+build.0</span>
</span>
<span class="line" id="L132">            }</span>
<span class="line" id="L133">            <span class="tok-kw">const</span> subfolder_name_normalized: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = normalized_name_fbs.getWritten();</span>
<span class="line" id="L134">            <span class="tok-kw">const</span> sem_ver = std.SemanticVersion.parse(subfolder_name_normalized);</span>
<span class="line" id="L135">            _ = sem_ver <span class="tok-kw">catch</span> <span class="tok-kw">continue</span> :iterate_folder;</span>
<span class="line" id="L136">        }</span>
<span class="line" id="L137">        <span class="tok-comment">// entry.name passed check</span>
</span>
<span class="line" id="L138"></span>
<span class="line" id="L139">        <span class="tok-kw">const</span> subfolder_name_allocated = <span class="tok-kw">try</span> allocator.dupe(<span class="tok-type">u8</span>, subfolder_name);</span>
<span class="line" id="L140">        <span class="tok-kw">errdefer</span> allocator.free(subfolder_name_allocated);</span>
<span class="line" id="L141">        <span class="tok-kw">try</span> dirs_filtered_list.append(subfolder_name_allocated);</span>
<span class="line" id="L142">    }</span>
<span class="line" id="L143"></span>
<span class="line" id="L144">    <span class="tok-kw">const</span> dirs_filtered_slice = <span class="tok-kw">try</span> dirs_filtered_list.toOwnedSlice();</span>
<span class="line" id="L145">    <span class="tok-comment">// Keep in mind that order of these names is not guaranteed by Windows,</span>
</span>
<span class="line" id="L146">    <span class="tok-comment">// so we cannot just reverse or &quot;while (popOrNull())&quot; this ArrayList.</span>
</span>
<span class="line" id="L147">    std.mem.sortUnstable([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, dirs_filtered_slice, {}, <span class="tok-kw">struct</span> {</span>
<span class="line" id="L148">        <span class="tok-kw">fn</span> <span class="tok-fn">desc</span>(_: <span class="tok-type">void</span>, lhs: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, rhs: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">bool</span> {</span>
<span class="line" id="L149">            <span class="tok-kw">return</span> std.mem.order(<span class="tok-type">u8</span>, lhs, rhs) == .gt;</span>
<span class="line" id="L150">        }</span>
<span class="line" id="L151">    }.desc);</span>
<span class="line" id="L152">    <span class="tok-kw">return</span> dirs_filtered_slice;</span>
<span class="line" id="L153">}</span>
<span class="line" id="L154"></span>
<span class="line" id="L155"><span class="tok-kw">const</span> RegistryWtf8 = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L156">    key: windows.HKEY,</span>
<span class="line" id="L157"></span>
<span class="line" id="L158">    <span class="tok-comment">/// Assert that `key` is valid WTF-8 string</span></span>
<span class="line" id="L159">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openKey</span>(hkey: windows.HKEY, key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-kw">error</span>{KeyNotFound}!RegistryWtf8 {</span>
<span class="line" id="L160">        <span class="tok-kw">const</span> key_wtf16le: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span> = key_wtf16le: {</span>
<span class="line" id="L161">            <span class="tok-kw">var</span> key_wtf16le_buf: [RegistryWtf16Le.key_name_max_len]<span class="tok-type">u16</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L162">            <span class="tok-kw">const</span> key_wtf16le_len: <span class="tok-type">usize</span> = std.unicode.wtf8ToWtf16Le(key_wtf16le_buf[<span class="tok-number">0</span>..], key) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L163">                <span class="tok-kw">error</span>.InvalidWtf8 =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L164">            };</span>
<span class="line" id="L165">            key_wtf16le_buf[key_wtf16le_len] = <span class="tok-number">0</span>;</span>
<span class="line" id="L166">            <span class="tok-kw">break</span> :key_wtf16le key_wtf16le_buf[<span class="tok-number">0</span>..key_wtf16le_len :<span class="tok-number">0</span>];</span>
<span class="line" id="L167">        };</span>
<span class="line" id="L168"></span>
<span class="line" id="L169">        <span class="tok-kw">const</span> registry_wtf16le = <span class="tok-kw">try</span> RegistryWtf16Le.openKey(hkey, key_wtf16le);</span>
<span class="line" id="L170">        <span class="tok-kw">return</span> RegistryWtf8{ .key = registry_wtf16le.key };</span>
<span class="line" id="L171">    }</span>
<span class="line" id="L172"></span>
<span class="line" id="L173">    <span class="tok-comment">/// Closes key, after that usage is invalid</span></span>
<span class="line" id="L174">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">closeKey</span>(self: *<span class="tok-kw">const</span> RegistryWtf8) <span class="tok-type">void</span> {</span>
<span class="line" id="L175">        <span class="tok-kw">const</span> return_code_int: windows.HRESULT = windows.advapi32.RegCloseKey(self.key);</span>
<span class="line" id="L176">        <span class="tok-kw">const</span> return_code: windows.Win32Error = <span class="tok-builtin">@enumFromInt</span>(return_code_int);</span>
<span class="line" id="L177">        <span class="tok-kw">switch</span> (return_code) {</span>
<span class="line" id="L178">            .SUCCESS =&gt; {},</span>
<span class="line" id="L179">            <span class="tok-kw">else</span> =&gt; {},</span>
<span class="line" id="L180">        }</span>
<span class="line" id="L181">    }</span>
<span class="line" id="L182"></span>
<span class="line" id="L183">    <span class="tok-comment">/// Get string from registry.</span></span>
<span class="line" id="L184">    <span class="tok-comment">/// Caller owns result.</span></span>
<span class="line" id="L185">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getString</span>(self: *<span class="tok-kw">const</span> RegistryWtf8, allocator: std.mem.Allocator, subkey: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, value_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-kw">error</span>{ OutOfMemory, ValueNameNotFound, NotAString, StringNotFound }![]<span class="tok-type">u8</span> {</span>
<span class="line" id="L186">        <span class="tok-kw">const</span> subkey_wtf16le: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span> = subkey_wtf16le: {</span>
<span class="line" id="L187">            <span class="tok-kw">var</span> subkey_wtf16le_buf: [RegistryWtf16Le.key_name_max_len]<span class="tok-type">u16</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L188">            <span class="tok-kw">const</span> subkey_wtf16le_len: <span class="tok-type">usize</span> = std.unicode.wtf8ToWtf16Le(subkey_wtf16le_buf[<span class="tok-number">0</span>..], subkey) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;</span>
<span class="line" id="L189">            subkey_wtf16le_buf[subkey_wtf16le_len] = <span class="tok-number">0</span>;</span>
<span class="line" id="L190">            <span class="tok-kw">break</span> :subkey_wtf16le subkey_wtf16le_buf[<span class="tok-number">0</span>..subkey_wtf16le_len :<span class="tok-number">0</span>];</span>
<span class="line" id="L191">        };</span>
<span class="line" id="L192"></span>
<span class="line" id="L193">        <span class="tok-kw">const</span> value_name_wtf16le: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span> = value_name_wtf16le: {</span>
<span class="line" id="L194">            <span class="tok-kw">var</span> value_name_wtf16le_buf: [RegistryWtf16Le.value_name_max_len]<span class="tok-type">u16</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L195">            <span class="tok-kw">const</span> value_name_wtf16le_len: <span class="tok-type">usize</span> = std.unicode.wtf8ToWtf16Le(value_name_wtf16le_buf[<span class="tok-number">0</span>..], value_name) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;</span>
<span class="line" id="L196">            value_name_wtf16le_buf[value_name_wtf16le_len] = <span class="tok-number">0</span>;</span>
<span class="line" id="L197">            <span class="tok-kw">break</span> :value_name_wtf16le value_name_wtf16le_buf[<span class="tok-number">0</span>..value_name_wtf16le_len :<span class="tok-number">0</span>];</span>
<span class="line" id="L198">        };</span>
<span class="line" id="L199"></span>
<span class="line" id="L200">        <span class="tok-kw">const</span> registry_wtf16le = RegistryWtf16Le{ .key = self.key };</span>
<span class="line" id="L201">        <span class="tok-kw">const</span> value_wtf16le = <span class="tok-kw">try</span> registry_wtf16le.getString(allocator, subkey_wtf16le, value_name_wtf16le);</span>
<span class="line" id="L202">        <span class="tok-kw">defer</span> allocator.free(value_wtf16le);</span>
<span class="line" id="L203"></span>
<span class="line" id="L204">        <span class="tok-kw">const</span> value_wtf8: []<span class="tok-type">u8</span> = <span class="tok-kw">try</span> std.unicode.wtf16LeToWtf8Alloc(allocator, value_wtf16le);</span>
<span class="line" id="L205">        <span class="tok-kw">errdefer</span> allocator.free(value_wtf8);</span>
<span class="line" id="L206"></span>
<span class="line" id="L207">        <span class="tok-kw">return</span> value_wtf8;</span>
<span class="line" id="L208">    }</span>
<span class="line" id="L209"></span>
<span class="line" id="L210">    <span class="tok-comment">/// Get DWORD (u32) from registry.</span></span>
<span class="line" id="L211">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getDword</span>(self: *<span class="tok-kw">const</span> RegistryWtf8, subkey: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, value_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-kw">error</span>{ ValueNameNotFound, NotADword, DwordTooLong, DwordNotFound }!<span class="tok-type">u32</span> {</span>
<span class="line" id="L212">        <span class="tok-kw">const</span> subkey_wtf16le: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span> = subkey_wtf16le: {</span>
<span class="line" id="L213">            <span class="tok-kw">var</span> subkey_wtf16le_buf: [RegistryWtf16Le.key_name_max_len]<span class="tok-type">u16</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L214">            <span class="tok-kw">const</span> subkey_wtf16le_len: <span class="tok-type">usize</span> = std.unicode.wtf8ToWtf16Le(subkey_wtf16le_buf[<span class="tok-number">0</span>..], subkey) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;</span>
<span class="line" id="L215">            subkey_wtf16le_buf[subkey_wtf16le_len] = <span class="tok-number">0</span>;</span>
<span class="line" id="L216">            <span class="tok-kw">break</span> :subkey_wtf16le subkey_wtf16le_buf[<span class="tok-number">0</span>..subkey_wtf16le_len :<span class="tok-number">0</span>];</span>
<span class="line" id="L217">        };</span>
<span class="line" id="L218"></span>
<span class="line" id="L219">        <span class="tok-kw">const</span> value_name_wtf16le: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span> = value_name_wtf16le: {</span>
<span class="line" id="L220">            <span class="tok-kw">var</span> value_name_wtf16le_buf: [RegistryWtf16Le.value_name_max_len]<span class="tok-type">u16</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L221">            <span class="tok-kw">const</span> value_name_wtf16le_len: <span class="tok-type">usize</span> = std.unicode.wtf8ToWtf16Le(value_name_wtf16le_buf[<span class="tok-number">0</span>..], value_name) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;</span>
<span class="line" id="L222">            value_name_wtf16le_buf[value_name_wtf16le_len] = <span class="tok-number">0</span>;</span>
<span class="line" id="L223">            <span class="tok-kw">break</span> :value_name_wtf16le value_name_wtf16le_buf[<span class="tok-number">0</span>..value_name_wtf16le_len :<span class="tok-number">0</span>];</span>
<span class="line" id="L224">        };</span>
<span class="line" id="L225"></span>
<span class="line" id="L226">        <span class="tok-kw">const</span> registry_wtf16le = RegistryWtf16Le{ .key = self.key };</span>
<span class="line" id="L227">        <span class="tok-kw">return</span> <span class="tok-kw">try</span> registry_wtf16le.getDword(subkey_wtf16le, value_name_wtf16le);</span>
<span class="line" id="L228">    }</span>
<span class="line" id="L229"></span>
<span class="line" id="L230">    <span class="tok-comment">/// Under private space with flags:</span></span>
<span class="line" id="L231">    <span class="tok-comment">/// KEY_QUERY_VALUE and KEY_ENUMERATE_SUB_KEYS.</span></span>
<span class="line" id="L232">    <span class="tok-comment">/// After finishing work, call `closeKey`.</span></span>
<span class="line" id="L233">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">loadFromPath</span>(absolute_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-kw">error</span>{KeyNotFound}!RegistryWtf8 {</span>
<span class="line" id="L234">        <span class="tok-kw">const</span> absolute_path_wtf16le: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span> = absolute_path_wtf16le: {</span>
<span class="line" id="L235">            <span class="tok-kw">var</span> absolute_path_wtf16le_buf: [RegistryWtf16Le.value_name_max_len]<span class="tok-type">u16</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L236">            <span class="tok-kw">const</span> absolute_path_wtf16le_len: <span class="tok-type">usize</span> = std.unicode.wtf8ToWtf16Le(absolute_path_wtf16le_buf[<span class="tok-number">0</span>..], absolute_path) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;</span>
<span class="line" id="L237">            absolute_path_wtf16le_buf[absolute_path_wtf16le_len] = <span class="tok-number">0</span>;</span>
<span class="line" id="L238">            <span class="tok-kw">break</span> :absolute_path_wtf16le absolute_path_wtf16le_buf[<span class="tok-number">0</span>..absolute_path_wtf16le_len :<span class="tok-number">0</span>];</span>
<span class="line" id="L239">        };</span>
<span class="line" id="L240"></span>
<span class="line" id="L241">        <span class="tok-kw">const</span> registry_wtf16le = <span class="tok-kw">try</span> RegistryWtf16Le.loadFromPath(absolute_path_wtf16le);</span>
<span class="line" id="L242">        <span class="tok-kw">return</span> RegistryWtf8{ .key = registry_wtf16le.key };</span>
<span class="line" id="L243">    }</span>
<span class="line" id="L244">};</span>
<span class="line" id="L245"></span>
<span class="line" id="L246"><span class="tok-kw">const</span> RegistryWtf16Le = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L247">    key: windows.HKEY,</span>
<span class="line" id="L248"></span>
<span class="line" id="L249">    <span class="tok-comment">/// Includes root key (f.e. HKEY_LOCAL_MACHINE).</span></span>
<span class="line" id="L250">    <span class="tok-comment">/// https://learn.microsoft.com/en-us/windows/win32/sysinfo/registry-element-size-limits</span></span>
<span class="line" id="L251">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> key_name_max_len = <span class="tok-number">255</span>;</span>
<span class="line" id="L252">    <span class="tok-comment">/// In Unicode characters.</span></span>
<span class="line" id="L253">    <span class="tok-comment">/// https://learn.microsoft.com/en-us/windows/win32/sysinfo/registry-element-size-limits</span></span>
<span class="line" id="L254">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> value_name_max_len = <span class="tok-number">16_383</span>;</span>
<span class="line" id="L255"></span>
<span class="line" id="L256">    <span class="tok-comment">/// Under HKEY_LOCAL_MACHINE with flags:</span></span>
<span class="line" id="L257">    <span class="tok-comment">/// KEY_QUERY_VALUE, KEY_WOW64_32KEY, and KEY_ENUMERATE_SUB_KEYS.</span></span>
<span class="line" id="L258">    <span class="tok-comment">/// After finishing work, call `closeKey`.</span></span>
<span class="line" id="L259">    <span class="tok-kw">fn</span> <span class="tok-fn">openKey</span>(hkey: windows.HKEY, key_wtf16le: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>) <span class="tok-kw">error</span>{KeyNotFound}!RegistryWtf16Le {</span>
<span class="line" id="L260">        <span class="tok-kw">var</span> key: windows.HKEY = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L261">        <span class="tok-kw">const</span> return_code_int: windows.HRESULT = windows.advapi32.RegOpenKeyExW(</span>
<span class="line" id="L262">            hkey,</span>
<span class="line" id="L263">            key_wtf16le,</span>
<span class="line" id="L264">            <span class="tok-number">0</span>,</span>
<span class="line" id="L265">            windows.KEY_QUERY_VALUE | windows.KEY_WOW64_32KEY | windows.KEY_ENUMERATE_SUB_KEYS,</span>
<span class="line" id="L266">            &amp;key,</span>
<span class="line" id="L267">        );</span>
<span class="line" id="L268">        <span class="tok-kw">const</span> return_code: windows.Win32Error = <span class="tok-builtin">@enumFromInt</span>(return_code_int);</span>
<span class="line" id="L269">        <span class="tok-kw">switch</span> (return_code) {</span>
<span class="line" id="L270">            .SUCCESS =&gt; {},</span>
<span class="line" id="L271">            .FILE_NOT_FOUND =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.KeyNotFound,</span>
<span class="line" id="L272"></span>
<span class="line" id="L273">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.KeyNotFound,</span>
<span class="line" id="L274">        }</span>
<span class="line" id="L275">        <span class="tok-kw">return</span> RegistryWtf16Le{ .key = key };</span>
<span class="line" id="L276">    }</span>
<span class="line" id="L277"></span>
<span class="line" id="L278">    <span class="tok-comment">/// Closes key, after that usage is invalid</span></span>
<span class="line" id="L279">    <span class="tok-kw">fn</span> <span class="tok-fn">closeKey</span>(self: *<span class="tok-kw">const</span> RegistryWtf16Le) <span class="tok-type">void</span> {</span>
<span class="line" id="L280">        <span class="tok-kw">const</span> return_code_int: windows.HRESULT = windows.advapi32.RegCloseKey(self.key);</span>
<span class="line" id="L281">        <span class="tok-kw">const</span> return_code: windows.Win32Error = <span class="tok-builtin">@enumFromInt</span>(return_code_int);</span>
<span class="line" id="L282">        <span class="tok-kw">switch</span> (return_code) {</span>
<span class="line" id="L283">            .SUCCESS =&gt; {},</span>
<span class="line" id="L284">            <span class="tok-kw">else</span> =&gt; {},</span>
<span class="line" id="L285">        }</span>
<span class="line" id="L286">    }</span>
<span class="line" id="L287"></span>
<span class="line" id="L288">    <span class="tok-comment">/// Get string ([:0]const u16) from registry.</span></span>
<span class="line" id="L289">    <span class="tok-kw">fn</span> <span class="tok-fn">getString</span>(self: *<span class="tok-kw">const</span> RegistryWtf16Le, allocator: std.mem.Allocator, subkey_wtf16le: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>, value_name_wtf16le: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>) <span class="tok-kw">error</span>{ OutOfMemory, ValueNameNotFound, NotAString, StringNotFound }![]<span class="tok-kw">const</span> <span class="tok-type">u16</span> {</span>
<span class="line" id="L290">        <span class="tok-kw">var</span> actual_type: windows.ULONG = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L291"></span>
<span class="line" id="L292">        <span class="tok-comment">// Calculating length to allocate</span>
</span>
<span class="line" id="L293">        <span class="tok-kw">var</span> value_wtf16le_buf_size: <span class="tok-type">u32</span> = <span class="tok-number">0</span>; <span class="tok-comment">// in bytes, including any terminating NUL character or characters.</span>
</span>
<span class="line" id="L294">        <span class="tok-kw">var</span> return_code_int: windows.HRESULT = windows.advapi32.RegGetValueW(</span>
<span class="line" id="L295">            self.key,</span>
<span class="line" id="L296">            subkey_wtf16le,</span>
<span class="line" id="L297">            value_name_wtf16le,</span>
<span class="line" id="L298">            RRF.RT_REG_SZ,</span>
<span class="line" id="L299">            &amp;actual_type,</span>
<span class="line" id="L300">            <span class="tok-null">null</span>,</span>
<span class="line" id="L301">            &amp;value_wtf16le_buf_size,</span>
<span class="line" id="L302">        );</span>
<span class="line" id="L303"></span>
<span class="line" id="L304">        <span class="tok-comment">// Check returned code and type</span>
</span>
<span class="line" id="L305">        <span class="tok-kw">var</span> return_code: windows.Win32Error = <span class="tok-builtin">@enumFromInt</span>(return_code_int);</span>
<span class="line" id="L306">        <span class="tok-kw">switch</span> (return_code) {</span>
<span class="line" id="L307">            .SUCCESS =&gt; std.debug.assert(value_wtf16le_buf_size != <span class="tok-number">0</span>),</span>
<span class="line" id="L308">            .MORE_DATA =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// We are only reading length</span>
</span>
<span class="line" id="L309">            .FILE_NOT_FOUND =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ValueNameNotFound,</span>
<span class="line" id="L310">            .INVALID_PARAMETER =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// We didn't combine RRF.SUBKEY_WOW6464KEY and RRF.SUBKEY_WOW6432KEY</span>
</span>
<span class="line" id="L311">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.StringNotFound,</span>
<span class="line" id="L312">        }</span>
<span class="line" id="L313">        <span class="tok-kw">switch</span> (actual_type) {</span>
<span class="line" id="L314">            windows.REG.SZ =&gt; {},</span>
<span class="line" id="L315">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotAString,</span>
<span class="line" id="L316">        }</span>
<span class="line" id="L317"></span>
<span class="line" id="L318">        <span class="tok-kw">const</span> value_wtf16le_buf: []<span class="tok-type">u16</span> = <span class="tok-kw">try</span> allocator.alloc(<span class="tok-type">u16</span>, std.math.divCeil(<span class="tok-type">u32</span>, value_wtf16le_buf_size, <span class="tok-number">2</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>);</span>
<span class="line" id="L319">        <span class="tok-kw">errdefer</span> allocator.free(value_wtf16le_buf);</span>
<span class="line" id="L320"></span>
<span class="line" id="L321">        return_code_int = windows.advapi32.RegGetValueW(</span>
<span class="line" id="L322">            self.key,</span>
<span class="line" id="L323">            subkey_wtf16le,</span>
<span class="line" id="L324">            value_name_wtf16le,</span>
<span class="line" id="L325">            RRF.RT_REG_SZ,</span>
<span class="line" id="L326">            &amp;actual_type,</span>
<span class="line" id="L327">            value_wtf16le_buf.ptr,</span>
<span class="line" id="L328">            &amp;value_wtf16le_buf_size,</span>
<span class="line" id="L329">        );</span>
<span class="line" id="L330"></span>
<span class="line" id="L331">        <span class="tok-comment">// Check returned code and (just in case) type again.</span>
</span>
<span class="line" id="L332">        return_code = <span class="tok-builtin">@enumFromInt</span>(return_code_int);</span>
<span class="line" id="L333">        <span class="tok-kw">switch</span> (return_code) {</span>
<span class="line" id="L334">            .SUCCESS =&gt; {},</span>
<span class="line" id="L335">            .MORE_DATA =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Calculated first time length should be enough, even overestimated</span>
</span>
<span class="line" id="L336">            .FILE_NOT_FOUND =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ValueNameNotFound,</span>
<span class="line" id="L337">            .INVALID_PARAMETER =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// We didn't combine RRF.SUBKEY_WOW6464KEY and RRF.SUBKEY_WOW6432KEY</span>
</span>
<span class="line" id="L338">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.StringNotFound,</span>
<span class="line" id="L339">        }</span>
<span class="line" id="L340">        <span class="tok-kw">switch</span> (actual_type) {</span>
<span class="line" id="L341">            windows.REG.SZ =&gt; {},</span>
<span class="line" id="L342">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotAString,</span>
<span class="line" id="L343">        }</span>
<span class="line" id="L344"></span>
<span class="line" id="L345">        <span class="tok-kw">const</span> value_wtf16le: []<span class="tok-kw">const</span> <span class="tok-type">u16</span> = value_wtf16le: {</span>
<span class="line" id="L346">            <span class="tok-comment">// note(bratishkaerik): somehow returned value in `buf_len` is overestimated by Windows and contains extra space</span>
</span>
<span class="line" id="L347">            <span class="tok-comment">// we will just search for zero termination and forget length</span>
</span>
<span class="line" id="L348">            <span class="tok-comment">// Windows sure is strange</span>
</span>
<span class="line" id="L349">            <span class="tok-kw">const</span> value_wtf16le_overestimated: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span> = <span class="tok-builtin">@ptrCast</span>(value_wtf16le_buf.ptr);</span>
<span class="line" id="L350">            <span class="tok-kw">break</span> :value_wtf16le std.mem.span(value_wtf16le_overestimated);</span>
<span class="line" id="L351">        };</span>
<span class="line" id="L352"></span>
<span class="line" id="L353">        _ = allocator.resize(value_wtf16le_buf, value_wtf16le.len);</span>
<span class="line" id="L354">        <span class="tok-kw">return</span> value_wtf16le;</span>
<span class="line" id="L355">    }</span>
<span class="line" id="L356"></span>
<span class="line" id="L357">    <span class="tok-comment">/// Get DWORD (u32) from registry.</span></span>
<span class="line" id="L358">    <span class="tok-kw">fn</span> <span class="tok-fn">getDword</span>(self: *<span class="tok-kw">const</span> RegistryWtf16Le, subkey_wtf16le: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>, value_name_wtf16le: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>) <span class="tok-kw">error</span>{ ValueNameNotFound, NotADword, DwordTooLong, DwordNotFound }!<span class="tok-type">u32</span> {</span>
<span class="line" id="L359">        <span class="tok-kw">var</span> actual_type: windows.ULONG = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L360">        <span class="tok-kw">var</span> reg_size: <span class="tok-type">u32</span> = <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">u32</span>);</span>
<span class="line" id="L361">        <span class="tok-kw">var</span> reg_value: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L362"></span>
<span class="line" id="L363">        <span class="tok-kw">const</span> return_code_int: windows.HRESULT = windows.advapi32.RegGetValueW(</span>
<span class="line" id="L364">            self.key,</span>
<span class="line" id="L365">            subkey_wtf16le,</span>
<span class="line" id="L366">            value_name_wtf16le,</span>
<span class="line" id="L367">            RRF.RT_REG_DWORD,</span>
<span class="line" id="L368">            &amp;actual_type,</span>
<span class="line" id="L369">            &amp;reg_value,</span>
<span class="line" id="L370">            &amp;reg_size,</span>
<span class="line" id="L371">        );</span>
<span class="line" id="L372">        <span class="tok-kw">const</span> return_code: windows.Win32Error = <span class="tok-builtin">@enumFromInt</span>(return_code_int);</span>
<span class="line" id="L373">        <span class="tok-kw">switch</span> (return_code) {</span>
<span class="line" id="L374">            .SUCCESS =&gt; {},</span>
<span class="line" id="L375">            .MORE_DATA =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DwordTooLong,</span>
<span class="line" id="L376">            .FILE_NOT_FOUND =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ValueNameNotFound,</span>
<span class="line" id="L377">            .INVALID_PARAMETER =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// We didn't combine RRF.SUBKEY_WOW6464KEY and RRF.SUBKEY_WOW6432KEY</span>
</span>
<span class="line" id="L378">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DwordNotFound,</span>
<span class="line" id="L379">        }</span>
<span class="line" id="L380"></span>
<span class="line" id="L381">        <span class="tok-kw">switch</span> (actual_type) {</span>
<span class="line" id="L382">            windows.REG.DWORD =&gt; {},</span>
<span class="line" id="L383">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotADword,</span>
<span class="line" id="L384">        }</span>
<span class="line" id="L385"></span>
<span class="line" id="L386">        <span class="tok-kw">return</span> reg_value;</span>
<span class="line" id="L387">    }</span>
<span class="line" id="L388"></span>
<span class="line" id="L389">    <span class="tok-comment">/// Under private space with flags:</span></span>
<span class="line" id="L390">    <span class="tok-comment">/// KEY_QUERY_VALUE and KEY_ENUMERATE_SUB_KEYS.</span></span>
<span class="line" id="L391">    <span class="tok-comment">/// After finishing work, call `closeKey`.</span></span>
<span class="line" id="L392">    <span class="tok-kw">fn</span> <span class="tok-fn">loadFromPath</span>(absolute_path_as_wtf16le: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>) <span class="tok-kw">error</span>{KeyNotFound}!RegistryWtf16Le {</span>
<span class="line" id="L393">        <span class="tok-kw">var</span> key: windows.HKEY = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L394"></span>
<span class="line" id="L395">        <span class="tok-kw">const</span> return_code_int: windows.HRESULT = std.os.windows.advapi32.RegLoadAppKeyW(</span>
<span class="line" id="L396">            absolute_path_as_wtf16le,</span>
<span class="line" id="L397">            &amp;key,</span>
<span class="line" id="L398">            windows.KEY_QUERY_VALUE | windows.KEY_ENUMERATE_SUB_KEYS,</span>
<span class="line" id="L399">            <span class="tok-number">0</span>,</span>
<span class="line" id="L400">            <span class="tok-number">0</span>,</span>
<span class="line" id="L401">        );</span>
<span class="line" id="L402">        <span class="tok-kw">const</span> return_code: windows.Win32Error = <span class="tok-builtin">@enumFromInt</span>(return_code_int);</span>
<span class="line" id="L403">        <span class="tok-kw">switch</span> (return_code) {</span>
<span class="line" id="L404">            .SUCCESS =&gt; {},</span>
<span class="line" id="L405">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.KeyNotFound,</span>
<span class="line" id="L406">        }</span>
<span class="line" id="L407"></span>
<span class="line" id="L408">        <span class="tok-kw">return</span> RegistryWtf16Le{ .key = key };</span>
<span class="line" id="L409">    }</span>
<span class="line" id="L410">};</span>
<span class="line" id="L411"></span>
<span class="line" id="L412"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Windows10Sdk = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L413">    path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L414">    version: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L415"></span>
<span class="line" id="L416">    <span class="tok-comment">/// Find path and version of Windows 10 SDK.</span></span>
<span class="line" id="L417">    <span class="tok-comment">/// Caller owns the result's fields.</span></span>
<span class="line" id="L418">    <span class="tok-comment">/// After finishing work, call `free(allocator)`.</span></span>
<span class="line" id="L419">    <span class="tok-kw">fn</span> <span class="tok-fn">find</span>(allocator: std.mem.Allocator) <span class="tok-kw">error</span>{ OutOfMemory, Windows10SdkNotFound, PathTooLong, VersionTooLong }!Windows10Sdk {</span>
<span class="line" id="L420">        <span class="tok-kw">const</span> v10_key = RegistryWtf8.openKey(windows.HKEY_LOCAL_MACHINE, <span class="tok-str">&quot;SOFTWARE\\Microsoft\\Microsoft SDKs\\Windows\\v10.0&quot;</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L421">            <span class="tok-kw">error</span>.KeyNotFound =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Windows10SdkNotFound,</span>
<span class="line" id="L422">        };</span>
<span class="line" id="L423">        <span class="tok-kw">defer</span> v10_key.closeKey();</span>
<span class="line" id="L424"></span>
<span class="line" id="L425">        <span class="tok-kw">const</span> path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = path10: {</span>
<span class="line" id="L426">            <span class="tok-kw">const</span> path_maybe_with_trailing_slash = v10_key.getString(allocator, <span class="tok-str">&quot;&quot;</span>, <span class="tok-str">&quot;InstallationFolder&quot;</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L427">                <span class="tok-kw">error</span>.NotAString =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Windows10SdkNotFound,</span>
<span class="line" id="L428">                <span class="tok-kw">error</span>.ValueNameNotFound =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Windows10SdkNotFound,</span>
<span class="line" id="L429">                <span class="tok-kw">error</span>.StringNotFound =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Windows10SdkNotFound,</span>
<span class="line" id="L430"></span>
<span class="line" id="L431">                <span class="tok-kw">error</span>.OutOfMemory =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory,</span>
<span class="line" id="L432">            };</span>
<span class="line" id="L433"></span>
<span class="line" id="L434">            <span class="tok-kw">if</span> (path_maybe_with_trailing_slash.len &gt; std.fs.MAX_PATH_BYTES <span class="tok-kw">or</span> !std.fs.path.isAbsolute(path_maybe_with_trailing_slash)) {</span>
<span class="line" id="L435">                allocator.free(path_maybe_with_trailing_slash);</span>
<span class="line" id="L436">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PathTooLong;</span>
<span class="line" id="L437">            }</span>
<span class="line" id="L438"></span>
<span class="line" id="L439">            <span class="tok-kw">var</span> path = std.ArrayList(<span class="tok-type">u8</span>).fromOwnedSlice(allocator, path_maybe_with_trailing_slash);</span>
<span class="line" id="L440">            <span class="tok-kw">errdefer</span> path.deinit();</span>
<span class="line" id="L441"></span>
<span class="line" id="L442">            <span class="tok-comment">// String might contain trailing slash, so trim it here</span>
</span>
<span class="line" id="L443">            <span class="tok-kw">if</span> (path.items.len &gt; <span class="tok-str">&quot;C:\\&quot;</span>.len <span class="tok-kw">and</span> path.getLast() == <span class="tok-str">'\\'</span>) _ = path.pop();</span>
<span class="line" id="L444"></span>
<span class="line" id="L445">            <span class="tok-kw">const</span> path_without_trailing_slash = <span class="tok-kw">try</span> path.toOwnedSlice();</span>
<span class="line" id="L446">            <span class="tok-kw">break</span> :path10 path_without_trailing_slash;</span>
<span class="line" id="L447">        };</span>
<span class="line" id="L448">        <span class="tok-kw">errdefer</span> allocator.free(path);</span>
<span class="line" id="L449"></span>
<span class="line" id="L450">        <span class="tok-kw">const</span> version: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = version10: {</span>
<span class="line" id="L451"></span>
<span class="line" id="L452">            <span class="tok-comment">// note(dimenus): Microsoft doesn't include the .0 in the ProductVersion key....</span>
</span>
<span class="line" id="L453">            <span class="tok-kw">const</span> version_without_0 = v10_key.getString(allocator, <span class="tok-str">&quot;&quot;</span>, <span class="tok-str">&quot;ProductVersion&quot;</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L454">                <span class="tok-kw">error</span>.NotAString =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Windows10SdkNotFound,</span>
<span class="line" id="L455">                <span class="tok-kw">error</span>.ValueNameNotFound =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Windows10SdkNotFound,</span>
<span class="line" id="L456">                <span class="tok-kw">error</span>.StringNotFound =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Windows10SdkNotFound,</span>
<span class="line" id="L457"></span>
<span class="line" id="L458">                <span class="tok-kw">error</span>.OutOfMemory =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory,</span>
<span class="line" id="L459">            };</span>
<span class="line" id="L460">            <span class="tok-kw">if</span> (version_without_0.len + <span class="tok-str">&quot;.0&quot;</span>.len &gt; product_version_max_length) {</span>
<span class="line" id="L461">                allocator.free(version_without_0);</span>
<span class="line" id="L462">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.VersionTooLong;</span>
<span class="line" id="L463">            }</span>
<span class="line" id="L464"></span>
<span class="line" id="L465">            <span class="tok-kw">var</span> version = std.ArrayList(<span class="tok-type">u8</span>).fromOwnedSlice(allocator, version_without_0);</span>
<span class="line" id="L466">            <span class="tok-kw">errdefer</span> version.deinit();</span>
<span class="line" id="L467"></span>
<span class="line" id="L468">            <span class="tok-kw">try</span> version.appendSlice(<span class="tok-str">&quot;.0&quot;</span>);</span>
<span class="line" id="L469"></span>
<span class="line" id="L470">            <span class="tok-kw">const</span> version_with_0 = <span class="tok-kw">try</span> version.toOwnedSlice();</span>
<span class="line" id="L471">            <span class="tok-kw">break</span> :version10 version_with_0;</span>
<span class="line" id="L472">        };</span>
<span class="line" id="L473">        <span class="tok-kw">errdefer</span> allocator.free(version);</span>
<span class="line" id="L474"></span>
<span class="line" id="L475">        <span class="tok-kw">return</span> Windows10Sdk{ .path = path, .version = version };</span>
<span class="line" id="L476">    }</span>
<span class="line" id="L477"></span>
<span class="line" id="L478">    <span class="tok-comment">/// Check whether this version is enumerated in registry.</span></span>
<span class="line" id="L479">    <span class="tok-kw">fn</span> <span class="tok-fn">isValidVersion</span>(windows10sdk: *<span class="tok-kw">const</span> Windows10Sdk) <span class="tok-type">bool</span> {</span>
<span class="line" id="L480">        <span class="tok-kw">var</span> buf: [std.fs.MAX_PATH_BYTES]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L481">        <span class="tok-kw">const</span> reg_query_as_wtf8 = std.fmt.bufPrint(buf[<span class="tok-number">0</span>..], <span class="tok-str">&quot;{s}\\{s}\\Installed Options&quot;</span>, .{ WINDOWS_KIT_REG_KEY, windows10sdk.version }) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L482">            <span class="tok-kw">error</span>.NoSpaceLeft =&gt; <span class="tok-kw">return</span> <span class="tok-null">false</span>,</span>
<span class="line" id="L483">        };</span>
<span class="line" id="L484"></span>
<span class="line" id="L485">        <span class="tok-kw">const</span> options_key = RegistryWtf8.openKey(windows.HKEY_LOCAL_MACHINE, reg_query_as_wtf8) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L486">            <span class="tok-kw">error</span>.KeyNotFound =&gt; <span class="tok-kw">return</span> <span class="tok-null">false</span>,</span>
<span class="line" id="L487">        };</span>
<span class="line" id="L488">        <span class="tok-kw">defer</span> options_key.closeKey();</span>
<span class="line" id="L489"></span>
<span class="line" id="L490">        <span class="tok-kw">const</span> option_name = <span class="tok-kw">comptime</span> <span class="tok-kw">switch</span> (builtin.target.cpu.arch) {</span>
<span class="line" id="L491">            .arm, .armeb =&gt; <span class="tok-str">&quot;OptionId.DesktopCPParm&quot;</span>,</span>
<span class="line" id="L492">            .aarch64 =&gt; <span class="tok-str">&quot;OptionId.DesktopCPParm64&quot;</span>,</span>
<span class="line" id="L493">            .x86_64 =&gt; <span class="tok-str">&quot;OptionId.DesktopCPPx64&quot;</span>,</span>
<span class="line" id="L494">            .x86 =&gt; <span class="tok-str">&quot;OptionId.DesktopCPPx86&quot;</span>,</span>
<span class="line" id="L495">            <span class="tok-kw">else</span> =&gt; |tag| <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Windows 10 SDK cannot be detected on architecture &quot;</span> ++ tag),</span>
<span class="line" id="L496">        };</span>
<span class="line" id="L497"></span>
<span class="line" id="L498">        <span class="tok-kw">const</span> reg_value = options_key.getDword(<span class="tok-str">&quot;&quot;</span>, option_name) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L499">        <span class="tok-kw">return</span> (reg_value == <span class="tok-number">1</span>);</span>
<span class="line" id="L500">    }</span>
<span class="line" id="L501"></span>
<span class="line" id="L502">    <span class="tok-kw">fn</span> <span class="tok-fn">free</span>(self: *<span class="tok-kw">const</span> Windows10Sdk, allocator: std.mem.Allocator) <span class="tok-type">void</span> {</span>
<span class="line" id="L503">        allocator.free(self.path);</span>
<span class="line" id="L504">        allocator.free(self.version);</span>
<span class="line" id="L505">    }</span>
<span class="line" id="L506">};</span>
<span class="line" id="L507"></span>
<span class="line" id="L508"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Windows81Sdk = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L509">    path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L510">    version: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L511"></span>
<span class="line" id="L512">    <span class="tok-comment">/// Find path and version of Windows 8.1 SDK.</span></span>
<span class="line" id="L513">    <span class="tok-comment">/// Caller owns the result's fields.</span></span>
<span class="line" id="L514">    <span class="tok-comment">/// After finishing work, call `free(allocator)`.</span></span>
<span class="line" id="L515">    <span class="tok-kw">fn</span> <span class="tok-fn">find</span>(allocator: std.mem.Allocator, roots_key: *<span class="tok-kw">const</span> RegistryWtf8) <span class="tok-kw">error</span>{ OutOfMemory, Windows81SdkNotFound, PathTooLong, VersionTooLong }!Windows81Sdk {</span>
<span class="line" id="L516">        <span class="tok-kw">const</span> path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = path81: {</span>
<span class="line" id="L517">            <span class="tok-kw">const</span> path_maybe_with_trailing_slash = roots_key.getString(allocator, <span class="tok-str">&quot;&quot;</span>, <span class="tok-str">&quot;KitsRoot81&quot;</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L518">                <span class="tok-kw">error</span>.NotAString =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Windows81SdkNotFound,</span>
<span class="line" id="L519">                <span class="tok-kw">error</span>.ValueNameNotFound =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Windows81SdkNotFound,</span>
<span class="line" id="L520">                <span class="tok-kw">error</span>.StringNotFound =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Windows81SdkNotFound,</span>
<span class="line" id="L521"></span>
<span class="line" id="L522">                <span class="tok-kw">error</span>.OutOfMemory =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory,</span>
<span class="line" id="L523">            };</span>
<span class="line" id="L524">            <span class="tok-kw">if</span> (path_maybe_with_trailing_slash.len &gt; std.fs.MAX_PATH_BYTES <span class="tok-kw">or</span> !std.fs.path.isAbsolute(path_maybe_with_trailing_slash)) {</span>
<span class="line" id="L525">                allocator.free(path_maybe_with_trailing_slash);</span>
<span class="line" id="L526">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PathTooLong;</span>
<span class="line" id="L527">            }</span>
<span class="line" id="L528"></span>
<span class="line" id="L529">            <span class="tok-kw">var</span> path = std.ArrayList(<span class="tok-type">u8</span>).fromOwnedSlice(allocator, path_maybe_with_trailing_slash);</span>
<span class="line" id="L530">            <span class="tok-kw">errdefer</span> path.deinit();</span>
<span class="line" id="L531"></span>
<span class="line" id="L532">            <span class="tok-comment">// String might contain trailing slash, so trim it here</span>
</span>
<span class="line" id="L533">            <span class="tok-kw">if</span> (path.items.len &gt; <span class="tok-str">&quot;C:\\&quot;</span>.len <span class="tok-kw">and</span> path.getLast() == <span class="tok-str">'\\'</span>) _ = path.pop();</span>
<span class="line" id="L534"></span>
<span class="line" id="L535">            <span class="tok-kw">const</span> path_without_trailing_slash = <span class="tok-kw">try</span> path.toOwnedSlice();</span>
<span class="line" id="L536">            <span class="tok-kw">break</span> :path81 path_without_trailing_slash;</span>
<span class="line" id="L537">        };</span>
<span class="line" id="L538">        <span class="tok-kw">errdefer</span> allocator.free(path);</span>
<span class="line" id="L539"></span>
<span class="line" id="L540">        <span class="tok-kw">const</span> version: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = version81: {</span>
<span class="line" id="L541">            <span class="tok-kw">var</span> buf: [std.fs.MAX_PATH_BYTES]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L542">            <span class="tok-kw">const</span> sdk_lib_dir_path = std.fmt.bufPrint(buf[<span class="tok-number">0</span>..], <span class="tok-str">&quot;{s}\\Lib\\&quot;</span>, .{path}) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L543">                <span class="tok-kw">error</span>.NoSpaceLeft =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PathTooLong,</span>
<span class="line" id="L544">            };</span>
<span class="line" id="L545">            <span class="tok-kw">if</span> (!std.fs.path.isAbsolute(sdk_lib_dir_path)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Windows81SdkNotFound;</span>
<span class="line" id="L546"></span>
<span class="line" id="L547">            <span class="tok-comment">// enumerate files in sdk path looking for latest version</span>
</span>
<span class="line" id="L548">            <span class="tok-kw">var</span> sdk_lib_dir = std.fs.openDirAbsolute(sdk_lib_dir_path, .{</span>
<span class="line" id="L549">                .iterate = <span class="tok-null">true</span>,</span>
<span class="line" id="L550">            }) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L551">                <span class="tok-kw">error</span>.NameTooLong =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PathTooLong,</span>
<span class="line" id="L552">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Windows81SdkNotFound,</span>
<span class="line" id="L553">            };</span>
<span class="line" id="L554">            <span class="tok-kw">defer</span> sdk_lib_dir.close();</span>
<span class="line" id="L555"></span>
<span class="line" id="L556">            <span class="tok-kw">var</span> iterator = sdk_lib_dir.iterate();</span>
<span class="line" id="L557">            <span class="tok-kw">const</span> versions = iterateAndFilterBySemVer(&amp;iterator, allocator, <span class="tok-str">&quot;winv&quot;</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L558">                <span class="tok-kw">error</span>.OutOfMemory =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory,</span>
<span class="line" id="L559">                <span class="tok-kw">error</span>.VersionNotFound =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Windows81SdkNotFound,</span>
<span class="line" id="L560">            };</span>
<span class="line" id="L561">            <span class="tok-kw">defer</span> {</span>
<span class="line" id="L562">                <span class="tok-kw">for</span> (versions) |version| allocator.free(version);</span>
<span class="line" id="L563">                allocator.free(versions);</span>
<span class="line" id="L564">            }</span>
<span class="line" id="L565">            <span class="tok-kw">const</span> latest_version = <span class="tok-kw">try</span> allocator.dupe(<span class="tok-type">u8</span>, versions[<span class="tok-number">0</span>]);</span>
<span class="line" id="L566">            <span class="tok-kw">break</span> :version81 latest_version;</span>
<span class="line" id="L567">        };</span>
<span class="line" id="L568">        <span class="tok-kw">errdefer</span> allocator.free(version);</span>
<span class="line" id="L569"></span>
<span class="line" id="L570">        <span class="tok-kw">return</span> Windows81Sdk{ .path = path, .version = version };</span>
<span class="line" id="L571">    }</span>
<span class="line" id="L572"></span>
<span class="line" id="L573">    <span class="tok-kw">fn</span> <span class="tok-fn">free</span>(self: *<span class="tok-kw">const</span> Windows81Sdk, allocator: std.mem.Allocator) <span class="tok-type">void</span> {</span>
<span class="line" id="L574">        allocator.free(self.path);</span>
<span class="line" id="L575">        allocator.free(self.version);</span>
<span class="line" id="L576">    }</span>
<span class="line" id="L577">};</span>
<span class="line" id="L578"></span>
<span class="line" id="L579"><span class="tok-kw">const</span> MsvcLibDir = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L580">    <span class="tok-kw">fn</span> <span class="tok-fn">findInstancesDirViaCLSID</span>(allocator: std.mem.Allocator) <span class="tok-kw">error</span>{ OutOfMemory, PathNotFound }!std.fs.Dir {</span>
<span class="line" id="L581">        <span class="tok-kw">const</span> setup_configuration_clsid = <span class="tok-str">&quot;{177f0c4a-1cd3-4de7-a32c-71dbbb9fa36d}&quot;</span>;</span>
<span class="line" id="L582">        <span class="tok-kw">const</span> setup_config_key = RegistryWtf8.openKey(windows.HKEY_CLASSES_ROOT, <span class="tok-str">&quot;CLSID\\&quot;</span> ++ setup_configuration_clsid) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L583">            <span class="tok-kw">error</span>.KeyNotFound =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PathNotFound,</span>
<span class="line" id="L584">        };</span>
<span class="line" id="L585">        <span class="tok-kw">defer</span> setup_config_key.closeKey();</span>
<span class="line" id="L586"></span>
<span class="line" id="L587">        <span class="tok-kw">const</span> dll_path = setup_config_key.getString(allocator, <span class="tok-str">&quot;InprocServer32&quot;</span>, <span class="tok-str">&quot;&quot;</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L588">            <span class="tok-kw">error</span>.NotAString,</span>
<span class="line" id="L589">            <span class="tok-kw">error</span>.ValueNameNotFound,</span>
<span class="line" id="L590">            <span class="tok-kw">error</span>.StringNotFound,</span>
<span class="line" id="L591">            =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PathNotFound,</span>
<span class="line" id="L592"></span>
<span class="line" id="L593">            <span class="tok-kw">error</span>.OutOfMemory =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory,</span>
<span class="line" id="L594">        };</span>
<span class="line" id="L595">        <span class="tok-kw">defer</span> allocator.free(dll_path);</span>
<span class="line" id="L596"></span>
<span class="line" id="L597">        <span class="tok-kw">var</span> path_it = std.fs.path.componentIterator(dll_path) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PathNotFound;</span>
<span class="line" id="L598">        <span class="tok-comment">// the .dll filename</span>
</span>
<span class="line" id="L599">        _ = path_it.last();</span>
<span class="line" id="L600">        <span class="tok-kw">const</span> root_path = <span class="tok-kw">while</span> (path_it.previous()) |dir_component| {</span>
<span class="line" id="L601">            <span class="tok-kw">if</span> (std.ascii.eqlIgnoreCase(dir_component.name, <span class="tok-str">&quot;VisualStudio&quot;</span>)) {</span>
<span class="line" id="L602">                <span class="tok-kw">break</span> dir_component.path;</span>
<span class="line" id="L603">            }</span>
<span class="line" id="L604">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L605">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PathNotFound;</span>
<span class="line" id="L606">        };</span>
<span class="line" id="L607"></span>
<span class="line" id="L608">        <span class="tok-kw">const</span> instances_path = <span class="tok-kw">try</span> std.fs.path.join(allocator, &amp;.{ root_path, <span class="tok-str">&quot;Packages&quot;</span>, <span class="tok-str">&quot;_Instances&quot;</span> });</span>
<span class="line" id="L609">        <span class="tok-kw">defer</span> allocator.free(instances_path);</span>
<span class="line" id="L610"></span>
<span class="line" id="L611">        <span class="tok-kw">return</span> std.fs.openDirAbsolute(instances_path, .{ .iterate = <span class="tok-null">true</span> }) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PathNotFound;</span>
<span class="line" id="L612">    }</span>
<span class="line" id="L613"></span>
<span class="line" id="L614">    <span class="tok-kw">fn</span> <span class="tok-fn">findInstancesDir</span>(allocator: std.mem.Allocator) <span class="tok-kw">error</span>{ OutOfMemory, PathNotFound }!std.fs.Dir {</span>
<span class="line" id="L615">        <span class="tok-comment">// First try to get the path from the .dll that would have been</span>
</span>
<span class="line" id="L616">        <span class="tok-comment">// loaded via COM for SetupConfiguration.</span>
</span>
<span class="line" id="L617">        <span class="tok-kw">return</span> findInstancesDirViaCLSID(allocator) <span class="tok-kw">catch</span> |orig_err| {</span>
<span class="line" id="L618">            <span class="tok-comment">// If that can't be found, fall back to manually appending</span>
</span>
<span class="line" id="L619">            <span class="tok-comment">// `Microsoft\VisualStudio\Packages\_Instances` to %PROGRAMDATA%</span>
</span>
<span class="line" id="L620">            <span class="tok-kw">const</span> program_data = std.process.getEnvVarOwned(allocator, <span class="tok-str">&quot;PROGRAMDATA&quot;</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L621">                <span class="tok-kw">error</span>.OutOfMemory =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L622">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> orig_err,</span>
<span class="line" id="L623">            };</span>
<span class="line" id="L624">            <span class="tok-kw">defer</span> allocator.free(program_data);</span>
<span class="line" id="L625"></span>
<span class="line" id="L626">            <span class="tok-kw">const</span> instances_path = <span class="tok-kw">try</span> std.fs.path.join(allocator, &amp;.{ program_data, <span class="tok-str">&quot;Microsoft&quot;</span>, <span class="tok-str">&quot;VisualStudio&quot;</span>, <span class="tok-str">&quot;Packages&quot;</span>, <span class="tok-str">&quot;_Instances&quot;</span> });</span>
<span class="line" id="L627">            <span class="tok-kw">defer</span> allocator.free(instances_path);</span>
<span class="line" id="L628"></span>
<span class="line" id="L629">            <span class="tok-kw">return</span> std.fs.openDirAbsolute(instances_path, .{ .iterate = <span class="tok-null">true</span> }) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> orig_err;</span>
<span class="line" id="L630">        };</span>
<span class="line" id="L631">    }</span>
<span class="line" id="L632"></span>
<span class="line" id="L633">    <span class="tok-comment">/// Intended to be equivalent to `ISetupHelper.ParseVersion`</span></span>
<span class="line" id="L634">    <span class="tok-comment">/// Example: 17.4.33205.214 -&gt; 0x0011000481b500d6</span></span>
<span class="line" id="L635">    <span class="tok-kw">fn</span> <span class="tok-fn">parseVersionQuad</span>(version: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-kw">error</span>{InvalidVersion}!<span class="tok-type">u64</span> {</span>
<span class="line" id="L636">        <span class="tok-kw">var</span> it = std.mem.splitScalar(<span class="tok-type">u8</span>, version, <span class="tok-str">'.'</span>);</span>
<span class="line" id="L637">        <span class="tok-kw">const</span> a = it.next() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidVersion;</span>
<span class="line" id="L638">        <span class="tok-kw">const</span> b = it.next() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidVersion;</span>
<span class="line" id="L639">        <span class="tok-kw">const</span> c = it.next() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidVersion;</span>
<span class="line" id="L640">        <span class="tok-kw">const</span> d = it.next() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidVersion;</span>
<span class="line" id="L641">        <span class="tok-kw">if</span> (it.next()) |_| <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidVersion;</span>
<span class="line" id="L642">        <span class="tok-kw">var</span> result: <span class="tok-type">u64</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L643">        <span class="tok-kw">var</span> result_bytes = std.mem.asBytes(&amp;result);</span>
<span class="line" id="L644"></span>
<span class="line" id="L645">        std.mem.writeInt(</span>
<span class="line" id="L646">            <span class="tok-type">u16</span>,</span>
<span class="line" id="L647">            result_bytes[<span class="tok-number">0</span>..<span class="tok-number">2</span>],</span>
<span class="line" id="L648">            std.fmt.parseUnsigned(<span class="tok-type">u16</span>, d, <span class="tok-number">10</span>) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidVersion,</span>
<span class="line" id="L649">            .little,</span>
<span class="line" id="L650">        );</span>
<span class="line" id="L651">        std.mem.writeInt(</span>
<span class="line" id="L652">            <span class="tok-type">u16</span>,</span>
<span class="line" id="L653">            result_bytes[<span class="tok-number">2</span>..<span class="tok-number">4</span>],</span>
<span class="line" id="L654">            std.fmt.parseUnsigned(<span class="tok-type">u16</span>, c, <span class="tok-number">10</span>) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidVersion,</span>
<span class="line" id="L655">            .little,</span>
<span class="line" id="L656">        );</span>
<span class="line" id="L657">        std.mem.writeInt(</span>
<span class="line" id="L658">            <span class="tok-type">u16</span>,</span>
<span class="line" id="L659">            result_bytes[<span class="tok-number">4</span>..<span class="tok-number">6</span>],</span>
<span class="line" id="L660">            std.fmt.parseUnsigned(<span class="tok-type">u16</span>, b, <span class="tok-number">10</span>) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidVersion,</span>
<span class="line" id="L661">            .little,</span>
<span class="line" id="L662">        );</span>
<span class="line" id="L663">        std.mem.writeInt(</span>
<span class="line" id="L664">            <span class="tok-type">u16</span>,</span>
<span class="line" id="L665">            result_bytes[<span class="tok-number">6</span>..<span class="tok-number">8</span>],</span>
<span class="line" id="L666">            std.fmt.parseUnsigned(<span class="tok-type">u16</span>, a, <span class="tok-number">10</span>) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidVersion,</span>
<span class="line" id="L667">            .little,</span>
<span class="line" id="L668">        );</span>
<span class="line" id="L669"></span>
<span class="line" id="L670">        <span class="tok-kw">return</span> result;</span>
<span class="line" id="L671">    }</span>
<span class="line" id="L672"></span>
<span class="line" id="L673">    <span class="tok-comment">/// Intended to be equivalent to ISetupConfiguration.EnumInstances:</span></span>
<span class="line" id="L674">    <span class="tok-comment">/// https://learn.microsoft.com/en-us/dotnet/api/microsoft.visualstudio.setup.configuration</span></span>
<span class="line" id="L675">    <span class="tok-comment">/// but without the use of COM in order to avoid a dependency on ole32.dll</span></span>
<span class="line" id="L676">    <span class="tok-comment">///</span></span>
<span class="line" id="L677">    <span class="tok-comment">/// The logic in this function is intended to match what ISetupConfiguration does</span></span>
<span class="line" id="L678">    <span class="tok-comment">/// under-the-hood, as verified using Procmon.</span></span>
<span class="line" id="L679">    <span class="tok-kw">fn</span> <span class="tok-fn">findViaCOM</span>(allocator: std.mem.Allocator) <span class="tok-kw">error</span>{ OutOfMemory, PathNotFound }![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L680">        <span class="tok-comment">// Typically `%PROGRAMDATA%\Microsoft\VisualStudio\Packages\_Instances`</span>
</span>
<span class="line" id="L681">        <span class="tok-comment">// This will contain directories with names of instance IDs like 80a758ca,</span>
</span>
<span class="line" id="L682">        <span class="tok-comment">// which will contain `state.json` files that have the version and</span>
</span>
<span class="line" id="L683">        <span class="tok-comment">// installation directory.</span>
</span>
<span class="line" id="L684">        <span class="tok-kw">var</span> instances_dir = <span class="tok-kw">try</span> findInstancesDir(allocator);</span>
<span class="line" id="L685">        <span class="tok-kw">defer</span> instances_dir.close();</span>
<span class="line" id="L686"></span>
<span class="line" id="L687">        <span class="tok-kw">var</span> state_subpath_buf: [std.fs.MAX_NAME_BYTES + <span class="tok-number">32</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L688">        <span class="tok-kw">var</span> latest_version_lib_dir = std.ArrayListUnmanaged(<span class="tok-type">u8</span>){};</span>
<span class="line" id="L689">        <span class="tok-kw">errdefer</span> latest_version_lib_dir.deinit(allocator);</span>
<span class="line" id="L690"></span>
<span class="line" id="L691">        <span class="tok-kw">var</span> latest_version: <span class="tok-type">u64</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L692">        <span class="tok-kw">var</span> instances_dir_it = instances_dir.iterateAssumeFirstIteration();</span>
<span class="line" id="L693">        <span class="tok-kw">while</span> (instances_dir_it.next() <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PathNotFound) |entry| {</span>
<span class="line" id="L694">            <span class="tok-kw">if</span> (entry.kind != .directory) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L695"></span>
<span class="line" id="L696">            <span class="tok-kw">var</span> fbs = std.io.fixedBufferStream(&amp;state_subpath_buf);</span>
<span class="line" id="L697">            <span class="tok-kw">const</span> writer = fbs.writer();</span>
<span class="line" id="L698"></span>
<span class="line" id="L699">            writer.writeAll(entry.name) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;</span>
<span class="line" id="L700">            writer.writeByte(std.fs.path.sep) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;</span>
<span class="line" id="L701">            writer.writeAll(<span class="tok-str">&quot;state.json&quot;</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;</span>
<span class="line" id="L702"></span>
<span class="line" id="L703">            <span class="tok-kw">const</span> json_contents = instances_dir.readFileAlloc(allocator, fbs.getWritten(), std.math.maxInt(<span class="tok-type">usize</span>)) <span class="tok-kw">catch</span> <span class="tok-kw">continue</span>;</span>
<span class="line" id="L704">            <span class="tok-kw">defer</span> allocator.free(json_contents);</span>
<span class="line" id="L705"></span>
<span class="line" id="L706">            <span class="tok-kw">var</span> parsed = std.json.parseFromSlice(std.json.Value, allocator, json_contents, .{}) <span class="tok-kw">catch</span> <span class="tok-kw">continue</span>;</span>
<span class="line" id="L707">            <span class="tok-kw">defer</span> parsed.deinit();</span>
<span class="line" id="L708"></span>
<span class="line" id="L709">            <span class="tok-kw">if</span> (parsed.value != .object) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L710">            <span class="tok-kw">const</span> catalog_info = parsed.value.object.get(<span class="tok-str">&quot;catalogInfo&quot;</span>) <span class="tok-kw">orelse</span> <span class="tok-kw">continue</span>;</span>
<span class="line" id="L711">            <span class="tok-kw">if</span> (catalog_info != .object) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L712">            <span class="tok-kw">const</span> product_version_value = catalog_info.object.get(<span class="tok-str">&quot;buildVersion&quot;</span>) <span class="tok-kw">orelse</span> <span class="tok-kw">continue</span>;</span>
<span class="line" id="L713">            <span class="tok-kw">if</span> (product_version_value != .string) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L714">            <span class="tok-kw">const</span> product_version_text = product_version_value.string;</span>
<span class="line" id="L715">            <span class="tok-kw">const</span> parsed_version = parseVersionQuad(product_version_text) <span class="tok-kw">catch</span> <span class="tok-kw">continue</span>;</span>
<span class="line" id="L716"></span>
<span class="line" id="L717">            <span class="tok-comment">// We want to end up with the most recent version installed</span>
</span>
<span class="line" id="L718">            <span class="tok-kw">if</span> (parsed_version &lt;= latest_version) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L719"></span>
<span class="line" id="L720">            <span class="tok-kw">const</span> installation_path = parsed.value.object.get(<span class="tok-str">&quot;installationPath&quot;</span>) <span class="tok-kw">orelse</span> <span class="tok-kw">continue</span>;</span>
<span class="line" id="L721">            <span class="tok-kw">if</span> (installation_path != .string) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L722"></span>
<span class="line" id="L723">            <span class="tok-kw">const</span> lib_dir_path = libDirFromInstallationPath(allocator, installation_path.string) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L724">                <span class="tok-kw">error</span>.OutOfMemory =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L725">                <span class="tok-kw">error</span>.PathNotFound =&gt; <span class="tok-kw">continue</span>,</span>
<span class="line" id="L726">            };</span>
<span class="line" id="L727">            <span class="tok-kw">defer</span> allocator.free(lib_dir_path);</span>
<span class="line" id="L728"></span>
<span class="line" id="L729">            latest_version_lib_dir.clearRetainingCapacity();</span>
<span class="line" id="L730">            <span class="tok-kw">try</span> latest_version_lib_dir.appendSlice(allocator, lib_dir_path);</span>
<span class="line" id="L731">            latest_version = parsed_version;</span>
<span class="line" id="L732">        }</span>
<span class="line" id="L733"></span>
<span class="line" id="L734">        <span class="tok-kw">if</span> (latest_version_lib_dir.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PathNotFound;</span>
<span class="line" id="L735">        <span class="tok-kw">return</span> latest_version_lib_dir.toOwnedSlice(allocator);</span>
<span class="line" id="L736">    }</span>
<span class="line" id="L737"></span>
<span class="line" id="L738">    <span class="tok-kw">fn</span> <span class="tok-fn">libDirFromInstallationPath</span>(allocator: std.mem.Allocator, installation_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-kw">error</span>{ OutOfMemory, PathNotFound }![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L739">        <span class="tok-kw">var</span> lib_dir_buf = <span class="tok-kw">try</span> std.ArrayList(<span class="tok-type">u8</span>).initCapacity(allocator, installation_path.len + <span class="tok-number">64</span>);</span>
<span class="line" id="L740">        <span class="tok-kw">errdefer</span> lib_dir_buf.deinit();</span>
<span class="line" id="L741"></span>
<span class="line" id="L742">        lib_dir_buf.appendSliceAssumeCapacity(installation_path);</span>
<span class="line" id="L743"></span>
<span class="line" id="L744">        <span class="tok-kw">if</span> (!std.fs.path.isSep(lib_dir_buf.getLast())) {</span>
<span class="line" id="L745">            <span class="tok-kw">try</span> lib_dir_buf.append(<span class="tok-str">'\\'</span>);</span>
<span class="line" id="L746">        }</span>
<span class="line" id="L747">        <span class="tok-kw">const</span> installation_path_with_trailing_sep_len = lib_dir_buf.items.len;</span>
<span class="line" id="L748"></span>
<span class="line" id="L749">        <span class="tok-kw">try</span> lib_dir_buf.appendSlice(<span class="tok-str">&quot;VC\\Auxiliary\\Build\\Microsoft.VCToolsVersion.default.txt&quot;</span>);</span>
<span class="line" id="L750">        <span class="tok-kw">var</span> default_tools_version_buf: [<span class="tok-number">512</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L751">        <span class="tok-kw">const</span> default_tools_version_contents = std.fs.cwd().readFile(lib_dir_buf.items, &amp;default_tools_version_buf) <span class="tok-kw">catch</span> {</span>
<span class="line" id="L752">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PathNotFound;</span>
<span class="line" id="L753">        };</span>
<span class="line" id="L754">        <span class="tok-kw">var</span> tokenizer = std.mem.tokenizeAny(<span class="tok-type">u8</span>, default_tools_version_contents, <span class="tok-str">&quot; \r\n&quot;</span>);</span>
<span class="line" id="L755">        <span class="tok-kw">const</span> default_tools_version = tokenizer.next() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PathNotFound;</span>
<span class="line" id="L756"></span>
<span class="line" id="L757">        lib_dir_buf.shrinkRetainingCapacity(installation_path_with_trailing_sep_len);</span>
<span class="line" id="L758">        <span class="tok-kw">try</span> lib_dir_buf.appendSlice(<span class="tok-str">&quot;VC\\Tools\\MSVC\\&quot;</span>);</span>
<span class="line" id="L759">        <span class="tok-kw">try</span> lib_dir_buf.appendSlice(default_tools_version);</span>
<span class="line" id="L760">        <span class="tok-kw">const</span> folder_with_arch = <span class="tok-str">&quot;\\Lib\\&quot;</span> ++ <span class="tok-kw">comptime</span> <span class="tok-kw">switch</span> (builtin.target.cpu.arch) {</span>
<span class="line" id="L761">            .x86 =&gt; <span class="tok-str">&quot;x86&quot;</span>,</span>
<span class="line" id="L762">            .x86_64 =&gt; <span class="tok-str">&quot;x64&quot;</span>,</span>
<span class="line" id="L763">            .arm, .armeb =&gt; <span class="tok-str">&quot;arm&quot;</span>,</span>
<span class="line" id="L764">            .aarch64 =&gt; <span class="tok-str">&quot;arm64&quot;</span>,</span>
<span class="line" id="L765">            <span class="tok-kw">else</span> =&gt; |tag| <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;MSVC lib dir cannot be detected on architecture &quot;</span> ++ tag),</span>
<span class="line" id="L766">        };</span>
<span class="line" id="L767">        <span class="tok-kw">try</span> lib_dir_buf.appendSlice(folder_with_arch);</span>
<span class="line" id="L768"></span>
<span class="line" id="L769">        <span class="tok-kw">if</span> (!verifyLibDir(lib_dir_buf.items)) {</span>
<span class="line" id="L770">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PathNotFound;</span>
<span class="line" id="L771">        }</span>
<span class="line" id="L772"></span>
<span class="line" id="L773">        <span class="tok-kw">return</span> lib_dir_buf.toOwnedSlice();</span>
<span class="line" id="L774">    }</span>
<span class="line" id="L775"></span>
<span class="line" id="L776">    <span class="tok-comment">// https://learn.microsoft.com/en-us/visualstudio/install/tools-for-managing-visual-studio-instances?view=vs-2022#editing-the-registry-for-a-visual-studio-instance</span>
</span>
<span class="line" id="L777">    <span class="tok-kw">fn</span> <span class="tok-fn">findViaRegistry</span>(allocator: std.mem.Allocator) <span class="tok-kw">error</span>{ OutOfMemory, PathNotFound }![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L778"></span>
<span class="line" id="L779">        <span class="tok-comment">// %localappdata%\Microsoft\VisualStudio\</span>
</span>
<span class="line" id="L780">        <span class="tok-comment">// %appdata%\Local\Microsoft\VisualStudio\</span>
</span>
<span class="line" id="L781">        <span class="tok-kw">const</span> visualstudio_folder_path = std.fs.getAppDataDir(allocator, <span class="tok-str">&quot;Microsoft\\VisualStudio\\&quot;</span>) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PathNotFound;</span>
<span class="line" id="L782">        <span class="tok-kw">defer</span> allocator.free(visualstudio_folder_path);</span>
<span class="line" id="L783"></span>
<span class="line" id="L784">        <span class="tok-kw">const</span> vs_versions: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = vs_versions: {</span>
<span class="line" id="L785">            <span class="tok-kw">if</span> (!std.fs.path.isAbsolute(visualstudio_folder_path)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PathNotFound;</span>
<span class="line" id="L786">            <span class="tok-comment">// enumerate folders that contain `privateregistry.bin`, looking for all versions</span>
</span>
<span class="line" id="L787">            <span class="tok-comment">// f.i. %localappdata%\Microsoft\VisualStudio\17.0_9e9cbb98\</span>
</span>
<span class="line" id="L788">            <span class="tok-kw">var</span> visualstudio_folder = std.fs.openDirAbsolute(visualstudio_folder_path, .{</span>
<span class="line" id="L789">                .iterate = <span class="tok-null">true</span>,</span>
<span class="line" id="L790">            }) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PathNotFound;</span>
<span class="line" id="L791">            <span class="tok-kw">defer</span> visualstudio_folder.close();</span>
<span class="line" id="L792"></span>
<span class="line" id="L793">            <span class="tok-kw">var</span> iterator = visualstudio_folder.iterate();</span>
<span class="line" id="L794">            <span class="tok-kw">const</span> versions = iterateAndFilterBySemVer(&amp;iterator, allocator, <span class="tok-null">null</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L795">                <span class="tok-kw">error</span>.OutOfMemory =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory,</span>
<span class="line" id="L796">                <span class="tok-kw">error</span>.VersionNotFound =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PathNotFound,</span>
<span class="line" id="L797">            };</span>
<span class="line" id="L798">            <span class="tok-kw">break</span> :vs_versions versions;</span>
<span class="line" id="L799">        };</span>
<span class="line" id="L800">        <span class="tok-kw">defer</span> {</span>
<span class="line" id="L801">            <span class="tok-kw">for</span> (vs_versions) |vs_version| allocator.free(vs_version);</span>
<span class="line" id="L802">            allocator.free(vs_versions);</span>
<span class="line" id="L803">        }</span>
<span class="line" id="L804">        <span class="tok-kw">var</span> config_subkey_buf: [RegistryWtf16Le.key_name_max_len * <span class="tok-number">2</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L805">        <span class="tok-kw">const</span> source_directories: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = source_directories: <span class="tok-kw">for</span> (vs_versions) |vs_version| {</span>
<span class="line" id="L806">            <span class="tok-kw">const</span> privateregistry_absolute_path = std.fs.path.join(allocator, &amp;.{ visualstudio_folder_path, vs_version, <span class="tok-str">&quot;privateregistry.bin&quot;</span> }) <span class="tok-kw">catch</span> <span class="tok-kw">continue</span>;</span>
<span class="line" id="L807">            <span class="tok-kw">defer</span> allocator.free(privateregistry_absolute_path);</span>
<span class="line" id="L808">            <span class="tok-kw">if</span> (!std.fs.path.isAbsolute(privateregistry_absolute_path)) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L809"></span>
<span class="line" id="L810">            <span class="tok-kw">const</span> visualstudio_registry = RegistryWtf8.loadFromPath(privateregistry_absolute_path) <span class="tok-kw">catch</span> <span class="tok-kw">continue</span>;</span>
<span class="line" id="L811">            <span class="tok-kw">defer</span> visualstudio_registry.closeKey();</span>
<span class="line" id="L812"></span>
<span class="line" id="L813">            <span class="tok-kw">const</span> config_subkey = std.fmt.bufPrint(config_subkey_buf[<span class="tok-number">0</span>..], <span class="tok-str">&quot;Software\\Microsoft\\VisualStudio\\{s}_Config&quot;</span>, .{vs_version}) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;</span>
<span class="line" id="L814"></span>
<span class="line" id="L815">            <span class="tok-kw">const</span> source_directories_value = visualstudio_registry.getString(allocator, config_subkey, <span class="tok-str">&quot;Source Directories&quot;</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L816">                <span class="tok-kw">error</span>.OutOfMemory =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory,</span>
<span class="line" id="L817">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">continue</span>,</span>
<span class="line" id="L818">            };</span>
<span class="line" id="L819">            <span class="tok-kw">if</span> (source_directories_value.len &gt; (std.fs.MAX_PATH_BYTES * <span class="tok-number">30</span>)) { <span class="tok-comment">// note(bratishkaerik): guessing from the fact that on my computer it has 15 pathes and at least some of them are not of max length</span>
</span>
<span class="line" id="L820">                allocator.free(source_directories_value);</span>
<span class="line" id="L821">                <span class="tok-kw">continue</span>;</span>
<span class="line" id="L822">            }</span>
<span class="line" id="L823"></span>
<span class="line" id="L824">            <span class="tok-kw">break</span> :source_directories source_directories_value;</span>
<span class="line" id="L825">        } <span class="tok-kw">else</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PathNotFound;</span>
<span class="line" id="L826">        <span class="tok-kw">defer</span> allocator.free(source_directories);</span>
<span class="line" id="L827"></span>
<span class="line" id="L828">        <span class="tok-kw">var</span> source_directories_splitted = std.mem.splitScalar(<span class="tok-type">u8</span>, source_directories, <span class="tok-str">';'</span>);</span>
<span class="line" id="L829"></span>
<span class="line" id="L830">        <span class="tok-kw">const</span> msvc_dir: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = msvc_dir: {</span>
<span class="line" id="L831">            <span class="tok-kw">const</span> msvc_include_dir_maybe_with_trailing_slash = <span class="tok-kw">try</span> allocator.dupe(<span class="tok-type">u8</span>, source_directories_splitted.first());</span>
<span class="line" id="L832"></span>
<span class="line" id="L833">            <span class="tok-kw">if</span> (msvc_include_dir_maybe_with_trailing_slash.len &gt; std.fs.MAX_PATH_BYTES <span class="tok-kw">or</span> !std.fs.path.isAbsolute(msvc_include_dir_maybe_with_trailing_slash)) {</span>
<span class="line" id="L834">                allocator.free(msvc_include_dir_maybe_with_trailing_slash);</span>
<span class="line" id="L835">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PathNotFound;</span>
<span class="line" id="L836">            }</span>
<span class="line" id="L837"></span>
<span class="line" id="L838">            <span class="tok-kw">var</span> msvc_dir = std.ArrayList(<span class="tok-type">u8</span>).fromOwnedSlice(allocator, msvc_include_dir_maybe_with_trailing_slash);</span>
<span class="line" id="L839">            <span class="tok-kw">errdefer</span> msvc_dir.deinit();</span>
<span class="line" id="L840"></span>
<span class="line" id="L841">            <span class="tok-comment">// String might contain trailing slash, so trim it here</span>
</span>
<span class="line" id="L842">            <span class="tok-kw">if</span> (msvc_dir.items.len &gt; <span class="tok-str">&quot;C:\\&quot;</span>.len <span class="tok-kw">and</span> msvc_dir.getLast() == <span class="tok-str">'\\'</span>) _ = msvc_dir.pop();</span>
<span class="line" id="L843"></span>
<span class="line" id="L844">            <span class="tok-comment">// Remove `\include` at the end of path</span>
</span>
<span class="line" id="L845">            <span class="tok-kw">if</span> (std.mem.endsWith(<span class="tok-type">u8</span>, msvc_dir.items, <span class="tok-str">&quot;\\include&quot;</span>)) {</span>
<span class="line" id="L846">                msvc_dir.shrinkRetainingCapacity(msvc_dir.items.len - <span class="tok-str">&quot;\\include&quot;</span>.len);</span>
<span class="line" id="L847">            }</span>
<span class="line" id="L848"></span>
<span class="line" id="L849">            <span class="tok-kw">const</span> folder_with_arch = <span class="tok-str">&quot;\\Lib\\&quot;</span> ++ <span class="tok-kw">comptime</span> <span class="tok-kw">switch</span> (builtin.target.cpu.arch) {</span>
<span class="line" id="L850">                .x86 =&gt; <span class="tok-str">&quot;x86&quot;</span>,</span>
<span class="line" id="L851">                .x86_64 =&gt; <span class="tok-str">&quot;x64&quot;</span>,</span>
<span class="line" id="L852">                .arm, .armeb =&gt; <span class="tok-str">&quot;arm&quot;</span>,</span>
<span class="line" id="L853">                .aarch64 =&gt; <span class="tok-str">&quot;arm64&quot;</span>,</span>
<span class="line" id="L854">                <span class="tok-kw">else</span> =&gt; |tag| <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;MSVC lib dir cannot be detected on architecture &quot;</span> ++ tag),</span>
<span class="line" id="L855">            };</span>
<span class="line" id="L856"></span>
<span class="line" id="L857">            <span class="tok-kw">try</span> msvc_dir.appendSlice(folder_with_arch);</span>
<span class="line" id="L858">            <span class="tok-kw">const</span> msvc_dir_with_arch = <span class="tok-kw">try</span> msvc_dir.toOwnedSlice();</span>
<span class="line" id="L859">            <span class="tok-kw">break</span> :msvc_dir msvc_dir_with_arch;</span>
<span class="line" id="L860">        };</span>
<span class="line" id="L861">        <span class="tok-kw">errdefer</span> allocator.free(msvc_dir);</span>
<span class="line" id="L862"></span>
<span class="line" id="L863">        <span class="tok-kw">if</span> (!verifyLibDir(msvc_dir)) {</span>
<span class="line" id="L864">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PathNotFound;</span>
<span class="line" id="L865">        }</span>
<span class="line" id="L866"></span>
<span class="line" id="L867">        <span class="tok-kw">return</span> msvc_dir;</span>
<span class="line" id="L868">    }</span>
<span class="line" id="L869"></span>
<span class="line" id="L870">    <span class="tok-kw">fn</span> <span class="tok-fn">findViaVs7Key</span>(allocator: std.mem.Allocator) <span class="tok-kw">error</span>{ OutOfMemory, PathNotFound }![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L871">        <span class="tok-kw">var</span> base_path: std.ArrayList(<span class="tok-type">u8</span>) = base_path: {</span>
<span class="line" id="L872">            try_env: {</span>
<span class="line" id="L873">                <span class="tok-kw">var</span> env_map = std.process.getEnvMap(allocator) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L874">                    <span class="tok-kw">error</span>.OutOfMemory =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory,</span>
<span class="line" id="L875">                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">break</span> :try_env,</span>
<span class="line" id="L876">                };</span>
<span class="line" id="L877">                <span class="tok-kw">defer</span> env_map.deinit();</span>
<span class="line" id="L878"></span>
<span class="line" id="L879">                <span class="tok-kw">if</span> (env_map.get(<span class="tok-str">&quot;VS140COMNTOOLS&quot;</span>)) |VS140COMNTOOLS| {</span>
<span class="line" id="L880">                    <span class="tok-kw">if</span> (VS140COMNTOOLS.len &lt; <span class="tok-str">&quot;C:\\Common7\\Tools&quot;</span>.len) <span class="tok-kw">break</span> :try_env;</span>
<span class="line" id="L881">                    <span class="tok-kw">if</span> (!std.fs.path.isAbsolute(VS140COMNTOOLS)) <span class="tok-kw">break</span> :try_env;</span>
<span class="line" id="L882">                    <span class="tok-kw">var</span> list = std.ArrayList(<span class="tok-type">u8</span>).init(allocator);</span>
<span class="line" id="L883">                    <span class="tok-kw">errdefer</span> list.deinit();</span>
<span class="line" id="L884"></span>
<span class="line" id="L885">                    <span class="tok-kw">try</span> list.appendSlice(VS140COMNTOOLS); <span class="tok-comment">// C:\Program Files (x86)\Microsoft Visual Studio 14.0\Common7\Tools</span>
</span>
<span class="line" id="L886">                    <span class="tok-comment">// String might contain trailing slash, so trim it here</span>
</span>
<span class="line" id="L887">                    <span class="tok-kw">if</span> (list.items.len &gt; <span class="tok-str">&quot;C:\\&quot;</span>.len <span class="tok-kw">and</span> list.getLast() == <span class="tok-str">'\\'</span>) _ = list.pop();</span>
<span class="line" id="L888">                    list.shrinkRetainingCapacity(list.items.len - <span class="tok-str">&quot;\\Common7\\Tools&quot;</span>.len); <span class="tok-comment">// C:\Program Files (x86)\Microsoft Visual Studio 14.0</span>
</span>
<span class="line" id="L889">                    <span class="tok-kw">break</span> :base_path list;</span>
<span class="line" id="L890">                }</span>
<span class="line" id="L891">            }</span>
<span class="line" id="L892"></span>
<span class="line" id="L893">            <span class="tok-kw">const</span> vs7_key = RegistryWtf8.openKey(windows.HKEY_LOCAL_MACHINE, <span class="tok-str">&quot;SOFTWARE\\Microsoft\\VisualStudio\\SxS\\VS7&quot;</span>) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PathNotFound;</span>
<span class="line" id="L894">            <span class="tok-kw">defer</span> vs7_key.closeKey();</span>
<span class="line" id="L895">            try_vs7_key: {</span>
<span class="line" id="L896">                <span class="tok-kw">const</span> path_maybe_with_trailing_slash = vs7_key.getString(allocator, <span class="tok-str">&quot;&quot;</span>, <span class="tok-str">&quot;14.0&quot;</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L897">                    <span class="tok-kw">error</span>.OutOfMemory =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory,</span>
<span class="line" id="L898">                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">break</span> :try_vs7_key,</span>
<span class="line" id="L899">                };</span>
<span class="line" id="L900"></span>
<span class="line" id="L901">                <span class="tok-kw">if</span> (path_maybe_with_trailing_slash.len &gt; std.fs.MAX_PATH_BYTES <span class="tok-kw">or</span> !std.fs.path.isAbsolute(path_maybe_with_trailing_slash)) {</span>
<span class="line" id="L902">                    allocator.free(path_maybe_with_trailing_slash);</span>
<span class="line" id="L903">                    <span class="tok-kw">break</span> :try_vs7_key;</span>
<span class="line" id="L904">                }</span>
<span class="line" id="L905"></span>
<span class="line" id="L906">                <span class="tok-kw">var</span> path = std.ArrayList(<span class="tok-type">u8</span>).fromOwnedSlice(allocator, path_maybe_with_trailing_slash);</span>
<span class="line" id="L907">                <span class="tok-kw">errdefer</span> path.deinit();</span>
<span class="line" id="L908"></span>
<span class="line" id="L909">                <span class="tok-comment">// String might contain trailing slash, so trim it here</span>
</span>
<span class="line" id="L910">                <span class="tok-kw">if</span> (path.items.len &gt; <span class="tok-str">&quot;C:\\&quot;</span>.len <span class="tok-kw">and</span> path.getLast() == <span class="tok-str">'\\'</span>) _ = path.pop();</span>
<span class="line" id="L911">                <span class="tok-kw">break</span> :base_path path;</span>
<span class="line" id="L912">            }</span>
<span class="line" id="L913">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PathNotFound;</span>
<span class="line" id="L914">        };</span>
<span class="line" id="L915">        <span class="tok-kw">errdefer</span> base_path.deinit();</span>
<span class="line" id="L916"></span>
<span class="line" id="L917">        <span class="tok-kw">const</span> folder_with_arch = <span class="tok-str">&quot;\\VC\\lib\\&quot;</span> ++ <span class="tok-kw">comptime</span> <span class="tok-kw">switch</span> (builtin.target.cpu.arch) {</span>
<span class="line" id="L918">            .x86 =&gt; <span class="tok-str">&quot;&quot;</span>, <span class="tok-comment">//x86 is in the root of the Lib folder</span>
</span>
<span class="line" id="L919">            .x86_64 =&gt; <span class="tok-str">&quot;amd64&quot;</span>,</span>
<span class="line" id="L920">            .arm, .armeb =&gt; <span class="tok-str">&quot;arm&quot;</span>,</span>
<span class="line" id="L921">            .aarch64 =&gt; <span class="tok-str">&quot;arm64&quot;</span>,</span>
<span class="line" id="L922">            <span class="tok-kw">else</span> =&gt; |tag| <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;MSVC lib dir cannot be detected on architecture &quot;</span> ++ tag),</span>
<span class="line" id="L923">        };</span>
<span class="line" id="L924">        <span class="tok-kw">try</span> base_path.appendSlice(folder_with_arch);</span>
<span class="line" id="L925"></span>
<span class="line" id="L926">        <span class="tok-kw">if</span> (!verifyLibDir(base_path.items)) {</span>
<span class="line" id="L927">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PathNotFound;</span>
<span class="line" id="L928">        }</span>
<span class="line" id="L929"></span>
<span class="line" id="L930">        <span class="tok-kw">const</span> full_path = <span class="tok-kw">try</span> base_path.toOwnedSlice();</span>
<span class="line" id="L931">        <span class="tok-kw">return</span> full_path;</span>
<span class="line" id="L932">    }</span>
<span class="line" id="L933"></span>
<span class="line" id="L934">    <span class="tok-kw">fn</span> <span class="tok-fn">verifyLibDir</span>(lib_dir_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">bool</span> {</span>
<span class="line" id="L935">        std.debug.assert(std.fs.path.isAbsolute(lib_dir_path)); <span class="tok-comment">// should be already handled in `findVia*`</span>
</span>
<span class="line" id="L936"></span>
<span class="line" id="L937">        <span class="tok-kw">var</span> dir = std.fs.openDirAbsolute(lib_dir_path, .{}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L938">        <span class="tok-kw">defer</span> dir.close();</span>
<span class="line" id="L939"></span>
<span class="line" id="L940">        <span class="tok-kw">const</span> stat = dir.statFile(<span class="tok-str">&quot;vcruntime.lib&quot;</span>) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L941">        <span class="tok-kw">if</span> (stat.kind != .file)</span>
<span class="line" id="L942">            <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L943"></span>
<span class="line" id="L944">        <span class="tok-kw">return</span> <span class="tok-null">true</span>;</span>
<span class="line" id="L945">    }</span>
<span class="line" id="L946"></span>
<span class="line" id="L947">    <span class="tok-comment">/// Find path to MSVC's `lib/` directory.</span></span>
<span class="line" id="L948">    <span class="tok-comment">/// Caller owns the result.</span></span>
<span class="line" id="L949">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">find</span>(allocator: std.mem.Allocator) <span class="tok-kw">error</span>{ OutOfMemory, MsvcLibDirNotFound }![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L950">        <span class="tok-kw">const</span> full_path = MsvcLibDir.findViaCOM(allocator) <span class="tok-kw">catch</span> |err1| <span class="tok-kw">switch</span> (err1) {</span>
<span class="line" id="L951">            <span class="tok-kw">error</span>.OutOfMemory =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory,</span>
<span class="line" id="L952">            <span class="tok-kw">error</span>.PathNotFound =&gt; MsvcLibDir.findViaRegistry(allocator) <span class="tok-kw">catch</span> |err2| <span class="tok-kw">switch</span> (err2) {</span>
<span class="line" id="L953">                <span class="tok-kw">error</span>.OutOfMemory =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory,</span>
<span class="line" id="L954">                <span class="tok-kw">error</span>.PathNotFound =&gt; MsvcLibDir.findViaVs7Key(allocator) <span class="tok-kw">catch</span> |err3| <span class="tok-kw">switch</span> (err3) {</span>
<span class="line" id="L955">                    <span class="tok-kw">error</span>.OutOfMemory =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory,</span>
<span class="line" id="L956">                    <span class="tok-kw">error</span>.PathNotFound =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MsvcLibDirNotFound,</span>
<span class="line" id="L957">                },</span>
<span class="line" id="L958">            },</span>
<span class="line" id="L959">        };</span>
<span class="line" id="L960">        <span class="tok-kw">errdefer</span> allocator.free(full_path);</span>
<span class="line" id="L961"></span>
<span class="line" id="L962">        <span class="tok-kw">return</span> full_path;</span>
<span class="line" id="L963">    }</span>
<span class="line" id="L964">};</span>
<span class="line" id="L965"></span>
</code></pre></body>
</html>