<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>zig/system.zig - source view</title>
    <link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAgklEQVR4AWMYWuD7EllJIM4G4g4g5oIJ/odhOJ8wToOxSTXgNxDHoeiBMfA4+wGShjyYOCkG/IGqWQziEzYAoUAeiF9D5U+DxEg14DRU7jWIT5IBIOdCxf+A+CQZAAoopEB7QJwBCBwHiip8UYmRdrAlDpIMgApwQZNnNii5Dq0MBgCxxycBnwEd+wAAAABJRU5ErkJggg==">
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style>
      body{
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        margin: 0;
        line-height: 1.5;
      }

      pre > code {
        display: block;
        overflow: auto;
        line-height: normal;
        margin: 0em;
      }
      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #005C7A;
      }
      .tok-comment {
          color: #545454;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #005C5C;
      }
      .tok-number {
          color: #005C5C;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }
      pre {
        counter-reset: line;
      }
      pre .line:before {
        counter-increment: line;
        content: counter(line);
        display: inline-block;
        padding-right: 1em;
        width: 2em;
        text-align: right;
        color: #999;
      }
      
      .line {
        width: 100%;
        display: inline-block;
      }
      .line:target {
        border-top: 1px solid #ccc;
        border-bottom: 1px solid #ccc;
        background: #fafafa;
      }

      @media (prefers-color-scheme: dark) {
        body{
            background:#222;
            color: #ccc;
        }
        pre > code {
            color: #ccc;
            background: #222;
            border: unset;
        }
        .line:target {
            border-top: 1px solid #444;
            border-bottom: 1px solid #444;
            background: #333;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
</head>
<body>
<pre><code><span class="line" id="L1"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> NativePaths = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;system/NativePaths.zig&quot;</span>);</span>
<span class="line" id="L2"></span>
<span class="line" id="L3"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> windows = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;system/windows.zig&quot;</span>);</span>
<span class="line" id="L4"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> darwin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;system/darwin.zig&quot;</span>);</span>
<span class="line" id="L5"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> linux = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;system/linux.zig&quot;</span>);</span>
<span class="line" id="L6"></span>
<span class="line" id="L7"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Executor = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {</span>
<span class="line" id="L8">    native,</span>
<span class="line" id="L9">    rosetta,</span>
<span class="line" id="L10">    qemu: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L11">    wine: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L12">    wasmtime: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L13">    darling: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L14">    bad_dl: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L15">    bad_os_or_cpu,</span>
<span class="line" id="L16">};</span>
<span class="line" id="L17"></span>
<span class="line" id="L18"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> GetExternalExecutorOptions = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L19">    allow_darling: <span class="tok-type">bool</span> = <span class="tok-null">true</span>,</span>
<span class="line" id="L20">    allow_qemu: <span class="tok-type">bool</span> = <span class="tok-null">true</span>,</span>
<span class="line" id="L21">    allow_rosetta: <span class="tok-type">bool</span> = <span class="tok-null">true</span>,</span>
<span class="line" id="L22">    allow_wasmtime: <span class="tok-type">bool</span> = <span class="tok-null">true</span>,</span>
<span class="line" id="L23">    allow_wine: <span class="tok-type">bool</span> = <span class="tok-null">true</span>,</span>
<span class="line" id="L24">    qemu_fixes_dl: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,</span>
<span class="line" id="L25">    link_libc: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,</span>
<span class="line" id="L26">};</span>
<span class="line" id="L27"></span>
<span class="line" id="L28"><span class="tok-comment">/// Return whether or not the given host is capable of running executables of</span></span>
<span class="line" id="L29"><span class="tok-comment">/// the other target.</span></span>
<span class="line" id="L30"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getExternalExecutor</span>(</span>
<span class="line" id="L31">    host: std.Target,</span>
<span class="line" id="L32">    candidate: *<span class="tok-kw">const</span> std.Target,</span>
<span class="line" id="L33">    options: GetExternalExecutorOptions,</span>
<span class="line" id="L34">) Executor {</span>
<span class="line" id="L35">    <span class="tok-kw">const</span> os_match = host.os.tag == candidate.os.tag;</span>
<span class="line" id="L36">    <span class="tok-kw">const</span> cpu_ok = cpu_ok: {</span>
<span class="line" id="L37">        <span class="tok-kw">if</span> (host.cpu.arch == candidate.cpu.arch)</span>
<span class="line" id="L38">            <span class="tok-kw">break</span> :cpu_ok <span class="tok-null">true</span>;</span>
<span class="line" id="L39"></span>
<span class="line" id="L40">        <span class="tok-kw">if</span> (host.cpu.arch == .x86_64 <span class="tok-kw">and</span> candidate.cpu.arch == .x86)</span>
<span class="line" id="L41">            <span class="tok-kw">break</span> :cpu_ok <span class="tok-null">true</span>;</span>
<span class="line" id="L42"></span>
<span class="line" id="L43">        <span class="tok-kw">if</span> (host.cpu.arch == .aarch64 <span class="tok-kw">and</span> candidate.cpu.arch == .arm)</span>
<span class="line" id="L44">            <span class="tok-kw">break</span> :cpu_ok <span class="tok-null">true</span>;</span>
<span class="line" id="L45"></span>
<span class="line" id="L46">        <span class="tok-kw">if</span> (host.cpu.arch == .aarch64_be <span class="tok-kw">and</span> candidate.cpu.arch == .armeb)</span>
<span class="line" id="L47">            <span class="tok-kw">break</span> :cpu_ok <span class="tok-null">true</span>;</span>
<span class="line" id="L48"></span>
<span class="line" id="L49">        <span class="tok-comment">// TODO additionally detect incompatible CPU features.</span>
</span>
<span class="line" id="L50">        <span class="tok-comment">// Note that in some cases the OS kernel will emulate missing CPU features</span>
</span>
<span class="line" id="L51">        <span class="tok-comment">// when an illegal instruction is encountered.</span>
</span>
<span class="line" id="L52"></span>
<span class="line" id="L53">        <span class="tok-kw">break</span> :cpu_ok <span class="tok-null">false</span>;</span>
<span class="line" id="L54">    };</span>
<span class="line" id="L55"></span>
<span class="line" id="L56">    <span class="tok-kw">var</span> bad_result: Executor = .bad_os_or_cpu;</span>
<span class="line" id="L57"></span>
<span class="line" id="L58">    <span class="tok-kw">if</span> (os_match <span class="tok-kw">and</span> cpu_ok) native: {</span>
<span class="line" id="L59">        <span class="tok-kw">if</span> (options.link_libc) {</span>
<span class="line" id="L60">            <span class="tok-kw">if</span> (candidate.dynamic_linker.get()) |candidate_dl| {</span>
<span class="line" id="L61">                fs.cwd().access(candidate_dl, .{}) <span class="tok-kw">catch</span> {</span>
<span class="line" id="L62">                    bad_result = .{ .bad_dl = candidate_dl };</span>
<span class="line" id="L63">                    <span class="tok-kw">break</span> :native;</span>
<span class="line" id="L64">                };</span>
<span class="line" id="L65">            }</span>
<span class="line" id="L66">        }</span>
<span class="line" id="L67">        <span class="tok-kw">return</span> .native;</span>
<span class="line" id="L68">    }</span>
<span class="line" id="L69"></span>
<span class="line" id="L70">    <span class="tok-comment">// If the OS match and OS is macOS and CPU is arm64, we can use Rosetta 2</span>
</span>
<span class="line" id="L71">    <span class="tok-comment">// to emulate the foreign architecture.</span>
</span>
<span class="line" id="L72">    <span class="tok-kw">if</span> (options.allow_rosetta <span class="tok-kw">and</span> os_match <span class="tok-kw">and</span></span>
<span class="line" id="L73">        host.os.tag == .macos <span class="tok-kw">and</span> host.cpu.arch == .aarch64)</span>
<span class="line" id="L74">    {</span>
<span class="line" id="L75">        <span class="tok-kw">switch</span> (candidate.cpu.arch) {</span>
<span class="line" id="L76">            .x86_64 =&gt; <span class="tok-kw">return</span> .rosetta,</span>
<span class="line" id="L77">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> bad_result,</span>
<span class="line" id="L78">        }</span>
<span class="line" id="L79">    }</span>
<span class="line" id="L80"></span>
<span class="line" id="L81">    <span class="tok-comment">// If the OS matches, we can use QEMU to emulate a foreign architecture.</span>
</span>
<span class="line" id="L82">    <span class="tok-kw">if</span> (options.allow_qemu <span class="tok-kw">and</span> os_match <span class="tok-kw">and</span> (!cpu_ok <span class="tok-kw">or</span> options.qemu_fixes_dl)) {</span>
<span class="line" id="L83">        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (candidate.cpu.arch) {</span>
<span class="line" id="L84">            .aarch64 =&gt; Executor{ .qemu = <span class="tok-str">&quot;qemu-aarch64&quot;</span> },</span>
<span class="line" id="L85">            .aarch64_be =&gt; Executor{ .qemu = <span class="tok-str">&quot;qemu-aarch64_be&quot;</span> },</span>
<span class="line" id="L86">            .arm =&gt; Executor{ .qemu = <span class="tok-str">&quot;qemu-arm&quot;</span> },</span>
<span class="line" id="L87">            .armeb =&gt; Executor{ .qemu = <span class="tok-str">&quot;qemu-armeb&quot;</span> },</span>
<span class="line" id="L88">            .hexagon =&gt; Executor{ .qemu = <span class="tok-str">&quot;qemu-hexagon&quot;</span> },</span>
<span class="line" id="L89">            .x86 =&gt; Executor{ .qemu = <span class="tok-str">&quot;qemu-i386&quot;</span> },</span>
<span class="line" id="L90">            .m68k =&gt; Executor{ .qemu = <span class="tok-str">&quot;qemu-m68k&quot;</span> },</span>
<span class="line" id="L91">            .mips =&gt; Executor{ .qemu = <span class="tok-str">&quot;qemu-mips&quot;</span> },</span>
<span class="line" id="L92">            .mipsel =&gt; Executor{ .qemu = <span class="tok-str">&quot;qemu-mipsel&quot;</span> },</span>
<span class="line" id="L93">            .mips64 =&gt; Executor{ .qemu = <span class="tok-str">&quot;qemu-mips64&quot;</span> },</span>
<span class="line" id="L94">            .mips64el =&gt; Executor{ .qemu = <span class="tok-str">&quot;qemu-mips64el&quot;</span> },</span>
<span class="line" id="L95">            .powerpc =&gt; Executor{ .qemu = <span class="tok-str">&quot;qemu-ppc&quot;</span> },</span>
<span class="line" id="L96">            .powerpc64 =&gt; Executor{ .qemu = <span class="tok-str">&quot;qemu-ppc64&quot;</span> },</span>
<span class="line" id="L97">            .powerpc64le =&gt; Executor{ .qemu = <span class="tok-str">&quot;qemu-ppc64le&quot;</span> },</span>
<span class="line" id="L98">            .riscv32 =&gt; Executor{ .qemu = <span class="tok-str">&quot;qemu-riscv32&quot;</span> },</span>
<span class="line" id="L99">            .riscv64 =&gt; Executor{ .qemu = <span class="tok-str">&quot;qemu-riscv64&quot;</span> },</span>
<span class="line" id="L100">            .s390x =&gt; Executor{ .qemu = <span class="tok-str">&quot;qemu-s390x&quot;</span> },</span>
<span class="line" id="L101">            .sparc =&gt; Executor{ .qemu = <span class="tok-str">&quot;qemu-sparc&quot;</span> },</span>
<span class="line" id="L102">            .sparc64 =&gt; Executor{ .qemu = <span class="tok-str">&quot;qemu-sparc64&quot;</span> },</span>
<span class="line" id="L103">            .x86_64 =&gt; Executor{ .qemu = <span class="tok-str">&quot;qemu-x86_64&quot;</span> },</span>
<span class="line" id="L104">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> bad_result,</span>
<span class="line" id="L105">        };</span>
<span class="line" id="L106">    }</span>
<span class="line" id="L107"></span>
<span class="line" id="L108">    <span class="tok-kw">switch</span> (candidate.os.tag) {</span>
<span class="line" id="L109">        .windows =&gt; {</span>
<span class="line" id="L110">            <span class="tok-kw">if</span> (options.allow_wine) {</span>
<span class="line" id="L111">                <span class="tok-comment">// x86_64 wine does not support emulating aarch64-windows and</span>
</span>
<span class="line" id="L112">                <span class="tok-comment">// vice versa.</span>
</span>
<span class="line" id="L113">                <span class="tok-kw">if</span> (candidate.cpu.arch != builtin.cpu.arch) {</span>
<span class="line" id="L114">                    <span class="tok-kw">return</span> bad_result;</span>
<span class="line" id="L115">                }</span>
<span class="line" id="L116">                <span class="tok-kw">switch</span> (candidate.ptrBitWidth()) {</span>
<span class="line" id="L117">                    <span class="tok-number">32</span> =&gt; <span class="tok-kw">return</span> Executor{ .wine = <span class="tok-str">&quot;wine&quot;</span> },</span>
<span class="line" id="L118">                    <span class="tok-number">64</span> =&gt; <span class="tok-kw">return</span> Executor{ .wine = <span class="tok-str">&quot;wine64&quot;</span> },</span>
<span class="line" id="L119">                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> bad_result,</span>
<span class="line" id="L120">                }</span>
<span class="line" id="L121">            }</span>
<span class="line" id="L122">            <span class="tok-kw">return</span> bad_result;</span>
<span class="line" id="L123">        },</span>
<span class="line" id="L124">        .wasi =&gt; {</span>
<span class="line" id="L125">            <span class="tok-kw">if</span> (options.allow_wasmtime) {</span>
<span class="line" id="L126">                <span class="tok-kw">switch</span> (candidate.ptrBitWidth()) {</span>
<span class="line" id="L127">                    <span class="tok-number">32</span> =&gt; <span class="tok-kw">return</span> Executor{ .wasmtime = <span class="tok-str">&quot;wasmtime&quot;</span> },</span>
<span class="line" id="L128">                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> bad_result,</span>
<span class="line" id="L129">                }</span>
<span class="line" id="L130">            }</span>
<span class="line" id="L131">            <span class="tok-kw">return</span> bad_result;</span>
<span class="line" id="L132">        },</span>
<span class="line" id="L133">        .macos =&gt; {</span>
<span class="line" id="L134">            <span class="tok-kw">if</span> (options.allow_darling) {</span>
<span class="line" id="L135">                <span class="tok-comment">// This check can be loosened once darling adds a QEMU-based emulation</span>
</span>
<span class="line" id="L136">                <span class="tok-comment">// layer for non-host architectures:</span>
</span>
<span class="line" id="L137">                <span class="tok-comment">// https://github.com/darlinghq/darling/issues/863</span>
</span>
<span class="line" id="L138">                <span class="tok-kw">if</span> (candidate.cpu.arch != builtin.cpu.arch) {</span>
<span class="line" id="L139">                    <span class="tok-kw">return</span> bad_result;</span>
<span class="line" id="L140">                }</span>
<span class="line" id="L141">                <span class="tok-kw">return</span> Executor{ .darling = <span class="tok-str">&quot;darling&quot;</span> };</span>
<span class="line" id="L142">            }</span>
<span class="line" id="L143">            <span class="tok-kw">return</span> bad_result;</span>
<span class="line" id="L144">        },</span>
<span class="line" id="L145">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> bad_result,</span>
<span class="line" id="L146">    }</span>
<span class="line" id="L147">}</span>
<span class="line" id="L148"></span>
<span class="line" id="L149"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> DetectError = <span class="tok-kw">error</span>{</span>
<span class="line" id="L150">    FileSystem,</span>
<span class="line" id="L151">    SystemResources,</span>
<span class="line" id="L152">    SymLinkLoop,</span>
<span class="line" id="L153">    ProcessFdQuotaExceeded,</span>
<span class="line" id="L154">    SystemFdQuotaExceeded,</span>
<span class="line" id="L155">    DeviceBusy,</span>
<span class="line" id="L156">    OSVersionDetectionFail,</span>
<span class="line" id="L157">    Unexpected,</span>
<span class="line" id="L158">};</span>
<span class="line" id="L159"></span>
<span class="line" id="L160"><span class="tok-comment">/// Given a `Target.Query`, which specifies in detail which parts of the</span></span>
<span class="line" id="L161"><span class="tok-comment">/// target should be detected natively, which should be standard or default,</span></span>
<span class="line" id="L162"><span class="tok-comment">/// and which are provided explicitly, this function resolves the native</span></span>
<span class="line" id="L163"><span class="tok-comment">/// components by detecting the native system, and then resolves</span></span>
<span class="line" id="L164"><span class="tok-comment">/// standard/default parts relative to that.</span></span>
<span class="line" id="L165"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">resolveTargetQuery</span>(query: Target.Query) DetectError!Target {</span>
<span class="line" id="L166">    <span class="tok-kw">const</span> query_os_tag = query.os_tag <span class="tok-kw">orelse</span> builtin.os.tag;</span>
<span class="line" id="L167">    <span class="tok-kw">var</span> os = query_os_tag.defaultVersionRange(query.cpu_arch <span class="tok-kw">orelse</span> builtin.cpu.arch);</span>
<span class="line" id="L168">    <span class="tok-kw">if</span> (query.os_tag == <span class="tok-null">null</span>) {</span>
<span class="line" id="L169">        <span class="tok-kw">switch</span> (builtin.target.os.tag) {</span>
<span class="line" id="L170">            .linux =&gt; {</span>
<span class="line" id="L171">                <span class="tok-kw">const</span> uts = std.os.uname();</span>
<span class="line" id="L172">                <span class="tok-kw">const</span> release = mem.sliceTo(&amp;uts.release, <span class="tok-number">0</span>);</span>
<span class="line" id="L173">                <span class="tok-comment">// The release field sometimes has a weird format,</span>
</span>
<span class="line" id="L174">                <span class="tok-comment">// `Version.parse` will attempt to find some meaningful interpretation.</span>
</span>
<span class="line" id="L175">                <span class="tok-kw">if</span> (std.SemanticVersion.parse(release)) |ver| {</span>
<span class="line" id="L176">                    os.version_range.linux.range.min = ver;</span>
<span class="line" id="L177">                    os.version_range.linux.range.max = ver;</span>
<span class="line" id="L178">                } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L179">                    <span class="tok-kw">error</span>.Overflow =&gt; {},</span>
<span class="line" id="L180">                    <span class="tok-kw">error</span>.InvalidVersion =&gt; {},</span>
<span class="line" id="L181">                }</span>
<span class="line" id="L182">            },</span>
<span class="line" id="L183">            .solaris, .illumos =&gt; {</span>
<span class="line" id="L184">                <span class="tok-kw">const</span> uts = std.os.uname();</span>
<span class="line" id="L185">                <span class="tok-kw">const</span> release = mem.sliceTo(&amp;uts.release, <span class="tok-number">0</span>);</span>
<span class="line" id="L186">                <span class="tok-kw">if</span> (std.SemanticVersion.parse(release)) |ver| {</span>
<span class="line" id="L187">                    os.version_range.semver.min = ver;</span>
<span class="line" id="L188">                    os.version_range.semver.max = ver;</span>
<span class="line" id="L189">                } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L190">                    <span class="tok-kw">error</span>.Overflow =&gt; {},</span>
<span class="line" id="L191">                    <span class="tok-kw">error</span>.InvalidVersion =&gt; {},</span>
<span class="line" id="L192">                }</span>
<span class="line" id="L193">            },</span>
<span class="line" id="L194">            .windows =&gt; {</span>
<span class="line" id="L195">                <span class="tok-kw">const</span> detected_version = windows.detectRuntimeVersion();</span>
<span class="line" id="L196">                os.version_range.windows.min = detected_version;</span>
<span class="line" id="L197">                os.version_range.windows.max = detected_version;</span>
<span class="line" id="L198">            },</span>
<span class="line" id="L199">            .macos =&gt; <span class="tok-kw">try</span> darwin.macos.detect(&amp;os),</span>
<span class="line" id="L200">            .freebsd, .netbsd, .dragonfly =&gt; {</span>
<span class="line" id="L201">                <span class="tok-kw">const</span> key = <span class="tok-kw">switch</span> (builtin.target.os.tag) {</span>
<span class="line" id="L202">                    .freebsd =&gt; <span class="tok-str">&quot;kern.osreldate&quot;</span>,</span>
<span class="line" id="L203">                    .netbsd, .dragonfly =&gt; <span class="tok-str">&quot;kern.osrevision&quot;</span>,</span>
<span class="line" id="L204">                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L205">                };</span>
<span class="line" id="L206">                <span class="tok-kw">var</span> value: <span class="tok-type">u32</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L207">                <span class="tok-kw">var</span> len: <span class="tok-type">usize</span> = <span class="tok-builtin">@sizeOf</span>(<span class="tok-builtin">@TypeOf</span>(value));</span>
<span class="line" id="L208"></span>
<span class="line" id="L209">                std.os.sysctlbynameZ(key, &amp;value, &amp;len, <span class="tok-null">null</span>, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L210">                    <span class="tok-kw">error</span>.NameTooLong =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// constant, known good value</span>
</span>
<span class="line" id="L211">                    <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// only when setting values,</span>
</span>
<span class="line" id="L212">                    <span class="tok-kw">error</span>.SystemResources =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// memory already on the stack</span>
</span>
<span class="line" id="L213">                    <span class="tok-kw">error</span>.UnknownName =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// constant, known good value</span>
</span>
<span class="line" id="L214">                    <span class="tok-kw">error</span>.Unexpected =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OSVersionDetectionFail,</span>
<span class="line" id="L215">                };</span>
<span class="line" id="L216"></span>
<span class="line" id="L217">                <span class="tok-kw">switch</span> (builtin.target.os.tag) {</span>
<span class="line" id="L218">                    .freebsd =&gt; {</span>
<span class="line" id="L219">                        <span class="tok-comment">// https://www.freebsd.org/doc/en_US.ISO8859-1/books/porters-handbook/versions.html</span>
</span>
<span class="line" id="L220">                        <span class="tok-comment">// Major * 100,000 has been convention since FreeBSD 2.2 (1997)</span>
</span>
<span class="line" id="L221">                        <span class="tok-comment">// Minor * 1(0),000 summed has been convention since FreeBSD 2.2 (1997)</span>
</span>
<span class="line" id="L222">                        <span class="tok-comment">// e.g. 492101 = 4.11-STABLE = 4.(9+2)</span>
</span>
<span class="line" id="L223">                        <span class="tok-kw">const</span> major = value / <span class="tok-number">100_000</span>;</span>
<span class="line" id="L224">                        <span class="tok-kw">const</span> minor1 = value % <span class="tok-number">100_000</span> / <span class="tok-number">10_000</span>; <span class="tok-comment">// usually 0 since 5.1</span>
</span>
<span class="line" id="L225">                        <span class="tok-kw">const</span> minor2 = value % <span class="tok-number">10_000</span> / <span class="tok-number">1_000</span>; <span class="tok-comment">// 0 before 5.1, minor version since</span>
</span>
<span class="line" id="L226">                        <span class="tok-kw">const</span> patch = value % <span class="tok-number">1_000</span>;</span>
<span class="line" id="L227">                        os.version_range.semver.min = .{ .major = major, .minor = minor1 + minor2, .patch = patch };</span>
<span class="line" id="L228">                        os.version_range.semver.max = os.version_range.semver.min;</span>
<span class="line" id="L229">                    },</span>
<span class="line" id="L230">                    .netbsd =&gt; {</span>
<span class="line" id="L231">                        <span class="tok-comment">// #define __NetBSD_Version__ MMmmrrpp00</span>
</span>
<span class="line" id="L232">                        <span class="tok-comment">//</span>
</span>
<span class="line" id="L233">                        <span class="tok-comment">// M = major version</span>
</span>
<span class="line" id="L234">                        <span class="tok-comment">// m = minor version; a minor number of 99 indicates current.</span>
</span>
<span class="line" id="L235">                        <span class="tok-comment">// r = 0 (*)</span>
</span>
<span class="line" id="L236">                        <span class="tok-comment">// p = patchlevel</span>
</span>
<span class="line" id="L237">                        <span class="tok-kw">const</span> major = value / <span class="tok-number">100_000_000</span>;</span>
<span class="line" id="L238">                        <span class="tok-kw">const</span> minor = value % <span class="tok-number">100_000_000</span> / <span class="tok-number">1_000_000</span>;</span>
<span class="line" id="L239">                        <span class="tok-kw">const</span> patch = value % <span class="tok-number">10_000</span> / <span class="tok-number">100</span>;</span>
<span class="line" id="L240">                        os.version_range.semver.min = .{ .major = major, .minor = minor, .patch = patch };</span>
<span class="line" id="L241">                        os.version_range.semver.max = os.version_range.semver.min;</span>
<span class="line" id="L242">                    },</span>
<span class="line" id="L243">                    .dragonfly =&gt; {</span>
<span class="line" id="L244">                        <span class="tok-comment">// https://github.com/DragonFlyBSD/DragonFlyBSD/blob/cb2cde83771754aeef9bb3251ee48959138dec87/Makefile.inc1#L15-L17</span>
</span>
<span class="line" id="L245">                        <span class="tok-comment">// flat base10 format: Mmmmpp</span>
</span>
<span class="line" id="L246">                        <span class="tok-comment">//   M = major</span>
</span>
<span class="line" id="L247">                        <span class="tok-comment">//   m = minor; odd-numbers indicate current dev branch</span>
</span>
<span class="line" id="L248">                        <span class="tok-comment">//   p = patch</span>
</span>
<span class="line" id="L249">                        <span class="tok-kw">const</span> major = value / <span class="tok-number">100_000</span>;</span>
<span class="line" id="L250">                        <span class="tok-kw">const</span> minor = value % <span class="tok-number">100_000</span> / <span class="tok-number">100</span>;</span>
<span class="line" id="L251">                        <span class="tok-kw">const</span> patch = value % <span class="tok-number">100</span>;</span>
<span class="line" id="L252">                        os.version_range.semver.min = .{ .major = major, .minor = minor, .patch = patch };</span>
<span class="line" id="L253">                        os.version_range.semver.max = os.version_range.semver.min;</span>
<span class="line" id="L254">                    },</span>
<span class="line" id="L255">                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L256">                }</span>
<span class="line" id="L257">            },</span>
<span class="line" id="L258">            .openbsd =&gt; {</span>
<span class="line" id="L259">                <span class="tok-kw">const</span> mib: [<span class="tok-number">2</span>]<span class="tok-type">c_int</span> = [_]<span class="tok-type">c_int</span>{</span>
<span class="line" id="L260">                    std.os.CTL.KERN,</span>
<span class="line" id="L261">                    std.os.KERN.OSRELEASE,</span>
<span class="line" id="L262">                };</span>
<span class="line" id="L263">                <span class="tok-kw">var</span> buf: [<span class="tok-number">64</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L264">                <span class="tok-comment">// consider that sysctl result includes null-termination</span>
</span>
<span class="line" id="L265">                <span class="tok-comment">// reserve 1 byte to ensure we never overflow when appending &quot;.0&quot;</span>
</span>
<span class="line" id="L266">                <span class="tok-kw">var</span> len: <span class="tok-type">usize</span> = buf.len - <span class="tok-number">1</span>;</span>
<span class="line" id="L267"></span>
<span class="line" id="L268">                std.os.sysctl(&amp;mib, &amp;buf, &amp;len, <span class="tok-null">null</span>, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L269">                    <span class="tok-kw">error</span>.NameTooLong =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// constant, known good value</span>
</span>
<span class="line" id="L270">                    <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// only when setting values,</span>
</span>
<span class="line" id="L271">                    <span class="tok-kw">error</span>.SystemResources =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// memory already on the stack</span>
</span>
<span class="line" id="L272">                    <span class="tok-kw">error</span>.UnknownName =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// constant, known good value</span>
</span>
<span class="line" id="L273">                    <span class="tok-kw">error</span>.Unexpected =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OSVersionDetectionFail,</span>
<span class="line" id="L274">                };</span>
<span class="line" id="L275"></span>
<span class="line" id="L276">                <span class="tok-comment">// append &quot;.0&quot; to satisfy semver</span>
</span>
<span class="line" id="L277">                buf[len - <span class="tok-number">1</span>] = <span class="tok-str">'.'</span>;</span>
<span class="line" id="L278">                buf[len] = <span class="tok-str">'0'</span>;</span>
<span class="line" id="L279">                len += <span class="tok-number">1</span>;</span>
<span class="line" id="L280"></span>
<span class="line" id="L281">                <span class="tok-kw">if</span> (std.SemanticVersion.parse(buf[<span class="tok-number">0</span>..len])) |ver| {</span>
<span class="line" id="L282">                    os.version_range.semver.min = ver;</span>
<span class="line" id="L283">                    os.version_range.semver.max = ver;</span>
<span class="line" id="L284">                } <span class="tok-kw">else</span> |_| {</span>
<span class="line" id="L285">                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OSVersionDetectionFail;</span>
<span class="line" id="L286">                }</span>
<span class="line" id="L287">            },</span>
<span class="line" id="L288">            <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L289">                <span class="tok-comment">// Unimplemented, fall back to default version range.</span>
</span>
<span class="line" id="L290">            },</span>
<span class="line" id="L291">        }</span>
<span class="line" id="L292">    }</span>
<span class="line" id="L293"></span>
<span class="line" id="L294">    <span class="tok-kw">if</span> (query.os_version_min) |min| <span class="tok-kw">switch</span> (min) {</span>
<span class="line" id="L295">        .none =&gt; {},</span>
<span class="line" id="L296">        .semver =&gt; |semver| <span class="tok-kw">switch</span> (os.tag) {</span>
<span class="line" id="L297">            .linux =&gt; os.version_range.linux.range.min = semver,</span>
<span class="line" id="L298">            <span class="tok-kw">else</span> =&gt; os.version_range.semver.min = semver,</span>
<span class="line" id="L299">        },</span>
<span class="line" id="L300">        .windows =&gt; |win_ver| os.version_range.windows.min = win_ver,</span>
<span class="line" id="L301">    };</span>
<span class="line" id="L302"></span>
<span class="line" id="L303">    <span class="tok-kw">if</span> (query.os_version_max) |max| <span class="tok-kw">switch</span> (max) {</span>
<span class="line" id="L304">        .none =&gt; {},</span>
<span class="line" id="L305">        .semver =&gt; |semver| <span class="tok-kw">switch</span> (os.tag) {</span>
<span class="line" id="L306">            .linux =&gt; os.version_range.linux.range.max = semver,</span>
<span class="line" id="L307">            <span class="tok-kw">else</span> =&gt; os.version_range.semver.max = semver,</span>
<span class="line" id="L308">        },</span>
<span class="line" id="L309">        .windows =&gt; |win_ver| os.version_range.windows.max = win_ver,</span>
<span class="line" id="L310">    };</span>
<span class="line" id="L311"></span>
<span class="line" id="L312">    <span class="tok-kw">if</span> (query.glibc_version) |glibc| {</span>
<span class="line" id="L313">        os.version_range.linux.glibc = glibc;</span>
<span class="line" id="L314">    }</span>
<span class="line" id="L315"></span>
<span class="line" id="L316">    <span class="tok-comment">// Until https://github.com/ziglang/zig/issues/4592 is implemented (support detecting the</span>
</span>
<span class="line" id="L317">    <span class="tok-comment">// native CPU architecture as being different than the current target), we use this:</span>
</span>
<span class="line" id="L318">    <span class="tok-kw">const</span> cpu_arch = query.cpu_arch <span class="tok-kw">orelse</span> builtin.cpu.arch;</span>
<span class="line" id="L319"></span>
<span class="line" id="L320">    <span class="tok-kw">const</span> cpu = <span class="tok-kw">switch</span> (query.cpu_model) {</span>
<span class="line" id="L321">        .native =&gt; detectNativeCpuAndFeatures(cpu_arch, os, query),</span>
<span class="line" id="L322">        .baseline =&gt; Target.Cpu.baseline(cpu_arch),</span>
<span class="line" id="L323">        .determined_by_cpu_arch =&gt; <span class="tok-kw">if</span> (query.cpu_arch == <span class="tok-null">null</span>)</span>
<span class="line" id="L324">            detectNativeCpuAndFeatures(cpu_arch, os, query)</span>
<span class="line" id="L325">        <span class="tok-kw">else</span></span>
<span class="line" id="L326">            Target.Cpu.baseline(cpu_arch),</span>
<span class="line" id="L327">        .explicit =&gt; |model| model.toCpu(cpu_arch),</span>
<span class="line" id="L328">    } <span class="tok-kw">orelse</span> backup_cpu_detection: {</span>
<span class="line" id="L329">        <span class="tok-kw">break</span> :backup_cpu_detection Target.Cpu.baseline(cpu_arch);</span>
<span class="line" id="L330">    };</span>
<span class="line" id="L331">    <span class="tok-kw">var</span> result = <span class="tok-kw">try</span> detectAbiAndDynamicLinker(cpu, os, query);</span>
<span class="line" id="L332">    <span class="tok-comment">// For x86, we need to populate some CPU feature flags depending on architecture</span>
</span>
<span class="line" id="L333">    <span class="tok-comment">// and mode:</span>
</span>
<span class="line" id="L334">    <span class="tok-comment">//  * 16bit_mode =&gt; if the abi is code16</span>
</span>
<span class="line" id="L335">    <span class="tok-comment">//  * 32bit_mode =&gt; if the arch is x86</span>
</span>
<span class="line" id="L336">    <span class="tok-comment">// However, the &quot;mode&quot; flags can be used as overrides, so if the user explicitly</span>
</span>
<span class="line" id="L337">    <span class="tok-comment">// sets one of them, that takes precedence.</span>
</span>
<span class="line" id="L338">    <span class="tok-kw">switch</span> (cpu_arch) {</span>
<span class="line" id="L339">        .x86 =&gt; {</span>
<span class="line" id="L340">            <span class="tok-kw">if</span> (!Target.x86.featureSetHasAny(query.cpu_features_add, .{</span>
<span class="line" id="L341">                .@&quot;16bit_mode&quot;, .@&quot;32bit_mode&quot;,</span>
<span class="line" id="L342">            })) {</span>
<span class="line" id="L343">                <span class="tok-kw">switch</span> (result.abi) {</span>
<span class="line" id="L344">                    .code16 =&gt; result.cpu.features.addFeature(</span>
<span class="line" id="L345">                        <span class="tok-builtin">@intFromEnum</span>(Target.x86.Feature.@&quot;16bit_mode&quot;),</span>
<span class="line" id="L346">                    ),</span>
<span class="line" id="L347">                    <span class="tok-kw">else</span> =&gt; result.cpu.features.addFeature(</span>
<span class="line" id="L348">                        <span class="tok-builtin">@intFromEnum</span>(Target.x86.Feature.@&quot;32bit_mode&quot;),</span>
<span class="line" id="L349">                    ),</span>
<span class="line" id="L350">                }</span>
<span class="line" id="L351">            }</span>
<span class="line" id="L352">        },</span>
<span class="line" id="L353">        .arm, .armeb =&gt; {</span>
<span class="line" id="L354">            <span class="tok-comment">// XXX What do we do if the target has the noarm feature?</span>
</span>
<span class="line" id="L355">            <span class="tok-comment">//     What do we do if the user specifies +thumb_mode?</span>
</span>
<span class="line" id="L356">        },</span>
<span class="line" id="L357">        .thumb, .thumbeb =&gt; {</span>
<span class="line" id="L358">            result.cpu.features.addFeature(</span>
<span class="line" id="L359">                <span class="tok-builtin">@intFromEnum</span>(Target.arm.Feature.thumb_mode),</span>
<span class="line" id="L360">            );</span>
<span class="line" id="L361">        },</span>
<span class="line" id="L362">        <span class="tok-kw">else</span> =&gt; {},</span>
<span class="line" id="L363">    }</span>
<span class="line" id="L364">    updateCpuFeatures(</span>
<span class="line" id="L365">        &amp;result.cpu.features,</span>
<span class="line" id="L366">        cpu_arch.allFeaturesList(),</span>
<span class="line" id="L367">        query.cpu_features_add,</span>
<span class="line" id="L368">        query.cpu_features_sub,</span>
<span class="line" id="L369">    );</span>
<span class="line" id="L370">    <span class="tok-kw">return</span> result;</span>
<span class="line" id="L371">}</span>
<span class="line" id="L372"></span>
<span class="line" id="L373"><span class="tok-kw">fn</span> <span class="tok-fn">updateCpuFeatures</span>(</span>
<span class="line" id="L374">    set: *Target.Cpu.Feature.Set,</span>
<span class="line" id="L375">    all_features_list: []<span class="tok-kw">const</span> Target.Cpu.Feature,</span>
<span class="line" id="L376">    add_set: Target.Cpu.Feature.Set,</span>
<span class="line" id="L377">    sub_set: Target.Cpu.Feature.Set,</span>
<span class="line" id="L378">) <span class="tok-type">void</span> {</span>
<span class="line" id="L379">    set.removeFeatureSet(sub_set);</span>
<span class="line" id="L380">    set.addFeatureSet(add_set);</span>
<span class="line" id="L381">    set.populateDependencies(all_features_list);</span>
<span class="line" id="L382">    set.removeFeatureSet(sub_set);</span>
<span class="line" id="L383">}</span>
<span class="line" id="L384"></span>
<span class="line" id="L385"><span class="tok-kw">fn</span> <span class="tok-fn">detectNativeCpuAndFeatures</span>(cpu_arch: Target.Cpu.Arch, os: Target.Os, query: Target.Query) ?Target.Cpu {</span>
<span class="line" id="L386">    <span class="tok-comment">// Here we switch on a comptime value rather than `cpu_arch`. This is valid because `cpu_arch`,</span>
</span>
<span class="line" id="L387">    <span class="tok-comment">// although it is a runtime value, is guaranteed to be one of the architectures in the set</span>
</span>
<span class="line" id="L388">    <span class="tok-comment">// of the respective switch prong.</span>
</span>
<span class="line" id="L389">    <span class="tok-kw">switch</span> (builtin.cpu.arch) {</span>
<span class="line" id="L390">        .x86_64, .x86 =&gt; {</span>
<span class="line" id="L391">            <span class="tok-kw">return</span> <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;system/x86.zig&quot;</span>).detectNativeCpuAndFeatures(cpu_arch, os, query);</span>
<span class="line" id="L392">        },</span>
<span class="line" id="L393">        <span class="tok-kw">else</span> =&gt; {},</span>
<span class="line" id="L394">    }</span>
<span class="line" id="L395"></span>
<span class="line" id="L396">    <span class="tok-kw">switch</span> (builtin.os.tag) {</span>
<span class="line" id="L397">        .linux =&gt; <span class="tok-kw">return</span> linux.detectNativeCpuAndFeatures(),</span>
<span class="line" id="L398">        .macos =&gt; <span class="tok-kw">return</span> darwin.macos.detectNativeCpuAndFeatures(),</span>
<span class="line" id="L399">        .windows =&gt; <span class="tok-kw">return</span> windows.detectNativeCpuAndFeatures(),</span>
<span class="line" id="L400">        <span class="tok-kw">else</span> =&gt; {},</span>
<span class="line" id="L401">    }</span>
<span class="line" id="L402"></span>
<span class="line" id="L403">    <span class="tok-comment">// This architecture does not have CPU model &amp; feature detection yet.</span>
</span>
<span class="line" id="L404">    <span class="tok-comment">// See https://github.com/ziglang/zig/issues/4591</span>
</span>
<span class="line" id="L405">    <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L406">}</span>
<span class="line" id="L407"></span>
<span class="line" id="L408"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> AbiAndDynamicLinkerFromFileError = <span class="tok-kw">error</span>{</span>
<span class="line" id="L409">    FileSystem,</span>
<span class="line" id="L410">    SystemResources,</span>
<span class="line" id="L411">    SymLinkLoop,</span>
<span class="line" id="L412">    ProcessFdQuotaExceeded,</span>
<span class="line" id="L413">    SystemFdQuotaExceeded,</span>
<span class="line" id="L414">    UnableToReadElfFile,</span>
<span class="line" id="L415">    InvalidElfClass,</span>
<span class="line" id="L416">    InvalidElfVersion,</span>
<span class="line" id="L417">    InvalidElfEndian,</span>
<span class="line" id="L418">    InvalidElfFile,</span>
<span class="line" id="L419">    InvalidElfMagic,</span>
<span class="line" id="L420">    Unexpected,</span>
<span class="line" id="L421">    UnexpectedEndOfFile,</span>
<span class="line" id="L422">    NameTooLong,</span>
<span class="line" id="L423">};</span>
<span class="line" id="L424"></span>
<span class="line" id="L425"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">abiAndDynamicLinkerFromFile</span>(</span>
<span class="line" id="L426">    file: fs.File,</span>
<span class="line" id="L427">    cpu: Target.Cpu,</span>
<span class="line" id="L428">    os: Target.Os,</span>
<span class="line" id="L429">    ld_info_list: []<span class="tok-kw">const</span> LdInfo,</span>
<span class="line" id="L430">    query: Target.Query,</span>
<span class="line" id="L431">) AbiAndDynamicLinkerFromFileError!Target {</span>
<span class="line" id="L432">    <span class="tok-kw">var</span> hdr_buf: [<span class="tok-builtin">@sizeOf</span>(elf.Elf64_Ehdr)]<span class="tok-type">u8</span> <span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(elf.Elf64_Ehdr)) = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L433">    _ = <span class="tok-kw">try</span> preadMin(file, &amp;hdr_buf, <span class="tok-number">0</span>, hdr_buf.len);</span>
<span class="line" id="L434">    <span class="tok-kw">const</span> hdr32 = <span class="tok-builtin">@as</span>(*elf.Elf32_Ehdr, <span class="tok-builtin">@ptrCast</span>(&amp;hdr_buf));</span>
<span class="line" id="L435">    <span class="tok-kw">const</span> hdr64 = <span class="tok-builtin">@as</span>(*elf.Elf64_Ehdr, <span class="tok-builtin">@ptrCast</span>(&amp;hdr_buf));</span>
<span class="line" id="L436">    <span class="tok-kw">if</span> (!mem.eql(<span class="tok-type">u8</span>, hdr32.e_ident[<span class="tok-number">0</span>..<span class="tok-number">4</span>], elf.MAGIC)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidElfMagic;</span>
<span class="line" id="L437">    <span class="tok-kw">const</span> elf_endian: std.builtin.Endian = <span class="tok-kw">switch</span> (hdr32.e_ident[elf.EI_DATA]) {</span>
<span class="line" id="L438">        elf.ELFDATA2LSB =&gt; .little,</span>
<span class="line" id="L439">        elf.ELFDATA2MSB =&gt; .big,</span>
<span class="line" id="L440">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidElfEndian,</span>
<span class="line" id="L441">    };</span>
<span class="line" id="L442">    <span class="tok-kw">const</span> need_bswap = elf_endian != native_endian;</span>
<span class="line" id="L443">    <span class="tok-kw">if</span> (hdr32.e_ident[elf.EI_VERSION] != <span class="tok-number">1</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidElfVersion;</span>
<span class="line" id="L444"></span>
<span class="line" id="L445">    <span class="tok-kw">const</span> is_64 = <span class="tok-kw">switch</span> (hdr32.e_ident[elf.EI_CLASS]) {</span>
<span class="line" id="L446">        elf.ELFCLASS32 =&gt; <span class="tok-null">false</span>,</span>
<span class="line" id="L447">        elf.ELFCLASS64 =&gt; <span class="tok-null">true</span>,</span>
<span class="line" id="L448">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidElfClass,</span>
<span class="line" id="L449">    };</span>
<span class="line" id="L450">    <span class="tok-kw">var</span> phoff = elfInt(is_64, need_bswap, hdr32.e_phoff, hdr64.e_phoff);</span>
<span class="line" id="L451">    <span class="tok-kw">const</span> phentsize = elfInt(is_64, need_bswap, hdr32.e_phentsize, hdr64.e_phentsize);</span>
<span class="line" id="L452">    <span class="tok-kw">const</span> phnum = elfInt(is_64, need_bswap, hdr32.e_phnum, hdr64.e_phnum);</span>
<span class="line" id="L453"></span>
<span class="line" id="L454">    <span class="tok-kw">var</span> result: Target = .{</span>
<span class="line" id="L455">        .cpu = cpu,</span>
<span class="line" id="L456">        .os = os,</span>
<span class="line" id="L457">        .abi = query.abi <span class="tok-kw">orelse</span> Target.Abi.default(cpu.arch, os),</span>
<span class="line" id="L458">        .ofmt = query.ofmt <span class="tok-kw">orelse</span> Target.ObjectFormat.default(os.tag, cpu.arch),</span>
<span class="line" id="L459">        .dynamic_linker = query.dynamic_linker,</span>
<span class="line" id="L460">    };</span>
<span class="line" id="L461">    <span class="tok-kw">var</span> rpath_offset: ?<span class="tok-type">u64</span> = <span class="tok-null">null</span>; <span class="tok-comment">// Found inside PT_DYNAMIC</span>
</span>
<span class="line" id="L462">    <span class="tok-kw">const</span> look_for_ld = query.dynamic_linker.get() == <span class="tok-null">null</span>;</span>
<span class="line" id="L463"></span>
<span class="line" id="L464">    <span class="tok-kw">var</span> ph_buf: [<span class="tok-number">16</span> * <span class="tok-builtin">@sizeOf</span>(elf.Elf64_Phdr)]<span class="tok-type">u8</span> <span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(elf.Elf64_Phdr)) = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L465">    <span class="tok-kw">if</span> (phentsize &gt; <span class="tok-builtin">@sizeOf</span>(elf.Elf64_Phdr)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidElfFile;</span>
<span class="line" id="L466"></span>
<span class="line" id="L467">    <span class="tok-kw">var</span> ph_i: <span class="tok-type">u16</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L468">    <span class="tok-kw">while</span> (ph_i &lt; phnum) {</span>
<span class="line" id="L469">        <span class="tok-comment">// Reserve some bytes so that we can deref the 64-bit struct fields</span>
</span>
<span class="line" id="L470">        <span class="tok-comment">// even when the ELF file is 32-bits.</span>
</span>
<span class="line" id="L471">        <span class="tok-kw">const</span> ph_reserve: <span class="tok-type">usize</span> = <span class="tok-builtin">@sizeOf</span>(elf.Elf64_Phdr) - <span class="tok-builtin">@sizeOf</span>(elf.Elf32_Phdr);</span>
<span class="line" id="L472">        <span class="tok-kw">const</span> ph_read_byte_len = <span class="tok-kw">try</span> preadMin(file, ph_buf[<span class="tok-number">0</span> .. ph_buf.len - ph_reserve], phoff, phentsize);</span>
<span class="line" id="L473">        <span class="tok-kw">var</span> ph_buf_i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L474">        <span class="tok-kw">while</span> (ph_buf_i &lt; ph_read_byte_len <span class="tok-kw">and</span> ph_i &lt; phnum) : ({</span>
<span class="line" id="L475">            ph_i += <span class="tok-number">1</span>;</span>
<span class="line" id="L476">            phoff += phentsize;</span>
<span class="line" id="L477">            ph_buf_i += phentsize;</span>
<span class="line" id="L478">        }) {</span>
<span class="line" id="L479">            <span class="tok-kw">const</span> ph32: *elf.Elf32_Phdr = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;ph_buf[ph_buf_i]));</span>
<span class="line" id="L480">            <span class="tok-kw">const</span> ph64: *elf.Elf64_Phdr = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;ph_buf[ph_buf_i]));</span>
<span class="line" id="L481">            <span class="tok-kw">const</span> p_type = elfInt(is_64, need_bswap, ph32.p_type, ph64.p_type);</span>
<span class="line" id="L482">            <span class="tok-kw">switch</span> (p_type) {</span>
<span class="line" id="L483">                elf.PT_INTERP =&gt; <span class="tok-kw">if</span> (look_for_ld) {</span>
<span class="line" id="L484">                    <span class="tok-kw">const</span> p_offset = elfInt(is_64, need_bswap, ph32.p_offset, ph64.p_offset);</span>
<span class="line" id="L485">                    <span class="tok-kw">const</span> p_filesz = elfInt(is_64, need_bswap, ph32.p_filesz, ph64.p_filesz);</span>
<span class="line" id="L486">                    <span class="tok-kw">if</span> (p_filesz &gt; result.dynamic_linker.buffer.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong;</span>
<span class="line" id="L487">                    <span class="tok-kw">const</span> filesz = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(p_filesz));</span>
<span class="line" id="L488">                    _ = <span class="tok-kw">try</span> preadMin(file, result.dynamic_linker.buffer[<span class="tok-number">0</span>..filesz], p_offset, filesz);</span>
<span class="line" id="L489">                    <span class="tok-comment">// PT_INTERP includes a null byte in filesz.</span>
</span>
<span class="line" id="L490">                    <span class="tok-kw">const</span> len = filesz - <span class="tok-number">1</span>;</span>
<span class="line" id="L491">                    <span class="tok-comment">// dynamic_linker.max_byte is &quot;max&quot;, not &quot;len&quot;.</span>
</span>
<span class="line" id="L492">                    <span class="tok-comment">// We know it will fit in u8 because we check against dynamic_linker.buffer.len above.</span>
</span>
<span class="line" id="L493">                    result.dynamic_linker.max_byte = <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@intCast</span>(len - <span class="tok-number">1</span>));</span>
<span class="line" id="L494"></span>
<span class="line" id="L495">                    <span class="tok-comment">// Use it to determine ABI.</span>
</span>
<span class="line" id="L496">                    <span class="tok-kw">const</span> full_ld_path = result.dynamic_linker.buffer[<span class="tok-number">0</span>..len];</span>
<span class="line" id="L497">                    <span class="tok-kw">for</span> (ld_info_list) |ld_info| {</span>
<span class="line" id="L498">                        <span class="tok-kw">const</span> standard_ld_basename = fs.path.basename(ld_info.ld.get().?);</span>
<span class="line" id="L499">                        <span class="tok-kw">if</span> (std.mem.endsWith(<span class="tok-type">u8</span>, full_ld_path, standard_ld_basename)) {</span>
<span class="line" id="L500">                            result.abi = ld_info.abi;</span>
<span class="line" id="L501">                            <span class="tok-kw">break</span>;</span>
<span class="line" id="L502">                        }</span>
<span class="line" id="L503">                    }</span>
<span class="line" id="L504">                },</span>
<span class="line" id="L505">                <span class="tok-comment">// We only need this for detecting glibc version.</span>
</span>
<span class="line" id="L506">                elf.PT_DYNAMIC =&gt; <span class="tok-kw">if</span> (builtin.target.os.tag == .linux <span class="tok-kw">and</span> result.isGnuLibC() <span class="tok-kw">and</span></span>
<span class="line" id="L507">                    query.glibc_version == <span class="tok-null">null</span>)</span>
<span class="line" id="L508">                {</span>
<span class="line" id="L509">                    <span class="tok-kw">var</span> dyn_off = elfInt(is_64, need_bswap, ph32.p_offset, ph64.p_offset);</span>
<span class="line" id="L510">                    <span class="tok-kw">const</span> p_filesz = elfInt(is_64, need_bswap, ph32.p_filesz, ph64.p_filesz);</span>
<span class="line" id="L511">                    <span class="tok-kw">const</span> dyn_size: <span class="tok-type">usize</span> = <span class="tok-kw">if</span> (is_64) <span class="tok-builtin">@sizeOf</span>(elf.Elf64_Dyn) <span class="tok-kw">else</span> <span class="tok-builtin">@sizeOf</span>(elf.Elf32_Dyn);</span>
<span class="line" id="L512">                    <span class="tok-kw">const</span> dyn_num = p_filesz / dyn_size;</span>
<span class="line" id="L513">                    <span class="tok-kw">var</span> dyn_buf: [<span class="tok-number">16</span> * <span class="tok-builtin">@sizeOf</span>(elf.Elf64_Dyn)]<span class="tok-type">u8</span> <span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(elf.Elf64_Dyn)) = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L514">                    <span class="tok-kw">var</span> dyn_i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L515">                    dyn: <span class="tok-kw">while</span> (dyn_i &lt; dyn_num) {</span>
<span class="line" id="L516">                        <span class="tok-comment">// Reserve some bytes so that we can deref the 64-bit struct fields</span>
</span>
<span class="line" id="L517">                        <span class="tok-comment">// even when the ELF file is 32-bits.</span>
</span>
<span class="line" id="L518">                        <span class="tok-kw">const</span> dyn_reserve: <span class="tok-type">usize</span> = <span class="tok-builtin">@sizeOf</span>(elf.Elf64_Dyn) - <span class="tok-builtin">@sizeOf</span>(elf.Elf32_Dyn);</span>
<span class="line" id="L519">                        <span class="tok-kw">const</span> dyn_read_byte_len = <span class="tok-kw">try</span> preadMin(</span>
<span class="line" id="L520">                            file,</span>
<span class="line" id="L521">                            dyn_buf[<span class="tok-number">0</span> .. dyn_buf.len - dyn_reserve],</span>
<span class="line" id="L522">                            dyn_off,</span>
<span class="line" id="L523">                            dyn_size,</span>
<span class="line" id="L524">                        );</span>
<span class="line" id="L525">                        <span class="tok-kw">var</span> dyn_buf_i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L526">                        <span class="tok-kw">while</span> (dyn_buf_i &lt; dyn_read_byte_len <span class="tok-kw">and</span> dyn_i &lt; dyn_num) : ({</span>
<span class="line" id="L527">                            dyn_i += <span class="tok-number">1</span>;</span>
<span class="line" id="L528">                            dyn_off += dyn_size;</span>
<span class="line" id="L529">                            dyn_buf_i += dyn_size;</span>
<span class="line" id="L530">                        }) {</span>
<span class="line" id="L531">                            <span class="tok-kw">const</span> dyn32: *elf.Elf32_Dyn = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;dyn_buf[dyn_buf_i]));</span>
<span class="line" id="L532">                            <span class="tok-kw">const</span> dyn64: *elf.Elf64_Dyn = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;dyn_buf[dyn_buf_i]));</span>
<span class="line" id="L533">                            <span class="tok-kw">const</span> tag = elfInt(is_64, need_bswap, dyn32.d_tag, dyn64.d_tag);</span>
<span class="line" id="L534">                            <span class="tok-kw">const</span> val = elfInt(is_64, need_bswap, dyn32.d_val, dyn64.d_val);</span>
<span class="line" id="L535">                            <span class="tok-kw">if</span> (tag == elf.DT_RUNPATH) {</span>
<span class="line" id="L536">                                rpath_offset = val;</span>
<span class="line" id="L537">                                <span class="tok-kw">break</span> :dyn;</span>
<span class="line" id="L538">                            }</span>
<span class="line" id="L539">                        }</span>
<span class="line" id="L540">                    }</span>
<span class="line" id="L541">                },</span>
<span class="line" id="L542">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">continue</span>,</span>
<span class="line" id="L543">            }</span>
<span class="line" id="L544">        }</span>
<span class="line" id="L545">    }</span>
<span class="line" id="L546"></span>
<span class="line" id="L547">    <span class="tok-kw">if</span> (builtin.target.os.tag == .linux <span class="tok-kw">and</span> result.isGnuLibC() <span class="tok-kw">and</span></span>
<span class="line" id="L548">        query.glibc_version == <span class="tok-null">null</span>)</span>
<span class="line" id="L549">    {</span>
<span class="line" id="L550">        <span class="tok-kw">const</span> shstrndx = elfInt(is_64, need_bswap, hdr32.e_shstrndx, hdr64.e_shstrndx);</span>
<span class="line" id="L551"></span>
<span class="line" id="L552">        <span class="tok-kw">var</span> shoff = elfInt(is_64, need_bswap, hdr32.e_shoff, hdr64.e_shoff);</span>
<span class="line" id="L553">        <span class="tok-kw">const</span> shentsize = elfInt(is_64, need_bswap, hdr32.e_shentsize, hdr64.e_shentsize);</span>
<span class="line" id="L554">        <span class="tok-kw">const</span> str_section_off = shoff + <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, shentsize) * <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, shstrndx);</span>
<span class="line" id="L555"></span>
<span class="line" id="L556">        <span class="tok-kw">var</span> sh_buf: [<span class="tok-number">16</span> * <span class="tok-builtin">@sizeOf</span>(elf.Elf64_Shdr)]<span class="tok-type">u8</span> <span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(elf.Elf64_Shdr)) = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L557">        <span class="tok-kw">if</span> (sh_buf.len &lt; shentsize) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidElfFile;</span>
<span class="line" id="L558"></span>
<span class="line" id="L559">        _ = <span class="tok-kw">try</span> preadMin(file, &amp;sh_buf, str_section_off, shentsize);</span>
<span class="line" id="L560">        <span class="tok-kw">const</span> shstr32: *elf.Elf32_Shdr = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;sh_buf));</span>
<span class="line" id="L561">        <span class="tok-kw">const</span> shstr64: *elf.Elf64_Shdr = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;sh_buf));</span>
<span class="line" id="L562">        <span class="tok-kw">const</span> shstrtab_off = elfInt(is_64, need_bswap, shstr32.sh_offset, shstr64.sh_offset);</span>
<span class="line" id="L563">        <span class="tok-kw">const</span> shstrtab_size = elfInt(is_64, need_bswap, shstr32.sh_size, shstr64.sh_size);</span>
<span class="line" id="L564">        <span class="tok-kw">var</span> strtab_buf: [<span class="tok-number">4096</span>:<span class="tok-number">0</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L565">        <span class="tok-kw">const</span> shstrtab_len = <span class="tok-builtin">@min</span>(shstrtab_size, strtab_buf.len);</span>
<span class="line" id="L566">        <span class="tok-kw">const</span> shstrtab_read_len = <span class="tok-kw">try</span> preadMin(file, &amp;strtab_buf, shstrtab_off, shstrtab_len);</span>
<span class="line" id="L567">        <span class="tok-kw">const</span> shstrtab = strtab_buf[<span class="tok-number">0</span>..shstrtab_read_len];</span>
<span class="line" id="L568"></span>
<span class="line" id="L569">        <span class="tok-kw">const</span> shnum = elfInt(is_64, need_bswap, hdr32.e_shnum, hdr64.e_shnum);</span>
<span class="line" id="L570">        <span class="tok-kw">var</span> sh_i: <span class="tok-type">u16</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L571">        <span class="tok-kw">const</span> dynstr: ?<span class="tok-kw">struct</span> { offset: <span class="tok-type">u64</span>, size: <span class="tok-type">u64</span> } = find_dyn_str: <span class="tok-kw">while</span> (sh_i &lt; shnum) {</span>
<span class="line" id="L572">            <span class="tok-comment">// Reserve some bytes so that we can deref the 64-bit struct fields</span>
</span>
<span class="line" id="L573">            <span class="tok-comment">// even when the ELF file is 32-bits.</span>
</span>
<span class="line" id="L574">            <span class="tok-kw">const</span> sh_reserve: <span class="tok-type">usize</span> = <span class="tok-builtin">@sizeOf</span>(elf.Elf64_Shdr) - <span class="tok-builtin">@sizeOf</span>(elf.Elf32_Shdr);</span>
<span class="line" id="L575">            <span class="tok-kw">const</span> sh_read_byte_len = <span class="tok-kw">try</span> preadMin(</span>
<span class="line" id="L576">                file,</span>
<span class="line" id="L577">                sh_buf[<span class="tok-number">0</span> .. sh_buf.len - sh_reserve],</span>
<span class="line" id="L578">                shoff,</span>
<span class="line" id="L579">                shentsize,</span>
<span class="line" id="L580">            );</span>
<span class="line" id="L581">            <span class="tok-kw">var</span> sh_buf_i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L582">            <span class="tok-kw">while</span> (sh_buf_i &lt; sh_read_byte_len <span class="tok-kw">and</span> sh_i &lt; shnum) : ({</span>
<span class="line" id="L583">                sh_i += <span class="tok-number">1</span>;</span>
<span class="line" id="L584">                shoff += shentsize;</span>
<span class="line" id="L585">                sh_buf_i += shentsize;</span>
<span class="line" id="L586">            }) {</span>
<span class="line" id="L587">                <span class="tok-kw">const</span> sh32: *elf.Elf32_Shdr = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;sh_buf[sh_buf_i]));</span>
<span class="line" id="L588">                <span class="tok-kw">const</span> sh64: *elf.Elf64_Shdr = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;sh_buf[sh_buf_i]));</span>
<span class="line" id="L589">                <span class="tok-kw">const</span> sh_name_off = elfInt(is_64, need_bswap, sh32.sh_name, sh64.sh_name);</span>
<span class="line" id="L590">                <span class="tok-kw">const</span> sh_name = mem.sliceTo(shstrtab[sh_name_off..], <span class="tok-number">0</span>);</span>
<span class="line" id="L591">                <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, sh_name, <span class="tok-str">&quot;.dynstr&quot;</span>)) {</span>
<span class="line" id="L592">                    <span class="tok-kw">break</span> :find_dyn_str .{</span>
<span class="line" id="L593">                        .offset = elfInt(is_64, need_bswap, sh32.sh_offset, sh64.sh_offset),</span>
<span class="line" id="L594">                        .size = elfInt(is_64, need_bswap, sh32.sh_size, sh64.sh_size),</span>
<span class="line" id="L595">                    };</span>
<span class="line" id="L596">                }</span>
<span class="line" id="L597">            }</span>
<span class="line" id="L598">        } <span class="tok-kw">else</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L599"></span>
<span class="line" id="L600">        <span class="tok-kw">if</span> (dynstr) |ds| {</span>
<span class="line" id="L601">            <span class="tok-kw">if</span> (rpath_offset) |rpoff| {</span>
<span class="line" id="L602">                <span class="tok-kw">if</span> (rpoff &gt; ds.size) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidElfFile;</span>
<span class="line" id="L603">                <span class="tok-kw">const</span> rpoff_file = ds.offset + rpoff;</span>
<span class="line" id="L604">                <span class="tok-kw">const</span> rp_max_size = ds.size - rpoff;</span>
<span class="line" id="L605"></span>
<span class="line" id="L606">                <span class="tok-kw">const</span> strtab_len = <span class="tok-builtin">@min</span>(rp_max_size, strtab_buf.len);</span>
<span class="line" id="L607">                <span class="tok-kw">const</span> strtab_read_len = <span class="tok-kw">try</span> preadMin(file, &amp;strtab_buf, rpoff_file, strtab_len);</span>
<span class="line" id="L608">                <span class="tok-kw">const</span> strtab = strtab_buf[<span class="tok-number">0</span>..strtab_read_len];</span>
<span class="line" id="L609"></span>
<span class="line" id="L610">                <span class="tok-kw">const</span> rpath_list = mem.sliceTo(strtab, <span class="tok-number">0</span>);</span>
<span class="line" id="L611">                <span class="tok-kw">var</span> it = mem.tokenizeScalar(<span class="tok-type">u8</span>, rpath_list, <span class="tok-str">':'</span>);</span>
<span class="line" id="L612">                <span class="tok-kw">while</span> (it.next()) |rpath| {</span>
<span class="line" id="L613">                    <span class="tok-kw">if</span> (glibcVerFromRPath(rpath)) |ver| {</span>
<span class="line" id="L614">                        result.os.version_range.linux.glibc = ver;</span>
<span class="line" id="L615">                        <span class="tok-kw">return</span> result;</span>
<span class="line" id="L616">                    } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L617">                        <span class="tok-kw">error</span>.GLibCNotFound =&gt; <span class="tok-kw">continue</span>,</span>
<span class="line" id="L618">                        <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L619">                    }</span>
<span class="line" id="L620">                }</span>
<span class="line" id="L621">            }</span>
<span class="line" id="L622">        }</span>
<span class="line" id="L623"></span>
<span class="line" id="L624">        <span class="tok-kw">if</span> (result.dynamic_linker.get()) |dl_path| glibc_ver: {</span>
<span class="line" id="L625">            <span class="tok-comment">// There is no DT_RUNPATH so we try to find libc.so.6 inside the same</span>
</span>
<span class="line" id="L626">            <span class="tok-comment">// directory as the dynamic linker.</span>
</span>
<span class="line" id="L627">            <span class="tok-kw">if</span> (fs.path.dirname(dl_path)) |rpath| {</span>
<span class="line" id="L628">                <span class="tok-kw">if</span> (glibcVerFromRPath(rpath)) |ver| {</span>
<span class="line" id="L629">                    result.os.version_range.linux.glibc = ver;</span>
<span class="line" id="L630">                    <span class="tok-kw">return</span> result;</span>
<span class="line" id="L631">                } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L632">                    <span class="tok-kw">error</span>.GLibCNotFound =&gt; {},</span>
<span class="line" id="L633">                    <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L634">                }</span>
<span class="line" id="L635">            }</span>
<span class="line" id="L636"></span>
<span class="line" id="L637">            <span class="tok-comment">// So far, no luck. Next we try to see if the information is</span>
</span>
<span class="line" id="L638">            <span class="tok-comment">// present in the symlink data for the dynamic linker path.</span>
</span>
<span class="line" id="L639">            <span class="tok-kw">var</span> link_buf: [std.os.PATH_MAX]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L640">            <span class="tok-kw">const</span> link_name = std.os.readlink(dl_path, &amp;link_buf) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L641">                <span class="tok-kw">error</span>.NameTooLong =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L642">                <span class="tok-kw">error</span>.InvalidUtf8 =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// WASI only</span>
</span>
<span class="line" id="L643">                <span class="tok-kw">error</span>.InvalidWtf8 =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Windows only</span>
</span>
<span class="line" id="L644">                <span class="tok-kw">error</span>.BadPathName =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Windows only</span>
</span>
<span class="line" id="L645">                <span class="tok-kw">error</span>.UnsupportedReparsePointType =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Windows only</span>
</span>
<span class="line" id="L646">                <span class="tok-kw">error</span>.NetworkNotFound =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Windows only</span>
</span>
<span class="line" id="L647"></span>
<span class="line" id="L648">                <span class="tok-kw">error</span>.AccessDenied,</span>
<span class="line" id="L649">                <span class="tok-kw">error</span>.FileNotFound,</span>
<span class="line" id="L650">                <span class="tok-kw">error</span>.NotLink,</span>
<span class="line" id="L651">                <span class="tok-kw">error</span>.NotDir,</span>
<span class="line" id="L652">                =&gt; <span class="tok-kw">break</span> :glibc_ver,</span>
<span class="line" id="L653"></span>
<span class="line" id="L654">                <span class="tok-kw">error</span>.SystemResources,</span>
<span class="line" id="L655">                <span class="tok-kw">error</span>.FileSystem,</span>
<span class="line" id="L656">                <span class="tok-kw">error</span>.SymLinkLoop,</span>
<span class="line" id="L657">                <span class="tok-kw">error</span>.Unexpected,</span>
<span class="line" id="L658">                =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L659">            };</span>
<span class="line" id="L660">            result.os.version_range.linux.glibc = glibcVerFromLinkName(</span>
<span class="line" id="L661">                fs.path.basename(link_name),</span>
<span class="line" id="L662">                <span class="tok-str">&quot;ld-&quot;</span>,</span>
<span class="line" id="L663">            ) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L664">                <span class="tok-kw">error</span>.UnrecognizedGnuLibCFileName,</span>
<span class="line" id="L665">                <span class="tok-kw">error</span>.InvalidGnuLibCVersion,</span>
<span class="line" id="L666">                =&gt; <span class="tok-kw">break</span> :glibc_ver,</span>
<span class="line" id="L667">            };</span>
<span class="line" id="L668">            <span class="tok-kw">return</span> result;</span>
<span class="line" id="L669">        }</span>
<span class="line" id="L670"></span>
<span class="line" id="L671">        <span class="tok-comment">// Nothing worked so far. Finally we fall back to hard-coded search paths.</span>
</span>
<span class="line" id="L672">        <span class="tok-comment">// Some distros such as Debian keep their libc.so.6 in `/lib/$triple/`.</span>
</span>
<span class="line" id="L673">        <span class="tok-kw">var</span> path_buf: [std.os.PATH_MAX]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L674">        <span class="tok-kw">var</span> index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L675">        <span class="tok-kw">const</span> prefix = <span class="tok-str">&quot;/lib/&quot;</span>;</span>
<span class="line" id="L676">        <span class="tok-kw">const</span> cpu_arch = <span class="tok-builtin">@tagName</span>(result.cpu.arch);</span>
<span class="line" id="L677">        <span class="tok-kw">const</span> os_tag = <span class="tok-builtin">@tagName</span>(result.os.tag);</span>
<span class="line" id="L678">        <span class="tok-kw">const</span> abi = <span class="tok-builtin">@tagName</span>(result.abi);</span>
<span class="line" id="L679">        <span class="tok-builtin">@memcpy</span>(path_buf[index..][<span class="tok-number">0</span>..prefix.len], prefix);</span>
<span class="line" id="L680">        index += prefix.len;</span>
<span class="line" id="L681">        <span class="tok-builtin">@memcpy</span>(path_buf[index..][<span class="tok-number">0</span>..cpu_arch.len], cpu_arch);</span>
<span class="line" id="L682">        index += cpu_arch.len;</span>
<span class="line" id="L683">        path_buf[index] = <span class="tok-str">'-'</span>;</span>
<span class="line" id="L684">        index += <span class="tok-number">1</span>;</span>
<span class="line" id="L685">        <span class="tok-builtin">@memcpy</span>(path_buf[index..][<span class="tok-number">0</span>..os_tag.len], os_tag);</span>
<span class="line" id="L686">        index += os_tag.len;</span>
<span class="line" id="L687">        path_buf[index] = <span class="tok-str">'-'</span>;</span>
<span class="line" id="L688">        index += <span class="tok-number">1</span>;</span>
<span class="line" id="L689">        <span class="tok-builtin">@memcpy</span>(path_buf[index..][<span class="tok-number">0</span>..abi.len], abi);</span>
<span class="line" id="L690">        index += abi.len;</span>
<span class="line" id="L691">        <span class="tok-kw">const</span> rpath = path_buf[<span class="tok-number">0</span>..index];</span>
<span class="line" id="L692">        <span class="tok-kw">if</span> (glibcVerFromRPath(rpath)) |ver| {</span>
<span class="line" id="L693">            result.os.version_range.linux.glibc = ver;</span>
<span class="line" id="L694">            <span class="tok-kw">return</span> result;</span>
<span class="line" id="L695">        } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L696">            <span class="tok-kw">error</span>.GLibCNotFound =&gt; {},</span>
<span class="line" id="L697">            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L698">        }</span>
<span class="line" id="L699">    }</span>
<span class="line" id="L700"></span>
<span class="line" id="L701">    <span class="tok-kw">return</span> result;</span>
<span class="line" id="L702">}</span>
<span class="line" id="L703"></span>
<span class="line" id="L704"><span class="tok-kw">fn</span> <span class="tok-fn">glibcVerFromLinkName</span>(link_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, prefix: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-kw">error</span>{ UnrecognizedGnuLibCFileName, InvalidGnuLibCVersion }!std.SemanticVersion {</span>
<span class="line" id="L705">    <span class="tok-comment">// example: &quot;libc-2.3.4.so&quot;</span>
</span>
<span class="line" id="L706">    <span class="tok-comment">// example: &quot;libc-2.27.so&quot;</span>
</span>
<span class="line" id="L707">    <span class="tok-comment">// example: &quot;ld-2.33.so&quot;</span>
</span>
<span class="line" id="L708">    <span class="tok-kw">const</span> suffix = <span class="tok-str">&quot;.so&quot;</span>;</span>
<span class="line" id="L709">    <span class="tok-kw">if</span> (!mem.startsWith(<span class="tok-type">u8</span>, link_name, prefix) <span class="tok-kw">or</span> !mem.endsWith(<span class="tok-type">u8</span>, link_name, suffix)) {</span>
<span class="line" id="L710">        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnrecognizedGnuLibCFileName;</span>
<span class="line" id="L711">    }</span>
<span class="line" id="L712">    <span class="tok-comment">// chop off &quot;libc-&quot; and &quot;.so&quot;</span>
</span>
<span class="line" id="L713">    <span class="tok-kw">const</span> link_name_chopped = link_name[prefix.len .. link_name.len - suffix.len];</span>
<span class="line" id="L714">    <span class="tok-kw">return</span> Target.Query.parseVersion(link_name_chopped) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L715">        <span class="tok-kw">error</span>.Overflow =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidGnuLibCVersion,</span>
<span class="line" id="L716">        <span class="tok-kw">error</span>.InvalidVersion =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidGnuLibCVersion,</span>
<span class="line" id="L717">    };</span>
<span class="line" id="L718">}</span>
<span class="line" id="L719"></span>
<span class="line" id="L720"><span class="tok-kw">test</span> glibcVerFromLinkName {</span>
<span class="line" id="L721">    <span class="tok-kw">try</span> std.testing.expectError(<span class="tok-kw">error</span>.UnrecognizedGnuLibCFileName, glibcVerFromLinkName(<span class="tok-str">&quot;ld-2.37.so&quot;</span>, <span class="tok-str">&quot;this-prefix-does-not-exist&quot;</span>));</span>
<span class="line" id="L722">    <span class="tok-kw">try</span> std.testing.expectError(<span class="tok-kw">error</span>.UnrecognizedGnuLibCFileName, glibcVerFromLinkName(<span class="tok-str">&quot;libc-2.37.so-is-not-end&quot;</span>, <span class="tok-str">&quot;libc-&quot;</span>));</span>
<span class="line" id="L723"></span>
<span class="line" id="L724">    <span class="tok-kw">try</span> std.testing.expectError(<span class="tok-kw">error</span>.InvalidGnuLibCVersion, glibcVerFromLinkName(<span class="tok-str">&quot;ld-2.so&quot;</span>, <span class="tok-str">&quot;ld-&quot;</span>));</span>
<span class="line" id="L725">    <span class="tok-kw">try</span> std.testing.expectEqual(std.SemanticVersion{ .major = <span class="tok-number">2</span>, .minor = <span class="tok-number">37</span>, .patch = <span class="tok-number">0</span> }, <span class="tok-kw">try</span> glibcVerFromLinkName(<span class="tok-str">&quot;ld-2.37.so&quot;</span>, <span class="tok-str">&quot;ld-&quot;</span>));</span>
<span class="line" id="L726">    <span class="tok-kw">try</span> std.testing.expectEqual(std.SemanticVersion{ .major = <span class="tok-number">2</span>, .minor = <span class="tok-number">37</span>, .patch = <span class="tok-number">0</span> }, <span class="tok-kw">try</span> glibcVerFromLinkName(<span class="tok-str">&quot;ld-2.37.0.so&quot;</span>, <span class="tok-str">&quot;ld-&quot;</span>));</span>
<span class="line" id="L727">    <span class="tok-kw">try</span> std.testing.expectEqual(std.SemanticVersion{ .major = <span class="tok-number">2</span>, .minor = <span class="tok-number">37</span>, .patch = <span class="tok-number">1</span> }, <span class="tok-kw">try</span> glibcVerFromLinkName(<span class="tok-str">&quot;ld-2.37.1.so&quot;</span>, <span class="tok-str">&quot;ld-&quot;</span>));</span>
<span class="line" id="L728">    <span class="tok-kw">try</span> std.testing.expectError(<span class="tok-kw">error</span>.InvalidGnuLibCVersion, glibcVerFromLinkName(<span class="tok-str">&quot;ld-2.37.4.5.so&quot;</span>, <span class="tok-str">&quot;ld-&quot;</span>));</span>
<span class="line" id="L729">}</span>
<span class="line" id="L730"></span>
<span class="line" id="L731"><span class="tok-kw">fn</span> <span class="tok-fn">glibcVerFromRPath</span>(rpath: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !std.SemanticVersion {</span>
<span class="line" id="L732">    <span class="tok-kw">var</span> dir = fs.cwd().openDir(rpath, .{}) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L733">        <span class="tok-kw">error</span>.NameTooLong =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L734">        <span class="tok-kw">error</span>.InvalidUtf8 =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// WASI only</span>
</span>
<span class="line" id="L735">        <span class="tok-kw">error</span>.InvalidWtf8 =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Windows-only</span>
</span>
<span class="line" id="L736">        <span class="tok-kw">error</span>.BadPathName =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L737">        <span class="tok-kw">error</span>.DeviceBusy =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L738">        <span class="tok-kw">error</span>.NetworkNotFound =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Windows-only</span>
</span>
<span class="line" id="L739"></span>
<span class="line" id="L740">        <span class="tok-kw">error</span>.FileNotFound,</span>
<span class="line" id="L741">        <span class="tok-kw">error</span>.NotDir,</span>
<span class="line" id="L742">        <span class="tok-kw">error</span>.AccessDenied,</span>
<span class="line" id="L743">        <span class="tok-kw">error</span>.NoDevice,</span>
<span class="line" id="L744">        =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.GLibCNotFound,</span>
<span class="line" id="L745"></span>
<span class="line" id="L746">        <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,</span>
<span class="line" id="L747">        <span class="tok-kw">error</span>.SystemFdQuotaExceeded,</span>
<span class="line" id="L748">        <span class="tok-kw">error</span>.SystemResources,</span>
<span class="line" id="L749">        <span class="tok-kw">error</span>.SymLinkLoop,</span>
<span class="line" id="L750">        <span class="tok-kw">error</span>.Unexpected,</span>
<span class="line" id="L751">        =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L752">    };</span>
<span class="line" id="L753">    <span class="tok-kw">defer</span> dir.close();</span>
<span class="line" id="L754"></span>
<span class="line" id="L755">    <span class="tok-comment">// Now we have a candidate for the path to libc shared object. In</span>
</span>
<span class="line" id="L756">    <span class="tok-comment">// the past, we used readlink() here because the link name would</span>
</span>
<span class="line" id="L757">    <span class="tok-comment">// reveal the glibc version. However, in more recent GNU/Linux</span>
</span>
<span class="line" id="L758">    <span class="tok-comment">// installations, there is no symlink. Thus we instead use a more</span>
</span>
<span class="line" id="L759">    <span class="tok-comment">// robust check of opening the libc shared object and looking at the</span>
</span>
<span class="line" id="L760">    <span class="tok-comment">// .dynstr section, and finding the max version number of symbols</span>
</span>
<span class="line" id="L761">    <span class="tok-comment">// that start with &quot;GLIBC_2.&quot;.</span>
</span>
<span class="line" id="L762">    <span class="tok-kw">const</span> glibc_so_basename = <span class="tok-str">&quot;libc.so.6&quot;</span>;</span>
<span class="line" id="L763">    <span class="tok-kw">var</span> f = dir.openFile(glibc_so_basename, .{}) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L764">        <span class="tok-kw">error</span>.NameTooLong =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L765">        <span class="tok-kw">error</span>.InvalidUtf8 =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// WASI only</span>
</span>
<span class="line" id="L766">        <span class="tok-kw">error</span>.InvalidWtf8 =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Windows only</span>
</span>
<span class="line" id="L767">        <span class="tok-kw">error</span>.BadPathName =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Windows only</span>
</span>
<span class="line" id="L768">        <span class="tok-kw">error</span>.PipeBusy =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Windows-only</span>
</span>
<span class="line" id="L769">        <span class="tok-kw">error</span>.SharingViolation =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Windows-only</span>
</span>
<span class="line" id="L770">        <span class="tok-kw">error</span>.NetworkNotFound =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Windows-only</span>
</span>
<span class="line" id="L771">        <span class="tok-kw">error</span>.AntivirusInterference =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Windows-only</span>
</span>
<span class="line" id="L772">        <span class="tok-kw">error</span>.FileLocksNotSupported =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// No lock requested.</span>
</span>
<span class="line" id="L773">        <span class="tok-kw">error</span>.NoSpaceLeft =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// read-only</span>
</span>
<span class="line" id="L774">        <span class="tok-kw">error</span>.PathAlreadyExists =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// read-only</span>
</span>
<span class="line" id="L775">        <span class="tok-kw">error</span>.DeviceBusy =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// read-only</span>
</span>
<span class="line" id="L776">        <span class="tok-kw">error</span>.FileBusy =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// read-only</span>
</span>
<span class="line" id="L777">        <span class="tok-kw">error</span>.WouldBlock =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// not using O_NONBLOCK</span>
</span>
<span class="line" id="L778">        <span class="tok-kw">error</span>.NoDevice =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// not asking for a special device</span>
</span>
<span class="line" id="L779"></span>
<span class="line" id="L780">        <span class="tok-kw">error</span>.AccessDenied,</span>
<span class="line" id="L781">        <span class="tok-kw">error</span>.FileNotFound,</span>
<span class="line" id="L782">        <span class="tok-kw">error</span>.NotDir,</span>
<span class="line" id="L783">        <span class="tok-kw">error</span>.IsDir,</span>
<span class="line" id="L784">        =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.GLibCNotFound,</span>
<span class="line" id="L785"></span>
<span class="line" id="L786">        <span class="tok-kw">error</span>.FileTooBig =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected,</span>
<span class="line" id="L787"></span>
<span class="line" id="L788">        <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,</span>
<span class="line" id="L789">        <span class="tok-kw">error</span>.SystemFdQuotaExceeded,</span>
<span class="line" id="L790">        <span class="tok-kw">error</span>.SystemResources,</span>
<span class="line" id="L791">        <span class="tok-kw">error</span>.SymLinkLoop,</span>
<span class="line" id="L792">        <span class="tok-kw">error</span>.Unexpected,</span>
<span class="line" id="L793">        =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L794">    };</span>
<span class="line" id="L795">    <span class="tok-kw">defer</span> f.close();</span>
<span class="line" id="L796"></span>
<span class="line" id="L797">    <span class="tok-kw">return</span> glibcVerFromSoFile(f) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L798">        <span class="tok-kw">error</span>.InvalidElfMagic,</span>
<span class="line" id="L799">        <span class="tok-kw">error</span>.InvalidElfEndian,</span>
<span class="line" id="L800">        <span class="tok-kw">error</span>.InvalidElfClass,</span>
<span class="line" id="L801">        <span class="tok-kw">error</span>.InvalidElfFile,</span>
<span class="line" id="L802">        <span class="tok-kw">error</span>.InvalidElfVersion,</span>
<span class="line" id="L803">        <span class="tok-kw">error</span>.InvalidGnuLibCVersion,</span>
<span class="line" id="L804">        <span class="tok-kw">error</span>.UnexpectedEndOfFile,</span>
<span class="line" id="L805">        =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.GLibCNotFound,</span>
<span class="line" id="L806"></span>
<span class="line" id="L807">        <span class="tok-kw">error</span>.SystemResources,</span>
<span class="line" id="L808">        <span class="tok-kw">error</span>.UnableToReadElfFile,</span>
<span class="line" id="L809">        <span class="tok-kw">error</span>.Unexpected,</span>
<span class="line" id="L810">        <span class="tok-kw">error</span>.FileSystem,</span>
<span class="line" id="L811">        =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L812">    };</span>
<span class="line" id="L813">}</span>
<span class="line" id="L814"></span>
<span class="line" id="L815"><span class="tok-kw">fn</span> <span class="tok-fn">glibcVerFromSoFile</span>(file: fs.File) !std.SemanticVersion {</span>
<span class="line" id="L816">    <span class="tok-kw">var</span> hdr_buf: [<span class="tok-builtin">@sizeOf</span>(elf.Elf64_Ehdr)]<span class="tok-type">u8</span> <span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(elf.Elf64_Ehdr)) = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L817">    _ = <span class="tok-kw">try</span> preadMin(file, &amp;hdr_buf, <span class="tok-number">0</span>, hdr_buf.len);</span>
<span class="line" id="L818">    <span class="tok-kw">const</span> hdr32 = <span class="tok-builtin">@as</span>(*elf.Elf32_Ehdr, <span class="tok-builtin">@ptrCast</span>(&amp;hdr_buf));</span>
<span class="line" id="L819">    <span class="tok-kw">const</span> hdr64 = <span class="tok-builtin">@as</span>(*elf.Elf64_Ehdr, <span class="tok-builtin">@ptrCast</span>(&amp;hdr_buf));</span>
<span class="line" id="L820">    <span class="tok-kw">if</span> (!mem.eql(<span class="tok-type">u8</span>, hdr32.e_ident[<span class="tok-number">0</span>..<span class="tok-number">4</span>], elf.MAGIC)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidElfMagic;</span>
<span class="line" id="L821">    <span class="tok-kw">const</span> elf_endian: std.builtin.Endian = <span class="tok-kw">switch</span> (hdr32.e_ident[elf.EI_DATA]) {</span>
<span class="line" id="L822">        elf.ELFDATA2LSB =&gt; .little,</span>
<span class="line" id="L823">        elf.ELFDATA2MSB =&gt; .big,</span>
<span class="line" id="L824">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidElfEndian,</span>
<span class="line" id="L825">    };</span>
<span class="line" id="L826">    <span class="tok-kw">const</span> need_bswap = elf_endian != native_endian;</span>
<span class="line" id="L827">    <span class="tok-kw">if</span> (hdr32.e_ident[elf.EI_VERSION] != <span class="tok-number">1</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidElfVersion;</span>
<span class="line" id="L828"></span>
<span class="line" id="L829">    <span class="tok-kw">const</span> is_64 = <span class="tok-kw">switch</span> (hdr32.e_ident[elf.EI_CLASS]) {</span>
<span class="line" id="L830">        elf.ELFCLASS32 =&gt; <span class="tok-null">false</span>,</span>
<span class="line" id="L831">        elf.ELFCLASS64 =&gt; <span class="tok-null">true</span>,</span>
<span class="line" id="L832">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidElfClass,</span>
<span class="line" id="L833">    };</span>
<span class="line" id="L834">    <span class="tok-kw">const</span> shstrndx = elfInt(is_64, need_bswap, hdr32.e_shstrndx, hdr64.e_shstrndx);</span>
<span class="line" id="L835">    <span class="tok-kw">var</span> shoff = elfInt(is_64, need_bswap, hdr32.e_shoff, hdr64.e_shoff);</span>
<span class="line" id="L836">    <span class="tok-kw">const</span> shentsize = elfInt(is_64, need_bswap, hdr32.e_shentsize, hdr64.e_shentsize);</span>
<span class="line" id="L837">    <span class="tok-kw">const</span> str_section_off = shoff + <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, shentsize) * <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, shstrndx);</span>
<span class="line" id="L838">    <span class="tok-kw">var</span> sh_buf: [<span class="tok-number">16</span> * <span class="tok-builtin">@sizeOf</span>(elf.Elf64_Shdr)]<span class="tok-type">u8</span> <span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(elf.Elf64_Shdr)) = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L839">    <span class="tok-kw">if</span> (sh_buf.len &lt; shentsize) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidElfFile;</span>
<span class="line" id="L840"></span>
<span class="line" id="L841">    _ = <span class="tok-kw">try</span> preadMin(file, &amp;sh_buf, str_section_off, shentsize);</span>
<span class="line" id="L842">    <span class="tok-kw">const</span> shstr32: *elf.Elf32_Shdr = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;sh_buf));</span>
<span class="line" id="L843">    <span class="tok-kw">const</span> shstr64: *elf.Elf64_Shdr = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;sh_buf));</span>
<span class="line" id="L844">    <span class="tok-kw">const</span> shstrtab_off = elfInt(is_64, need_bswap, shstr32.sh_offset, shstr64.sh_offset);</span>
<span class="line" id="L845">    <span class="tok-kw">const</span> shstrtab_size = elfInt(is_64, need_bswap, shstr32.sh_size, shstr64.sh_size);</span>
<span class="line" id="L846">    <span class="tok-kw">var</span> strtab_buf: [<span class="tok-number">4096</span>:<span class="tok-number">0</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L847">    <span class="tok-kw">const</span> shstrtab_len = <span class="tok-builtin">@min</span>(shstrtab_size, strtab_buf.len);</span>
<span class="line" id="L848">    <span class="tok-kw">const</span> shstrtab_read_len = <span class="tok-kw">try</span> preadMin(file, &amp;strtab_buf, shstrtab_off, shstrtab_len);</span>
<span class="line" id="L849">    <span class="tok-kw">const</span> shstrtab = strtab_buf[<span class="tok-number">0</span>..shstrtab_read_len];</span>
<span class="line" id="L850">    <span class="tok-kw">const</span> shnum = elfInt(is_64, need_bswap, hdr32.e_shnum, hdr64.e_shnum);</span>
<span class="line" id="L851">    <span class="tok-kw">var</span> sh_i: <span class="tok-type">u16</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L852">    <span class="tok-kw">const</span> dynstr: <span class="tok-kw">struct</span> { offset: <span class="tok-type">u64</span>, size: <span class="tok-type">u64</span> } = find_dyn_str: <span class="tok-kw">while</span> (sh_i &lt; shnum) {</span>
<span class="line" id="L853">        <span class="tok-comment">// Reserve some bytes so that we can deref the 64-bit struct fields</span>
</span>
<span class="line" id="L854">        <span class="tok-comment">// even when the ELF file is 32-bits.</span>
</span>
<span class="line" id="L855">        <span class="tok-kw">const</span> sh_reserve: <span class="tok-type">usize</span> = <span class="tok-builtin">@sizeOf</span>(elf.Elf64_Shdr) - <span class="tok-builtin">@sizeOf</span>(elf.Elf32_Shdr);</span>
<span class="line" id="L856">        <span class="tok-kw">const</span> sh_read_byte_len = <span class="tok-kw">try</span> preadMin(</span>
<span class="line" id="L857">            file,</span>
<span class="line" id="L858">            sh_buf[<span class="tok-number">0</span> .. sh_buf.len - sh_reserve],</span>
<span class="line" id="L859">            shoff,</span>
<span class="line" id="L860">            shentsize,</span>
<span class="line" id="L861">        );</span>
<span class="line" id="L862">        <span class="tok-kw">var</span> sh_buf_i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L863">        <span class="tok-kw">while</span> (sh_buf_i &lt; sh_read_byte_len <span class="tok-kw">and</span> sh_i &lt; shnum) : ({</span>
<span class="line" id="L864">            sh_i += <span class="tok-number">1</span>;</span>
<span class="line" id="L865">            shoff += shentsize;</span>
<span class="line" id="L866">            sh_buf_i += shentsize;</span>
<span class="line" id="L867">        }) {</span>
<span class="line" id="L868">            <span class="tok-kw">const</span> sh32: *elf.Elf32_Shdr = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;sh_buf[sh_buf_i]));</span>
<span class="line" id="L869">            <span class="tok-kw">const</span> sh64: *elf.Elf64_Shdr = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;sh_buf[sh_buf_i]));</span>
<span class="line" id="L870">            <span class="tok-kw">const</span> sh_name_off = elfInt(is_64, need_bswap, sh32.sh_name, sh64.sh_name);</span>
<span class="line" id="L871">            <span class="tok-kw">const</span> sh_name = mem.sliceTo(shstrtab[sh_name_off..], <span class="tok-number">0</span>);</span>
<span class="line" id="L872">            <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, sh_name, <span class="tok-str">&quot;.dynstr&quot;</span>)) {</span>
<span class="line" id="L873">                <span class="tok-kw">break</span> :find_dyn_str .{</span>
<span class="line" id="L874">                    .offset = elfInt(is_64, need_bswap, sh32.sh_offset, sh64.sh_offset),</span>
<span class="line" id="L875">                    .size = elfInt(is_64, need_bswap, sh32.sh_size, sh64.sh_size),</span>
<span class="line" id="L876">                };</span>
<span class="line" id="L877">            }</span>
<span class="line" id="L878">        }</span>
<span class="line" id="L879">    } <span class="tok-kw">else</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidGnuLibCVersion;</span>
<span class="line" id="L880"></span>
<span class="line" id="L881">    <span class="tok-comment">// Here we loop over all the strings in the dynstr string table, assuming that any</span>
</span>
<span class="line" id="L882">    <span class="tok-comment">// strings that start with &quot;GLIBC_2.&quot; indicate the existence of such a glibc version,</span>
</span>
<span class="line" id="L883">    <span class="tok-comment">// and furthermore, that the system-installed glibc is at minimum that version.</span>
</span>
<span class="line" id="L884"></span>
<span class="line" id="L885">    <span class="tok-comment">// Empirically, glibc 2.34 libc.so .dynstr section is 32441 bytes on my system.</span>
</span>
<span class="line" id="L886">    <span class="tok-comment">// Here I use double this value plus some headroom. This makes it only need</span>
</span>
<span class="line" id="L887">    <span class="tok-comment">// a single read syscall here.</span>
</span>
<span class="line" id="L888">    <span class="tok-kw">var</span> buf: [<span class="tok-number">80000</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L889">    <span class="tok-kw">if</span> (buf.len &lt; dynstr.size) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidGnuLibCVersion;</span>
<span class="line" id="L890"></span>
<span class="line" id="L891">    <span class="tok-kw">const</span> dynstr_size: <span class="tok-type">usize</span> = <span class="tok-builtin">@intCast</span>(dynstr.size);</span>
<span class="line" id="L892">    <span class="tok-kw">const</span> dynstr_bytes = buf[<span class="tok-number">0</span>..dynstr_size];</span>
<span class="line" id="L893">    _ = <span class="tok-kw">try</span> preadMin(file, dynstr_bytes, dynstr.offset, dynstr_bytes.len);</span>
<span class="line" id="L894">    <span class="tok-kw">var</span> it = mem.splitScalar(<span class="tok-type">u8</span>, dynstr_bytes, <span class="tok-number">0</span>);</span>
<span class="line" id="L895">    <span class="tok-kw">var</span> max_ver: std.SemanticVersion = .{ .major = <span class="tok-number">2</span>, .minor = <span class="tok-number">2</span>, .patch = <span class="tok-number">5</span> };</span>
<span class="line" id="L896">    <span class="tok-kw">while</span> (it.next()) |s| {</span>
<span class="line" id="L897">        <span class="tok-kw">if</span> (mem.startsWith(<span class="tok-type">u8</span>, s, <span class="tok-str">&quot;GLIBC_2.&quot;</span>)) {</span>
<span class="line" id="L898">            <span class="tok-kw">const</span> chopped = s[<span class="tok-str">&quot;GLIBC_&quot;</span>.len..];</span>
<span class="line" id="L899">            <span class="tok-kw">const</span> ver = Target.Query.parseVersion(chopped) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L900">                <span class="tok-kw">error</span>.Overflow =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidGnuLibCVersion,</span>
<span class="line" id="L901">                <span class="tok-kw">error</span>.InvalidVersion =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidGnuLibCVersion,</span>
<span class="line" id="L902">            };</span>
<span class="line" id="L903">            <span class="tok-kw">switch</span> (ver.order(max_ver)) {</span>
<span class="line" id="L904">                .gt =&gt; max_ver = ver,</span>
<span class="line" id="L905">                .lt, .eq =&gt; <span class="tok-kw">continue</span>,</span>
<span class="line" id="L906">            }</span>
<span class="line" id="L907">        }</span>
<span class="line" id="L908">    }</span>
<span class="line" id="L909">    <span class="tok-kw">return</span> max_ver;</span>
<span class="line" id="L910">}</span>
<span class="line" id="L911"></span>
<span class="line" id="L912"><span class="tok-comment">/// In the past, this function attempted to use the executable's own binary if it was dynamically</span></span>
<span class="line" id="L913"><span class="tok-comment">/// linked to answer both the C ABI question and the dynamic linker question. However, this</span></span>
<span class="line" id="L914"><span class="tok-comment">/// could be problematic on a system that uses a RUNPATH for the compiler binary, locking</span></span>
<span class="line" id="L915"><span class="tok-comment">/// it to an older glibc version, while system binaries such as /usr/bin/env use a newer glibc</span></span>
<span class="line" id="L916"><span class="tok-comment">/// version. The problem is that libc.so.6 glibc version will match that of the system while</span></span>
<span class="line" id="L917"><span class="tok-comment">/// the dynamic linker will match that of the compiler binary. Executables with these versions</span></span>
<span class="line" id="L918"><span class="tok-comment">/// mismatching will fail to run.</span></span>
<span class="line" id="L919"><span class="tok-comment">///</span></span>
<span class="line" id="L920"><span class="tok-comment">/// Therefore, this function works the same regardless of whether the compiler binary is</span></span>
<span class="line" id="L921"><span class="tok-comment">/// dynamically or statically linked. It inspects `/usr/bin/env` as an ELF file to find the</span></span>
<span class="line" id="L922"><span class="tok-comment">/// answer to these questions, or if there is a shebang line, then it chases the referenced</span></span>
<span class="line" id="L923"><span class="tok-comment">/// file recursively. If that does not provide the answer, then the function falls back to</span></span>
<span class="line" id="L924"><span class="tok-comment">/// defaults.</span></span>
<span class="line" id="L925"><span class="tok-kw">fn</span> <span class="tok-fn">detectAbiAndDynamicLinker</span>(</span>
<span class="line" id="L926">    cpu: Target.Cpu,</span>
<span class="line" id="L927">    os: Target.Os,</span>
<span class="line" id="L928">    query: Target.Query,</span>
<span class="line" id="L929">) DetectError!Target {</span>
<span class="line" id="L930">    <span class="tok-kw">const</span> native_target_has_ld = <span class="tok-kw">comptime</span> builtin.target.hasDynamicLinker();</span>
<span class="line" id="L931">    <span class="tok-kw">const</span> is_linux = builtin.target.os.tag == .linux;</span>
<span class="line" id="L932">    <span class="tok-kw">const</span> is_solarish = builtin.target.os.tag.isSolarish();</span>
<span class="line" id="L933">    <span class="tok-kw">const</span> have_all_info = query.dynamic_linker.get() != <span class="tok-null">null</span> <span class="tok-kw">and</span></span>
<span class="line" id="L934">        query.abi != <span class="tok-null">null</span> <span class="tok-kw">and</span> (!is_linux <span class="tok-kw">or</span> query.abi.?.isGnu());</span>
<span class="line" id="L935">    <span class="tok-kw">const</span> os_is_non_native = query.os_tag != <span class="tok-null">null</span>;</span>
<span class="line" id="L936">    <span class="tok-comment">// The Solaris/illumos environment is always the same.</span>
</span>
<span class="line" id="L937">    <span class="tok-kw">if</span> (!native_target_has_ld <span class="tok-kw">or</span> have_all_info <span class="tok-kw">or</span> os_is_non_native <span class="tok-kw">or</span> is_solarish) {</span>
<span class="line" id="L938">        <span class="tok-kw">return</span> defaultAbiAndDynamicLinker(cpu, os, query);</span>
<span class="line" id="L939">    }</span>
<span class="line" id="L940">    <span class="tok-kw">if</span> (query.abi) |abi| {</span>
<span class="line" id="L941">        <span class="tok-kw">if</span> (abi.isMusl()) {</span>
<span class="line" id="L942">            <span class="tok-comment">// musl implies static linking.</span>
</span>
<span class="line" id="L943">            <span class="tok-kw">return</span> defaultAbiAndDynamicLinker(cpu, os, query);</span>
<span class="line" id="L944">        }</span>
<span class="line" id="L945">    }</span>
<span class="line" id="L946">    <span class="tok-comment">// The current target's ABI cannot be relied on for this. For example, we may build the zig</span>
</span>
<span class="line" id="L947">    <span class="tok-comment">// compiler for target riscv64-linux-musl and provide a tarball for users to download.</span>
</span>
<span class="line" id="L948">    <span class="tok-comment">// A user could then run that zig compiler on riscv64-linux-gnu. This use case is well-defined</span>
</span>
<span class="line" id="L949">    <span class="tok-comment">// and supported by Zig. But that means that we must detect the system ABI here rather than</span>
</span>
<span class="line" id="L950">    <span class="tok-comment">// relying on `builtin.target`.</span>
</span>
<span class="line" id="L951">    <span class="tok-kw">const</span> all_abis = <span class="tok-kw">comptime</span> blk: {</span>
<span class="line" id="L952">        assert(<span class="tok-builtin">@intFromEnum</span>(Target.Abi.none) == <span class="tok-number">0</span>);</span>
<span class="line" id="L953">        <span class="tok-kw">const</span> fields = std.meta.fields(Target.Abi)[<span class="tok-number">1</span>..];</span>
<span class="line" id="L954">        <span class="tok-kw">var</span> array: [fields.len]Target.Abi = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L955">        <span class="tok-kw">for</span> (fields, <span class="tok-number">0</span>..) |field, i| {</span>
<span class="line" id="L956">            array[i] = <span class="tok-builtin">@field</span>(Target.Abi, field.name);</span>
<span class="line" id="L957">        }</span>
<span class="line" id="L958">        <span class="tok-kw">break</span> :blk array;</span>
<span class="line" id="L959">    };</span>
<span class="line" id="L960">    <span class="tok-kw">var</span> ld_info_list_buffer: [all_abis.len]LdInfo = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L961">    <span class="tok-kw">var</span> ld_info_list_len: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L962">    <span class="tok-kw">const</span> ofmt = query.ofmt <span class="tok-kw">orelse</span> Target.ObjectFormat.default(os.tag, cpu.arch);</span>
<span class="line" id="L963"></span>
<span class="line" id="L964">    <span class="tok-kw">for</span> (all_abis) |abi| {</span>
<span class="line" id="L965">        <span class="tok-comment">// This may be a nonsensical parameter. We detect this with</span>
</span>
<span class="line" id="L966">        <span class="tok-comment">// error.UnknownDynamicLinkerPath and skip adding it to `ld_info_list`.</span>
</span>
<span class="line" id="L967">        <span class="tok-kw">const</span> target: Target = .{</span>
<span class="line" id="L968">            .cpu = cpu,</span>
<span class="line" id="L969">            .os = os,</span>
<span class="line" id="L970">            .abi = abi,</span>
<span class="line" id="L971">            .ofmt = ofmt,</span>
<span class="line" id="L972">        };</span>
<span class="line" id="L973">        <span class="tok-kw">const</span> ld = target.standardDynamicLinkerPath();</span>
<span class="line" id="L974">        <span class="tok-kw">if</span> (ld.get() == <span class="tok-null">null</span>) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L975"></span>
<span class="line" id="L976">        ld_info_list_buffer[ld_info_list_len] = .{</span>
<span class="line" id="L977">            .ld = ld,</span>
<span class="line" id="L978">            .abi = abi,</span>
<span class="line" id="L979">        };</span>
<span class="line" id="L980">        ld_info_list_len += <span class="tok-number">1</span>;</span>
<span class="line" id="L981">    }</span>
<span class="line" id="L982">    <span class="tok-kw">const</span> ld_info_list = ld_info_list_buffer[<span class="tok-number">0</span>..ld_info_list_len];</span>
<span class="line" id="L983"></span>
<span class="line" id="L984">    <span class="tok-comment">// Best case scenario: the executable is dynamically linked, and we can iterate</span>
</span>
<span class="line" id="L985">    <span class="tok-comment">// over our own shared objects and find a dynamic linker.</span>
</span>
<span class="line" id="L986">    <span class="tok-kw">const</span> elf_file = blk: {</span>
<span class="line" id="L987">        <span class="tok-comment">// This block looks for a shebang line in /usr/bin/env,</span>
</span>
<span class="line" id="L988">        <span class="tok-comment">// if it finds one, then instead of using /usr/bin/env as the ELF file to examine, it uses the file it references instead,</span>
</span>
<span class="line" id="L989">        <span class="tok-comment">// doing the same logic recursively in case it finds another shebang line.</span>
</span>
<span class="line" id="L990"></span>
<span class="line" id="L991">        <span class="tok-comment">// Since /usr/bin/env is hard-coded into the shebang line of many portable scripts, it's a</span>
</span>
<span class="line" id="L992">        <span class="tok-comment">// reasonably reliable path to start with.</span>
</span>
<span class="line" id="L993">        <span class="tok-kw">var</span> file_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">&quot;/usr/bin/env&quot;</span>;</span>
<span class="line" id="L994">        <span class="tok-comment">// #! (2) + 255 (max length of shebang line since Linux 5.1) + \n (1)</span>
</span>
<span class="line" id="L995">        <span class="tok-kw">var</span> buffer: [<span class="tok-number">258</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L996">        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L997">            <span class="tok-kw">const</span> file = fs.openFileAbsolute(file_name, .{}) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L998">                <span class="tok-kw">error</span>.NoSpaceLeft =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L999">                <span class="tok-kw">error</span>.NameTooLong =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1000">                <span class="tok-kw">error</span>.PathAlreadyExists =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1001">                <span class="tok-kw">error</span>.SharingViolation =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1002">                <span class="tok-kw">error</span>.InvalidUtf8 =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// WASI only</span>
</span>
<span class="line" id="L1003">                <span class="tok-kw">error</span>.InvalidWtf8 =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Windows only</span>
</span>
<span class="line" id="L1004">                <span class="tok-kw">error</span>.BadPathName =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1005">                <span class="tok-kw">error</span>.PipeBusy =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1006">                <span class="tok-kw">error</span>.FileLocksNotSupported =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1007">                <span class="tok-kw">error</span>.WouldBlock =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1008">                <span class="tok-kw">error</span>.FileBusy =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// opened without write permissions</span>
</span>
<span class="line" id="L1009">                <span class="tok-kw">error</span>.AntivirusInterference =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Windows-only error</span>
</span>
<span class="line" id="L1010"></span>
<span class="line" id="L1011">                <span class="tok-kw">error</span>.IsDir,</span>
<span class="line" id="L1012">                <span class="tok-kw">error</span>.NotDir,</span>
<span class="line" id="L1013">                <span class="tok-kw">error</span>.AccessDenied,</span>
<span class="line" id="L1014">                <span class="tok-kw">error</span>.NoDevice,</span>
<span class="line" id="L1015">                <span class="tok-kw">error</span>.FileNotFound,</span>
<span class="line" id="L1016">                <span class="tok-kw">error</span>.NetworkNotFound,</span>
<span class="line" id="L1017">                <span class="tok-kw">error</span>.FileTooBig,</span>
<span class="line" id="L1018">                <span class="tok-kw">error</span>.Unexpected,</span>
<span class="line" id="L1019">                =&gt; |e| {</span>
<span class="line" id="L1020">                    std.log.warn(<span class="tok-str">&quot;Encountered error: {s}, falling back to default ABI and dynamic linker.\n&quot;</span>, .{<span class="tok-builtin">@errorName</span>(e)});</span>
<span class="line" id="L1021">                    <span class="tok-kw">return</span> defaultAbiAndDynamicLinker(cpu, os, query);</span>
<span class="line" id="L1022">                },</span>
<span class="line" id="L1023"></span>
<span class="line" id="L1024">                <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L1025">            };</span>
<span class="line" id="L1026">            <span class="tok-kw">errdefer</span> file.close();</span>
<span class="line" id="L1027"></span>
<span class="line" id="L1028">            <span class="tok-kw">const</span> len = preadMin(file, &amp;buffer, <span class="tok-number">0</span>, buffer.len) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1029">                <span class="tok-kw">error</span>.UnexpectedEndOfFile,</span>
<span class="line" id="L1030">                <span class="tok-kw">error</span>.UnableToReadElfFile,</span>
<span class="line" id="L1031">                =&gt; <span class="tok-kw">break</span> :blk file,</span>
<span class="line" id="L1032"></span>
<span class="line" id="L1033">                <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L1034">            };</span>
<span class="line" id="L1035">            <span class="tok-kw">const</span> newline = mem.indexOfScalar(<span class="tok-type">u8</span>, buffer[<span class="tok-number">0</span>..len], <span class="tok-str">'\n'</span>) <span class="tok-kw">orelse</span> <span class="tok-kw">break</span> :blk file;</span>
<span class="line" id="L1036">            <span class="tok-kw">const</span> line = buffer[<span class="tok-number">0</span>..newline];</span>
<span class="line" id="L1037">            <span class="tok-kw">if</span> (!mem.startsWith(<span class="tok-type">u8</span>, line, <span class="tok-str">&quot;#!&quot;</span>)) <span class="tok-kw">break</span> :blk file;</span>
<span class="line" id="L1038">            <span class="tok-kw">var</span> it = mem.tokenizeScalar(<span class="tok-type">u8</span>, line[<span class="tok-number">2</span>..], <span class="tok-str">' '</span>);</span>
<span class="line" id="L1039">            file_name = it.next() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> defaultAbiAndDynamicLinker(cpu, os, query);</span>
<span class="line" id="L1040">            file.close();</span>
<span class="line" id="L1041">        }</span>
<span class="line" id="L1042">    };</span>
<span class="line" id="L1043">    <span class="tok-kw">defer</span> elf_file.close();</span>
<span class="line" id="L1044"></span>
<span class="line" id="L1045">    <span class="tok-comment">// If Zig is statically linked, such as via distributed binary static builds, the above</span>
</span>
<span class="line" id="L1046">    <span class="tok-comment">// trick (block self_exe) won't work. The next thing we fall back to is the same thing, but for elf_file.</span>
</span>
<span class="line" id="L1047">    <span class="tok-comment">// TODO: inline this function and combine the buffer we already read above to find</span>
</span>
<span class="line" id="L1048">    <span class="tok-comment">// the possible shebang line with the buffer we use for the ELF header.</span>
</span>
<span class="line" id="L1049">    <span class="tok-kw">return</span> abiAndDynamicLinkerFromFile(elf_file, cpu, os, ld_info_list, query) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1050">        <span class="tok-kw">error</span>.FileSystem,</span>
<span class="line" id="L1051">        <span class="tok-kw">error</span>.SystemResources,</span>
<span class="line" id="L1052">        <span class="tok-kw">error</span>.SymLinkLoop,</span>
<span class="line" id="L1053">        <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,</span>
<span class="line" id="L1054">        <span class="tok-kw">error</span>.SystemFdQuotaExceeded,</span>
<span class="line" id="L1055">        =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L1056"></span>
<span class="line" id="L1057">        <span class="tok-kw">error</span>.UnableToReadElfFile,</span>
<span class="line" id="L1058">        <span class="tok-kw">error</span>.InvalidElfClass,</span>
<span class="line" id="L1059">        <span class="tok-kw">error</span>.InvalidElfVersion,</span>
<span class="line" id="L1060">        <span class="tok-kw">error</span>.InvalidElfEndian,</span>
<span class="line" id="L1061">        <span class="tok-kw">error</span>.InvalidElfFile,</span>
<span class="line" id="L1062">        <span class="tok-kw">error</span>.InvalidElfMagic,</span>
<span class="line" id="L1063">        <span class="tok-kw">error</span>.Unexpected,</span>
<span class="line" id="L1064">        <span class="tok-kw">error</span>.UnexpectedEndOfFile,</span>
<span class="line" id="L1065">        <span class="tok-kw">error</span>.NameTooLong,</span>
<span class="line" id="L1066">        <span class="tok-comment">// Finally, we fall back on the standard path.</span>
</span>
<span class="line" id="L1067">        =&gt; |e| {</span>
<span class="line" id="L1068">            std.log.warn(<span class="tok-str">&quot;Encountered error: {s}, falling back to default ABI and dynamic linker.\n&quot;</span>, .{<span class="tok-builtin">@errorName</span>(e)});</span>
<span class="line" id="L1069">            <span class="tok-kw">return</span> defaultAbiAndDynamicLinker(cpu, os, query);</span>
<span class="line" id="L1070">        },</span>
<span class="line" id="L1071">    };</span>
<span class="line" id="L1072">}</span>
<span class="line" id="L1073"></span>
<span class="line" id="L1074"><span class="tok-kw">fn</span> <span class="tok-fn">defaultAbiAndDynamicLinker</span>(cpu: Target.Cpu, os: Target.Os, query: Target.Query) !Target {</span>
<span class="line" id="L1075">    <span class="tok-kw">const</span> abi = query.abi <span class="tok-kw">orelse</span> Target.Abi.default(cpu.arch, os);</span>
<span class="line" id="L1076">    <span class="tok-kw">return</span> .{</span>
<span class="line" id="L1077">        .cpu = cpu,</span>
<span class="line" id="L1078">        .os = os,</span>
<span class="line" id="L1079">        .abi = abi,</span>
<span class="line" id="L1080">        .ofmt = query.ofmt <span class="tok-kw">orelse</span> Target.ObjectFormat.default(os.tag, cpu.arch),</span>
<span class="line" id="L1081">        .dynamic_linker = <span class="tok-kw">if</span> (query.dynamic_linker.get() == <span class="tok-null">null</span>)</span>
<span class="line" id="L1082">            Target.standardDynamicLinkerPath_cpu_os_abi(cpu, os.tag, abi)</span>
<span class="line" id="L1083">        <span class="tok-kw">else</span></span>
<span class="line" id="L1084">            query.dynamic_linker,</span>
<span class="line" id="L1085">    };</span>
<span class="line" id="L1086">}</span>
<span class="line" id="L1087"></span>
<span class="line" id="L1088"><span class="tok-kw">const</span> LdInfo = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1089">    ld: Target.DynamicLinker,</span>
<span class="line" id="L1090">    abi: Target.Abi,</span>
<span class="line" id="L1091">};</span>
<span class="line" id="L1092"></span>
<span class="line" id="L1093"><span class="tok-kw">fn</span> <span class="tok-fn">preadMin</span>(file: fs.File, buf: []<span class="tok-type">u8</span>, offset: <span class="tok-type">u64</span>, min_read_len: <span class="tok-type">usize</span>) !<span class="tok-type">usize</span> {</span>
<span class="line" id="L1094">    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1095">    <span class="tok-kw">while</span> (i &lt; min_read_len) {</span>
<span class="line" id="L1096">        <span class="tok-kw">const</span> len = file.pread(buf[i..], offset + i) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1097">            <span class="tok-kw">error</span>.OperationAborted =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Windows-only</span>
</span>
<span class="line" id="L1098">            <span class="tok-kw">error</span>.WouldBlock =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Did not request blocking mode</span>
</span>
<span class="line" id="L1099">            <span class="tok-kw">error</span>.NotOpenForReading =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1100">            <span class="tok-kw">error</span>.SystemResources =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,</span>
<span class="line" id="L1101">            <span class="tok-kw">error</span>.IsDir =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnableToReadElfFile,</span>
<span class="line" id="L1102">            <span class="tok-kw">error</span>.BrokenPipe =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnableToReadElfFile,</span>
<span class="line" id="L1103">            <span class="tok-kw">error</span>.Unseekable =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnableToReadElfFile,</span>
<span class="line" id="L1104">            <span class="tok-kw">error</span>.ConnectionResetByPeer =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnableToReadElfFile,</span>
<span class="line" id="L1105">            <span class="tok-kw">error</span>.ConnectionTimedOut =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnableToReadElfFile,</span>
<span class="line" id="L1106">            <span class="tok-kw">error</span>.SocketNotConnected =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnableToReadElfFile,</span>
<span class="line" id="L1107">            <span class="tok-kw">error</span>.Unexpected =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected,</span>
<span class="line" id="L1108">            <span class="tok-kw">error</span>.InputOutput =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileSystem,</span>
<span class="line" id="L1109">            <span class="tok-kw">error</span>.AccessDenied =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected,</span>
<span class="line" id="L1110">        };</span>
<span class="line" id="L1111">        <span class="tok-kw">if</span> (len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedEndOfFile;</span>
<span class="line" id="L1112">        i += len;</span>
<span class="line" id="L1113">    }</span>
<span class="line" id="L1114">    <span class="tok-kw">return</span> i;</span>
<span class="line" id="L1115">}</span>
<span class="line" id="L1116"></span>
<span class="line" id="L1117"><span class="tok-kw">fn</span> <span class="tok-fn">elfInt</span>(is_64: <span class="tok-type">bool</span>, need_bswap: <span class="tok-type">bool</span>, int_32: <span class="tok-kw">anytype</span>, int_64: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@TypeOf</span>(int_64) {</span>
<span class="line" id="L1118">    <span class="tok-kw">if</span> (is_64) {</span>
<span class="line" id="L1119">        <span class="tok-kw">if</span> (need_bswap) {</span>
<span class="line" id="L1120">            <span class="tok-kw">return</span> <span class="tok-builtin">@byteSwap</span>(int_64);</span>
<span class="line" id="L1121">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1122">            <span class="tok-kw">return</span> int_64;</span>
<span class="line" id="L1123">        }</span>
<span class="line" id="L1124">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1125">        <span class="tok-kw">if</span> (need_bswap) {</span>
<span class="line" id="L1126">            <span class="tok-kw">return</span> <span class="tok-builtin">@byteSwap</span>(int_32);</span>
<span class="line" id="L1127">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1128">            <span class="tok-kw">return</span> int_32;</span>
<span class="line" id="L1129">        }</span>
<span class="line" id="L1130">    }</span>
<span class="line" id="L1131">}</span>
<span class="line" id="L1132"></span>
<span class="line" id="L1133"><span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);</span>
<span class="line" id="L1134"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;../std.zig&quot;</span>);</span>
<span class="line" id="L1135"><span class="tok-kw">const</span> mem = std.mem;</span>
<span class="line" id="L1136"><span class="tok-kw">const</span> elf = std.elf;</span>
<span class="line" id="L1137"><span class="tok-kw">const</span> fs = std.fs;</span>
<span class="line" id="L1138"><span class="tok-kw">const</span> assert = std.debug.assert;</span>
<span class="line" id="L1139"><span class="tok-kw">const</span> Target = std.Target;</span>
<span class="line" id="L1140"><span class="tok-kw">const</span> native_endian = builtin.cpu.arch.endian();</span>
<span class="line" id="L1141"></span>
<span class="line" id="L1142"><span class="tok-kw">test</span> {</span>
<span class="line" id="L1143">    _ = NativePaths;</span>
<span class="line" id="L1144"></span>
<span class="line" id="L1145">    _ = darwin;</span>
<span class="line" id="L1146">    _ = linux;</span>
<span class="line" id="L1147">    _ = windows;</span>
<span class="line" id="L1148">}</span>
<span class="line" id="L1149"></span>
</code></pre></body>
</html>