<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>zig/AstGen.zig - source view</title>
    <link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAgklEQVR4AWMYWuD7EllJIM4G4g4g5oIJ/odhOJ8wToOxSTXgNxDHoeiBMfA4+wGShjyYOCkG/IGqWQziEzYAoUAeiF9D5U+DxEg14DRU7jWIT5IBIOdCxf+A+CQZAAoopEB7QJwBCBwHiip8UYmRdrAlDpIMgApwQZNnNii5Dq0MBgCxxycBnwEd+wAAAABJRU5ErkJggg==">
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style>
      body{
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        margin: 0;
        line-height: 1.5;
      }

      pre > code {
        display: block;
        overflow: auto;
        line-height: normal;
        margin: 0em;
      }
      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #005C7A;
      }
      .tok-comment {
          color: #545454;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #005C5C;
      }
      .tok-number {
          color: #005C5C;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }
      pre {
        counter-reset: line;
      }
      pre .line:before {
        counter-increment: line;
        content: counter(line);
        display: inline-block;
        padding-right: 1em;
        width: 2em;
        text-align: right;
        color: #999;
      }
      
      .line {
        width: 100%;
        display: inline-block;
      }
      .line:target {
        border-top: 1px solid #ccc;
        border-bottom: 1px solid #ccc;
        background: #fafafa;
      }

      @media (prefers-color-scheme: dark) {
        body{
            background:#222;
            color: #ccc;
        }
        pre > code {
            color: #ccc;
            background: #222;
            border: unset;
        }
        .line:target {
            border-top: 1px solid #444;
            border-bottom: 1px solid #444;
            background: #333;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
</head>
<body>
<pre><code><span class="line" id="L1"><span class="tok-comment">//! Ingests an AST and produces ZIR code.</span></span>
<span class="line" id="L2"><span class="tok-kw">const</span> AstGen = <span class="tok-builtin">@This</span>();</span>
<span class="line" id="L3"></span>
<span class="line" id="L4"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);</span>
<span class="line" id="L5"><span class="tok-kw">const</span> Ast = std.zig.Ast;</span>
<span class="line" id="L6"><span class="tok-kw">const</span> mem = std.mem;</span>
<span class="line" id="L7"><span class="tok-kw">const</span> Allocator = std.mem.Allocator;</span>
<span class="line" id="L8"><span class="tok-kw">const</span> assert = std.debug.assert;</span>
<span class="line" id="L9"><span class="tok-kw">const</span> ArrayListUnmanaged = std.ArrayListUnmanaged;</span>
<span class="line" id="L10"><span class="tok-kw">const</span> StringIndexAdapter = std.hash_map.StringIndexAdapter;</span>
<span class="line" id="L11"><span class="tok-kw">const</span> StringIndexContext = std.hash_map.StringIndexContext;</span>
<span class="line" id="L12"></span>
<span class="line" id="L13"><span class="tok-kw">const</span> isPrimitive = std.zig.primitives.isPrimitive;</span>
<span class="line" id="L14"></span>
<span class="line" id="L15"><span class="tok-kw">const</span> Zir = std.zig.Zir;</span>
<span class="line" id="L16"><span class="tok-kw">const</span> BuiltinFn = std.zig.BuiltinFn;</span>
<span class="line" id="L17"><span class="tok-kw">const</span> AstRlAnnotate = std.zig.AstRlAnnotate;</span>
<span class="line" id="L18"></span>
<span class="line" id="L19">gpa: Allocator,</span>
<span class="line" id="L20">tree: *<span class="tok-kw">const</span> Ast,</span>
<span class="line" id="L21"><span class="tok-comment">/// The set of nodes which, given the choice, must expose a result pointer to</span></span>
<span class="line" id="L22"><span class="tok-comment">/// sub-expressions. See `AstRlAnnotate` for details.</span></span>
<span class="line" id="L23">nodes_need_rl: *<span class="tok-kw">const</span> AstRlAnnotate.RlNeededSet,</span>
<span class="line" id="L24">instructions: std.MultiArrayList(Zir.Inst) = .{},</span>
<span class="line" id="L25">extra: ArrayListUnmanaged(<span class="tok-type">u32</span>) = .{},</span>
<span class="line" id="L26">string_bytes: ArrayListUnmanaged(<span class="tok-type">u8</span>) = .{},</span>
<span class="line" id="L27"><span class="tok-comment">/// Tracks the current byte offset within the source file.</span></span>
<span class="line" id="L28"><span class="tok-comment">/// Used to populate line deltas in the ZIR. AstGen maintains</span></span>
<span class="line" id="L29"><span class="tok-comment">/// this &quot;cursor&quot; throughout the entire AST lowering process in order</span></span>
<span class="line" id="L30"><span class="tok-comment">/// to avoid starting over the line/column scan for every declaration, which</span></span>
<span class="line" id="L31"><span class="tok-comment">/// would be O(N^2).</span></span>
<span class="line" id="L32">source_offset: <span class="tok-type">u32</span> = <span class="tok-number">0</span>,</span>
<span class="line" id="L33"><span class="tok-comment">/// Tracks the corresponding line of `source_offset`.</span></span>
<span class="line" id="L34"><span class="tok-comment">/// This value is absolute.</span></span>
<span class="line" id="L35">source_line: <span class="tok-type">u32</span> = <span class="tok-number">0</span>,</span>
<span class="line" id="L36"><span class="tok-comment">/// Tracks the corresponding column of `source_offset`.</span></span>
<span class="line" id="L37"><span class="tok-comment">/// This value is absolute.</span></span>
<span class="line" id="L38">source_column: <span class="tok-type">u32</span> = <span class="tok-number">0</span>,</span>
<span class="line" id="L39"><span class="tok-comment">/// Used for temporary allocations; freed after AstGen is complete.</span></span>
<span class="line" id="L40"><span class="tok-comment">/// The resulting ZIR code has no references to anything in this arena.</span></span>
<span class="line" id="L41">arena: Allocator,</span>
<span class="line" id="L42">string_table: std.HashMapUnmanaged(<span class="tok-type">u32</span>, <span class="tok-type">void</span>, StringIndexContext, std.hash_map.default_max_load_percentage) = .{},</span>
<span class="line" id="L43">compile_errors: ArrayListUnmanaged(Zir.Inst.CompileErrors.Item) = .{},</span>
<span class="line" id="L44"><span class="tok-comment">/// The topmost block of the current function.</span></span>
<span class="line" id="L45">fn_block: ?*GenZir = <span class="tok-null">null</span>,</span>
<span class="line" id="L46">fn_var_args: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,</span>
<span class="line" id="L47"><span class="tok-comment">/// Whether we are somewhere within a function. If `true`, any container decls may be</span></span>
<span class="line" id="L48"><span class="tok-comment">/// generic and thus must be tunneled through closure.</span></span>
<span class="line" id="L49">within_fn: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,</span>
<span class="line" id="L50"><span class="tok-comment">/// The return type of the current function. This may be a trivial `Ref`, or</span></span>
<span class="line" id="L51"><span class="tok-comment">/// otherwise it refers to a `ret_type` instruction.</span></span>
<span class="line" id="L52">fn_ret_ty: Zir.Inst.Ref = .none,</span>
<span class="line" id="L53"><span class="tok-comment">/// Maps string table indexes to the first `@import` ZIR instruction</span></span>
<span class="line" id="L54"><span class="tok-comment">/// that uses this string as the operand.</span></span>
<span class="line" id="L55">imports: std.AutoArrayHashMapUnmanaged(Zir.NullTerminatedString, Ast.TokenIndex) = .{},</span>
<span class="line" id="L56"><span class="tok-comment">/// Used for temporary storage when building payloads.</span></span>
<span class="line" id="L57">scratch: std.ArrayListUnmanaged(<span class="tok-type">u32</span>) = .{},</span>
<span class="line" id="L58"><span class="tok-comment">/// Whenever a `ref` instruction is needed, it is created and saved in this</span></span>
<span class="line" id="L59"><span class="tok-comment">/// table instead of being immediately appended to the current block body.</span></span>
<span class="line" id="L60"><span class="tok-comment">/// Then, when the instruction is being added to the parent block (typically from</span></span>
<span class="line" id="L61"><span class="tok-comment">/// setBlockBody), if it has a ref_table entry, then the ref instruction is added</span></span>
<span class="line" id="L62"><span class="tok-comment">/// there. This makes sure two properties are upheld:</span></span>
<span class="line" id="L63"><span class="tok-comment">/// 1. All pointers to the same locals return the same address. This is required</span></span>
<span class="line" id="L64"><span class="tok-comment">///    to be compliant with the language specification.</span></span>
<span class="line" id="L65"><span class="tok-comment">/// 2. `ref` instructions will dominate their uses. This is a required property</span></span>
<span class="line" id="L66"><span class="tok-comment">///    of ZIR.</span></span>
<span class="line" id="L67"><span class="tok-comment">/// The key is the ref operand; the value is the ref instruction.</span></span>
<span class="line" id="L68">ref_table: std.AutoHashMapUnmanaged(Zir.Inst.Index, Zir.Inst.Index) = .{},</span>
<span class="line" id="L69"></span>
<span class="line" id="L70"><span class="tok-kw">const</span> InnerError = <span class="tok-kw">error</span>{ OutOfMemory, AnalysisFail };</span>
<span class="line" id="L71"></span>
<span class="line" id="L72"><span class="tok-kw">fn</span> <span class="tok-fn">addExtra</span>(astgen: *AstGen, extra: <span class="tok-kw">anytype</span>) Allocator.Error!<span class="tok-type">u32</span> {</span>
<span class="line" id="L73">    <span class="tok-kw">const</span> fields = std.meta.fields(<span class="tok-builtin">@TypeOf</span>(extra));</span>
<span class="line" id="L74">    <span class="tok-kw">try</span> astgen.extra.ensureUnusedCapacity(astgen.gpa, fields.len);</span>
<span class="line" id="L75">    <span class="tok-kw">return</span> addExtraAssumeCapacity(astgen, extra);</span>
<span class="line" id="L76">}</span>
<span class="line" id="L77"></span>
<span class="line" id="L78"><span class="tok-kw">fn</span> <span class="tok-fn">addExtraAssumeCapacity</span>(astgen: *AstGen, extra: <span class="tok-kw">anytype</span>) <span class="tok-type">u32</span> {</span>
<span class="line" id="L79">    <span class="tok-kw">const</span> fields = std.meta.fields(<span class="tok-builtin">@TypeOf</span>(extra));</span>
<span class="line" id="L80">    <span class="tok-kw">const</span> extra_index: <span class="tok-type">u32</span> = <span class="tok-builtin">@intCast</span>(astgen.extra.items.len);</span>
<span class="line" id="L81">    astgen.extra.items.len += fields.len;</span>
<span class="line" id="L82">    setExtra(astgen, extra_index, extra);</span>
<span class="line" id="L83">    <span class="tok-kw">return</span> extra_index;</span>
<span class="line" id="L84">}</span>
<span class="line" id="L85"></span>
<span class="line" id="L86"><span class="tok-kw">fn</span> <span class="tok-fn">setExtra</span>(astgen: *AstGen, index: <span class="tok-type">usize</span>, extra: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L87">    <span class="tok-kw">const</span> fields = std.meta.fields(<span class="tok-builtin">@TypeOf</span>(extra));</span>
<span class="line" id="L88">    <span class="tok-kw">var</span> i = index;</span>
<span class="line" id="L89">    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (fields) |field| {</span>
<span class="line" id="L90">        astgen.extra.items[i] = <span class="tok-kw">switch</span> (field.<span class="tok-type">type</span>) {</span>
<span class="line" id="L91">            <span class="tok-type">u32</span> =&gt; <span class="tok-builtin">@field</span>(extra, field.name),</span>
<span class="line" id="L92"></span>
<span class="line" id="L93">            Zir.Inst.Ref,</span>
<span class="line" id="L94">            Zir.Inst.Index,</span>
<span class="line" id="L95">            Zir.Inst.Declaration.Name,</span>
<span class="line" id="L96">            Zir.NullTerminatedString,</span>
<span class="line" id="L97">            =&gt; <span class="tok-builtin">@intFromEnum</span>(<span class="tok-builtin">@field</span>(extra, field.name)),</span>
<span class="line" id="L98"></span>
<span class="line" id="L99">            <span class="tok-type">i32</span>,</span>
<span class="line" id="L100">            Zir.Inst.Call.Flags,</span>
<span class="line" id="L101">            Zir.Inst.BuiltinCall.Flags,</span>
<span class="line" id="L102">            Zir.Inst.SwitchBlock.Bits,</span>
<span class="line" id="L103">            Zir.Inst.SwitchBlockErrUnion.Bits,</span>
<span class="line" id="L104">            Zir.Inst.FuncFancy.Bits,</span>
<span class="line" id="L105">            Zir.Inst.Declaration.Flags,</span>
<span class="line" id="L106">            =&gt; <span class="tok-builtin">@bitCast</span>(<span class="tok-builtin">@field</span>(extra, field.name)),</span>
<span class="line" id="L107"></span>
<span class="line" id="L108">            <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;bad field type&quot;</span>),</span>
<span class="line" id="L109">        };</span>
<span class="line" id="L110">        i += <span class="tok-number">1</span>;</span>
<span class="line" id="L111">    }</span>
<span class="line" id="L112">}</span>
<span class="line" id="L113"></span>
<span class="line" id="L114"><span class="tok-kw">fn</span> <span class="tok-fn">reserveExtra</span>(astgen: *AstGen, size: <span class="tok-type">usize</span>) Allocator.Error!<span class="tok-type">u32</span> {</span>
<span class="line" id="L115">    <span class="tok-kw">const</span> extra_index: <span class="tok-type">u32</span> = <span class="tok-builtin">@intCast</span>(astgen.extra.items.len);</span>
<span class="line" id="L116">    <span class="tok-kw">try</span> astgen.extra.resize(astgen.gpa, extra_index + size);</span>
<span class="line" id="L117">    <span class="tok-kw">return</span> extra_index;</span>
<span class="line" id="L118">}</span>
<span class="line" id="L119"></span>
<span class="line" id="L120"><span class="tok-kw">fn</span> <span class="tok-fn">appendRefs</span>(astgen: *AstGen, refs: []<span class="tok-kw">const</span> Zir.Inst.Ref) !<span class="tok-type">void</span> {</span>
<span class="line" id="L121">    <span class="tok-kw">return</span> astgen.extra.appendSlice(astgen.gpa, <span class="tok-builtin">@ptrCast</span>(refs));</span>
<span class="line" id="L122">}</span>
<span class="line" id="L123"></span>
<span class="line" id="L124"><span class="tok-kw">fn</span> <span class="tok-fn">appendRefsAssumeCapacity</span>(astgen: *AstGen, refs: []<span class="tok-kw">const</span> Zir.Inst.Ref) <span class="tok-type">void</span> {</span>
<span class="line" id="L125">    astgen.extra.appendSliceAssumeCapacity(<span class="tok-builtin">@ptrCast</span>(refs));</span>
<span class="line" id="L126">}</span>
<span class="line" id="L127"></span>
<span class="line" id="L128"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">generate</span>(gpa: Allocator, tree: Ast) Allocator.Error!Zir {</span>
<span class="line" id="L129">    <span class="tok-kw">var</span> arena = std.heap.ArenaAllocator.init(gpa);</span>
<span class="line" id="L130">    <span class="tok-kw">defer</span> arena.deinit();</span>
<span class="line" id="L131"></span>
<span class="line" id="L132">    <span class="tok-kw">var</span> nodes_need_rl = <span class="tok-kw">try</span> AstRlAnnotate.annotate(gpa, arena.allocator(), tree);</span>
<span class="line" id="L133">    <span class="tok-kw">defer</span> nodes_need_rl.deinit(gpa);</span>
<span class="line" id="L134"></span>
<span class="line" id="L135">    <span class="tok-kw">var</span> astgen: AstGen = .{</span>
<span class="line" id="L136">        .gpa = gpa,</span>
<span class="line" id="L137">        .arena = arena.allocator(),</span>
<span class="line" id="L138">        .tree = &amp;tree,</span>
<span class="line" id="L139">        .nodes_need_rl = &amp;nodes_need_rl,</span>
<span class="line" id="L140">    };</span>
<span class="line" id="L141">    <span class="tok-kw">defer</span> astgen.deinit(gpa);</span>
<span class="line" id="L142"></span>
<span class="line" id="L143">    <span class="tok-comment">// String table index 0 is reserved for `NullTerminatedString.empty`.</span>
</span>
<span class="line" id="L144">    <span class="tok-kw">try</span> astgen.string_bytes.append(gpa, <span class="tok-number">0</span>);</span>
<span class="line" id="L145"></span>
<span class="line" id="L146">    <span class="tok-comment">// We expect at least as many ZIR instructions and extra data items</span>
</span>
<span class="line" id="L147">    <span class="tok-comment">// as AST nodes.</span>
</span>
<span class="line" id="L148">    <span class="tok-kw">try</span> astgen.instructions.ensureTotalCapacity(gpa, tree.nodes.len);</span>
<span class="line" id="L149"></span>
<span class="line" id="L150">    <span class="tok-comment">// First few indexes of extra are reserved and set at the end.</span>
</span>
<span class="line" id="L151">    <span class="tok-kw">const</span> reserved_count = <span class="tok-builtin">@typeInfo</span>(Zir.ExtraIndex).Enum.fields.len;</span>
<span class="line" id="L152">    <span class="tok-kw">try</span> astgen.extra.ensureTotalCapacity(gpa, tree.nodes.len + reserved_count);</span>
<span class="line" id="L153">    astgen.extra.items.len += reserved_count;</span>
<span class="line" id="L154"></span>
<span class="line" id="L155">    <span class="tok-kw">var</span> top_scope: Scope.Top = .{};</span>
<span class="line" id="L156"></span>
<span class="line" id="L157">    <span class="tok-kw">var</span> gz_instructions: std.ArrayListUnmanaged(Zir.Inst.Index) = .{};</span>
<span class="line" id="L158">    <span class="tok-kw">var</span> gen_scope: GenZir = .{</span>
<span class="line" id="L159">        .is_comptime = <span class="tok-null">true</span>,</span>
<span class="line" id="L160">        .parent = &amp;top_scope.base,</span>
<span class="line" id="L161">        .anon_name_strategy = .parent,</span>
<span class="line" id="L162">        .decl_node_index = <span class="tok-number">0</span>,</span>
<span class="line" id="L163">        .decl_line = <span class="tok-number">0</span>,</span>
<span class="line" id="L164">        .astgen = &amp;astgen,</span>
<span class="line" id="L165">        .instructions = &amp;gz_instructions,</span>
<span class="line" id="L166">        .instructions_top = <span class="tok-number">0</span>,</span>
<span class="line" id="L167">    };</span>
<span class="line" id="L168">    <span class="tok-kw">defer</span> gz_instructions.deinit(gpa);</span>
<span class="line" id="L169"></span>
<span class="line" id="L170">    <span class="tok-comment">// The AST -&gt; ZIR lowering process assumes an AST that does not have any</span>
</span>
<span class="line" id="L171">    <span class="tok-comment">// parse errors.</span>
</span>
<span class="line" id="L172">    <span class="tok-kw">if</span> (tree.errors.len == <span class="tok-number">0</span>) {</span>
<span class="line" id="L173">        <span class="tok-kw">if</span> (AstGen.structDeclInner(</span>
<span class="line" id="L174">            &amp;gen_scope,</span>
<span class="line" id="L175">            &amp;gen_scope.base,</span>
<span class="line" id="L176">            <span class="tok-number">0</span>,</span>
<span class="line" id="L177">            tree.containerDeclRoot(),</span>
<span class="line" id="L178">            .Auto,</span>
<span class="line" id="L179">            <span class="tok-number">0</span>,</span>
<span class="line" id="L180">        )) |struct_decl_ref| {</span>
<span class="line" id="L181">            assert(struct_decl_ref.toIndex().? == .main_struct_inst);</span>
<span class="line" id="L182">        } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L183">            <span class="tok-kw">error</span>.OutOfMemory =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory,</span>
<span class="line" id="L184">            <span class="tok-kw">error</span>.AnalysisFail =&gt; {}, <span class="tok-comment">// Handled via compile_errors below.</span>
</span>
<span class="line" id="L185">        }</span>
<span class="line" id="L186">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L187">        <span class="tok-kw">try</span> lowerAstErrors(&amp;astgen);</span>
<span class="line" id="L188">    }</span>
<span class="line" id="L189"></span>
<span class="line" id="L190">    <span class="tok-kw">const</span> err_index = <span class="tok-builtin">@intFromEnum</span>(Zir.ExtraIndex.compile_errors);</span>
<span class="line" id="L191">    <span class="tok-kw">if</span> (astgen.compile_errors.items.len == <span class="tok-number">0</span>) {</span>
<span class="line" id="L192">        astgen.extra.items[err_index] = <span class="tok-number">0</span>;</span>
<span class="line" id="L193">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L194">        <span class="tok-kw">try</span> astgen.extra.ensureUnusedCapacity(gpa, <span class="tok-number">1</span> + astgen.compile_errors.items.len *</span>
<span class="line" id="L195">            <span class="tok-builtin">@typeInfo</span>(Zir.Inst.CompileErrors.Item).Struct.fields.len);</span>
<span class="line" id="L196"></span>
<span class="line" id="L197">        astgen.extra.items[err_index] = astgen.addExtraAssumeCapacity(Zir.Inst.CompileErrors{</span>
<span class="line" id="L198">            .items_len = <span class="tok-builtin">@intCast</span>(astgen.compile_errors.items.len),</span>
<span class="line" id="L199">        });</span>
<span class="line" id="L200"></span>
<span class="line" id="L201">        <span class="tok-kw">for</span> (astgen.compile_errors.items) |item| {</span>
<span class="line" id="L202">            _ = astgen.addExtraAssumeCapacity(item);</span>
<span class="line" id="L203">        }</span>
<span class="line" id="L204">    }</span>
<span class="line" id="L205"></span>
<span class="line" id="L206">    <span class="tok-kw">const</span> imports_index = <span class="tok-builtin">@intFromEnum</span>(Zir.ExtraIndex.imports);</span>
<span class="line" id="L207">    <span class="tok-kw">if</span> (astgen.imports.count() == <span class="tok-number">0</span>) {</span>
<span class="line" id="L208">        astgen.extra.items[imports_index] = <span class="tok-number">0</span>;</span>
<span class="line" id="L209">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L210">        <span class="tok-kw">try</span> astgen.extra.ensureUnusedCapacity(gpa, <span class="tok-builtin">@typeInfo</span>(Zir.Inst.Imports).Struct.fields.len +</span>
<span class="line" id="L211">            astgen.imports.count() * <span class="tok-builtin">@typeInfo</span>(Zir.Inst.Imports.Item).Struct.fields.len);</span>
<span class="line" id="L212"></span>
<span class="line" id="L213">        astgen.extra.items[imports_index] = astgen.addExtraAssumeCapacity(Zir.Inst.Imports{</span>
<span class="line" id="L214">            .imports_len = <span class="tok-builtin">@intCast</span>(astgen.imports.count()),</span>
<span class="line" id="L215">        });</span>
<span class="line" id="L216"></span>
<span class="line" id="L217">        <span class="tok-kw">var</span> it = astgen.imports.iterator();</span>
<span class="line" id="L218">        <span class="tok-kw">while</span> (it.next()) |entry| {</span>
<span class="line" id="L219">            _ = astgen.addExtraAssumeCapacity(Zir.Inst.Imports.Item{</span>
<span class="line" id="L220">                .name = entry.key_ptr.*,</span>
<span class="line" id="L221">                .token = entry.value_ptr.*,</span>
<span class="line" id="L222">            });</span>
<span class="line" id="L223">        }</span>
<span class="line" id="L224">    }</span>
<span class="line" id="L225"></span>
<span class="line" id="L226">    <span class="tok-kw">return</span> Zir{</span>
<span class="line" id="L227">        .instructions = astgen.instructions.toOwnedSlice(),</span>
<span class="line" id="L228">        .string_bytes = <span class="tok-kw">try</span> astgen.string_bytes.toOwnedSlice(gpa),</span>
<span class="line" id="L229">        .extra = <span class="tok-kw">try</span> astgen.extra.toOwnedSlice(gpa),</span>
<span class="line" id="L230">    };</span>
<span class="line" id="L231">}</span>
<span class="line" id="L232"></span>
<span class="line" id="L233"><span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(astgen: *AstGen, gpa: Allocator) <span class="tok-type">void</span> {</span>
<span class="line" id="L234">    astgen.instructions.deinit(gpa);</span>
<span class="line" id="L235">    astgen.extra.deinit(gpa);</span>
<span class="line" id="L236">    astgen.string_table.deinit(gpa);</span>
<span class="line" id="L237">    astgen.string_bytes.deinit(gpa);</span>
<span class="line" id="L238">    astgen.compile_errors.deinit(gpa);</span>
<span class="line" id="L239">    astgen.imports.deinit(gpa);</span>
<span class="line" id="L240">    astgen.scratch.deinit(gpa);</span>
<span class="line" id="L241">    astgen.ref_table.deinit(gpa);</span>
<span class="line" id="L242">}</span>
<span class="line" id="L243"></span>
<span class="line" id="L244"><span class="tok-kw">const</span> ResultInfo = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L245">    <span class="tok-comment">/// The semantics requested for the result location</span></span>
<span class="line" id="L246">    rl: Loc,</span>
<span class="line" id="L247"></span>
<span class="line" id="L248">    <span class="tok-comment">/// The &quot;operator&quot; consuming the result location</span></span>
<span class="line" id="L249">    ctx: Context = .none,</span>
<span class="line" id="L250"></span>
<span class="line" id="L251">    <span class="tok-comment">/// Turns a `coerced_ty` back into a `ty`. Should be called at branch points</span></span>
<span class="line" id="L252">    <span class="tok-comment">/// such as if and switch expressions.</span></span>
<span class="line" id="L253">    <span class="tok-kw">fn</span> <span class="tok-fn">br</span>(ri: ResultInfo) ResultInfo {</span>
<span class="line" id="L254">        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (ri.rl) {</span>
<span class="line" id="L255">            .coerced_ty =&gt; |ty| .{</span>
<span class="line" id="L256">                .rl = .{ .ty = ty },</span>
<span class="line" id="L257">                .ctx = ri.ctx,</span>
<span class="line" id="L258">            },</span>
<span class="line" id="L259">            <span class="tok-kw">else</span> =&gt; ri,</span>
<span class="line" id="L260">        };</span>
<span class="line" id="L261">    }</span>
<span class="line" id="L262"></span>
<span class="line" id="L263">    <span class="tok-kw">fn</span> <span class="tok-fn">zirTag</span>(ri: ResultInfo) Zir.Inst.Tag {</span>
<span class="line" id="L264">        <span class="tok-kw">switch</span> (ri.rl) {</span>
<span class="line" id="L265">            .ty =&gt; <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (ri.ctx) {</span>
<span class="line" id="L266">                .shift_op =&gt; .as_shift_operand,</span>
<span class="line" id="L267">                <span class="tok-kw">else</span> =&gt; .as_node,</span>
<span class="line" id="L268">            },</span>
<span class="line" id="L269">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L270">        }</span>
<span class="line" id="L271">    }</span>
<span class="line" id="L272"></span>
<span class="line" id="L273">    <span class="tok-kw">const</span> Loc = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {</span>
<span class="line" id="L274">        <span class="tok-comment">/// The expression is the right-hand side of assignment to `_`. Only the side-effects of the</span></span>
<span class="line" id="L275">        <span class="tok-comment">/// expression should be generated. The result instruction from the expression must</span></span>
<span class="line" id="L276">        <span class="tok-comment">/// be ignored.</span></span>
<span class="line" id="L277">        discard,</span>
<span class="line" id="L278">        <span class="tok-comment">/// The expression has an inferred type, and it will be evaluated as an rvalue.</span></span>
<span class="line" id="L279">        none,</span>
<span class="line" id="L280">        <span class="tok-comment">/// The expression will be coerced into this type, but it will be evaluated as an rvalue.</span></span>
<span class="line" id="L281">        ty: Zir.Inst.Ref,</span>
<span class="line" id="L282">        <span class="tok-comment">/// Same as `ty` but it is guaranteed that Sema will additionally perform the coercion,</span></span>
<span class="line" id="L283">        <span class="tok-comment">/// so no `as` instruction needs to be emitted.</span></span>
<span class="line" id="L284">        coerced_ty: Zir.Inst.Ref,</span>
<span class="line" id="L285">        <span class="tok-comment">/// The expression must generate a pointer rather than a value. For example, the left hand side</span></span>
<span class="line" id="L286">        <span class="tok-comment">/// of an assignment uses this kind of result location.</span></span>
<span class="line" id="L287">        ref,</span>
<span class="line" id="L288">        <span class="tok-comment">/// The expression must generate a pointer rather than a value, and the pointer will be coerced</span></span>
<span class="line" id="L289">        <span class="tok-comment">/// by other code to this type, which is guaranteed by earlier instructions to be a pointer type.</span></span>
<span class="line" id="L290">        ref_coerced_ty: Zir.Inst.Ref,</span>
<span class="line" id="L291">        <span class="tok-comment">/// The expression must store its result into this typed pointer. The result instruction</span></span>
<span class="line" id="L292">        <span class="tok-comment">/// from the expression must be ignored.</span></span>
<span class="line" id="L293">        ptr: PtrResultLoc,</span>
<span class="line" id="L294">        <span class="tok-comment">/// The expression must store its result into this allocation, which has an inferred type.</span></span>
<span class="line" id="L295">        <span class="tok-comment">/// The result instruction from the expression must be ignored.</span></span>
<span class="line" id="L296">        <span class="tok-comment">/// Always an instruction with tag `alloc_inferred`.</span></span>
<span class="line" id="L297">        inferred_ptr: Zir.Inst.Ref,</span>
<span class="line" id="L298">        <span class="tok-comment">/// The expression has a sequence of pointers to store its results into due to a destructure</span></span>
<span class="line" id="L299">        <span class="tok-comment">/// operation. Each of these pointers may or may not have an inferred type.</span></span>
<span class="line" id="L300">        destructure: <span class="tok-kw">struct</span> {</span>
<span class="line" id="L301">            <span class="tok-comment">/// The AST node of the destructure operation itself.</span></span>
<span class="line" id="L302">            src_node: Ast.Node.Index,</span>
<span class="line" id="L303">            <span class="tok-comment">/// The pointers to store results into.</span></span>
<span class="line" id="L304">            components: []<span class="tok-kw">const</span> DestructureComponent,</span>
<span class="line" id="L305">        },</span>
<span class="line" id="L306"></span>
<span class="line" id="L307">        <span class="tok-kw">const</span> DestructureComponent = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {</span>
<span class="line" id="L308">            typed_ptr: PtrResultLoc,</span>
<span class="line" id="L309">            inferred_ptr: Zir.Inst.Ref,</span>
<span class="line" id="L310">            discard,</span>
<span class="line" id="L311">        };</span>
<span class="line" id="L312"></span>
<span class="line" id="L313">        <span class="tok-kw">const</span> PtrResultLoc = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L314">            inst: Zir.Inst.Ref,</span>
<span class="line" id="L315">            src_node: ?Ast.Node.Index = <span class="tok-null">null</span>,</span>
<span class="line" id="L316">        };</span>
<span class="line" id="L317"></span>
<span class="line" id="L318">        <span class="tok-comment">/// Find the result type for a cast builtin given the result location.</span></span>
<span class="line" id="L319">        <span class="tok-comment">/// If the location does not have a known result type, emits an error on</span></span>
<span class="line" id="L320">        <span class="tok-comment">/// the given node.</span></span>
<span class="line" id="L321">        <span class="tok-kw">fn</span> <span class="tok-fn">resultType</span>(rl: Loc, gz: *GenZir, node: Ast.Node.Index) !?Zir.Inst.Ref {</span>
<span class="line" id="L322">            <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (rl) {</span>
<span class="line" id="L323">                .discard, .none, .ref, .inferred_ptr, .destructure =&gt; <span class="tok-null">null</span>,</span>
<span class="line" id="L324">                .ty, .coerced_ty =&gt; |ty_ref| ty_ref,</span>
<span class="line" id="L325">                .ref_coerced_ty =&gt; |ptr_ty| <span class="tok-kw">try</span> gz.addUnNode(.elem_type, ptr_ty, node),</span>
<span class="line" id="L326">                .ptr =&gt; |ptr| {</span>
<span class="line" id="L327">                    <span class="tok-kw">const</span> ptr_ty = <span class="tok-kw">try</span> gz.addUnNode(.typeof, ptr.inst, node);</span>
<span class="line" id="L328">                    <span class="tok-kw">return</span> <span class="tok-kw">try</span> gz.addUnNode(.elem_type, ptr_ty, node);</span>
<span class="line" id="L329">                },</span>
<span class="line" id="L330">            };</span>
<span class="line" id="L331">        }</span>
<span class="line" id="L332"></span>
<span class="line" id="L333">        <span class="tok-kw">fn</span> <span class="tok-fn">resultTypeForCast</span>(rl: Loc, gz: *GenZir, node: Ast.Node.Index, builtin_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !Zir.Inst.Ref {</span>
<span class="line" id="L334">            <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L335">            <span class="tok-kw">if</span> (<span class="tok-kw">try</span> rl.resultType(gz, node)) |ty| <span class="tok-kw">return</span> ty;</span>
<span class="line" id="L336">            <span class="tok-kw">switch</span> (rl) {</span>
<span class="line" id="L337">                .destructure =&gt; |destructure| <span class="tok-kw">return</span> astgen.failNodeNotes(node, <span class="tok-str">&quot;{s} must have a known result type&quot;</span>, .{builtin_name}, &amp;.{</span>
<span class="line" id="L338">                    <span class="tok-kw">try</span> astgen.errNoteNode(destructure.src_node, <span class="tok-str">&quot;destructure expressions do not provide a single result type&quot;</span>, .{}),</span>
<span class="line" id="L339">                    <span class="tok-kw">try</span> astgen.errNoteNode(node, <span class="tok-str">&quot;use @as to provide explicit result type&quot;</span>, .{}),</span>
<span class="line" id="L340">                }),</span>
<span class="line" id="L341">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> astgen.failNodeNotes(node, <span class="tok-str">&quot;{s} must have a known result type&quot;</span>, .{builtin_name}, &amp;.{</span>
<span class="line" id="L342">                    <span class="tok-kw">try</span> astgen.errNoteNode(node, <span class="tok-str">&quot;use @as to provide explicit result type&quot;</span>, .{}),</span>
<span class="line" id="L343">                }),</span>
<span class="line" id="L344">            }</span>
<span class="line" id="L345">        }</span>
<span class="line" id="L346">    };</span>
<span class="line" id="L347"></span>
<span class="line" id="L348">    <span class="tok-kw">const</span> Context = <span class="tok-kw">enum</span> {</span>
<span class="line" id="L349">        <span class="tok-comment">/// The expression is the operand to a return expression.</span></span>
<span class="line" id="L350">        @&quot;return&quot;,</span>
<span class="line" id="L351">        <span class="tok-comment">/// The expression is the input to an error-handling operator (if-else, try, or catch).</span></span>
<span class="line" id="L352">        error_handling_expr,</span>
<span class="line" id="L353">        <span class="tok-comment">/// The expression is the right-hand side of a shift operation.</span></span>
<span class="line" id="L354">        shift_op,</span>
<span class="line" id="L355">        <span class="tok-comment">/// The expression is an argument in a function call.</span></span>
<span class="line" id="L356">        fn_arg,</span>
<span class="line" id="L357">        <span class="tok-comment">/// The expression is the right-hand side of an initializer for a `const` variable</span></span>
<span class="line" id="L358">        const_init,</span>
<span class="line" id="L359">        <span class="tok-comment">/// The expression is the right-hand side of an assignment expression.</span></span>
<span class="line" id="L360">        assignment,</span>
<span class="line" id="L361">        <span class="tok-comment">/// No specific operator in particular.</span></span>
<span class="line" id="L362">        none,</span>
<span class="line" id="L363">    };</span>
<span class="line" id="L364">};</span>
<span class="line" id="L365"></span>
<span class="line" id="L366"><span class="tok-kw">const</span> coerced_align_ri: ResultInfo = .{ .rl = .{ .coerced_ty = .u29_type } };</span>
<span class="line" id="L367"><span class="tok-kw">const</span> coerced_addrspace_ri: ResultInfo = .{ .rl = .{ .coerced_ty = .address_space_type } };</span>
<span class="line" id="L368"><span class="tok-kw">const</span> coerced_linksection_ri: ResultInfo = .{ .rl = .{ .coerced_ty = .slice_const_u8_type } };</span>
<span class="line" id="L369"><span class="tok-kw">const</span> coerced_type_ri: ResultInfo = .{ .rl = .{ .coerced_ty = .type_type } };</span>
<span class="line" id="L370"><span class="tok-kw">const</span> coerced_bool_ri: ResultInfo = .{ .rl = .{ .coerced_ty = .bool_type } };</span>
<span class="line" id="L371"></span>
<span class="line" id="L372"><span class="tok-kw">fn</span> <span class="tok-fn">typeExpr</span>(gz: *GenZir, scope: *Scope, type_node: Ast.Node.Index) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L373">    <span class="tok-kw">return</span> comptimeExpr(gz, scope, coerced_type_ri, type_node);</span>
<span class="line" id="L374">}</span>
<span class="line" id="L375"></span>
<span class="line" id="L376"><span class="tok-kw">fn</span> <span class="tok-fn">reachableTypeExpr</span>(</span>
<span class="line" id="L377">    gz: *GenZir,</span>
<span class="line" id="L378">    scope: *Scope,</span>
<span class="line" id="L379">    type_node: Ast.Node.Index,</span>
<span class="line" id="L380">    reachable_node: Ast.Node.Index,</span>
<span class="line" id="L381">) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L382">    <span class="tok-kw">return</span> reachableExprComptime(gz, scope, coerced_type_ri, type_node, reachable_node, <span class="tok-null">true</span>);</span>
<span class="line" id="L383">}</span>
<span class="line" id="L384"></span>
<span class="line" id="L385"><span class="tok-comment">/// Same as `expr` but fails with a compile error if the result type is `noreturn`.</span></span>
<span class="line" id="L386"><span class="tok-kw">fn</span> <span class="tok-fn">reachableExpr</span>(</span>
<span class="line" id="L387">    gz: *GenZir,</span>
<span class="line" id="L388">    scope: *Scope,</span>
<span class="line" id="L389">    ri: ResultInfo,</span>
<span class="line" id="L390">    node: Ast.Node.Index,</span>
<span class="line" id="L391">    reachable_node: Ast.Node.Index,</span>
<span class="line" id="L392">) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L393">    <span class="tok-kw">return</span> reachableExprComptime(gz, scope, ri, node, reachable_node, <span class="tok-null">false</span>);</span>
<span class="line" id="L394">}</span>
<span class="line" id="L395"></span>
<span class="line" id="L396"><span class="tok-kw">fn</span> <span class="tok-fn">reachableExprComptime</span>(</span>
<span class="line" id="L397">    gz: *GenZir,</span>
<span class="line" id="L398">    scope: *Scope,</span>
<span class="line" id="L399">    ri: ResultInfo,</span>
<span class="line" id="L400">    node: Ast.Node.Index,</span>
<span class="line" id="L401">    reachable_node: Ast.Node.Index,</span>
<span class="line" id="L402">    force_comptime: <span class="tok-type">bool</span>,</span>
<span class="line" id="L403">) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L404">    <span class="tok-kw">const</span> result_inst = <span class="tok-kw">if</span> (force_comptime)</span>
<span class="line" id="L405">        <span class="tok-kw">try</span> comptimeExpr(gz, scope, ri, node)</span>
<span class="line" id="L406">    <span class="tok-kw">else</span></span>
<span class="line" id="L407">        <span class="tok-kw">try</span> expr(gz, scope, ri, node);</span>
<span class="line" id="L408"></span>
<span class="line" id="L409">    <span class="tok-kw">if</span> (gz.refIsNoReturn(result_inst)) {</span>
<span class="line" id="L410">        <span class="tok-kw">try</span> gz.astgen.appendErrorNodeNotes(reachable_node, <span class="tok-str">&quot;unreachable code&quot;</span>, .{}, &amp;[_]<span class="tok-type">u32</span>{</span>
<span class="line" id="L411">            <span class="tok-kw">try</span> gz.astgen.errNoteNode(node, <span class="tok-str">&quot;control flow is diverted here&quot;</span>, .{}),</span>
<span class="line" id="L412">        });</span>
<span class="line" id="L413">    }</span>
<span class="line" id="L414">    <span class="tok-kw">return</span> result_inst;</span>
<span class="line" id="L415">}</span>
<span class="line" id="L416"></span>
<span class="line" id="L417"><span class="tok-kw">fn</span> <span class="tok-fn">lvalExpr</span>(gz: *GenZir, scope: *Scope, node: Ast.Node.Index) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L418">    <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L419">    <span class="tok-kw">const</span> tree = astgen.tree;</span>
<span class="line" id="L420">    <span class="tok-kw">const</span> node_tags = tree.nodes.items(.tag);</span>
<span class="line" id="L421">    <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);</span>
<span class="line" id="L422">    <span class="tok-kw">switch</span> (node_tags[node]) {</span>
<span class="line" id="L423">        .root =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L424">        .@&quot;usingnamespace&quot; =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L425">        .test_decl =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L426">        .global_var_decl =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L427">        .local_var_decl =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L428">        .simple_var_decl =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L429">        .aligned_var_decl =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L430">        .switch_case =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L431">        .switch_case_inline =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L432">        .switch_case_one =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L433">        .switch_case_inline_one =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L434">        .container_field_init =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L435">        .container_field_align =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L436">        .container_field =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L437">        .asm_output =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L438">        .asm_input =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L439"></span>
<span class="line" id="L440">        .assign,</span>
<span class="line" id="L441">        .assign_destructure,</span>
<span class="line" id="L442">        .assign_bit_and,</span>
<span class="line" id="L443">        .assign_bit_or,</span>
<span class="line" id="L444">        .assign_shl,</span>
<span class="line" id="L445">        .assign_shl_sat,</span>
<span class="line" id="L446">        .assign_shr,</span>
<span class="line" id="L447">        .assign_bit_xor,</span>
<span class="line" id="L448">        .assign_div,</span>
<span class="line" id="L449">        .assign_sub,</span>
<span class="line" id="L450">        .assign_sub_wrap,</span>
<span class="line" id="L451">        .assign_sub_sat,</span>
<span class="line" id="L452">        .assign_mod,</span>
<span class="line" id="L453">        .assign_add,</span>
<span class="line" id="L454">        .assign_add_wrap,</span>
<span class="line" id="L455">        .assign_add_sat,</span>
<span class="line" id="L456">        .assign_mul,</span>
<span class="line" id="L457">        .assign_mul_wrap,</span>
<span class="line" id="L458">        .assign_mul_sat,</span>
<span class="line" id="L459">        .add,</span>
<span class="line" id="L460">        .add_wrap,</span>
<span class="line" id="L461">        .add_sat,</span>
<span class="line" id="L462">        .sub,</span>
<span class="line" id="L463">        .sub_wrap,</span>
<span class="line" id="L464">        .sub_sat,</span>
<span class="line" id="L465">        .mul,</span>
<span class="line" id="L466">        .mul_wrap,</span>
<span class="line" id="L467">        .mul_sat,</span>
<span class="line" id="L468">        .div,</span>
<span class="line" id="L469">        .mod,</span>
<span class="line" id="L470">        .bit_and,</span>
<span class="line" id="L471">        .bit_or,</span>
<span class="line" id="L472">        .shl,</span>
<span class="line" id="L473">        .shl_sat,</span>
<span class="line" id="L474">        .shr,</span>
<span class="line" id="L475">        .bit_xor,</span>
<span class="line" id="L476">        .bang_equal,</span>
<span class="line" id="L477">        .equal_equal,</span>
<span class="line" id="L478">        .greater_than,</span>
<span class="line" id="L479">        .greater_or_equal,</span>
<span class="line" id="L480">        .less_than,</span>
<span class="line" id="L481">        .less_or_equal,</span>
<span class="line" id="L482">        .array_cat,</span>
<span class="line" id="L483">        .array_mult,</span>
<span class="line" id="L484">        .bool_and,</span>
<span class="line" id="L485">        .bool_or,</span>
<span class="line" id="L486">        .@&quot;asm&quot;,</span>
<span class="line" id="L487">        .asm_simple,</span>
<span class="line" id="L488">        .string_literal,</span>
<span class="line" id="L489">        .number_literal,</span>
<span class="line" id="L490">        .call,</span>
<span class="line" id="L491">        .call_comma,</span>
<span class="line" id="L492">        .async_call,</span>
<span class="line" id="L493">        .async_call_comma,</span>
<span class="line" id="L494">        .call_one,</span>
<span class="line" id="L495">        .call_one_comma,</span>
<span class="line" id="L496">        .async_call_one,</span>
<span class="line" id="L497">        .async_call_one_comma,</span>
<span class="line" id="L498">        .unreachable_literal,</span>
<span class="line" id="L499">        .@&quot;return&quot;,</span>
<span class="line" id="L500">        .@&quot;if&quot;,</span>
<span class="line" id="L501">        .if_simple,</span>
<span class="line" id="L502">        .@&quot;while&quot;,</span>
<span class="line" id="L503">        .while_simple,</span>
<span class="line" id="L504">        .while_cont,</span>
<span class="line" id="L505">        .bool_not,</span>
<span class="line" id="L506">        .address_of,</span>
<span class="line" id="L507">        .optional_type,</span>
<span class="line" id="L508">        .block,</span>
<span class="line" id="L509">        .block_semicolon,</span>
<span class="line" id="L510">        .block_two,</span>
<span class="line" id="L511">        .block_two_semicolon,</span>
<span class="line" id="L512">        .@&quot;break&quot;,</span>
<span class="line" id="L513">        .ptr_type_aligned,</span>
<span class="line" id="L514">        .ptr_type_sentinel,</span>
<span class="line" id="L515">        .ptr_type,</span>
<span class="line" id="L516">        .ptr_type_bit_range,</span>
<span class="line" id="L517">        .array_type,</span>
<span class="line" id="L518">        .array_type_sentinel,</span>
<span class="line" id="L519">        .enum_literal,</span>
<span class="line" id="L520">        .multiline_string_literal,</span>
<span class="line" id="L521">        .char_literal,</span>
<span class="line" id="L522">        .@&quot;defer&quot;,</span>
<span class="line" id="L523">        .@&quot;errdefer&quot;,</span>
<span class="line" id="L524">        .@&quot;catch&quot;,</span>
<span class="line" id="L525">        .error_union,</span>
<span class="line" id="L526">        .merge_error_sets,</span>
<span class="line" id="L527">        .switch_range,</span>
<span class="line" id="L528">        .for_range,</span>
<span class="line" id="L529">        .@&quot;await&quot;,</span>
<span class="line" id="L530">        .bit_not,</span>
<span class="line" id="L531">        .negation,</span>
<span class="line" id="L532">        .negation_wrap,</span>
<span class="line" id="L533">        .@&quot;resume&quot;,</span>
<span class="line" id="L534">        .@&quot;try&quot;,</span>
<span class="line" id="L535">        .slice,</span>
<span class="line" id="L536">        .slice_open,</span>
<span class="line" id="L537">        .slice_sentinel,</span>
<span class="line" id="L538">        .array_init_one,</span>
<span class="line" id="L539">        .array_init_one_comma,</span>
<span class="line" id="L540">        .array_init_dot_two,</span>
<span class="line" id="L541">        .array_init_dot_two_comma,</span>
<span class="line" id="L542">        .array_init_dot,</span>
<span class="line" id="L543">        .array_init_dot_comma,</span>
<span class="line" id="L544">        .array_init,</span>
<span class="line" id="L545">        .array_init_comma,</span>
<span class="line" id="L546">        .struct_init_one,</span>
<span class="line" id="L547">        .struct_init_one_comma,</span>
<span class="line" id="L548">        .struct_init_dot_two,</span>
<span class="line" id="L549">        .struct_init_dot_two_comma,</span>
<span class="line" id="L550">        .struct_init_dot,</span>
<span class="line" id="L551">        .struct_init_dot_comma,</span>
<span class="line" id="L552">        .struct_init,</span>
<span class="line" id="L553">        .struct_init_comma,</span>
<span class="line" id="L554">        .@&quot;switch&quot;,</span>
<span class="line" id="L555">        .switch_comma,</span>
<span class="line" id="L556">        .@&quot;for&quot;,</span>
<span class="line" id="L557">        .for_simple,</span>
<span class="line" id="L558">        .@&quot;suspend&quot;,</span>
<span class="line" id="L559">        .@&quot;continue&quot;,</span>
<span class="line" id="L560">        .fn_proto_simple,</span>
<span class="line" id="L561">        .fn_proto_multi,</span>
<span class="line" id="L562">        .fn_proto_one,</span>
<span class="line" id="L563">        .fn_proto,</span>
<span class="line" id="L564">        .fn_decl,</span>
<span class="line" id="L565">        .anyframe_type,</span>
<span class="line" id="L566">        .anyframe_literal,</span>
<span class="line" id="L567">        .error_set_decl,</span>
<span class="line" id="L568">        .container_decl,</span>
<span class="line" id="L569">        .container_decl_trailing,</span>
<span class="line" id="L570">        .container_decl_two,</span>
<span class="line" id="L571">        .container_decl_two_trailing,</span>
<span class="line" id="L572">        .container_decl_arg,</span>
<span class="line" id="L573">        .container_decl_arg_trailing,</span>
<span class="line" id="L574">        .tagged_union,</span>
<span class="line" id="L575">        .tagged_union_trailing,</span>
<span class="line" id="L576">        .tagged_union_two,</span>
<span class="line" id="L577">        .tagged_union_two_trailing,</span>
<span class="line" id="L578">        .tagged_union_enum_tag,</span>
<span class="line" id="L579">        .tagged_union_enum_tag_trailing,</span>
<span class="line" id="L580">        .@&quot;comptime&quot;,</span>
<span class="line" id="L581">        .@&quot;nosuspend&quot;,</span>
<span class="line" id="L582">        .error_value,</span>
<span class="line" id="L583">        =&gt; <span class="tok-kw">return</span> astgen.failNode(node, <span class="tok-str">&quot;invalid left-hand side to assignment&quot;</span>, .{}),</span>
<span class="line" id="L584"></span>
<span class="line" id="L585">        .builtin_call,</span>
<span class="line" id="L586">        .builtin_call_comma,</span>
<span class="line" id="L587">        .builtin_call_two,</span>
<span class="line" id="L588">        .builtin_call_two_comma,</span>
<span class="line" id="L589">        =&gt; {</span>
<span class="line" id="L590">            <span class="tok-kw">const</span> builtin_token = main_tokens[node];</span>
<span class="line" id="L591">            <span class="tok-kw">const</span> builtin_name = tree.tokenSlice(builtin_token);</span>
<span class="line" id="L592">            <span class="tok-comment">// If the builtin is an invalid name, we don't cause an error here; instead</span>
</span>
<span class="line" id="L593">            <span class="tok-comment">// let it pass, and the error will be &quot;invalid builtin function&quot; later.</span>
</span>
<span class="line" id="L594">            <span class="tok-kw">if</span> (BuiltinFn.list.get(builtin_name)) |info| {</span>
<span class="line" id="L595">                <span class="tok-kw">if</span> (!info.allows_lvalue) {</span>
<span class="line" id="L596">                    <span class="tok-kw">return</span> astgen.failNode(node, <span class="tok-str">&quot;invalid left-hand side to assignment&quot;</span>, .{});</span>
<span class="line" id="L597">                }</span>
<span class="line" id="L598">            }</span>
<span class="line" id="L599">        },</span>
<span class="line" id="L600"></span>
<span class="line" id="L601">        <span class="tok-comment">// These can be assigned to.</span>
</span>
<span class="line" id="L602">        .unwrap_optional,</span>
<span class="line" id="L603">        .deref,</span>
<span class="line" id="L604">        .field_access,</span>
<span class="line" id="L605">        .array_access,</span>
<span class="line" id="L606">        .identifier,</span>
<span class="line" id="L607">        .grouped_expression,</span>
<span class="line" id="L608">        .@&quot;orelse&quot;,</span>
<span class="line" id="L609">        =&gt; {},</span>
<span class="line" id="L610">    }</span>
<span class="line" id="L611">    <span class="tok-kw">return</span> expr(gz, scope, .{ .rl = .ref }, node);</span>
<span class="line" id="L612">}</span>
<span class="line" id="L613"></span>
<span class="line" id="L614"><span class="tok-comment">/// Turn Zig AST into untyped ZIR instructions.</span></span>
<span class="line" id="L615"><span class="tok-comment">/// When `rl` is discard, ptr, inferred_ptr, or inferred_ptr, the</span></span>
<span class="line" id="L616"><span class="tok-comment">/// result instruction can be used to inspect whether it is isNoReturn() but that is it,</span></span>
<span class="line" id="L617"><span class="tok-comment">/// it must otherwise not be used.</span></span>
<span class="line" id="L618"><span class="tok-kw">fn</span> <span class="tok-fn">expr</span>(gz: *GenZir, scope: *Scope, ri: ResultInfo, node: Ast.Node.Index) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L619">    <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L620">    <span class="tok-kw">const</span> tree = astgen.tree;</span>
<span class="line" id="L621">    <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);</span>
<span class="line" id="L622">    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);</span>
<span class="line" id="L623">    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);</span>
<span class="line" id="L624">    <span class="tok-kw">const</span> node_tags = tree.nodes.items(.tag);</span>
<span class="line" id="L625"></span>
<span class="line" id="L626">    <span class="tok-kw">const</span> prev_anon_name_strategy = gz.anon_name_strategy;</span>
<span class="line" id="L627">    <span class="tok-kw">defer</span> gz.anon_name_strategy = prev_anon_name_strategy;</span>
<span class="line" id="L628">    <span class="tok-kw">if</span> (!nodeUsesAnonNameStrategy(tree, node)) {</span>
<span class="line" id="L629">        gz.anon_name_strategy = .anon;</span>
<span class="line" id="L630">    }</span>
<span class="line" id="L631"></span>
<span class="line" id="L632">    <span class="tok-kw">switch</span> (node_tags[node]) {</span>
<span class="line" id="L633">        .root =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Top-level declaration.</span>
</span>
<span class="line" id="L634">        .@&quot;usingnamespace&quot; =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Top-level declaration.</span>
</span>
<span class="line" id="L635">        .test_decl =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Top-level declaration.</span>
</span>
<span class="line" id="L636">        .container_field_init =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Top-level declaration.</span>
</span>
<span class="line" id="L637">        .container_field_align =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Top-level declaration.</span>
</span>
<span class="line" id="L638">        .container_field =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Top-level declaration.</span>
</span>
<span class="line" id="L639">        .fn_decl =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Top-level declaration.</span>
</span>
<span class="line" id="L640"></span>
<span class="line" id="L641">        .global_var_decl =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Handled in `blockExpr`.</span>
</span>
<span class="line" id="L642">        .local_var_decl =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Handled in `blockExpr`.</span>
</span>
<span class="line" id="L643">        .simple_var_decl =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Handled in `blockExpr`.</span>
</span>
<span class="line" id="L644">        .aligned_var_decl =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Handled in `blockExpr`.</span>
</span>
<span class="line" id="L645">        .@&quot;defer&quot; =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Handled in `blockExpr`.</span>
</span>
<span class="line" id="L646">        .@&quot;errdefer&quot; =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Handled in `blockExpr`.</span>
</span>
<span class="line" id="L647"></span>
<span class="line" id="L648">        .switch_case =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Handled in `switchExpr`.</span>
</span>
<span class="line" id="L649">        .switch_case_inline =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Handled in `switchExpr`.</span>
</span>
<span class="line" id="L650">        .switch_case_one =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Handled in `switchExpr`.</span>
</span>
<span class="line" id="L651">        .switch_case_inline_one =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Handled in `switchExpr`.</span>
</span>
<span class="line" id="L652">        .switch_range =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Handled in `switchExpr`.</span>
</span>
<span class="line" id="L653"></span>
<span class="line" id="L654">        .asm_output =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Handled in `asmExpr`.</span>
</span>
<span class="line" id="L655">        .asm_input =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Handled in `asmExpr`.</span>
</span>
<span class="line" id="L656"></span>
<span class="line" id="L657">        .for_range =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Handled in `forExpr`.</span>
</span>
<span class="line" id="L658"></span>
<span class="line" id="L659">        .assign =&gt; {</span>
<span class="line" id="L660">            <span class="tok-kw">try</span> assign(gz, scope, node);</span>
<span class="line" id="L661">            <span class="tok-kw">return</span> rvalue(gz, ri, .void_value, node);</span>
<span class="line" id="L662">        },</span>
<span class="line" id="L663"></span>
<span class="line" id="L664">        .assign_destructure =&gt; {</span>
<span class="line" id="L665">            <span class="tok-comment">// Note that this variant does not declare any new var/const: that</span>
</span>
<span class="line" id="L666">            <span class="tok-comment">// variant is handled by `blockExprStmts`.</span>
</span>
<span class="line" id="L667">            <span class="tok-kw">try</span> assignDestructure(gz, scope, node);</span>
<span class="line" id="L668">            <span class="tok-kw">return</span> rvalue(gz, ri, .void_value, node);</span>
<span class="line" id="L669">        },</span>
<span class="line" id="L670"></span>
<span class="line" id="L671">        .assign_shl =&gt; {</span>
<span class="line" id="L672">            <span class="tok-kw">try</span> assignShift(gz, scope, node, .shl);</span>
<span class="line" id="L673">            <span class="tok-kw">return</span> rvalue(gz, ri, .void_value, node);</span>
<span class="line" id="L674">        },</span>
<span class="line" id="L675">        .assign_shl_sat =&gt; {</span>
<span class="line" id="L676">            <span class="tok-kw">try</span> assignShiftSat(gz, scope, node);</span>
<span class="line" id="L677">            <span class="tok-kw">return</span> rvalue(gz, ri, .void_value, node);</span>
<span class="line" id="L678">        },</span>
<span class="line" id="L679">        .assign_shr =&gt; {</span>
<span class="line" id="L680">            <span class="tok-kw">try</span> assignShift(gz, scope, node, .shr);</span>
<span class="line" id="L681">            <span class="tok-kw">return</span> rvalue(gz, ri, .void_value, node);</span>
<span class="line" id="L682">        },</span>
<span class="line" id="L683"></span>
<span class="line" id="L684">        .assign_bit_and =&gt; {</span>
<span class="line" id="L685">            <span class="tok-kw">try</span> assignOp(gz, scope, node, .bit_and);</span>
<span class="line" id="L686">            <span class="tok-kw">return</span> rvalue(gz, ri, .void_value, node);</span>
<span class="line" id="L687">        },</span>
<span class="line" id="L688">        .assign_bit_or =&gt; {</span>
<span class="line" id="L689">            <span class="tok-kw">try</span> assignOp(gz, scope, node, .bit_or);</span>
<span class="line" id="L690">            <span class="tok-kw">return</span> rvalue(gz, ri, .void_value, node);</span>
<span class="line" id="L691">        },</span>
<span class="line" id="L692">        .assign_bit_xor =&gt; {</span>
<span class="line" id="L693">            <span class="tok-kw">try</span> assignOp(gz, scope, node, .xor);</span>
<span class="line" id="L694">            <span class="tok-kw">return</span> rvalue(gz, ri, .void_value, node);</span>
<span class="line" id="L695">        },</span>
<span class="line" id="L696">        .assign_div =&gt; {</span>
<span class="line" id="L697">            <span class="tok-kw">try</span> assignOp(gz, scope, node, .div);</span>
<span class="line" id="L698">            <span class="tok-kw">return</span> rvalue(gz, ri, .void_value, node);</span>
<span class="line" id="L699">        },</span>
<span class="line" id="L700">        .assign_sub =&gt; {</span>
<span class="line" id="L701">            <span class="tok-kw">try</span> assignOp(gz, scope, node, .sub);</span>
<span class="line" id="L702">            <span class="tok-kw">return</span> rvalue(gz, ri, .void_value, node);</span>
<span class="line" id="L703">        },</span>
<span class="line" id="L704">        .assign_sub_wrap =&gt; {</span>
<span class="line" id="L705">            <span class="tok-kw">try</span> assignOp(gz, scope, node, .subwrap);</span>
<span class="line" id="L706">            <span class="tok-kw">return</span> rvalue(gz, ri, .void_value, node);</span>
<span class="line" id="L707">        },</span>
<span class="line" id="L708">        .assign_sub_sat =&gt; {</span>
<span class="line" id="L709">            <span class="tok-kw">try</span> assignOp(gz, scope, node, .sub_sat);</span>
<span class="line" id="L710">            <span class="tok-kw">return</span> rvalue(gz, ri, .void_value, node);</span>
<span class="line" id="L711">        },</span>
<span class="line" id="L712">        .assign_mod =&gt; {</span>
<span class="line" id="L713">            <span class="tok-kw">try</span> assignOp(gz, scope, node, .mod_rem);</span>
<span class="line" id="L714">            <span class="tok-kw">return</span> rvalue(gz, ri, .void_value, node);</span>
<span class="line" id="L715">        },</span>
<span class="line" id="L716">        .assign_add =&gt; {</span>
<span class="line" id="L717">            <span class="tok-kw">try</span> assignOp(gz, scope, node, .add);</span>
<span class="line" id="L718">            <span class="tok-kw">return</span> rvalue(gz, ri, .void_value, node);</span>
<span class="line" id="L719">        },</span>
<span class="line" id="L720">        .assign_add_wrap =&gt; {</span>
<span class="line" id="L721">            <span class="tok-kw">try</span> assignOp(gz, scope, node, .addwrap);</span>
<span class="line" id="L722">            <span class="tok-kw">return</span> rvalue(gz, ri, .void_value, node);</span>
<span class="line" id="L723">        },</span>
<span class="line" id="L724">        .assign_add_sat =&gt; {</span>
<span class="line" id="L725">            <span class="tok-kw">try</span> assignOp(gz, scope, node, .add_sat);</span>
<span class="line" id="L726">            <span class="tok-kw">return</span> rvalue(gz, ri, .void_value, node);</span>
<span class="line" id="L727">        },</span>
<span class="line" id="L728">        .assign_mul =&gt; {</span>
<span class="line" id="L729">            <span class="tok-kw">try</span> assignOp(gz, scope, node, .mul);</span>
<span class="line" id="L730">            <span class="tok-kw">return</span> rvalue(gz, ri, .void_value, node);</span>
<span class="line" id="L731">        },</span>
<span class="line" id="L732">        .assign_mul_wrap =&gt; {</span>
<span class="line" id="L733">            <span class="tok-kw">try</span> assignOp(gz, scope, node, .mulwrap);</span>
<span class="line" id="L734">            <span class="tok-kw">return</span> rvalue(gz, ri, .void_value, node);</span>
<span class="line" id="L735">        },</span>
<span class="line" id="L736">        .assign_mul_sat =&gt; {</span>
<span class="line" id="L737">            <span class="tok-kw">try</span> assignOp(gz, scope, node, .mul_sat);</span>
<span class="line" id="L738">            <span class="tok-kw">return</span> rvalue(gz, ri, .void_value, node);</span>
<span class="line" id="L739">        },</span>
<span class="line" id="L740"></span>
<span class="line" id="L741">        <span class="tok-comment">// zig fmt: off</span>
</span>
<span class="line" id="L742">        .shl =&gt; <span class="tok-kw">return</span> shiftOp(gz, scope, ri, node, node_datas[node].lhs, node_datas[node].rhs, .shl),</span>
<span class="line" id="L743">        .shr =&gt; <span class="tok-kw">return</span> shiftOp(gz, scope, ri, node, node_datas[node].lhs, node_datas[node].rhs, .shr),</span>
<span class="line" id="L744"></span>
<span class="line" id="L745">        .add      =&gt; <span class="tok-kw">return</span> simpleBinOp(gz, scope, ri, node, .add),</span>
<span class="line" id="L746">        .add_wrap =&gt; <span class="tok-kw">return</span> simpleBinOp(gz, scope, ri, node, .addwrap),</span>
<span class="line" id="L747">        .add_sat  =&gt; <span class="tok-kw">return</span> simpleBinOp(gz, scope, ri, node, .add_sat),</span>
<span class="line" id="L748">        .sub      =&gt; <span class="tok-kw">return</span> simpleBinOp(gz, scope, ri, node, .sub),</span>
<span class="line" id="L749">        .sub_wrap =&gt; <span class="tok-kw">return</span> simpleBinOp(gz, scope, ri, node, .subwrap),</span>
<span class="line" id="L750">        .sub_sat  =&gt; <span class="tok-kw">return</span> simpleBinOp(gz, scope, ri, node, .sub_sat),</span>
<span class="line" id="L751">        .mul      =&gt; <span class="tok-kw">return</span> simpleBinOp(gz, scope, ri, node, .mul),</span>
<span class="line" id="L752">        .mul_wrap =&gt; <span class="tok-kw">return</span> simpleBinOp(gz, scope, ri, node, .mulwrap),</span>
<span class="line" id="L753">        .mul_sat  =&gt; <span class="tok-kw">return</span> simpleBinOp(gz, scope, ri, node, .mul_sat),</span>
<span class="line" id="L754">        .div      =&gt; <span class="tok-kw">return</span> simpleBinOp(gz, scope, ri, node, .div),</span>
<span class="line" id="L755">        .mod      =&gt; <span class="tok-kw">return</span> simpleBinOp(gz, scope, ri, node, .mod_rem),</span>
<span class="line" id="L756">        .shl_sat  =&gt; <span class="tok-kw">return</span> simpleBinOp(gz, scope, ri, node, .shl_sat),</span>
<span class="line" id="L757"></span>
<span class="line" id="L758">        .bit_and          =&gt; <span class="tok-kw">return</span> simpleBinOp(gz, scope, ri, node, .bit_and),</span>
<span class="line" id="L759">        .bit_or           =&gt; <span class="tok-kw">return</span> simpleBinOp(gz, scope, ri, node, .bit_or),</span>
<span class="line" id="L760">        .bit_xor          =&gt; <span class="tok-kw">return</span> simpleBinOp(gz, scope, ri, node, .xor),</span>
<span class="line" id="L761">        .bang_equal       =&gt; <span class="tok-kw">return</span> simpleBinOp(gz, scope, ri, node, .cmp_neq),</span>
<span class="line" id="L762">        .equal_equal      =&gt; <span class="tok-kw">return</span> simpleBinOp(gz, scope, ri, node, .cmp_eq),</span>
<span class="line" id="L763">        .greater_than     =&gt; <span class="tok-kw">return</span> simpleBinOp(gz, scope, ri, node, .cmp_gt),</span>
<span class="line" id="L764">        .greater_or_equal =&gt; <span class="tok-kw">return</span> simpleBinOp(gz, scope, ri, node, .cmp_gte),</span>
<span class="line" id="L765">        .less_than        =&gt; <span class="tok-kw">return</span> simpleBinOp(gz, scope, ri, node, .cmp_lt),</span>
<span class="line" id="L766">        .less_or_equal    =&gt; <span class="tok-kw">return</span> simpleBinOp(gz, scope, ri, node, .cmp_lte),</span>
<span class="line" id="L767">        .array_cat        =&gt; <span class="tok-kw">return</span> simpleBinOp(gz, scope, ri, node, .array_cat),</span>
<span class="line" id="L768"></span>
<span class="line" id="L769">        .array_mult =&gt; {</span>
<span class="line" id="L770">            <span class="tok-comment">// This syntax form does not currently use the result type in the language specification.</span>
</span>
<span class="line" id="L771">            <span class="tok-comment">// However, the result type can be used to emit more optimal code for large multiplications by</span>
</span>
<span class="line" id="L772">            <span class="tok-comment">// having Sema perform a coercion before the multiplication operation.</span>
</span>
<span class="line" id="L773">            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addPlNode(.array_mul, node, Zir.Inst.ArrayMul{</span>
<span class="line" id="L774">                .res_ty = <span class="tok-kw">if</span> (<span class="tok-kw">try</span> ri.rl.resultType(gz, node)) |t| t <span class="tok-kw">else</span> .none,</span>
<span class="line" id="L775">                .lhs = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .none }, node_datas[node].lhs),</span>
<span class="line" id="L776">                .rhs = <span class="tok-kw">try</span> comptimeExpr(gz, scope, .{ .rl = .{ .coerced_ty = .usize_type } }, node_datas[node].rhs),</span>
<span class="line" id="L777">            });</span>
<span class="line" id="L778">            <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L779">        },</span>
<span class="line" id="L780"></span>
<span class="line" id="L781">        .error_union      =&gt; <span class="tok-kw">return</span> simpleBinOp(gz, scope, ri, node, .error_union_type),</span>
<span class="line" id="L782">        .merge_error_sets =&gt; <span class="tok-kw">return</span> simpleBinOp(gz, scope, ri, node, .merge_error_sets),</span>
<span class="line" id="L783"></span>
<span class="line" id="L784">        .bool_and =&gt; <span class="tok-kw">return</span> boolBinOp(gz, scope, ri, node, .bool_br_and),</span>
<span class="line" id="L785">        .bool_or  =&gt; <span class="tok-kw">return</span> boolBinOp(gz, scope, ri, node, .bool_br_or),</span>
<span class="line" id="L786"></span>
<span class="line" id="L787">        .bool_not =&gt; <span class="tok-kw">return</span> simpleUnOp(gz, scope, ri, node, coerced_bool_ri, node_datas[node].lhs, .bool_not),</span>
<span class="line" id="L788">        .bit_not  =&gt; <span class="tok-kw">return</span> simpleUnOp(gz, scope, ri, node, .{ .rl = .none }, node_datas[node].lhs, .bit_not),</span>
<span class="line" id="L789"></span>
<span class="line" id="L790">        .negation      =&gt; <span class="tok-kw">return</span>   negation(gz, scope, ri, node),</span>
<span class="line" id="L791">        .negation_wrap =&gt; <span class="tok-kw">return</span> simpleUnOp(gz, scope, ri, node, .{ .rl = .none }, node_datas[node].lhs, .negate_wrap),</span>
<span class="line" id="L792"></span>
<span class="line" id="L793">        .identifier =&gt; <span class="tok-kw">return</span> identifier(gz, scope, ri, node),</span>
<span class="line" id="L794"></span>
<span class="line" id="L795">        .asm_simple,</span>
<span class="line" id="L796">        .@&quot;asm&quot;,</span>
<span class="line" id="L797">        =&gt; <span class="tok-kw">return</span> asmExpr(gz, scope, ri, node, tree.fullAsm(node).?),</span>
<span class="line" id="L798"></span>
<span class="line" id="L799">        .string_literal           =&gt; <span class="tok-kw">return</span> stringLiteral(gz, ri, node),</span>
<span class="line" id="L800">        .multiline_string_literal =&gt; <span class="tok-kw">return</span> multilineStringLiteral(gz, ri, node),</span>
<span class="line" id="L801"></span>
<span class="line" id="L802">        .number_literal =&gt; <span class="tok-kw">return</span> numberLiteral(gz, ri, node, node, .positive),</span>
<span class="line" id="L803">        <span class="tok-comment">// zig fmt: on</span>
</span>
<span class="line" id="L804"></span>
<span class="line" id="L805">        .builtin_call_two, .builtin_call_two_comma =&gt; {</span>
<span class="line" id="L806">            <span class="tok-kw">if</span> (node_datas[node].lhs == <span class="tok-number">0</span>) {</span>
<span class="line" id="L807">                <span class="tok-kw">const</span> params = [_]Ast.Node.Index{};</span>
<span class="line" id="L808">                <span class="tok-kw">return</span> builtinCall(gz, scope, ri, node, &amp;params);</span>
<span class="line" id="L809">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (node_datas[node].rhs == <span class="tok-number">0</span>) {</span>
<span class="line" id="L810">                <span class="tok-kw">const</span> params = [_]Ast.Node.Index{node_datas[node].lhs};</span>
<span class="line" id="L811">                <span class="tok-kw">return</span> builtinCall(gz, scope, ri, node, &amp;params);</span>
<span class="line" id="L812">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L813">                <span class="tok-kw">const</span> params = [_]Ast.Node.Index{ node_datas[node].lhs, node_datas[node].rhs };</span>
<span class="line" id="L814">                <span class="tok-kw">return</span> builtinCall(gz, scope, ri, node, &amp;params);</span>
<span class="line" id="L815">            }</span>
<span class="line" id="L816">        },</span>
<span class="line" id="L817">        .builtin_call, .builtin_call_comma =&gt; {</span>
<span class="line" id="L818">            <span class="tok-kw">const</span> params = tree.extra_data[node_datas[node].lhs..node_datas[node].rhs];</span>
<span class="line" id="L819">            <span class="tok-kw">return</span> builtinCall(gz, scope, ri, node, params);</span>
<span class="line" id="L820">        },</span>
<span class="line" id="L821"></span>
<span class="line" id="L822">        .call_one,</span>
<span class="line" id="L823">        .call_one_comma,</span>
<span class="line" id="L824">        .async_call_one,</span>
<span class="line" id="L825">        .async_call_one_comma,</span>
<span class="line" id="L826">        .call,</span>
<span class="line" id="L827">        .call_comma,</span>
<span class="line" id="L828">        .async_call,</span>
<span class="line" id="L829">        .async_call_comma,</span>
<span class="line" id="L830">        =&gt; {</span>
<span class="line" id="L831">            <span class="tok-kw">var</span> buf: [<span class="tok-number">1</span>]Ast.Node.Index = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L832">            <span class="tok-kw">return</span> callExpr(gz, scope, ri, node, tree.fullCall(&amp;buf, node).?);</span>
<span class="line" id="L833">        },</span>
<span class="line" id="L834"></span>
<span class="line" id="L835">        .unreachable_literal =&gt; {</span>
<span class="line" id="L836">            <span class="tok-kw">try</span> emitDbgNode(gz, node);</span>
<span class="line" id="L837">            _ = <span class="tok-kw">try</span> gz.addAsIndex(.{</span>
<span class="line" id="L838">                .tag = .@&quot;unreachable&quot;,</span>
<span class="line" id="L839">                .data = .{ .@&quot;unreachable&quot; = .{</span>
<span class="line" id="L840">                    .src_node = gz.nodeIndexToRelative(node),</span>
<span class="line" id="L841">                } },</span>
<span class="line" id="L842">            });</span>
<span class="line" id="L843">            <span class="tok-kw">return</span> Zir.Inst.Ref.unreachable_value;</span>
<span class="line" id="L844">        },</span>
<span class="line" id="L845">        .@&quot;return&quot; =&gt; <span class="tok-kw">return</span> ret(gz, scope, node),</span>
<span class="line" id="L846">        .field_access =&gt; <span class="tok-kw">return</span> fieldAccess(gz, scope, ri, node),</span>
<span class="line" id="L847"></span>
<span class="line" id="L848">        .if_simple,</span>
<span class="line" id="L849">        .@&quot;if&quot;,</span>
<span class="line" id="L850">        =&gt; {</span>
<span class="line" id="L851">            <span class="tok-kw">const</span> if_full = tree.fullIf(node).?;</span>
<span class="line" id="L852">            no_switch_on_err: {</span>
<span class="line" id="L853">                <span class="tok-kw">const</span> error_token = if_full.error_token <span class="tok-kw">orelse</span> <span class="tok-kw">break</span> :no_switch_on_err;</span>
<span class="line" id="L854">                <span class="tok-kw">switch</span> (node_tags[if_full.ast.else_expr]) {</span>
<span class="line" id="L855">                    .@&quot;switch&quot;, .switch_comma =&gt; {},</span>
<span class="line" id="L856">                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">break</span> :no_switch_on_err,</span>
<span class="line" id="L857">                }</span>
<span class="line" id="L858">                <span class="tok-kw">const</span> switch_operand = node_datas[if_full.ast.else_expr].lhs;</span>
<span class="line" id="L859">                <span class="tok-kw">if</span> (node_tags[switch_operand] != .identifier) <span class="tok-kw">break</span> :no_switch_on_err;</span>
<span class="line" id="L860">                <span class="tok-kw">if</span> (!mem.eql(<span class="tok-type">u8</span>, tree.tokenSlice(error_token), tree.tokenSlice(main_tokens[switch_operand]))) <span class="tok-kw">break</span> :no_switch_on_err;</span>
<span class="line" id="L861">                <span class="tok-kw">return</span> switchExprErrUnion(gz, scope, ri.br(), node, .@&quot;if&quot;);</span>
<span class="line" id="L862">            }</span>
<span class="line" id="L863">            <span class="tok-kw">return</span> ifExpr(gz, scope, ri.br(), node, if_full);</span>
<span class="line" id="L864">        },</span>
<span class="line" id="L865"></span>
<span class="line" id="L866">        .while_simple,</span>
<span class="line" id="L867">        .while_cont,</span>
<span class="line" id="L868">        .@&quot;while&quot;,</span>
<span class="line" id="L869">        =&gt; <span class="tok-kw">return</span> whileExpr(gz, scope, ri.br(), node, tree.fullWhile(node).?, <span class="tok-null">false</span>),</span>
<span class="line" id="L870"></span>
<span class="line" id="L871">        .for_simple, .@&quot;for&quot; =&gt; <span class="tok-kw">return</span> forExpr(gz, scope, ri.br(), node, tree.fullFor(node).?, <span class="tok-null">false</span>),</span>
<span class="line" id="L872"></span>
<span class="line" id="L873">        .slice_open =&gt; {</span>
<span class="line" id="L874">            <span class="tok-kw">const</span> lhs = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .ref }, node_datas[node].lhs);</span>
<span class="line" id="L875"></span>
<span class="line" id="L876">            <span class="tok-kw">const</span> cursor = maybeAdvanceSourceCursorToMainToken(gz, node);</span>
<span class="line" id="L877">            <span class="tok-kw">const</span> start = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .{ .coerced_ty = .usize_type } }, node_datas[node].rhs);</span>
<span class="line" id="L878">            <span class="tok-kw">try</span> emitDbgStmt(gz, cursor);</span>
<span class="line" id="L879">            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addPlNode(.slice_start, node, Zir.Inst.SliceStart{</span>
<span class="line" id="L880">                .lhs = lhs,</span>
<span class="line" id="L881">                .start = start,</span>
<span class="line" id="L882">            });</span>
<span class="line" id="L883">            <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L884">        },</span>
<span class="line" id="L885">        .slice =&gt; {</span>
<span class="line" id="L886">            <span class="tok-kw">const</span> extra = tree.extraData(node_datas[node].rhs, Ast.Node.Slice);</span>
<span class="line" id="L887">            <span class="tok-kw">const</span> lhs_node = node_datas[node].lhs;</span>
<span class="line" id="L888">            <span class="tok-kw">const</span> lhs_tag = node_tags[lhs_node];</span>
<span class="line" id="L889">            <span class="tok-kw">const</span> lhs_is_slice_sentinel = lhs_tag == .slice_sentinel;</span>
<span class="line" id="L890">            <span class="tok-kw">const</span> lhs_is_open_slice = lhs_tag == .slice_open <span class="tok-kw">or</span></span>
<span class="line" id="L891">                (lhs_is_slice_sentinel <span class="tok-kw">and</span> tree.extraData(node_datas[lhs_node].rhs, Ast.Node.SliceSentinel).end == <span class="tok-number">0</span>);</span>
<span class="line" id="L892">            <span class="tok-kw">if</span> (lhs_is_open_slice <span class="tok-kw">and</span> nodeIsTriviallyZero(tree, extra.start)) {</span>
<span class="line" id="L893">                <span class="tok-kw">const</span> lhs = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .ref }, node_datas[lhs_node].lhs);</span>
<span class="line" id="L894"></span>
<span class="line" id="L895">                <span class="tok-kw">const</span> start = <span class="tok-kw">if</span> (lhs_is_slice_sentinel) start: {</span>
<span class="line" id="L896">                    <span class="tok-kw">const</span> lhs_extra = tree.extraData(node_datas[lhs_node].rhs, Ast.Node.SliceSentinel);</span>
<span class="line" id="L897">                    <span class="tok-kw">break</span> :start <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .{ .coerced_ty = .usize_type } }, lhs_extra.start);</span>
<span class="line" id="L898">                } <span class="tok-kw">else</span> <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .{ .coerced_ty = .usize_type } }, node_datas[lhs_node].rhs);</span>
<span class="line" id="L899"></span>
<span class="line" id="L900">                <span class="tok-kw">const</span> cursor = maybeAdvanceSourceCursorToMainToken(gz, node);</span>
<span class="line" id="L901">                <span class="tok-kw">const</span> len = <span class="tok-kw">if</span> (extra.end != <span class="tok-number">0</span>) <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .{ .coerced_ty = .usize_type } }, extra.end) <span class="tok-kw">else</span> .none;</span>
<span class="line" id="L902">                <span class="tok-kw">try</span> emitDbgStmt(gz, cursor);</span>
<span class="line" id="L903">                <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addPlNode(.slice_length, node, Zir.Inst.SliceLength{</span>
<span class="line" id="L904">                    .lhs = lhs,</span>
<span class="line" id="L905">                    .start = start,</span>
<span class="line" id="L906">                    .len = len,</span>
<span class="line" id="L907">                    .start_src_node_offset = gz.nodeIndexToRelative(lhs_node),</span>
<span class="line" id="L908">                    .sentinel = .none,</span>
<span class="line" id="L909">                });</span>
<span class="line" id="L910">                <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L911">            }</span>
<span class="line" id="L912">            <span class="tok-kw">const</span> lhs = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .ref }, node_datas[node].lhs);</span>
<span class="line" id="L913"></span>
<span class="line" id="L914">            <span class="tok-kw">const</span> cursor = maybeAdvanceSourceCursorToMainToken(gz, node);</span>
<span class="line" id="L915">            <span class="tok-kw">const</span> start = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .{ .coerced_ty = .usize_type } }, extra.start);</span>
<span class="line" id="L916">            <span class="tok-kw">const</span> end = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .{ .coerced_ty = .usize_type } }, extra.end);</span>
<span class="line" id="L917">            <span class="tok-kw">try</span> emitDbgStmt(gz, cursor);</span>
<span class="line" id="L918">            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addPlNode(.slice_end, node, Zir.Inst.SliceEnd{</span>
<span class="line" id="L919">                .lhs = lhs,</span>
<span class="line" id="L920">                .start = start,</span>
<span class="line" id="L921">                .end = end,</span>
<span class="line" id="L922">            });</span>
<span class="line" id="L923">            <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L924">        },</span>
<span class="line" id="L925">        .slice_sentinel =&gt; {</span>
<span class="line" id="L926">            <span class="tok-kw">const</span> extra = tree.extraData(node_datas[node].rhs, Ast.Node.SliceSentinel);</span>
<span class="line" id="L927">            <span class="tok-kw">const</span> lhs_node = node_datas[node].lhs;</span>
<span class="line" id="L928">            <span class="tok-kw">const</span> lhs_tag = node_tags[lhs_node];</span>
<span class="line" id="L929">            <span class="tok-kw">const</span> lhs_is_slice_sentinel = lhs_tag == .slice_sentinel;</span>
<span class="line" id="L930">            <span class="tok-kw">const</span> lhs_is_open_slice = lhs_tag == .slice_open <span class="tok-kw">or</span></span>
<span class="line" id="L931">                (lhs_is_slice_sentinel <span class="tok-kw">and</span> tree.extraData(node_datas[lhs_node].rhs, Ast.Node.SliceSentinel).end == <span class="tok-number">0</span>);</span>
<span class="line" id="L932">            <span class="tok-kw">if</span> (lhs_is_open_slice <span class="tok-kw">and</span> nodeIsTriviallyZero(tree, extra.start)) {</span>
<span class="line" id="L933">                <span class="tok-kw">const</span> lhs = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .ref }, node_datas[lhs_node].lhs);</span>
<span class="line" id="L934"></span>
<span class="line" id="L935">                <span class="tok-kw">const</span> start = <span class="tok-kw">if</span> (lhs_is_slice_sentinel) start: {</span>
<span class="line" id="L936">                    <span class="tok-kw">const</span> lhs_extra = tree.extraData(node_datas[lhs_node].rhs, Ast.Node.SliceSentinel);</span>
<span class="line" id="L937">                    <span class="tok-kw">break</span> :start <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .{ .coerced_ty = .usize_type } }, lhs_extra.start);</span>
<span class="line" id="L938">                } <span class="tok-kw">else</span> <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .{ .coerced_ty = .usize_type } }, node_datas[lhs_node].rhs);</span>
<span class="line" id="L939"></span>
<span class="line" id="L940">                <span class="tok-kw">const</span> cursor = maybeAdvanceSourceCursorToMainToken(gz, node);</span>
<span class="line" id="L941">                <span class="tok-kw">const</span> len = <span class="tok-kw">if</span> (extra.end != <span class="tok-number">0</span>) <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .{ .coerced_ty = .usize_type } }, extra.end) <span class="tok-kw">else</span> .none;</span>
<span class="line" id="L942">                <span class="tok-kw">const</span> sentinel = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .none }, extra.sentinel);</span>
<span class="line" id="L943">                <span class="tok-kw">try</span> emitDbgStmt(gz, cursor);</span>
<span class="line" id="L944">                <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addPlNode(.slice_length, node, Zir.Inst.SliceLength{</span>
<span class="line" id="L945">                    .lhs = lhs,</span>
<span class="line" id="L946">                    .start = start,</span>
<span class="line" id="L947">                    .len = len,</span>
<span class="line" id="L948">                    .start_src_node_offset = gz.nodeIndexToRelative(lhs_node),</span>
<span class="line" id="L949">                    .sentinel = sentinel,</span>
<span class="line" id="L950">                });</span>
<span class="line" id="L951">                <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L952">            }</span>
<span class="line" id="L953">            <span class="tok-kw">const</span> lhs = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .ref }, node_datas[node].lhs);</span>
<span class="line" id="L954"></span>
<span class="line" id="L955">            <span class="tok-kw">const</span> cursor = maybeAdvanceSourceCursorToMainToken(gz, node);</span>
<span class="line" id="L956">            <span class="tok-kw">const</span> start = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .{ .coerced_ty = .usize_type } }, extra.start);</span>
<span class="line" id="L957">            <span class="tok-kw">const</span> end = <span class="tok-kw">if</span> (extra.end != <span class="tok-number">0</span>) <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .{ .coerced_ty = .usize_type } }, extra.end) <span class="tok-kw">else</span> .none;</span>
<span class="line" id="L958">            <span class="tok-kw">const</span> sentinel = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .none }, extra.sentinel);</span>
<span class="line" id="L959">            <span class="tok-kw">try</span> emitDbgStmt(gz, cursor);</span>
<span class="line" id="L960">            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addPlNode(.slice_sentinel, node, Zir.Inst.SliceSentinel{</span>
<span class="line" id="L961">                .lhs = lhs,</span>
<span class="line" id="L962">                .start = start,</span>
<span class="line" id="L963">                .end = end,</span>
<span class="line" id="L964">                .sentinel = sentinel,</span>
<span class="line" id="L965">            });</span>
<span class="line" id="L966">            <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L967">        },</span>
<span class="line" id="L968"></span>
<span class="line" id="L969">        .deref =&gt; {</span>
<span class="line" id="L970">            <span class="tok-kw">const</span> lhs = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .none }, node_datas[node].lhs);</span>
<span class="line" id="L971">            _ = <span class="tok-kw">try</span> gz.addUnNode(.validate_deref, lhs, node);</span>
<span class="line" id="L972">            <span class="tok-kw">switch</span> (ri.rl) {</span>
<span class="line" id="L973">                .ref, .ref_coerced_ty =&gt; <span class="tok-kw">return</span> lhs,</span>
<span class="line" id="L974">                <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L975">                    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addUnNode(.load, lhs, node);</span>
<span class="line" id="L976">                    <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L977">                },</span>
<span class="line" id="L978">            }</span>
<span class="line" id="L979">        },</span>
<span class="line" id="L980">        .address_of =&gt; {</span>
<span class="line" id="L981">            <span class="tok-kw">const</span> operand_rl: ResultInfo.Loc = <span class="tok-kw">if</span> (<span class="tok-kw">try</span> ri.rl.resultType(gz, node)) |res_ty_inst| rl: {</span>
<span class="line" id="L982">                _ = <span class="tok-kw">try</span> gz.addUnTok(.validate_ref_ty, res_ty_inst, tree.firstToken(node));</span>
<span class="line" id="L983">                <span class="tok-kw">break</span> :rl .{ .ref_coerced_ty = res_ty_inst };</span>
<span class="line" id="L984">            } <span class="tok-kw">else</span> .ref;</span>
<span class="line" id="L985">            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = operand_rl }, node_datas[node].lhs);</span>
<span class="line" id="L986">            <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L987">        },</span>
<span class="line" id="L988">        .optional_type =&gt; {</span>
<span class="line" id="L989">            <span class="tok-kw">const</span> operand = <span class="tok-kw">try</span> typeExpr(gz, scope, node_datas[node].lhs);</span>
<span class="line" id="L990">            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addUnNode(.optional_type, operand, node);</span>
<span class="line" id="L991">            <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L992">        },</span>
<span class="line" id="L993">        .unwrap_optional =&gt; <span class="tok-kw">switch</span> (ri.rl) {</span>
<span class="line" id="L994">            .ref, .ref_coerced_ty =&gt; {</span>
<span class="line" id="L995">                <span class="tok-kw">const</span> lhs = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .ref }, node_datas[node].lhs);</span>
<span class="line" id="L996"></span>
<span class="line" id="L997">                <span class="tok-kw">const</span> cursor = maybeAdvanceSourceCursorToMainToken(gz, node);</span>
<span class="line" id="L998">                <span class="tok-kw">try</span> emitDbgStmt(gz, cursor);</span>
<span class="line" id="L999"></span>
<span class="line" id="L1000">                <span class="tok-kw">return</span> gz.addUnNode(.optional_payload_safe_ptr, lhs, node);</span>
<span class="line" id="L1001">            },</span>
<span class="line" id="L1002">            <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L1003">                <span class="tok-kw">const</span> lhs = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .none }, node_datas[node].lhs);</span>
<span class="line" id="L1004"></span>
<span class="line" id="L1005">                <span class="tok-kw">const</span> cursor = maybeAdvanceSourceCursorToMainToken(gz, node);</span>
<span class="line" id="L1006">                <span class="tok-kw">try</span> emitDbgStmt(gz, cursor);</span>
<span class="line" id="L1007"></span>
<span class="line" id="L1008">                <span class="tok-kw">return</span> rvalue(gz, ri, <span class="tok-kw">try</span> gz.addUnNode(.optional_payload_safe, lhs, node), node);</span>
<span class="line" id="L1009">            },</span>
<span class="line" id="L1010">        },</span>
<span class="line" id="L1011">        .block_two, .block_two_semicolon =&gt; {</span>
<span class="line" id="L1012">            <span class="tok-kw">const</span> statements = [<span class="tok-number">2</span>]Ast.Node.Index{ node_datas[node].lhs, node_datas[node].rhs };</span>
<span class="line" id="L1013">            <span class="tok-kw">if</span> (node_datas[node].lhs == <span class="tok-number">0</span>) {</span>
<span class="line" id="L1014">                <span class="tok-kw">return</span> blockExpr(gz, scope, ri, node, statements[<span class="tok-number">0</span>..<span class="tok-number">0</span>]);</span>
<span class="line" id="L1015">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (node_datas[node].rhs == <span class="tok-number">0</span>) {</span>
<span class="line" id="L1016">                <span class="tok-kw">return</span> blockExpr(gz, scope, ri, node, statements[<span class="tok-number">0</span>..<span class="tok-number">1</span>]);</span>
<span class="line" id="L1017">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1018">                <span class="tok-kw">return</span> blockExpr(gz, scope, ri, node, statements[<span class="tok-number">0</span>..<span class="tok-number">2</span>]);</span>
<span class="line" id="L1019">            }</span>
<span class="line" id="L1020">        },</span>
<span class="line" id="L1021">        .block, .block_semicolon =&gt; {</span>
<span class="line" id="L1022">            <span class="tok-kw">const</span> statements = tree.extra_data[node_datas[node].lhs..node_datas[node].rhs];</span>
<span class="line" id="L1023">            <span class="tok-kw">return</span> blockExpr(gz, scope, ri, node, statements);</span>
<span class="line" id="L1024">        },</span>
<span class="line" id="L1025">        .enum_literal =&gt; <span class="tok-kw">return</span> simpleStrTok(gz, ri, main_tokens[node], node, .enum_literal),</span>
<span class="line" id="L1026">        .error_value =&gt; <span class="tok-kw">return</span> simpleStrTok(gz, ri, node_datas[node].rhs, node, .error_value),</span>
<span class="line" id="L1027">        <span class="tok-comment">// TODO restore this when implementing https://github.com/ziglang/zig/issues/6025</span>
</span>
<span class="line" id="L1028">        <span class="tok-comment">// .anyframe_literal =&gt; return rvalue(gz, ri, .anyframe_type, node),</span>
</span>
<span class="line" id="L1029">        .anyframe_literal =&gt; {</span>
<span class="line" id="L1030">            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addUnNode(.anyframe_type, .void_type, node);</span>
<span class="line" id="L1031">            <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L1032">        },</span>
<span class="line" id="L1033">        .anyframe_type =&gt; {</span>
<span class="line" id="L1034">            <span class="tok-kw">const</span> return_type = <span class="tok-kw">try</span> typeExpr(gz, scope, node_datas[node].rhs);</span>
<span class="line" id="L1035">            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addUnNode(.anyframe_type, return_type, node);</span>
<span class="line" id="L1036">            <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L1037">        },</span>
<span class="line" id="L1038">        .@&quot;catch&quot; =&gt; {</span>
<span class="line" id="L1039">            <span class="tok-kw">const</span> catch_token = main_tokens[node];</span>
<span class="line" id="L1040">            <span class="tok-kw">const</span> payload_token: ?Ast.TokenIndex = <span class="tok-kw">if</span> (token_tags[catch_token + <span class="tok-number">1</span>] == .pipe)</span>
<span class="line" id="L1041">                catch_token + <span class="tok-number">2</span></span>
<span class="line" id="L1042">            <span class="tok-kw">else</span></span>
<span class="line" id="L1043">                <span class="tok-null">null</span>;</span>
<span class="line" id="L1044">            no_switch_on_err: {</span>
<span class="line" id="L1045">                <span class="tok-kw">const</span> capture_token = payload_token <span class="tok-kw">orelse</span> <span class="tok-kw">break</span> :no_switch_on_err;</span>
<span class="line" id="L1046">                <span class="tok-kw">switch</span> (node_tags[node_datas[node].rhs]) {</span>
<span class="line" id="L1047">                    .@&quot;switch&quot;, .switch_comma =&gt; {},</span>
<span class="line" id="L1048">                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">break</span> :no_switch_on_err,</span>
<span class="line" id="L1049">                }</span>
<span class="line" id="L1050">                <span class="tok-kw">const</span> switch_operand = node_datas[node_datas[node].rhs].lhs;</span>
<span class="line" id="L1051">                <span class="tok-kw">if</span> (node_tags[switch_operand] != .identifier) <span class="tok-kw">break</span> :no_switch_on_err;</span>
<span class="line" id="L1052">                <span class="tok-kw">if</span> (!mem.eql(<span class="tok-type">u8</span>, tree.tokenSlice(capture_token), tree.tokenSlice(main_tokens[switch_operand]))) <span class="tok-kw">break</span> :no_switch_on_err;</span>
<span class="line" id="L1053">                <span class="tok-kw">return</span> switchExprErrUnion(gz, scope, ri.br(), node, .@&quot;catch&quot;);</span>
<span class="line" id="L1054">            }</span>
<span class="line" id="L1055">            <span class="tok-kw">switch</span> (ri.rl) {</span>
<span class="line" id="L1056">                .ref, .ref_coerced_ty =&gt; <span class="tok-kw">return</span> orelseCatchExpr(</span>
<span class="line" id="L1057">                    gz,</span>
<span class="line" id="L1058">                    scope,</span>
<span class="line" id="L1059">                    ri,</span>
<span class="line" id="L1060">                    node,</span>
<span class="line" id="L1061">                    node_datas[node].lhs,</span>
<span class="line" id="L1062">                    .is_non_err_ptr,</span>
<span class="line" id="L1063">                    .err_union_payload_unsafe_ptr,</span>
<span class="line" id="L1064">                    .err_union_code_ptr,</span>
<span class="line" id="L1065">                    node_datas[node].rhs,</span>
<span class="line" id="L1066">                    payload_token,</span>
<span class="line" id="L1067">                ),</span>
<span class="line" id="L1068">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> orelseCatchExpr(</span>
<span class="line" id="L1069">                    gz,</span>
<span class="line" id="L1070">                    scope,</span>
<span class="line" id="L1071">                    ri,</span>
<span class="line" id="L1072">                    node,</span>
<span class="line" id="L1073">                    node_datas[node].lhs,</span>
<span class="line" id="L1074">                    .is_non_err,</span>
<span class="line" id="L1075">                    .err_union_payload_unsafe,</span>
<span class="line" id="L1076">                    .err_union_code,</span>
<span class="line" id="L1077">                    node_datas[node].rhs,</span>
<span class="line" id="L1078">                    payload_token,</span>
<span class="line" id="L1079">                ),</span>
<span class="line" id="L1080">            }</span>
<span class="line" id="L1081">        },</span>
<span class="line" id="L1082">        .@&quot;orelse&quot; =&gt; <span class="tok-kw">switch</span> (ri.rl) {</span>
<span class="line" id="L1083">            .ref, .ref_coerced_ty =&gt; <span class="tok-kw">return</span> orelseCatchExpr(</span>
<span class="line" id="L1084">                gz,</span>
<span class="line" id="L1085">                scope,</span>
<span class="line" id="L1086">                ri,</span>
<span class="line" id="L1087">                node,</span>
<span class="line" id="L1088">                node_datas[node].lhs,</span>
<span class="line" id="L1089">                .is_non_null_ptr,</span>
<span class="line" id="L1090">                .optional_payload_unsafe_ptr,</span>
<span class="line" id="L1091">                <span class="tok-null">undefined</span>,</span>
<span class="line" id="L1092">                node_datas[node].rhs,</span>
<span class="line" id="L1093">                <span class="tok-null">null</span>,</span>
<span class="line" id="L1094">            ),</span>
<span class="line" id="L1095">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> orelseCatchExpr(</span>
<span class="line" id="L1096">                gz,</span>
<span class="line" id="L1097">                scope,</span>
<span class="line" id="L1098">                ri,</span>
<span class="line" id="L1099">                node,</span>
<span class="line" id="L1100">                node_datas[node].lhs,</span>
<span class="line" id="L1101">                .is_non_null,</span>
<span class="line" id="L1102">                .optional_payload_unsafe,</span>
<span class="line" id="L1103">                <span class="tok-null">undefined</span>,</span>
<span class="line" id="L1104">                node_datas[node].rhs,</span>
<span class="line" id="L1105">                <span class="tok-null">null</span>,</span>
<span class="line" id="L1106">            ),</span>
<span class="line" id="L1107">        },</span>
<span class="line" id="L1108"></span>
<span class="line" id="L1109">        .ptr_type_aligned,</span>
<span class="line" id="L1110">        .ptr_type_sentinel,</span>
<span class="line" id="L1111">        .ptr_type,</span>
<span class="line" id="L1112">        .ptr_type_bit_range,</span>
<span class="line" id="L1113">        =&gt; <span class="tok-kw">return</span> ptrType(gz, scope, ri, node, tree.fullPtrType(node).?),</span>
<span class="line" id="L1114"></span>
<span class="line" id="L1115">        .container_decl,</span>
<span class="line" id="L1116">        .container_decl_trailing,</span>
<span class="line" id="L1117">        .container_decl_arg,</span>
<span class="line" id="L1118">        .container_decl_arg_trailing,</span>
<span class="line" id="L1119">        .container_decl_two,</span>
<span class="line" id="L1120">        .container_decl_two_trailing,</span>
<span class="line" id="L1121">        .tagged_union,</span>
<span class="line" id="L1122">        .tagged_union_trailing,</span>
<span class="line" id="L1123">        .tagged_union_enum_tag,</span>
<span class="line" id="L1124">        .tagged_union_enum_tag_trailing,</span>
<span class="line" id="L1125">        .tagged_union_two,</span>
<span class="line" id="L1126">        .tagged_union_two_trailing,</span>
<span class="line" id="L1127">        =&gt; {</span>
<span class="line" id="L1128">            <span class="tok-kw">var</span> buf: [<span class="tok-number">2</span>]Ast.Node.Index = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1129">            <span class="tok-kw">return</span> containerDecl(gz, scope, ri, node, tree.fullContainerDecl(&amp;buf, node).?);</span>
<span class="line" id="L1130">        },</span>
<span class="line" id="L1131"></span>
<span class="line" id="L1132">        .@&quot;break&quot; =&gt; <span class="tok-kw">return</span> breakExpr(gz, scope, node),</span>
<span class="line" id="L1133">        .@&quot;continue&quot; =&gt; <span class="tok-kw">return</span> continueExpr(gz, scope, node),</span>
<span class="line" id="L1134">        .grouped_expression =&gt; <span class="tok-kw">return</span> expr(gz, scope, ri, node_datas[node].lhs),</span>
<span class="line" id="L1135">        .array_type =&gt; <span class="tok-kw">return</span> arrayType(gz, scope, ri, node),</span>
<span class="line" id="L1136">        .array_type_sentinel =&gt; <span class="tok-kw">return</span> arrayTypeSentinel(gz, scope, ri, node),</span>
<span class="line" id="L1137">        .char_literal =&gt; <span class="tok-kw">return</span> charLiteral(gz, ri, node),</span>
<span class="line" id="L1138">        .error_set_decl =&gt; <span class="tok-kw">return</span> errorSetDecl(gz, ri, node),</span>
<span class="line" id="L1139">        .array_access =&gt; <span class="tok-kw">return</span> arrayAccess(gz, scope, ri, node),</span>
<span class="line" id="L1140">        .@&quot;comptime&quot; =&gt; <span class="tok-kw">return</span> comptimeExprAst(gz, scope, ri, node),</span>
<span class="line" id="L1141">        .@&quot;switch&quot;, .switch_comma =&gt; <span class="tok-kw">return</span> switchExpr(gz, scope, ri.br(), node),</span>
<span class="line" id="L1142"></span>
<span class="line" id="L1143">        .@&quot;nosuspend&quot; =&gt; <span class="tok-kw">return</span> nosuspendExpr(gz, scope, ri, node),</span>
<span class="line" id="L1144">        .@&quot;suspend&quot; =&gt; <span class="tok-kw">return</span> suspendExpr(gz, scope, node),</span>
<span class="line" id="L1145">        .@&quot;await&quot; =&gt; <span class="tok-kw">return</span> awaitExpr(gz, scope, ri, node),</span>
<span class="line" id="L1146">        .@&quot;resume&quot; =&gt; <span class="tok-kw">return</span> resumeExpr(gz, scope, ri, node),</span>
<span class="line" id="L1147"></span>
<span class="line" id="L1148">        .@&quot;try&quot; =&gt; <span class="tok-kw">return</span> tryExpr(gz, scope, ri, node, node_datas[node].lhs),</span>
<span class="line" id="L1149"></span>
<span class="line" id="L1150">        .array_init_one,</span>
<span class="line" id="L1151">        .array_init_one_comma,</span>
<span class="line" id="L1152">        .array_init_dot_two,</span>
<span class="line" id="L1153">        .array_init_dot_two_comma,</span>
<span class="line" id="L1154">        .array_init_dot,</span>
<span class="line" id="L1155">        .array_init_dot_comma,</span>
<span class="line" id="L1156">        .array_init,</span>
<span class="line" id="L1157">        .array_init_comma,</span>
<span class="line" id="L1158">        =&gt; {</span>
<span class="line" id="L1159">            <span class="tok-kw">var</span> buf: [<span class="tok-number">2</span>]Ast.Node.Index = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1160">            <span class="tok-kw">return</span> arrayInitExpr(gz, scope, ri, node, tree.fullArrayInit(&amp;buf, node).?);</span>
<span class="line" id="L1161">        },</span>
<span class="line" id="L1162"></span>
<span class="line" id="L1163">        .struct_init_one,</span>
<span class="line" id="L1164">        .struct_init_one_comma,</span>
<span class="line" id="L1165">        .struct_init_dot_two,</span>
<span class="line" id="L1166">        .struct_init_dot_two_comma,</span>
<span class="line" id="L1167">        .struct_init_dot,</span>
<span class="line" id="L1168">        .struct_init_dot_comma,</span>
<span class="line" id="L1169">        .struct_init,</span>
<span class="line" id="L1170">        .struct_init_comma,</span>
<span class="line" id="L1171">        =&gt; {</span>
<span class="line" id="L1172">            <span class="tok-kw">var</span> buf: [<span class="tok-number">2</span>]Ast.Node.Index = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1173">            <span class="tok-kw">return</span> structInitExpr(gz, scope, ri, node, tree.fullStructInit(&amp;buf, node).?);</span>
<span class="line" id="L1174">        },</span>
<span class="line" id="L1175"></span>
<span class="line" id="L1176">        .fn_proto_simple,</span>
<span class="line" id="L1177">        .fn_proto_multi,</span>
<span class="line" id="L1178">        .fn_proto_one,</span>
<span class="line" id="L1179">        .fn_proto,</span>
<span class="line" id="L1180">        =&gt; {</span>
<span class="line" id="L1181">            <span class="tok-kw">var</span> buf: [<span class="tok-number">1</span>]Ast.Node.Index = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1182">            <span class="tok-kw">return</span> fnProtoExpr(gz, scope, ri, node, tree.fullFnProto(&amp;buf, node).?);</span>
<span class="line" id="L1183">        },</span>
<span class="line" id="L1184">    }</span>
<span class="line" id="L1185">}</span>
<span class="line" id="L1186"></span>
<span class="line" id="L1187"><span class="tok-kw">fn</span> <span class="tok-fn">nosuspendExpr</span>(</span>
<span class="line" id="L1188">    gz: *GenZir,</span>
<span class="line" id="L1189">    scope: *Scope,</span>
<span class="line" id="L1190">    ri: ResultInfo,</span>
<span class="line" id="L1191">    node: Ast.Node.Index,</span>
<span class="line" id="L1192">) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L1193">    <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L1194">    <span class="tok-kw">const</span> tree = astgen.tree;</span>
<span class="line" id="L1195">    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);</span>
<span class="line" id="L1196">    <span class="tok-kw">const</span> body_node = node_datas[node].lhs;</span>
<span class="line" id="L1197">    assert(body_node != <span class="tok-number">0</span>);</span>
<span class="line" id="L1198">    <span class="tok-kw">if</span> (gz.nosuspend_node != <span class="tok-number">0</span>) {</span>
<span class="line" id="L1199">        <span class="tok-kw">try</span> astgen.appendErrorNodeNotes(node, <span class="tok-str">&quot;redundant nosuspend block&quot;</span>, .{}, &amp;[_]<span class="tok-type">u32</span>{</span>
<span class="line" id="L1200">            <span class="tok-kw">try</span> astgen.errNoteNode(gz.nosuspend_node, <span class="tok-str">&quot;other nosuspend block here&quot;</span>, .{}),</span>
<span class="line" id="L1201">        });</span>
<span class="line" id="L1202">    }</span>
<span class="line" id="L1203">    gz.nosuspend_node = node;</span>
<span class="line" id="L1204">    <span class="tok-kw">defer</span> gz.nosuspend_node = <span class="tok-number">0</span>;</span>
<span class="line" id="L1205">    <span class="tok-kw">return</span> expr(gz, scope, ri, body_node);</span>
<span class="line" id="L1206">}</span>
<span class="line" id="L1207"></span>
<span class="line" id="L1208"><span class="tok-kw">fn</span> <span class="tok-fn">suspendExpr</span>(</span>
<span class="line" id="L1209">    gz: *GenZir,</span>
<span class="line" id="L1210">    scope: *Scope,</span>
<span class="line" id="L1211">    node: Ast.Node.Index,</span>
<span class="line" id="L1212">) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L1213">    <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L1214">    <span class="tok-kw">const</span> gpa = astgen.gpa;</span>
<span class="line" id="L1215">    <span class="tok-kw">const</span> tree = astgen.tree;</span>
<span class="line" id="L1216">    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);</span>
<span class="line" id="L1217">    <span class="tok-kw">const</span> body_node = node_datas[node].lhs;</span>
<span class="line" id="L1218"></span>
<span class="line" id="L1219">    <span class="tok-kw">if</span> (gz.nosuspend_node != <span class="tok-number">0</span>) {</span>
<span class="line" id="L1220">        <span class="tok-kw">return</span> astgen.failNodeNotes(node, <span class="tok-str">&quot;suspend inside nosuspend block&quot;</span>, .{}, &amp;[_]<span class="tok-type">u32</span>{</span>
<span class="line" id="L1221">            <span class="tok-kw">try</span> astgen.errNoteNode(gz.nosuspend_node, <span class="tok-str">&quot;nosuspend block here&quot;</span>, .{}),</span>
<span class="line" id="L1222">        });</span>
<span class="line" id="L1223">    }</span>
<span class="line" id="L1224">    <span class="tok-kw">if</span> (gz.suspend_node != <span class="tok-number">0</span>) {</span>
<span class="line" id="L1225">        <span class="tok-kw">return</span> astgen.failNodeNotes(node, <span class="tok-str">&quot;cannot suspend inside suspend block&quot;</span>, .{}, &amp;[_]<span class="tok-type">u32</span>{</span>
<span class="line" id="L1226">            <span class="tok-kw">try</span> astgen.errNoteNode(gz.suspend_node, <span class="tok-str">&quot;other suspend block here&quot;</span>, .{}),</span>
<span class="line" id="L1227">        });</span>
<span class="line" id="L1228">    }</span>
<span class="line" id="L1229">    assert(body_node != <span class="tok-number">0</span>);</span>
<span class="line" id="L1230"></span>
<span class="line" id="L1231">    <span class="tok-kw">const</span> suspend_inst = <span class="tok-kw">try</span> gz.makeBlockInst(.suspend_block, node);</span>
<span class="line" id="L1232">    <span class="tok-kw">try</span> gz.instructions.append(gpa, suspend_inst);</span>
<span class="line" id="L1233"></span>
<span class="line" id="L1234">    <span class="tok-kw">var</span> suspend_scope = gz.makeSubBlock(scope);</span>
<span class="line" id="L1235">    suspend_scope.suspend_node = node;</span>
<span class="line" id="L1236">    <span class="tok-kw">defer</span> suspend_scope.unstack();</span>
<span class="line" id="L1237"></span>
<span class="line" id="L1238">    <span class="tok-kw">const</span> body_result = <span class="tok-kw">try</span> fullBodyExpr(&amp;suspend_scope, &amp;suspend_scope.base, .{ .rl = .none }, body_node);</span>
<span class="line" id="L1239">    <span class="tok-kw">if</span> (!gz.refIsNoReturn(body_result)) {</span>
<span class="line" id="L1240">        _ = <span class="tok-kw">try</span> suspend_scope.addBreak(.break_inline, suspend_inst, .void_value);</span>
<span class="line" id="L1241">    }</span>
<span class="line" id="L1242">    <span class="tok-kw">try</span> suspend_scope.setBlockBody(suspend_inst);</span>
<span class="line" id="L1243"></span>
<span class="line" id="L1244">    <span class="tok-kw">return</span> suspend_inst.toRef();</span>
<span class="line" id="L1245">}</span>
<span class="line" id="L1246"></span>
<span class="line" id="L1247"><span class="tok-kw">fn</span> <span class="tok-fn">awaitExpr</span>(</span>
<span class="line" id="L1248">    gz: *GenZir,</span>
<span class="line" id="L1249">    scope: *Scope,</span>
<span class="line" id="L1250">    ri: ResultInfo,</span>
<span class="line" id="L1251">    node: Ast.Node.Index,</span>
<span class="line" id="L1252">) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L1253">    <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L1254">    <span class="tok-kw">const</span> tree = astgen.tree;</span>
<span class="line" id="L1255">    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);</span>
<span class="line" id="L1256">    <span class="tok-kw">const</span> rhs_node = node_datas[node].lhs;</span>
<span class="line" id="L1257"></span>
<span class="line" id="L1258">    <span class="tok-kw">if</span> (gz.suspend_node != <span class="tok-number">0</span>) {</span>
<span class="line" id="L1259">        <span class="tok-kw">return</span> astgen.failNodeNotes(node, <span class="tok-str">&quot;cannot await inside suspend block&quot;</span>, .{}, &amp;[_]<span class="tok-type">u32</span>{</span>
<span class="line" id="L1260">            <span class="tok-kw">try</span> astgen.errNoteNode(gz.suspend_node, <span class="tok-str">&quot;suspend block here&quot;</span>, .{}),</span>
<span class="line" id="L1261">        });</span>
<span class="line" id="L1262">    }</span>
<span class="line" id="L1263">    <span class="tok-kw">const</span> operand = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .ref }, rhs_node);</span>
<span class="line" id="L1264">    <span class="tok-kw">const</span> result = <span class="tok-kw">if</span> (gz.nosuspend_node != <span class="tok-number">0</span>)</span>
<span class="line" id="L1265">        <span class="tok-kw">try</span> gz.addExtendedPayload(.await_nosuspend, Zir.Inst.UnNode{</span>
<span class="line" id="L1266">            .node = gz.nodeIndexToRelative(node),</span>
<span class="line" id="L1267">            .operand = operand,</span>
<span class="line" id="L1268">        })</span>
<span class="line" id="L1269">    <span class="tok-kw">else</span></span>
<span class="line" id="L1270">        <span class="tok-kw">try</span> gz.addUnNode(.@&quot;await&quot;, operand, node);</span>
<span class="line" id="L1271"></span>
<span class="line" id="L1272">    <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L1273">}</span>
<span class="line" id="L1274"></span>
<span class="line" id="L1275"><span class="tok-kw">fn</span> <span class="tok-fn">resumeExpr</span>(</span>
<span class="line" id="L1276">    gz: *GenZir,</span>
<span class="line" id="L1277">    scope: *Scope,</span>
<span class="line" id="L1278">    ri: ResultInfo,</span>
<span class="line" id="L1279">    node: Ast.Node.Index,</span>
<span class="line" id="L1280">) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L1281">    <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L1282">    <span class="tok-kw">const</span> tree = astgen.tree;</span>
<span class="line" id="L1283">    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);</span>
<span class="line" id="L1284">    <span class="tok-kw">const</span> rhs_node = node_datas[node].lhs;</span>
<span class="line" id="L1285">    <span class="tok-kw">const</span> operand = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .ref }, rhs_node);</span>
<span class="line" id="L1286">    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addUnNode(.@&quot;resume&quot;, operand, node);</span>
<span class="line" id="L1287">    <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L1288">}</span>
<span class="line" id="L1289"></span>
<span class="line" id="L1290"><span class="tok-kw">fn</span> <span class="tok-fn">fnProtoExpr</span>(</span>
<span class="line" id="L1291">    gz: *GenZir,</span>
<span class="line" id="L1292">    scope: *Scope,</span>
<span class="line" id="L1293">    ri: ResultInfo,</span>
<span class="line" id="L1294">    node: Ast.Node.Index,</span>
<span class="line" id="L1295">    fn_proto: Ast.full.FnProto,</span>
<span class="line" id="L1296">) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L1297">    <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L1298">    <span class="tok-kw">const</span> tree = astgen.tree;</span>
<span class="line" id="L1299">    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);</span>
<span class="line" id="L1300"></span>
<span class="line" id="L1301">    <span class="tok-kw">if</span> (fn_proto.name_token) |some| {</span>
<span class="line" id="L1302">        <span class="tok-kw">return</span> astgen.failTok(some, <span class="tok-str">&quot;function type cannot have a name&quot;</span>, .{});</span>
<span class="line" id="L1303">    }</span>
<span class="line" id="L1304"></span>
<span class="line" id="L1305">    <span class="tok-kw">const</span> is_extern = blk: {</span>
<span class="line" id="L1306">        <span class="tok-kw">const</span> maybe_extern_token = fn_proto.extern_export_inline_token <span class="tok-kw">orelse</span> <span class="tok-kw">break</span> :blk <span class="tok-null">false</span>;</span>
<span class="line" id="L1307">        <span class="tok-kw">break</span> :blk token_tags[maybe_extern_token] == .keyword_extern;</span>
<span class="line" id="L1308">    };</span>
<span class="line" id="L1309">    assert(!is_extern);</span>
<span class="line" id="L1310"></span>
<span class="line" id="L1311">    <span class="tok-kw">var</span> block_scope = gz.makeSubBlock(scope);</span>
<span class="line" id="L1312">    <span class="tok-kw">defer</span> block_scope.unstack();</span>
<span class="line" id="L1313"></span>
<span class="line" id="L1314">    <span class="tok-kw">const</span> block_inst = <span class="tok-kw">try</span> gz.makeBlockInst(.block_inline, node);</span>
<span class="line" id="L1315"></span>
<span class="line" id="L1316">    <span class="tok-kw">var</span> noalias_bits: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1317">    <span class="tok-kw">const</span> is_var_args = is_var_args: {</span>
<span class="line" id="L1318">        <span class="tok-kw">var</span> param_type_i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1319">        <span class="tok-kw">var</span> it = fn_proto.iterate(tree);</span>
<span class="line" id="L1320">        <span class="tok-kw">while</span> (it.next()) |param| : (param_type_i += <span class="tok-number">1</span>) {</span>
<span class="line" id="L1321">            <span class="tok-kw">const</span> is_comptime = <span class="tok-kw">if</span> (param.comptime_noalias) |token| <span class="tok-kw">switch</span> (token_tags[token]) {</span>
<span class="line" id="L1322">                .keyword_noalias =&gt; is_comptime: {</span>
<span class="line" id="L1323">                    noalias_bits |= <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>) &lt;&lt; (std.math.cast(<span class="tok-type">u5</span>, param_type_i) <span class="tok-kw">orelse</span></span>
<span class="line" id="L1324">                        <span class="tok-kw">return</span> astgen.failTok(token, <span class="tok-str">&quot;this compiler implementation only supports 'noalias' on the first 32 parameters&quot;</span>, .{}));</span>
<span class="line" id="L1325">                    <span class="tok-kw">break</span> :is_comptime <span class="tok-null">false</span>;</span>
<span class="line" id="L1326">                },</span>
<span class="line" id="L1327">                .keyword_comptime =&gt; <span class="tok-null">true</span>,</span>
<span class="line" id="L1328">                <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,</span>
<span class="line" id="L1329">            } <span class="tok-kw">else</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L1330"></span>
<span class="line" id="L1331">            <span class="tok-kw">const</span> is_anytype = <span class="tok-kw">if</span> (param.anytype_ellipsis3) |token| blk: {</span>
<span class="line" id="L1332">                <span class="tok-kw">switch</span> (token_tags[token]) {</span>
<span class="line" id="L1333">                    .keyword_anytype =&gt; <span class="tok-kw">break</span> :blk <span class="tok-null">true</span>,</span>
<span class="line" id="L1334">                    .ellipsis3 =&gt; <span class="tok-kw">break</span> :is_var_args <span class="tok-null">true</span>,</span>
<span class="line" id="L1335">                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1336">                }</span>
<span class="line" id="L1337">            } <span class="tok-kw">else</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L1338"></span>
<span class="line" id="L1339">            <span class="tok-kw">const</span> param_name = <span class="tok-kw">if</span> (param.name_token) |name_token| blk: {</span>
<span class="line" id="L1340">                <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, <span class="tok-str">&quot;_&quot;</span>, tree.tokenSlice(name_token)))</span>
<span class="line" id="L1341">                    <span class="tok-kw">break</span> :blk .empty;</span>
<span class="line" id="L1342"></span>
<span class="line" id="L1343">                <span class="tok-kw">break</span> :blk <span class="tok-kw">try</span> astgen.identAsString(name_token);</span>
<span class="line" id="L1344">            } <span class="tok-kw">else</span> .empty;</span>
<span class="line" id="L1345"></span>
<span class="line" id="L1346">            <span class="tok-kw">if</span> (is_anytype) {</span>
<span class="line" id="L1347">                <span class="tok-kw">const</span> name_token = param.name_token <span class="tok-kw">orelse</span> param.anytype_ellipsis3.?;</span>
<span class="line" id="L1348"></span>
<span class="line" id="L1349">                <span class="tok-kw">const</span> tag: Zir.Inst.Tag = <span class="tok-kw">if</span> (is_comptime)</span>
<span class="line" id="L1350">                    .param_anytype_comptime</span>
<span class="line" id="L1351">                <span class="tok-kw">else</span></span>
<span class="line" id="L1352">                    .param_anytype;</span>
<span class="line" id="L1353">                _ = <span class="tok-kw">try</span> block_scope.addStrTok(tag, param_name, name_token);</span>
<span class="line" id="L1354">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1355">                <span class="tok-kw">const</span> param_type_node = param.type_expr;</span>
<span class="line" id="L1356">                assert(param_type_node != <span class="tok-number">0</span>);</span>
<span class="line" id="L1357">                <span class="tok-kw">var</span> param_gz = block_scope.makeSubBlock(scope);</span>
<span class="line" id="L1358">                <span class="tok-kw">defer</span> param_gz.unstack();</span>
<span class="line" id="L1359">                <span class="tok-kw">const</span> param_type = <span class="tok-kw">try</span> fullBodyExpr(&amp;param_gz, scope, coerced_type_ri, param_type_node);</span>
<span class="line" id="L1360">                <span class="tok-kw">const</span> param_inst_expected: Zir.Inst.Index = <span class="tok-builtin">@enumFromInt</span>(astgen.instructions.len + <span class="tok-number">1</span>);</span>
<span class="line" id="L1361">                _ = <span class="tok-kw">try</span> param_gz.addBreakWithSrcNode(.break_inline, param_inst_expected, param_type, param_type_node);</span>
<span class="line" id="L1362">                <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);</span>
<span class="line" id="L1363">                <span class="tok-kw">const</span> name_token = param.name_token <span class="tok-kw">orelse</span> main_tokens[param_type_node];</span>
<span class="line" id="L1364">                <span class="tok-kw">const</span> tag: Zir.Inst.Tag = <span class="tok-kw">if</span> (is_comptime) .param_comptime <span class="tok-kw">else</span> .param;</span>
<span class="line" id="L1365">                <span class="tok-kw">const</span> param_inst = <span class="tok-kw">try</span> block_scope.addParam(&amp;param_gz, tag, name_token, param_name, param.first_doc_comment);</span>
<span class="line" id="L1366">                assert(param_inst_expected == param_inst);</span>
<span class="line" id="L1367">            }</span>
<span class="line" id="L1368">        }</span>
<span class="line" id="L1369">        <span class="tok-kw">break</span> :is_var_args <span class="tok-null">false</span>;</span>
<span class="line" id="L1370">    };</span>
<span class="line" id="L1371"></span>
<span class="line" id="L1372">    <span class="tok-kw">const</span> align_ref: Zir.Inst.Ref = <span class="tok-kw">if</span> (fn_proto.ast.align_expr == <span class="tok-number">0</span>) .none <span class="tok-kw">else</span> inst: {</span>
<span class="line" id="L1373">        <span class="tok-kw">break</span> :inst <span class="tok-kw">try</span> expr(&amp;block_scope, scope, coerced_align_ri, fn_proto.ast.align_expr);</span>
<span class="line" id="L1374">    };</span>
<span class="line" id="L1375"></span>
<span class="line" id="L1376">    <span class="tok-kw">if</span> (fn_proto.ast.addrspace_expr != <span class="tok-number">0</span>) {</span>
<span class="line" id="L1377">        <span class="tok-kw">return</span> astgen.failNode(fn_proto.ast.addrspace_expr, <span class="tok-str">&quot;addrspace not allowed on function prototypes&quot;</span>, .{});</span>
<span class="line" id="L1378">    }</span>
<span class="line" id="L1379"></span>
<span class="line" id="L1380">    <span class="tok-kw">if</span> (fn_proto.ast.section_expr != <span class="tok-number">0</span>) {</span>
<span class="line" id="L1381">        <span class="tok-kw">return</span> astgen.failNode(fn_proto.ast.section_expr, <span class="tok-str">&quot;linksection not allowed on function prototypes&quot;</span>, .{});</span>
<span class="line" id="L1382">    }</span>
<span class="line" id="L1383"></span>
<span class="line" id="L1384">    <span class="tok-kw">const</span> cc: Zir.Inst.Ref = <span class="tok-kw">if</span> (fn_proto.ast.callconv_expr != <span class="tok-number">0</span>)</span>
<span class="line" id="L1385">        <span class="tok-kw">try</span> expr(</span>
<span class="line" id="L1386">            &amp;block_scope,</span>
<span class="line" id="L1387">            scope,</span>
<span class="line" id="L1388">            .{ .rl = .{ .coerced_ty = .calling_convention_type } },</span>
<span class="line" id="L1389">            fn_proto.ast.callconv_expr,</span>
<span class="line" id="L1390">        )</span>
<span class="line" id="L1391">    <span class="tok-kw">else</span></span>
<span class="line" id="L1392">        Zir.Inst.Ref.none;</span>
<span class="line" id="L1393"></span>
<span class="line" id="L1394">    <span class="tok-kw">const</span> maybe_bang = tree.firstToken(fn_proto.ast.return_type) - <span class="tok-number">1</span>;</span>
<span class="line" id="L1395">    <span class="tok-kw">const</span> is_inferred_error = token_tags[maybe_bang] == .bang;</span>
<span class="line" id="L1396">    <span class="tok-kw">if</span> (is_inferred_error) {</span>
<span class="line" id="L1397">        <span class="tok-kw">return</span> astgen.failTok(maybe_bang, <span class="tok-str">&quot;function prototype may not have inferred error set&quot;</span>, .{});</span>
<span class="line" id="L1398">    }</span>
<span class="line" id="L1399">    <span class="tok-kw">const</span> ret_ty = <span class="tok-kw">try</span> expr(&amp;block_scope, scope, coerced_type_ri, fn_proto.ast.return_type);</span>
<span class="line" id="L1400"></span>
<span class="line" id="L1401">    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> block_scope.addFunc(.{</span>
<span class="line" id="L1402">        .src_node = fn_proto.ast.proto_node,</span>
<span class="line" id="L1403"></span>
<span class="line" id="L1404">        .cc_ref = cc,</span>
<span class="line" id="L1405">        .cc_gz = <span class="tok-null">null</span>,</span>
<span class="line" id="L1406">        .align_ref = align_ref,</span>
<span class="line" id="L1407">        .align_gz = <span class="tok-null">null</span>,</span>
<span class="line" id="L1408">        .ret_ref = ret_ty,</span>
<span class="line" id="L1409">        .ret_gz = <span class="tok-null">null</span>,</span>
<span class="line" id="L1410">        .section_ref = .none,</span>
<span class="line" id="L1411">        .section_gz = <span class="tok-null">null</span>,</span>
<span class="line" id="L1412">        .addrspace_ref = .none,</span>
<span class="line" id="L1413">        .addrspace_gz = <span class="tok-null">null</span>,</span>
<span class="line" id="L1414"></span>
<span class="line" id="L1415">        .param_block = block_inst,</span>
<span class="line" id="L1416">        .body_gz = <span class="tok-null">null</span>,</span>
<span class="line" id="L1417">        .lib_name = .empty,</span>
<span class="line" id="L1418">        .is_var_args = is_var_args,</span>
<span class="line" id="L1419">        .is_inferred_error = <span class="tok-null">false</span>,</span>
<span class="line" id="L1420">        .is_test = <span class="tok-null">false</span>,</span>
<span class="line" id="L1421">        .is_extern = <span class="tok-null">false</span>,</span>
<span class="line" id="L1422">        .is_noinline = <span class="tok-null">false</span>,</span>
<span class="line" id="L1423">        .noalias_bits = noalias_bits,</span>
<span class="line" id="L1424">    });</span>
<span class="line" id="L1425"></span>
<span class="line" id="L1426">    _ = <span class="tok-kw">try</span> block_scope.addBreak(.break_inline, block_inst, result);</span>
<span class="line" id="L1427">    <span class="tok-kw">try</span> block_scope.setBlockBody(block_inst);</span>
<span class="line" id="L1428">    <span class="tok-kw">try</span> gz.instructions.append(astgen.gpa, block_inst);</span>
<span class="line" id="L1429"></span>
<span class="line" id="L1430">    <span class="tok-kw">return</span> rvalue(gz, ri, block_inst.toRef(), fn_proto.ast.proto_node);</span>
<span class="line" id="L1431">}</span>
<span class="line" id="L1432"></span>
<span class="line" id="L1433"><span class="tok-kw">fn</span> <span class="tok-fn">arrayInitExpr</span>(</span>
<span class="line" id="L1434">    gz: *GenZir,</span>
<span class="line" id="L1435">    scope: *Scope,</span>
<span class="line" id="L1436">    ri: ResultInfo,</span>
<span class="line" id="L1437">    node: Ast.Node.Index,</span>
<span class="line" id="L1438">    array_init: Ast.full.ArrayInit,</span>
<span class="line" id="L1439">) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L1440">    <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L1441">    <span class="tok-kw">const</span> tree = astgen.tree;</span>
<span class="line" id="L1442">    <span class="tok-kw">const</span> node_tags = tree.nodes.items(.tag);</span>
<span class="line" id="L1443">    <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);</span>
<span class="line" id="L1444"></span>
<span class="line" id="L1445">    assert(array_init.ast.elements.len != <span class="tok-number">0</span>); <span class="tok-comment">// Otherwise it would be struct init.</span>
</span>
<span class="line" id="L1446"></span>
<span class="line" id="L1447">    <span class="tok-kw">const</span> array_ty: Zir.Inst.Ref, <span class="tok-kw">const</span> elem_ty: Zir.Inst.Ref = inst: {</span>
<span class="line" id="L1448">        <span class="tok-kw">if</span> (array_init.ast.type_expr == <span class="tok-number">0</span>) <span class="tok-kw">break</span> :inst .{ .none, .none };</span>
<span class="line" id="L1449"></span>
<span class="line" id="L1450">        infer: {</span>
<span class="line" id="L1451">            <span class="tok-kw">const</span> array_type: Ast.full.ArrayType = tree.fullArrayType(array_init.ast.type_expr) <span class="tok-kw">orelse</span> <span class="tok-kw">break</span> :infer;</span>
<span class="line" id="L1452">            <span class="tok-comment">// This intentionally does not support `@&quot;_&quot;` syntax.</span>
</span>
<span class="line" id="L1453">            <span class="tok-kw">if</span> (node_tags[array_type.ast.elem_count] == .identifier <span class="tok-kw">and</span></span>
<span class="line" id="L1454">                mem.eql(<span class="tok-type">u8</span>, tree.tokenSlice(main_tokens[array_type.ast.elem_count]), <span class="tok-str">&quot;_&quot;</span>))</span>
<span class="line" id="L1455">            {</span>
<span class="line" id="L1456">                <span class="tok-kw">const</span> len_inst = <span class="tok-kw">try</span> gz.addInt(array_init.ast.elements.len);</span>
<span class="line" id="L1457">                <span class="tok-kw">const</span> elem_type = <span class="tok-kw">try</span> typeExpr(gz, scope, array_type.ast.elem_type);</span>
<span class="line" id="L1458">                <span class="tok-kw">if</span> (array_type.ast.sentinel == <span class="tok-number">0</span>) {</span>
<span class="line" id="L1459">                    <span class="tok-kw">const</span> array_type_inst = <span class="tok-kw">try</span> gz.addPlNode(.array_type, array_init.ast.type_expr, Zir.Inst.Bin{</span>
<span class="line" id="L1460">                        .lhs = len_inst,</span>
<span class="line" id="L1461">                        .rhs = elem_type,</span>
<span class="line" id="L1462">                    });</span>
<span class="line" id="L1463">                    <span class="tok-kw">break</span> :inst .{ array_type_inst, elem_type };</span>
<span class="line" id="L1464">                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1465">                    <span class="tok-kw">const</span> sentinel = <span class="tok-kw">try</span> comptimeExpr(gz, scope, .{ .rl = .{ .ty = elem_type } }, array_type.ast.sentinel);</span>
<span class="line" id="L1466">                    <span class="tok-kw">const</span> array_type_inst = <span class="tok-kw">try</span> gz.addPlNode(</span>
<span class="line" id="L1467">                        .array_type_sentinel,</span>
<span class="line" id="L1468">                        array_init.ast.type_expr,</span>
<span class="line" id="L1469">                        Zir.Inst.ArrayTypeSentinel{</span>
<span class="line" id="L1470">                            .len = len_inst,</span>
<span class="line" id="L1471">                            .elem_type = elem_type,</span>
<span class="line" id="L1472">                            .sentinel = sentinel,</span>
<span class="line" id="L1473">                        },</span>
<span class="line" id="L1474">                    );</span>
<span class="line" id="L1475">                    <span class="tok-kw">break</span> :inst .{ array_type_inst, elem_type };</span>
<span class="line" id="L1476">                }</span>
<span class="line" id="L1477">            }</span>
<span class="line" id="L1478">        }</span>
<span class="line" id="L1479">        <span class="tok-kw">const</span> array_type_inst = <span class="tok-kw">try</span> typeExpr(gz, scope, array_init.ast.type_expr);</span>
<span class="line" id="L1480">        _ = <span class="tok-kw">try</span> gz.addPlNode(.validate_array_init_ty, node, Zir.Inst.ArrayInit{</span>
<span class="line" id="L1481">            .ty = array_type_inst,</span>
<span class="line" id="L1482">            .init_count = <span class="tok-builtin">@intCast</span>(array_init.ast.elements.len),</span>
<span class="line" id="L1483">        });</span>
<span class="line" id="L1484">        <span class="tok-kw">break</span> :inst .{ array_type_inst, .none };</span>
<span class="line" id="L1485">    };</span>
<span class="line" id="L1486"></span>
<span class="line" id="L1487">    <span class="tok-kw">if</span> (array_ty != .none) {</span>
<span class="line" id="L1488">        <span class="tok-comment">// Typed inits do not use RLS for language simplicity.</span>
</span>
<span class="line" id="L1489">        <span class="tok-kw">switch</span> (ri.rl) {</span>
<span class="line" id="L1490">            .discard =&gt; {</span>
<span class="line" id="L1491">                <span class="tok-kw">if</span> (elem_ty != .none) {</span>
<span class="line" id="L1492">                    <span class="tok-kw">const</span> elem_ri: ResultInfo = .{ .rl = .{ .ty = elem_ty } };</span>
<span class="line" id="L1493">                    <span class="tok-kw">for</span> (array_init.ast.elements) |elem_init| {</span>
<span class="line" id="L1494">                        _ = <span class="tok-kw">try</span> expr(gz, scope, elem_ri, elem_init);</span>
<span class="line" id="L1495">                    }</span>
<span class="line" id="L1496">                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1497">                    <span class="tok-kw">for</span> (array_init.ast.elements, <span class="tok-number">0</span>..) |elem_init, i| {</span>
<span class="line" id="L1498">                        <span class="tok-kw">const</span> this_elem_ty = <span class="tok-kw">try</span> gz.add(.{</span>
<span class="line" id="L1499">                            .tag = .array_init_elem_type,</span>
<span class="line" id="L1500">                            .data = .{ .bin = .{</span>
<span class="line" id="L1501">                                .lhs = array_ty,</span>
<span class="line" id="L1502">                                .rhs = <span class="tok-builtin">@enumFromInt</span>(i),</span>
<span class="line" id="L1503">                            } },</span>
<span class="line" id="L1504">                        });</span>
<span class="line" id="L1505">                        _ = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .{ .ty = this_elem_ty } }, elem_init);</span>
<span class="line" id="L1506">                    }</span>
<span class="line" id="L1507">                }</span>
<span class="line" id="L1508">                <span class="tok-kw">return</span> .void_value;</span>
<span class="line" id="L1509">            },</span>
<span class="line" id="L1510">            .ref =&gt; <span class="tok-kw">return</span> arrayInitExprTyped(gz, scope, node, array_init.ast.elements, array_ty, elem_ty, <span class="tok-null">true</span>),</span>
<span class="line" id="L1511">            <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L1512">                <span class="tok-kw">const</span> array_inst = <span class="tok-kw">try</span> arrayInitExprTyped(gz, scope, node, array_init.ast.elements, array_ty, elem_ty, <span class="tok-null">false</span>);</span>
<span class="line" id="L1513">                <span class="tok-kw">return</span> rvalue(gz, ri, array_inst, node);</span>
<span class="line" id="L1514">            },</span>
<span class="line" id="L1515">        }</span>
<span class="line" id="L1516">    }</span>
<span class="line" id="L1517"></span>
<span class="line" id="L1518">    <span class="tok-kw">switch</span> (ri.rl) {</span>
<span class="line" id="L1519">        .none =&gt; <span class="tok-kw">return</span> arrayInitExprAnon(gz, scope, node, array_init.ast.elements),</span>
<span class="line" id="L1520">        .discard =&gt; {</span>
<span class="line" id="L1521">            <span class="tok-kw">for</span> (array_init.ast.elements) |elem_init| {</span>
<span class="line" id="L1522">                _ = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .discard }, elem_init);</span>
<span class="line" id="L1523">            }</span>
<span class="line" id="L1524">            <span class="tok-kw">return</span> Zir.Inst.Ref.void_value;</span>
<span class="line" id="L1525">        },</span>
<span class="line" id="L1526">        .ref =&gt; {</span>
<span class="line" id="L1527">            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> arrayInitExprAnon(gz, scope, node, array_init.ast.elements);</span>
<span class="line" id="L1528">            <span class="tok-kw">return</span> gz.addUnTok(.ref, result, tree.firstToken(node));</span>
<span class="line" id="L1529">        },</span>
<span class="line" id="L1530">        .ref_coerced_ty =&gt; |ptr_ty_inst| {</span>
<span class="line" id="L1531">            <span class="tok-kw">const</span> dest_arr_ty_inst = <span class="tok-kw">try</span> gz.addPlNode(.validate_array_init_ref_ty, node, Zir.Inst.ArrayInitRefTy{</span>
<span class="line" id="L1532">                .ptr_ty = ptr_ty_inst,</span>
<span class="line" id="L1533">                .elem_count = <span class="tok-builtin">@intCast</span>(array_init.ast.elements.len),</span>
<span class="line" id="L1534">            });</span>
<span class="line" id="L1535">            <span class="tok-kw">return</span> arrayInitExprTyped(gz, scope, node, array_init.ast.elements, dest_arr_ty_inst, .none, <span class="tok-null">true</span>);</span>
<span class="line" id="L1536">        },</span>
<span class="line" id="L1537">        .ty, .coerced_ty =&gt; |result_ty_inst| {</span>
<span class="line" id="L1538">            _ = <span class="tok-kw">try</span> gz.addPlNode(.validate_array_init_result_ty, node, Zir.Inst.ArrayInit{</span>
<span class="line" id="L1539">                .ty = result_ty_inst,</span>
<span class="line" id="L1540">                .init_count = <span class="tok-builtin">@intCast</span>(array_init.ast.elements.len),</span>
<span class="line" id="L1541">            });</span>
<span class="line" id="L1542">            <span class="tok-kw">return</span> arrayInitExprTyped(gz, scope, node, array_init.ast.elements, result_ty_inst, .none, <span class="tok-null">false</span>);</span>
<span class="line" id="L1543">        },</span>
<span class="line" id="L1544">        .ptr =&gt; |ptr| {</span>
<span class="line" id="L1545">            <span class="tok-kw">try</span> arrayInitExprPtr(gz, scope, node, array_init.ast.elements, ptr.inst);</span>
<span class="line" id="L1546">            <span class="tok-kw">return</span> .void_value;</span>
<span class="line" id="L1547">        },</span>
<span class="line" id="L1548">        .inferred_ptr =&gt; {</span>
<span class="line" id="L1549">            <span class="tok-comment">// We can't get elem pointers of an untyped inferred alloc, so must perform a</span>
</span>
<span class="line" id="L1550">            <span class="tok-comment">// standard anonymous initialization followed by an rvalue store.</span>
</span>
<span class="line" id="L1551">            <span class="tok-comment">// See corresponding logic in structInitExpr.</span>
</span>
<span class="line" id="L1552">            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> arrayInitExprAnon(gz, scope, node, array_init.ast.elements);</span>
<span class="line" id="L1553">            <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L1554">        },</span>
<span class="line" id="L1555">        .destructure =&gt; |destructure| {</span>
<span class="line" id="L1556">            <span class="tok-comment">// Untyped init - destructure directly into result pointers</span>
</span>
<span class="line" id="L1557">            <span class="tok-kw">if</span> (array_init.ast.elements.len != destructure.components.len) {</span>
<span class="line" id="L1558">                <span class="tok-kw">return</span> astgen.failNodeNotes(node, <span class="tok-str">&quot;expected {} elements for destructure, found {}&quot;</span>, .{</span>
<span class="line" id="L1559">                    destructure.components.len,</span>
<span class="line" id="L1560">                    array_init.ast.elements.len,</span>
<span class="line" id="L1561">                }, &amp;.{</span>
<span class="line" id="L1562">                    <span class="tok-kw">try</span> astgen.errNoteNode(destructure.src_node, <span class="tok-str">&quot;result destructured here&quot;</span>, .{}),</span>
<span class="line" id="L1563">                });</span>
<span class="line" id="L1564">            }</span>
<span class="line" id="L1565">            <span class="tok-kw">for</span> (array_init.ast.elements, destructure.components) |elem_init, ds_comp| {</span>
<span class="line" id="L1566">                <span class="tok-kw">const</span> elem_ri: ResultInfo = .{ .rl = <span class="tok-kw">switch</span> (ds_comp) {</span>
<span class="line" id="L1567">                    .typed_ptr =&gt; |ptr_rl| .{ .ptr = ptr_rl },</span>
<span class="line" id="L1568">                    .inferred_ptr =&gt; |ptr_inst| .{ .inferred_ptr = ptr_inst },</span>
<span class="line" id="L1569">                    .discard =&gt; .discard,</span>
<span class="line" id="L1570">                } };</span>
<span class="line" id="L1571">                _ = <span class="tok-kw">try</span> expr(gz, scope, elem_ri, elem_init);</span>
<span class="line" id="L1572">            }</span>
<span class="line" id="L1573">            <span class="tok-kw">return</span> .void_value;</span>
<span class="line" id="L1574">        },</span>
<span class="line" id="L1575">    }</span>
<span class="line" id="L1576">}</span>
<span class="line" id="L1577"></span>
<span class="line" id="L1578"><span class="tok-comment">/// An array initialization expression using an `array_init_anon` instruction.</span></span>
<span class="line" id="L1579"><span class="tok-kw">fn</span> <span class="tok-fn">arrayInitExprAnon</span>(</span>
<span class="line" id="L1580">    gz: *GenZir,</span>
<span class="line" id="L1581">    scope: *Scope,</span>
<span class="line" id="L1582">    node: Ast.Node.Index,</span>
<span class="line" id="L1583">    elements: []<span class="tok-kw">const</span> Ast.Node.Index,</span>
<span class="line" id="L1584">) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L1585">    <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L1586"></span>
<span class="line" id="L1587">    <span class="tok-kw">const</span> payload_index = <span class="tok-kw">try</span> addExtra(astgen, Zir.Inst.MultiOp{</span>
<span class="line" id="L1588">        .operands_len = <span class="tok-builtin">@intCast</span>(elements.len),</span>
<span class="line" id="L1589">    });</span>
<span class="line" id="L1590">    <span class="tok-kw">var</span> extra_index = <span class="tok-kw">try</span> reserveExtra(astgen, elements.len);</span>
<span class="line" id="L1591"></span>
<span class="line" id="L1592">    <span class="tok-kw">for</span> (elements) |elem_init| {</span>
<span class="line" id="L1593">        <span class="tok-kw">const</span> elem_ref = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .none }, elem_init);</span>
<span class="line" id="L1594">        astgen.extra.items[extra_index] = <span class="tok-builtin">@intFromEnum</span>(elem_ref);</span>
<span class="line" id="L1595">        extra_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L1596">    }</span>
<span class="line" id="L1597">    <span class="tok-kw">return</span> <span class="tok-kw">try</span> gz.addPlNodePayloadIndex(.array_init_anon, node, payload_index);</span>
<span class="line" id="L1598">}</span>
<span class="line" id="L1599"></span>
<span class="line" id="L1600"><span class="tok-comment">/// An array initialization expression using an `array_init` or `array_init_ref` instruction.</span></span>
<span class="line" id="L1601"><span class="tok-kw">fn</span> <span class="tok-fn">arrayInitExprTyped</span>(</span>
<span class="line" id="L1602">    gz: *GenZir,</span>
<span class="line" id="L1603">    scope: *Scope,</span>
<span class="line" id="L1604">    node: Ast.Node.Index,</span>
<span class="line" id="L1605">    elements: []<span class="tok-kw">const</span> Ast.Node.Index,</span>
<span class="line" id="L1606">    ty_inst: Zir.Inst.Ref,</span>
<span class="line" id="L1607">    maybe_elem_ty_inst: Zir.Inst.Ref,</span>
<span class="line" id="L1608">    is_ref: <span class="tok-type">bool</span>,</span>
<span class="line" id="L1609">) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L1610">    <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L1611"></span>
<span class="line" id="L1612">    <span class="tok-kw">const</span> len = elements.len + <span class="tok-number">1</span>; <span class="tok-comment">// +1 for type</span>
</span>
<span class="line" id="L1613">    <span class="tok-kw">const</span> payload_index = <span class="tok-kw">try</span> addExtra(astgen, Zir.Inst.MultiOp{</span>
<span class="line" id="L1614">        .operands_len = <span class="tok-builtin">@intCast</span>(len),</span>
<span class="line" id="L1615">    });</span>
<span class="line" id="L1616">    <span class="tok-kw">var</span> extra_index = <span class="tok-kw">try</span> reserveExtra(astgen, len);</span>
<span class="line" id="L1617">    astgen.extra.items[extra_index] = <span class="tok-builtin">@intFromEnum</span>(ty_inst);</span>
<span class="line" id="L1618">    extra_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L1619"></span>
<span class="line" id="L1620">    <span class="tok-kw">if</span> (maybe_elem_ty_inst != .none) {</span>
<span class="line" id="L1621">        <span class="tok-kw">const</span> elem_ri: ResultInfo = .{ .rl = .{ .coerced_ty = maybe_elem_ty_inst } };</span>
<span class="line" id="L1622">        <span class="tok-kw">for</span> (elements) |elem_init| {</span>
<span class="line" id="L1623">            <span class="tok-kw">const</span> elem_inst = <span class="tok-kw">try</span> expr(gz, scope, elem_ri, elem_init);</span>
<span class="line" id="L1624">            astgen.extra.items[extra_index] = <span class="tok-builtin">@intFromEnum</span>(elem_inst);</span>
<span class="line" id="L1625">            extra_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L1626">        }</span>
<span class="line" id="L1627">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1628">        <span class="tok-kw">for</span> (elements, <span class="tok-number">0</span>..) |elem_init, i| {</span>
<span class="line" id="L1629">            <span class="tok-kw">const</span> ri: ResultInfo = .{ .rl = .{ .coerced_ty = <span class="tok-kw">try</span> gz.add(.{</span>
<span class="line" id="L1630">                .tag = .array_init_elem_type,</span>
<span class="line" id="L1631">                .data = .{ .bin = .{</span>
<span class="line" id="L1632">                    .lhs = ty_inst,</span>
<span class="line" id="L1633">                    .rhs = <span class="tok-builtin">@enumFromInt</span>(i),</span>
<span class="line" id="L1634">                } },</span>
<span class="line" id="L1635">            }) } };</span>
<span class="line" id="L1636"></span>
<span class="line" id="L1637">            <span class="tok-kw">const</span> elem_inst = <span class="tok-kw">try</span> expr(gz, scope, ri, elem_init);</span>
<span class="line" id="L1638">            astgen.extra.items[extra_index] = <span class="tok-builtin">@intFromEnum</span>(elem_inst);</span>
<span class="line" id="L1639">            extra_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L1640">        }</span>
<span class="line" id="L1641">    }</span>
<span class="line" id="L1642"></span>
<span class="line" id="L1643">    <span class="tok-kw">const</span> tag: Zir.Inst.Tag = <span class="tok-kw">if</span> (is_ref) .array_init_ref <span class="tok-kw">else</span> .array_init;</span>
<span class="line" id="L1644">    <span class="tok-kw">return</span> <span class="tok-kw">try</span> gz.addPlNodePayloadIndex(tag, node, payload_index);</span>
<span class="line" id="L1645">}</span>
<span class="line" id="L1646"></span>
<span class="line" id="L1647"><span class="tok-comment">/// An array initialization expression using element pointers.</span></span>
<span class="line" id="L1648"><span class="tok-kw">fn</span> <span class="tok-fn">arrayInitExprPtr</span>(</span>
<span class="line" id="L1649">    gz: *GenZir,</span>
<span class="line" id="L1650">    scope: *Scope,</span>
<span class="line" id="L1651">    node: Ast.Node.Index,</span>
<span class="line" id="L1652">    elements: []<span class="tok-kw">const</span> Ast.Node.Index,</span>
<span class="line" id="L1653">    ptr_inst: Zir.Inst.Ref,</span>
<span class="line" id="L1654">) InnerError!<span class="tok-type">void</span> {</span>
<span class="line" id="L1655">    <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L1656"></span>
<span class="line" id="L1657">    <span class="tok-kw">const</span> array_ptr_inst = <span class="tok-kw">try</span> gz.addUnNode(.opt_eu_base_ptr_init, ptr_inst, node);</span>
<span class="line" id="L1658"></span>
<span class="line" id="L1659">    <span class="tok-kw">const</span> payload_index = <span class="tok-kw">try</span> addExtra(astgen, Zir.Inst.Block{</span>
<span class="line" id="L1660">        .body_len = <span class="tok-builtin">@intCast</span>(elements.len),</span>
<span class="line" id="L1661">    });</span>
<span class="line" id="L1662">    <span class="tok-kw">var</span> extra_index = <span class="tok-kw">try</span> reserveExtra(astgen, elements.len);</span>
<span class="line" id="L1663"></span>
<span class="line" id="L1664">    <span class="tok-kw">for</span> (elements, <span class="tok-number">0</span>..) |elem_init, i| {</span>
<span class="line" id="L1665">        <span class="tok-kw">const</span> elem_ptr_inst = <span class="tok-kw">try</span> gz.addPlNode(.array_init_elem_ptr, elem_init, Zir.Inst.ElemPtrImm{</span>
<span class="line" id="L1666">            .ptr = array_ptr_inst,</span>
<span class="line" id="L1667">            .index = <span class="tok-builtin">@intCast</span>(i),</span>
<span class="line" id="L1668">        });</span>
<span class="line" id="L1669">        astgen.extra.items[extra_index] = <span class="tok-builtin">@intFromEnum</span>(elem_ptr_inst.toIndex().?);</span>
<span class="line" id="L1670">        extra_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L1671">        _ = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .{ .ptr = .{ .inst = elem_ptr_inst } } }, elem_init);</span>
<span class="line" id="L1672">    }</span>
<span class="line" id="L1673"></span>
<span class="line" id="L1674">    _ = <span class="tok-kw">try</span> gz.addPlNodePayloadIndex(.validate_ptr_array_init, node, payload_index);</span>
<span class="line" id="L1675">}</span>
<span class="line" id="L1676"></span>
<span class="line" id="L1677"><span class="tok-kw">fn</span> <span class="tok-fn">structInitExpr</span>(</span>
<span class="line" id="L1678">    gz: *GenZir,</span>
<span class="line" id="L1679">    scope: *Scope,</span>
<span class="line" id="L1680">    ri: ResultInfo,</span>
<span class="line" id="L1681">    node: Ast.Node.Index,</span>
<span class="line" id="L1682">    struct_init: Ast.full.StructInit,</span>
<span class="line" id="L1683">) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L1684">    <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L1685">    <span class="tok-kw">const</span> tree = astgen.tree;</span>
<span class="line" id="L1686"></span>
<span class="line" id="L1687">    <span class="tok-kw">if</span> (struct_init.ast.type_expr == <span class="tok-number">0</span>) {</span>
<span class="line" id="L1688">        <span class="tok-kw">if</span> (struct_init.ast.fields.len == <span class="tok-number">0</span>) {</span>
<span class="line" id="L1689">            <span class="tok-comment">// Anonymous init with no fields.</span>
</span>
<span class="line" id="L1690">            <span class="tok-kw">switch</span> (ri.rl) {</span>
<span class="line" id="L1691">                .discard =&gt; <span class="tok-kw">return</span> .void_value,</span>
<span class="line" id="L1692">                .ref_coerced_ty =&gt; |ptr_ty_inst| <span class="tok-kw">return</span> gz.addUnNode(.struct_init_empty_ref_result, ptr_ty_inst, node),</span>
<span class="line" id="L1693">                .ty, .coerced_ty =&gt; |ty_inst| <span class="tok-kw">return</span> gz.addUnNode(.struct_init_empty_result, ty_inst, node),</span>
<span class="line" id="L1694">                .ptr =&gt; {</span>
<span class="line" id="L1695">                    <span class="tok-comment">// TODO: should we modify this to use RLS for the field stores here?</span>
</span>
<span class="line" id="L1696">                    <span class="tok-kw">const</span> ty_inst = (<span class="tok-kw">try</span> ri.rl.resultType(gz, node)).?;</span>
<span class="line" id="L1697">                    <span class="tok-kw">const</span> val = <span class="tok-kw">try</span> gz.addUnNode(.struct_init_empty_result, ty_inst, node);</span>
<span class="line" id="L1698">                    <span class="tok-kw">return</span> rvalue(gz, ri, val, node);</span>
<span class="line" id="L1699">                },</span>
<span class="line" id="L1700">                .none, .ref, .inferred_ptr =&gt; {</span>
<span class="line" id="L1701">                    <span class="tok-kw">return</span> rvalue(gz, ri, .empty_struct, node);</span>
<span class="line" id="L1702">                },</span>
<span class="line" id="L1703">                .destructure =&gt; |destructure| {</span>
<span class="line" id="L1704">                    <span class="tok-kw">return</span> astgen.failNodeNotes(node, <span class="tok-str">&quot;empty initializer cannot be destructured&quot;</span>, .{}, &amp;.{</span>
<span class="line" id="L1705">                        <span class="tok-kw">try</span> astgen.errNoteNode(destructure.src_node, <span class="tok-str">&quot;result destructured here&quot;</span>, .{}),</span>
<span class="line" id="L1706">                    });</span>
<span class="line" id="L1707">                },</span>
<span class="line" id="L1708">            }</span>
<span class="line" id="L1709">        }</span>
<span class="line" id="L1710">    } <span class="tok-kw">else</span> array: {</span>
<span class="line" id="L1711">        <span class="tok-kw">const</span> node_tags = tree.nodes.items(.tag);</span>
<span class="line" id="L1712">        <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);</span>
<span class="line" id="L1713">        <span class="tok-kw">const</span> array_type: Ast.full.ArrayType = tree.fullArrayType(struct_init.ast.type_expr) <span class="tok-kw">orelse</span> {</span>
<span class="line" id="L1714">            <span class="tok-kw">if</span> (struct_init.ast.fields.len == <span class="tok-number">0</span>) {</span>
<span class="line" id="L1715">                <span class="tok-kw">const</span> ty_inst = <span class="tok-kw">try</span> typeExpr(gz, scope, struct_init.ast.type_expr);</span>
<span class="line" id="L1716">                <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addUnNode(.struct_init_empty, ty_inst, node);</span>
<span class="line" id="L1717">                <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L1718">            }</span>
<span class="line" id="L1719">            <span class="tok-kw">break</span> :array;</span>
<span class="line" id="L1720">        };</span>
<span class="line" id="L1721">        <span class="tok-kw">const</span> is_inferred_array_len = node_tags[array_type.ast.elem_count] == .identifier <span class="tok-kw">and</span></span>
<span class="line" id="L1722">            <span class="tok-comment">// This intentionally does not support `@&quot;_&quot;` syntax.</span>
</span>
<span class="line" id="L1723">            mem.eql(<span class="tok-type">u8</span>, tree.tokenSlice(main_tokens[array_type.ast.elem_count]), <span class="tok-str">&quot;_&quot;</span>);</span>
<span class="line" id="L1724">        <span class="tok-kw">if</span> (struct_init.ast.fields.len == <span class="tok-number">0</span>) {</span>
<span class="line" id="L1725">            <span class="tok-kw">if</span> (is_inferred_array_len) {</span>
<span class="line" id="L1726">                <span class="tok-kw">const</span> elem_type = <span class="tok-kw">try</span> typeExpr(gz, scope, array_type.ast.elem_type);</span>
<span class="line" id="L1727">                <span class="tok-kw">const</span> array_type_inst = <span class="tok-kw">if</span> (array_type.ast.sentinel == <span class="tok-number">0</span>) blk: {</span>
<span class="line" id="L1728">                    <span class="tok-kw">break</span> :blk <span class="tok-kw">try</span> gz.addPlNode(.array_type, struct_init.ast.type_expr, Zir.Inst.Bin{</span>
<span class="line" id="L1729">                        .lhs = .zero_usize,</span>
<span class="line" id="L1730">                        .rhs = elem_type,</span>
<span class="line" id="L1731">                    });</span>
<span class="line" id="L1732">                } <span class="tok-kw">else</span> blk: {</span>
<span class="line" id="L1733">                    <span class="tok-kw">const</span> sentinel = <span class="tok-kw">try</span> comptimeExpr(gz, scope, .{ .rl = .{ .ty = elem_type } }, array_type.ast.sentinel);</span>
<span class="line" id="L1734">                    <span class="tok-kw">break</span> :blk <span class="tok-kw">try</span> gz.addPlNode(</span>
<span class="line" id="L1735">                        .array_type_sentinel,</span>
<span class="line" id="L1736">                        struct_init.ast.type_expr,</span>
<span class="line" id="L1737">                        Zir.Inst.ArrayTypeSentinel{</span>
<span class="line" id="L1738">                            .len = .zero_usize,</span>
<span class="line" id="L1739">                            .elem_type = elem_type,</span>
<span class="line" id="L1740">                            .sentinel = sentinel,</span>
<span class="line" id="L1741">                        },</span>
<span class="line" id="L1742">                    );</span>
<span class="line" id="L1743">                };</span>
<span class="line" id="L1744">                <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addUnNode(.struct_init_empty, array_type_inst, node);</span>
<span class="line" id="L1745">                <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L1746">            }</span>
<span class="line" id="L1747">            <span class="tok-kw">const</span> ty_inst = <span class="tok-kw">try</span> typeExpr(gz, scope, struct_init.ast.type_expr);</span>
<span class="line" id="L1748">            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addUnNode(.struct_init_empty, ty_inst, node);</span>
<span class="line" id="L1749">            <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L1750">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1751">            <span class="tok-kw">return</span> astgen.failNode(</span>
<span class="line" id="L1752">                struct_init.ast.type_expr,</span>
<span class="line" id="L1753">                <span class="tok-str">&quot;initializing array with struct syntax&quot;</span>,</span>
<span class="line" id="L1754">                .{},</span>
<span class="line" id="L1755">            );</span>
<span class="line" id="L1756">        }</span>
<span class="line" id="L1757">    }</span>
<span class="line" id="L1758"></span>
<span class="line" id="L1759">    {</span>
<span class="line" id="L1760">        <span class="tok-kw">var</span> sfba = std.heap.stackFallback(<span class="tok-number">256</span>, astgen.arena);</span>
<span class="line" id="L1761">        <span class="tok-kw">const</span> sfba_allocator = sfba.get();</span>
<span class="line" id="L1762"></span>
<span class="line" id="L1763">        <span class="tok-kw">var</span> duplicate_names = std.AutoArrayHashMap(Zir.NullTerminatedString, ArrayListUnmanaged(Ast.TokenIndex)).init(sfba_allocator);</span>
<span class="line" id="L1764">        <span class="tok-kw">try</span> duplicate_names.ensureTotalCapacity(<span class="tok-builtin">@intCast</span>(struct_init.ast.fields.len));</span>
<span class="line" id="L1765"></span>
<span class="line" id="L1766">        <span class="tok-comment">// When there aren't errors, use this to avoid a second iteration.</span>
</span>
<span class="line" id="L1767">        <span class="tok-kw">var</span> any_duplicate = <span class="tok-null">false</span>;</span>
<span class="line" id="L1768"></span>
<span class="line" id="L1769">        <span class="tok-kw">for</span> (struct_init.ast.fields) |field| {</span>
<span class="line" id="L1770">            <span class="tok-kw">const</span> name_token = tree.firstToken(field) - <span class="tok-number">2</span>;</span>
<span class="line" id="L1771">            <span class="tok-kw">const</span> name_index = <span class="tok-kw">try</span> astgen.identAsString(name_token);</span>
<span class="line" id="L1772"></span>
<span class="line" id="L1773">            <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> duplicate_names.getOrPut(name_index);</span>
<span class="line" id="L1774"></span>
<span class="line" id="L1775">            <span class="tok-kw">if</span> (gop.found_existing) {</span>
<span class="line" id="L1776">                <span class="tok-kw">try</span> gop.value_ptr.append(sfba_allocator, name_token);</span>
<span class="line" id="L1777">                any_duplicate = <span class="tok-null">true</span>;</span>
<span class="line" id="L1778">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1779">                gop.value_ptr.* = .{};</span>
<span class="line" id="L1780">                <span class="tok-kw">try</span> gop.value_ptr.append(sfba_allocator, name_token);</span>
<span class="line" id="L1781">            }</span>
<span class="line" id="L1782">        }</span>
<span class="line" id="L1783"></span>
<span class="line" id="L1784">        <span class="tok-kw">if</span> (any_duplicate) {</span>
<span class="line" id="L1785">            <span class="tok-kw">var</span> it = duplicate_names.iterator();</span>
<span class="line" id="L1786"></span>
<span class="line" id="L1787">            <span class="tok-kw">while</span> (it.next()) |entry| {</span>
<span class="line" id="L1788">                <span class="tok-kw">const</span> record = entry.value_ptr.*;</span>
<span class="line" id="L1789">                <span class="tok-kw">if</span> (record.items.len &gt; <span class="tok-number">1</span>) {</span>
<span class="line" id="L1790">                    <span class="tok-kw">var</span> error_notes = std.ArrayList(<span class="tok-type">u32</span>).init(astgen.arena);</span>
<span class="line" id="L1791"></span>
<span class="line" id="L1792">                    <span class="tok-kw">for</span> (record.items[<span class="tok-number">1</span>..]) |duplicate| {</span>
<span class="line" id="L1793">                        <span class="tok-kw">try</span> error_notes.append(<span class="tok-kw">try</span> astgen.errNoteTok(duplicate, <span class="tok-str">&quot;duplicate name here&quot;</span>, .{}));</span>
<span class="line" id="L1794">                    }</span>
<span class="line" id="L1795"></span>
<span class="line" id="L1796">                    <span class="tok-kw">try</span> error_notes.append(<span class="tok-kw">try</span> astgen.errNoteNode(node, <span class="tok-str">&quot;struct declared here&quot;</span>, .{}));</span>
<span class="line" id="L1797"></span>
<span class="line" id="L1798">                    <span class="tok-kw">try</span> astgen.appendErrorTokNotes(</span>
<span class="line" id="L1799">                        record.items[<span class="tok-number">0</span>],</span>
<span class="line" id="L1800">                        <span class="tok-str">&quot;duplicate struct field name&quot;</span>,</span>
<span class="line" id="L1801">                        .{},</span>
<span class="line" id="L1802">                        error_notes.items,</span>
<span class="line" id="L1803">                    );</span>
<span class="line" id="L1804">                }</span>
<span class="line" id="L1805">            }</span>
<span class="line" id="L1806"></span>
<span class="line" id="L1807">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AnalysisFail;</span>
<span class="line" id="L1808">        }</span>
<span class="line" id="L1809">    }</span>
<span class="line" id="L1810"></span>
<span class="line" id="L1811">    <span class="tok-kw">if</span> (struct_init.ast.type_expr != <span class="tok-number">0</span>) {</span>
<span class="line" id="L1812">        <span class="tok-comment">// Typed inits do not use RLS for language simplicity.</span>
</span>
<span class="line" id="L1813">        <span class="tok-kw">const</span> ty_inst = <span class="tok-kw">try</span> typeExpr(gz, scope, struct_init.ast.type_expr);</span>
<span class="line" id="L1814">        _ = <span class="tok-kw">try</span> gz.addUnNode(.validate_struct_init_ty, ty_inst, node);</span>
<span class="line" id="L1815">        <span class="tok-kw">switch</span> (ri.rl) {</span>
<span class="line" id="L1816">            .ref =&gt; <span class="tok-kw">return</span> structInitExprTyped(gz, scope, node, struct_init, ty_inst, <span class="tok-null">true</span>),</span>
<span class="line" id="L1817">            <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L1818">                <span class="tok-kw">const</span> struct_inst = <span class="tok-kw">try</span> structInitExprTyped(gz, scope, node, struct_init, ty_inst, <span class="tok-null">false</span>);</span>
<span class="line" id="L1819">                <span class="tok-kw">return</span> rvalue(gz, ri, struct_inst, node);</span>
<span class="line" id="L1820">            },</span>
<span class="line" id="L1821">        }</span>
<span class="line" id="L1822">    }</span>
<span class="line" id="L1823"></span>
<span class="line" id="L1824">    <span class="tok-kw">switch</span> (ri.rl) {</span>
<span class="line" id="L1825">        .none =&gt; <span class="tok-kw">return</span> structInitExprAnon(gz, scope, node, struct_init),</span>
<span class="line" id="L1826">        .discard =&gt; {</span>
<span class="line" id="L1827">            <span class="tok-comment">// Even if discarding we must perform side-effects.</span>
</span>
<span class="line" id="L1828">            <span class="tok-kw">for</span> (struct_init.ast.fields) |field_init| {</span>
<span class="line" id="L1829">                _ = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .discard }, field_init);</span>
<span class="line" id="L1830">            }</span>
<span class="line" id="L1831">            <span class="tok-kw">return</span> .void_value;</span>
<span class="line" id="L1832">        },</span>
<span class="line" id="L1833">        .ref =&gt; {</span>
<span class="line" id="L1834">            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> structInitExprAnon(gz, scope, node, struct_init);</span>
<span class="line" id="L1835">            <span class="tok-kw">return</span> gz.addUnTok(.ref, result, tree.firstToken(node));</span>
<span class="line" id="L1836">        },</span>
<span class="line" id="L1837">        .ref_coerced_ty =&gt; |ptr_ty_inst| {</span>
<span class="line" id="L1838">            <span class="tok-kw">const</span> result_ty_inst = <span class="tok-kw">try</span> gz.addUnNode(.elem_type, ptr_ty_inst, node);</span>
<span class="line" id="L1839">            _ = <span class="tok-kw">try</span> gz.addUnNode(.validate_struct_init_result_ty, result_ty_inst, node);</span>
<span class="line" id="L1840">            <span class="tok-kw">return</span> structInitExprTyped(gz, scope, node, struct_init, result_ty_inst, <span class="tok-null">true</span>);</span>
<span class="line" id="L1841">        },</span>
<span class="line" id="L1842">        .ty, .coerced_ty =&gt; |result_ty_inst| {</span>
<span class="line" id="L1843">            _ = <span class="tok-kw">try</span> gz.addUnNode(.validate_struct_init_result_ty, result_ty_inst, node);</span>
<span class="line" id="L1844">            <span class="tok-kw">return</span> structInitExprTyped(gz, scope, node, struct_init, result_ty_inst, <span class="tok-null">false</span>);</span>
<span class="line" id="L1845">        },</span>
<span class="line" id="L1846">        .ptr =&gt; |ptr| {</span>
<span class="line" id="L1847">            <span class="tok-kw">try</span> structInitExprPtr(gz, scope, node, struct_init, ptr.inst);</span>
<span class="line" id="L1848">            <span class="tok-kw">return</span> .void_value;</span>
<span class="line" id="L1849">        },</span>
<span class="line" id="L1850">        .inferred_ptr =&gt; {</span>
<span class="line" id="L1851">            <span class="tok-comment">// We can't get field pointers of an untyped inferred alloc, so must perform a</span>
</span>
<span class="line" id="L1852">            <span class="tok-comment">// standard anonymous initialization followed by an rvalue store.</span>
</span>
<span class="line" id="L1853">            <span class="tok-comment">// See corresponding logic in arrayInitExpr.</span>
</span>
<span class="line" id="L1854">            <span class="tok-kw">const</span> struct_inst = <span class="tok-kw">try</span> structInitExprAnon(gz, scope, node, struct_init);</span>
<span class="line" id="L1855">            <span class="tok-kw">return</span> rvalue(gz, ri, struct_inst, node);</span>
<span class="line" id="L1856">        },</span>
<span class="line" id="L1857">        .destructure =&gt; |destructure| {</span>
<span class="line" id="L1858">            <span class="tok-comment">// This is an untyped init, so is an actual struct, which does</span>
</span>
<span class="line" id="L1859">            <span class="tok-comment">// not support destructuring.</span>
</span>
<span class="line" id="L1860">            <span class="tok-kw">return</span> astgen.failNodeNotes(node, <span class="tok-str">&quot;struct value cannot be destructured&quot;</span>, .{}, &amp;.{</span>
<span class="line" id="L1861">                <span class="tok-kw">try</span> astgen.errNoteNode(destructure.src_node, <span class="tok-str">&quot;result destructured here&quot;</span>, .{}),</span>
<span class="line" id="L1862">            });</span>
<span class="line" id="L1863">        },</span>
<span class="line" id="L1864">    }</span>
<span class="line" id="L1865">}</span>
<span class="line" id="L1866"></span>
<span class="line" id="L1867"><span class="tok-comment">/// A struct initialization expression using a `struct_init_anon` instruction.</span></span>
<span class="line" id="L1868"><span class="tok-kw">fn</span> <span class="tok-fn">structInitExprAnon</span>(</span>
<span class="line" id="L1869">    gz: *GenZir,</span>
<span class="line" id="L1870">    scope: *Scope,</span>
<span class="line" id="L1871">    node: Ast.Node.Index,</span>
<span class="line" id="L1872">    struct_init: Ast.full.StructInit,</span>
<span class="line" id="L1873">) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L1874">    <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L1875">    <span class="tok-kw">const</span> tree = astgen.tree;</span>
<span class="line" id="L1876"></span>
<span class="line" id="L1877">    <span class="tok-kw">const</span> payload_index = <span class="tok-kw">try</span> addExtra(astgen, Zir.Inst.StructInitAnon{</span>
<span class="line" id="L1878">        .fields_len = <span class="tok-builtin">@intCast</span>(struct_init.ast.fields.len),</span>
<span class="line" id="L1879">    });</span>
<span class="line" id="L1880">    <span class="tok-kw">const</span> field_size = <span class="tok-builtin">@typeInfo</span>(Zir.Inst.StructInitAnon.Item).Struct.fields.len;</span>
<span class="line" id="L1881">    <span class="tok-kw">var</span> extra_index: <span class="tok-type">usize</span> = <span class="tok-kw">try</span> reserveExtra(astgen, struct_init.ast.fields.len * field_size);</span>
<span class="line" id="L1882"></span>
<span class="line" id="L1883">    <span class="tok-kw">for</span> (struct_init.ast.fields) |field_init| {</span>
<span class="line" id="L1884">        <span class="tok-kw">const</span> name_token = tree.firstToken(field_init) - <span class="tok-number">2</span>;</span>
<span class="line" id="L1885">        <span class="tok-kw">const</span> str_index = <span class="tok-kw">try</span> astgen.identAsString(name_token);</span>
<span class="line" id="L1886">        setExtra(astgen, extra_index, Zir.Inst.StructInitAnon.Item{</span>
<span class="line" id="L1887">            .field_name = str_index,</span>
<span class="line" id="L1888">            .init = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .none }, field_init),</span>
<span class="line" id="L1889">        });</span>
<span class="line" id="L1890">        extra_index += field_size;</span>
<span class="line" id="L1891">    }</span>
<span class="line" id="L1892"></span>
<span class="line" id="L1893">    <span class="tok-kw">return</span> gz.addPlNodePayloadIndex(.struct_init_anon, node, payload_index);</span>
<span class="line" id="L1894">}</span>
<span class="line" id="L1895"></span>
<span class="line" id="L1896"><span class="tok-comment">/// A struct initialization expression using a `struct_init` or `struct_init_ref` instruction.</span></span>
<span class="line" id="L1897"><span class="tok-kw">fn</span> <span class="tok-fn">structInitExprTyped</span>(</span>
<span class="line" id="L1898">    gz: *GenZir,</span>
<span class="line" id="L1899">    scope: *Scope,</span>
<span class="line" id="L1900">    node: Ast.Node.Index,</span>
<span class="line" id="L1901">    struct_init: Ast.full.StructInit,</span>
<span class="line" id="L1902">    ty_inst: Zir.Inst.Ref,</span>
<span class="line" id="L1903">    is_ref: <span class="tok-type">bool</span>,</span>
<span class="line" id="L1904">) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L1905">    <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L1906">    <span class="tok-kw">const</span> tree = astgen.tree;</span>
<span class="line" id="L1907"></span>
<span class="line" id="L1908">    <span class="tok-kw">const</span> payload_index = <span class="tok-kw">try</span> addExtra(astgen, Zir.Inst.StructInit{</span>
<span class="line" id="L1909">        .fields_len = <span class="tok-builtin">@intCast</span>(struct_init.ast.fields.len),</span>
<span class="line" id="L1910">    });</span>
<span class="line" id="L1911">    <span class="tok-kw">const</span> field_size = <span class="tok-builtin">@typeInfo</span>(Zir.Inst.StructInit.Item).Struct.fields.len;</span>
<span class="line" id="L1912">    <span class="tok-kw">var</span> extra_index: <span class="tok-type">usize</span> = <span class="tok-kw">try</span> reserveExtra(astgen, struct_init.ast.fields.len * field_size);</span>
<span class="line" id="L1913"></span>
<span class="line" id="L1914">    <span class="tok-kw">for</span> (struct_init.ast.fields) |field_init| {</span>
<span class="line" id="L1915">        <span class="tok-kw">const</span> name_token = tree.firstToken(field_init) - <span class="tok-number">2</span>;</span>
<span class="line" id="L1916">        <span class="tok-kw">const</span> str_index = <span class="tok-kw">try</span> astgen.identAsString(name_token);</span>
<span class="line" id="L1917">        <span class="tok-kw">const</span> field_ty_inst = <span class="tok-kw">try</span> gz.addPlNode(.struct_init_field_type, field_init, Zir.Inst.FieldType{</span>
<span class="line" id="L1918">            .container_type = ty_inst,</span>
<span class="line" id="L1919">            .name_start = str_index,</span>
<span class="line" id="L1920">        });</span>
<span class="line" id="L1921">        setExtra(astgen, extra_index, Zir.Inst.StructInit.Item{</span>
<span class="line" id="L1922">            .field_type = field_ty_inst.toIndex().?,</span>
<span class="line" id="L1923">            .init = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .{ .coerced_ty = field_ty_inst } }, field_init),</span>
<span class="line" id="L1924">        });</span>
<span class="line" id="L1925">        extra_index += field_size;</span>
<span class="line" id="L1926">    }</span>
<span class="line" id="L1927"></span>
<span class="line" id="L1928">    <span class="tok-kw">const</span> tag: Zir.Inst.Tag = <span class="tok-kw">if</span> (is_ref) .struct_init_ref <span class="tok-kw">else</span> .struct_init;</span>
<span class="line" id="L1929">    <span class="tok-kw">return</span> gz.addPlNodePayloadIndex(tag, node, payload_index);</span>
<span class="line" id="L1930">}</span>
<span class="line" id="L1931"></span>
<span class="line" id="L1932"><span class="tok-comment">/// A struct initialization expression using field pointers.</span></span>
<span class="line" id="L1933"><span class="tok-kw">fn</span> <span class="tok-fn">structInitExprPtr</span>(</span>
<span class="line" id="L1934">    gz: *GenZir,</span>
<span class="line" id="L1935">    scope: *Scope,</span>
<span class="line" id="L1936">    node: Ast.Node.Index,</span>
<span class="line" id="L1937">    struct_init: Ast.full.StructInit,</span>
<span class="line" id="L1938">    ptr_inst: Zir.Inst.Ref,</span>
<span class="line" id="L1939">) InnerError!<span class="tok-type">void</span> {</span>
<span class="line" id="L1940">    <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L1941">    <span class="tok-kw">const</span> tree = astgen.tree;</span>
<span class="line" id="L1942"></span>
<span class="line" id="L1943">    <span class="tok-kw">const</span> struct_ptr_inst = <span class="tok-kw">try</span> gz.addUnNode(.opt_eu_base_ptr_init, ptr_inst, node);</span>
<span class="line" id="L1944"></span>
<span class="line" id="L1945">    <span class="tok-kw">const</span> payload_index = <span class="tok-kw">try</span> addExtra(astgen, Zir.Inst.Block{</span>
<span class="line" id="L1946">        .body_len = <span class="tok-builtin">@intCast</span>(struct_init.ast.fields.len),</span>
<span class="line" id="L1947">    });</span>
<span class="line" id="L1948">    <span class="tok-kw">var</span> extra_index = <span class="tok-kw">try</span> reserveExtra(astgen, struct_init.ast.fields.len);</span>
<span class="line" id="L1949"></span>
<span class="line" id="L1950">    <span class="tok-kw">for</span> (struct_init.ast.fields) |field_init| {</span>
<span class="line" id="L1951">        <span class="tok-kw">const</span> name_token = tree.firstToken(field_init) - <span class="tok-number">2</span>;</span>
<span class="line" id="L1952">        <span class="tok-kw">const</span> str_index = <span class="tok-kw">try</span> astgen.identAsString(name_token);</span>
<span class="line" id="L1953">        <span class="tok-kw">const</span> field_ptr = <span class="tok-kw">try</span> gz.addPlNode(.struct_init_field_ptr, field_init, Zir.Inst.Field{</span>
<span class="line" id="L1954">            .lhs = struct_ptr_inst,</span>
<span class="line" id="L1955">            .field_name_start = str_index,</span>
<span class="line" id="L1956">        });</span>
<span class="line" id="L1957">        astgen.extra.items[extra_index] = <span class="tok-builtin">@intFromEnum</span>(field_ptr.toIndex().?);</span>
<span class="line" id="L1958">        extra_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L1959">        _ = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .{ .ptr = .{ .inst = field_ptr } } }, field_init);</span>
<span class="line" id="L1960">    }</span>
<span class="line" id="L1961"></span>
<span class="line" id="L1962">    _ = <span class="tok-kw">try</span> gz.addPlNodePayloadIndex(.validate_ptr_struct_init, node, payload_index);</span>
<span class="line" id="L1963">}</span>
<span class="line" id="L1964"></span>
<span class="line" id="L1965"><span class="tok-comment">/// This explicitly calls expr in a comptime scope by wrapping it in a `block_comptime` if</span></span>
<span class="line" id="L1966"><span class="tok-comment">/// necessary. It should be used whenever we need to force compile-time evaluation of something,</span></span>
<span class="line" id="L1967"><span class="tok-comment">/// such as a type.</span></span>
<span class="line" id="L1968"><span class="tok-comment">/// The function corresponding to `comptime` expression syntax is `comptimeExprAst`.</span></span>
<span class="line" id="L1969"><span class="tok-kw">fn</span> <span class="tok-fn">comptimeExpr</span>(</span>
<span class="line" id="L1970">    gz: *GenZir,</span>
<span class="line" id="L1971">    scope: *Scope,</span>
<span class="line" id="L1972">    ri: ResultInfo,</span>
<span class="line" id="L1973">    node: Ast.Node.Index,</span>
<span class="line" id="L1974">) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L1975">    <span class="tok-kw">if</span> (gz.is_comptime) {</span>
<span class="line" id="L1976">        <span class="tok-comment">// No need to change anything!</span>
</span>
<span class="line" id="L1977">        <span class="tok-kw">return</span> expr(gz, scope, ri, node);</span>
<span class="line" id="L1978">    }</span>
<span class="line" id="L1979"></span>
<span class="line" id="L1980">    <span class="tok-comment">// There's an optimization here: if the body will be evaluated at comptime regardless, there's</span>
</span>
<span class="line" id="L1981">    <span class="tok-comment">// no need to wrap it in a block. This is hard to determine in general, but we can identify a</span>
</span>
<span class="line" id="L1982">    <span class="tok-comment">// common subset of trivially comptime expressions to take down the size of the ZIR a bit.</span>
</span>
<span class="line" id="L1983">    <span class="tok-kw">const</span> tree = gz.astgen.tree;</span>
<span class="line" id="L1984">    <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);</span>
<span class="line" id="L1985">    <span class="tok-kw">const</span> node_tags = tree.nodes.items(.tag);</span>
<span class="line" id="L1986">    <span class="tok-kw">switch</span> (node_tags[node]) {</span>
<span class="line" id="L1987">        <span class="tok-comment">// Any identifier in `primitive_instrs` is trivially comptime. In particular, this includes</span>
</span>
<span class="line" id="L1988">        <span class="tok-comment">// some common types, so we can elide `block_comptime` for a few common type annotations.</span>
</span>
<span class="line" id="L1989">        .identifier =&gt; {</span>
<span class="line" id="L1990">            <span class="tok-kw">const</span> ident_token = main_tokens[node];</span>
<span class="line" id="L1991">            <span class="tok-kw">const</span> ident_name_raw = tree.tokenSlice(ident_token);</span>
<span class="line" id="L1992">            <span class="tok-kw">if</span> (primitive_instrs.get(ident_name_raw)) |zir_const_ref| {</span>
<span class="line" id="L1993">                <span class="tok-comment">// No need to worry about result location here, we're not creating a comptime block!</span>
</span>
<span class="line" id="L1994">                <span class="tok-kw">return</span> rvalue(gz, ri, zir_const_ref, node);</span>
<span class="line" id="L1995">            }</span>
<span class="line" id="L1996">        },</span>
<span class="line" id="L1997"></span>
<span class="line" id="L1998">        <span class="tok-comment">// We can also avoid the block for a few trivial AST tags which are always comptime-known.</span>
</span>
<span class="line" id="L1999">        .number_literal, .string_literal, .multiline_string_literal, .enum_literal, .error_value =&gt; {</span>
<span class="line" id="L2000">            <span class="tok-comment">// No need to worry about result location here, we're not creating a comptime block!</span>
</span>
<span class="line" id="L2001">            <span class="tok-kw">return</span> expr(gz, scope, ri, node);</span>
<span class="line" id="L2002">        },</span>
<span class="line" id="L2003"></span>
<span class="line" id="L2004">        <span class="tok-comment">// Lastly, for labelled blocks, avoid emitting a labelled block directly inside this</span>
</span>
<span class="line" id="L2005">        <span class="tok-comment">// comptime block, because that would be silly! Note that we don't bother doing this for</span>
</span>
<span class="line" id="L2006">        <span class="tok-comment">// unlabelled blocks, since they don't generate blocks at comptime anyway (see `blockExpr`).</span>
</span>
<span class="line" id="L2007">        .block_two, .block_two_semicolon, .block, .block_semicolon =&gt; {</span>
<span class="line" id="L2008">            <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);</span>
<span class="line" id="L2009">            <span class="tok-kw">const</span> lbrace = main_tokens[node];</span>
<span class="line" id="L2010">            <span class="tok-comment">// Careful! We can't pass in the real result location here, since it may</span>
</span>
<span class="line" id="L2011">            <span class="tok-comment">// refer to runtime memory. A runtime-to-comptime boundary has to remove</span>
</span>
<span class="line" id="L2012">            <span class="tok-comment">// result location information, compute the result, and copy it to the true</span>
</span>
<span class="line" id="L2013">            <span class="tok-comment">// result location at runtime. We do this below as well.</span>
</span>
<span class="line" id="L2014">            <span class="tok-kw">const</span> ty_only_ri: ResultInfo = .{</span>
<span class="line" id="L2015">                .ctx = ri.ctx,</span>
<span class="line" id="L2016">                .rl = <span class="tok-kw">if</span> (<span class="tok-kw">try</span> ri.rl.resultType(gz, node)) |res_ty|</span>
<span class="line" id="L2017">                    .{ .coerced_ty = res_ty }</span>
<span class="line" id="L2018">                <span class="tok-kw">else</span></span>
<span class="line" id="L2019">                    .none,</span>
<span class="line" id="L2020">            };</span>
<span class="line" id="L2021">            <span class="tok-kw">if</span> (token_tags[lbrace - <span class="tok-number">1</span>] == .colon <span class="tok-kw">and</span></span>
<span class="line" id="L2022">                token_tags[lbrace - <span class="tok-number">2</span>] == .identifier)</span>
<span class="line" id="L2023">            {</span>
<span class="line" id="L2024">                <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);</span>
<span class="line" id="L2025">                <span class="tok-kw">switch</span> (node_tags[node]) {</span>
<span class="line" id="L2026">                    .block_two, .block_two_semicolon =&gt; {</span>
<span class="line" id="L2027">                        <span class="tok-kw">const</span> stmts: [<span class="tok-number">2</span>]Ast.Node.Index = .{ node_datas[node].lhs, node_datas[node].rhs };</span>
<span class="line" id="L2028">                        <span class="tok-kw">const</span> stmt_slice = <span class="tok-kw">if</span> (stmts[<span class="tok-number">0</span>] == <span class="tok-number">0</span>)</span>
<span class="line" id="L2029">                            stmts[<span class="tok-number">0</span>..<span class="tok-number">0</span>]</span>
<span class="line" id="L2030">                        <span class="tok-kw">else</span> <span class="tok-kw">if</span> (stmts[<span class="tok-number">1</span>] == <span class="tok-number">0</span>)</span>
<span class="line" id="L2031">                            stmts[<span class="tok-number">0</span>..<span class="tok-number">1</span>]</span>
<span class="line" id="L2032">                        <span class="tok-kw">else</span></span>
<span class="line" id="L2033">                            stmts[<span class="tok-number">0</span>..<span class="tok-number">2</span>];</span>
<span class="line" id="L2034"></span>
<span class="line" id="L2035">                        <span class="tok-kw">const</span> block_ref = <span class="tok-kw">try</span> labeledBlockExpr(gz, scope, ty_only_ri, node, stmt_slice, <span class="tok-null">true</span>);</span>
<span class="line" id="L2036">                        <span class="tok-kw">return</span> rvalue(gz, ri, block_ref, node);</span>
<span class="line" id="L2037">                    },</span>
<span class="line" id="L2038">                    .block, .block_semicolon =&gt; {</span>
<span class="line" id="L2039">                        <span class="tok-kw">const</span> stmts = tree.extra_data[node_datas[node].lhs..node_datas[node].rhs];</span>
<span class="line" id="L2040">                        <span class="tok-comment">// Replace result location and copy back later - see above.</span>
</span>
<span class="line" id="L2041">                        <span class="tok-kw">const</span> block_ref = <span class="tok-kw">try</span> labeledBlockExpr(gz, scope, ty_only_ri, node, stmts, <span class="tok-null">true</span>);</span>
<span class="line" id="L2042">                        <span class="tok-kw">return</span> rvalue(gz, ri, block_ref, node);</span>
<span class="line" id="L2043">                    },</span>
<span class="line" id="L2044">                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L2045">                }</span>
<span class="line" id="L2046">            }</span>
<span class="line" id="L2047">        },</span>
<span class="line" id="L2048"></span>
<span class="line" id="L2049">        <span class="tok-comment">// In other cases, we don't optimize anything - we need a wrapper comptime block.</span>
</span>
<span class="line" id="L2050">        <span class="tok-kw">else</span> =&gt; {},</span>
<span class="line" id="L2051">    }</span>
<span class="line" id="L2052"></span>
<span class="line" id="L2053">    <span class="tok-kw">var</span> block_scope = gz.makeSubBlock(scope);</span>
<span class="line" id="L2054">    block_scope.is_comptime = <span class="tok-null">true</span>;</span>
<span class="line" id="L2055">    <span class="tok-kw">defer</span> block_scope.unstack();</span>
<span class="line" id="L2056"></span>
<span class="line" id="L2057">    <span class="tok-kw">const</span> block_inst = <span class="tok-kw">try</span> gz.makeBlockInst(.block_comptime, node);</span>
<span class="line" id="L2058">    <span class="tok-comment">// Replace result location and copy back later - see above.</span>
</span>
<span class="line" id="L2059">    <span class="tok-kw">const</span> ty_only_ri: ResultInfo = .{</span>
<span class="line" id="L2060">        .ctx = ri.ctx,</span>
<span class="line" id="L2061">        .rl = <span class="tok-kw">if</span> (<span class="tok-kw">try</span> ri.rl.resultType(gz, node)) |res_ty|</span>
<span class="line" id="L2062">            .{ .coerced_ty = res_ty }</span>
<span class="line" id="L2063">        <span class="tok-kw">else</span></span>
<span class="line" id="L2064">            .none,</span>
<span class="line" id="L2065">    };</span>
<span class="line" id="L2066">    <span class="tok-kw">const</span> block_result = <span class="tok-kw">try</span> fullBodyExpr(&amp;block_scope, scope, ty_only_ri, node);</span>
<span class="line" id="L2067">    <span class="tok-kw">if</span> (!gz.refIsNoReturn(block_result)) {</span>
<span class="line" id="L2068">        _ = <span class="tok-kw">try</span> block_scope.addBreak(.@&quot;break&quot;, block_inst, block_result);</span>
<span class="line" id="L2069">    }</span>
<span class="line" id="L2070">    <span class="tok-kw">try</span> block_scope.setBlockBody(block_inst);</span>
<span class="line" id="L2071">    <span class="tok-kw">try</span> gz.instructions.append(gz.astgen.gpa, block_inst);</span>
<span class="line" id="L2072"></span>
<span class="line" id="L2073">    <span class="tok-kw">return</span> rvalue(gz, ri, block_inst.toRef(), node);</span>
<span class="line" id="L2074">}</span>
<span class="line" id="L2075"></span>
<span class="line" id="L2076"><span class="tok-comment">/// This one is for an actual `comptime` syntax, and will emit a compile error if</span></span>
<span class="line" id="L2077"><span class="tok-comment">/// the scope is already known to be comptime-evaluated.</span></span>
<span class="line" id="L2078"><span class="tok-comment">/// See `comptimeExpr` for the helper function for calling expr in a comptime scope.</span></span>
<span class="line" id="L2079"><span class="tok-kw">fn</span> <span class="tok-fn">comptimeExprAst</span>(</span>
<span class="line" id="L2080">    gz: *GenZir,</span>
<span class="line" id="L2081">    scope: *Scope,</span>
<span class="line" id="L2082">    ri: ResultInfo,</span>
<span class="line" id="L2083">    node: Ast.Node.Index,</span>
<span class="line" id="L2084">) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L2085">    <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L2086">    <span class="tok-kw">if</span> (gz.is_comptime) {</span>
<span class="line" id="L2087">        <span class="tok-kw">return</span> astgen.failNode(node, <span class="tok-str">&quot;redundant comptime keyword in already comptime scope&quot;</span>, .{});</span>
<span class="line" id="L2088">    }</span>
<span class="line" id="L2089">    <span class="tok-kw">const</span> tree = astgen.tree;</span>
<span class="line" id="L2090">    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);</span>
<span class="line" id="L2091">    <span class="tok-kw">const</span> body_node = node_datas[node].lhs;</span>
<span class="line" id="L2092">    <span class="tok-kw">return</span> comptimeExpr(gz, scope, ri, body_node);</span>
<span class="line" id="L2093">}</span>
<span class="line" id="L2094"></span>
<span class="line" id="L2095"><span class="tok-comment">/// Restore the error return trace index. Performs the restore only if the result is a non-error or</span></span>
<span class="line" id="L2096"><span class="tok-comment">/// if the result location is a non-error-handling expression.</span></span>
<span class="line" id="L2097"><span class="tok-kw">fn</span> <span class="tok-fn">restoreErrRetIndex</span>(</span>
<span class="line" id="L2098">    gz: *GenZir,</span>
<span class="line" id="L2099">    bt: GenZir.BranchTarget,</span>
<span class="line" id="L2100">    ri: ResultInfo,</span>
<span class="line" id="L2101">    node: Ast.Node.Index,</span>
<span class="line" id="L2102">    result: Zir.Inst.Ref,</span>
<span class="line" id="L2103">) !<span class="tok-type">void</span> {</span>
<span class="line" id="L2104">    <span class="tok-kw">const</span> op = <span class="tok-kw">switch</span> (nodeMayEvalToError(gz.astgen.tree, node)) {</span>
<span class="line" id="L2105">        .always =&gt; <span class="tok-kw">return</span>, <span class="tok-comment">// never restore/pop</span>
</span>
<span class="line" id="L2106">        .never =&gt; .none, <span class="tok-comment">// always restore/pop</span>
</span>
<span class="line" id="L2107">        .maybe =&gt; <span class="tok-kw">switch</span> (ri.ctx) {</span>
<span class="line" id="L2108">            .error_handling_expr, .@&quot;return&quot;, .fn_arg, .const_init =&gt; <span class="tok-kw">switch</span> (ri.rl) {</span>
<span class="line" id="L2109">                .ptr =&gt; |ptr_res| <span class="tok-kw">try</span> gz.addUnNode(.load, ptr_res.inst, node),</span>
<span class="line" id="L2110">                .inferred_ptr =&gt; blk: {</span>
<span class="line" id="L2111">                    <span class="tok-comment">// This is a terrible workaround for Sema's inability to load from a .alloc_inferred ptr</span>
</span>
<span class="line" id="L2112">                    <span class="tok-comment">// before its type has been resolved. There is no valid operand to use here, so error</span>
</span>
<span class="line" id="L2113">                    <span class="tok-comment">// traces will be popped prematurely.</span>
</span>
<span class="line" id="L2114">                    <span class="tok-comment">// TODO: Update this to do a proper load from the rl_ptr, once Sema can support it.</span>
</span>
<span class="line" id="L2115">                    <span class="tok-kw">break</span> :blk .none;</span>
<span class="line" id="L2116">                },</span>
<span class="line" id="L2117">                .destructure =&gt; <span class="tok-kw">return</span>, <span class="tok-comment">// value must be a tuple or array, so never restore/pop</span>
</span>
<span class="line" id="L2118">                <span class="tok-kw">else</span> =&gt; result,</span>
<span class="line" id="L2119">            },</span>
<span class="line" id="L2120">            <span class="tok-kw">else</span> =&gt; .none, <span class="tok-comment">// always restore/pop</span>
</span>
<span class="line" id="L2121">        },</span>
<span class="line" id="L2122">    };</span>
<span class="line" id="L2123">    _ = <span class="tok-kw">try</span> gz.addRestoreErrRetIndex(bt, .{ .if_non_error = op }, node);</span>
<span class="line" id="L2124">}</span>
<span class="line" id="L2125"></span>
<span class="line" id="L2126"><span class="tok-kw">fn</span> <span class="tok-fn">breakExpr</span>(parent_gz: *GenZir, parent_scope: *Scope, node: Ast.Node.Index) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L2127">    <span class="tok-kw">const</span> astgen = parent_gz.astgen;</span>
<span class="line" id="L2128">    <span class="tok-kw">const</span> tree = astgen.tree;</span>
<span class="line" id="L2129">    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);</span>
<span class="line" id="L2130">    <span class="tok-kw">const</span> break_label = node_datas[node].lhs;</span>
<span class="line" id="L2131">    <span class="tok-kw">const</span> rhs = node_datas[node].rhs;</span>
<span class="line" id="L2132"></span>
<span class="line" id="L2133">    <span class="tok-comment">// Look for the label in the scope.</span>
</span>
<span class="line" id="L2134">    <span class="tok-kw">var</span> scope = parent_scope;</span>
<span class="line" id="L2135">    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L2136">        <span class="tok-kw">switch</span> (scope.tag) {</span>
<span class="line" id="L2137">            .gen_zir =&gt; {</span>
<span class="line" id="L2138">                <span class="tok-kw">const</span> block_gz = scope.cast(GenZir).?;</span>
<span class="line" id="L2139"></span>
<span class="line" id="L2140">                <span class="tok-kw">if</span> (block_gz.cur_defer_node != <span class="tok-number">0</span>) {</span>
<span class="line" id="L2141">                    <span class="tok-comment">// We are breaking out of a `defer` block.</span>
</span>
<span class="line" id="L2142">                    <span class="tok-kw">return</span> astgen.failNodeNotes(node, <span class="tok-str">&quot;cannot break out of defer expression&quot;</span>, .{}, &amp;.{</span>
<span class="line" id="L2143">                        <span class="tok-kw">try</span> astgen.errNoteNode(</span>
<span class="line" id="L2144">                            block_gz.cur_defer_node,</span>
<span class="line" id="L2145">                            <span class="tok-str">&quot;defer expression here&quot;</span>,</span>
<span class="line" id="L2146">                            .{},</span>
<span class="line" id="L2147">                        ),</span>
<span class="line" id="L2148">                    });</span>
<span class="line" id="L2149">                }</span>
<span class="line" id="L2150"></span>
<span class="line" id="L2151">                <span class="tok-kw">const</span> block_inst = blk: {</span>
<span class="line" id="L2152">                    <span class="tok-kw">if</span> (break_label != <span class="tok-number">0</span>) {</span>
<span class="line" id="L2153">                        <span class="tok-kw">if</span> (block_gz.label) |*label| {</span>
<span class="line" id="L2154">                            <span class="tok-kw">if</span> (<span class="tok-kw">try</span> astgen.tokenIdentEql(label.token, break_label)) {</span>
<span class="line" id="L2155">                                label.used = <span class="tok-null">true</span>;</span>
<span class="line" id="L2156">                                <span class="tok-kw">break</span> :blk label.block_inst;</span>
<span class="line" id="L2157">                            }</span>
<span class="line" id="L2158">                        }</span>
<span class="line" id="L2159">                    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (block_gz.break_block.unwrap()) |i| {</span>
<span class="line" id="L2160">                        <span class="tok-kw">break</span> :blk i;</span>
<span class="line" id="L2161">                    }</span>
<span class="line" id="L2162">                    <span class="tok-comment">// If not the target, start over with the parent</span>
</span>
<span class="line" id="L2163">                    scope = block_gz.parent;</span>
<span class="line" id="L2164">                    <span class="tok-kw">continue</span>;</span>
<span class="line" id="L2165">                };</span>
<span class="line" id="L2166">                <span class="tok-comment">// If we made it here, this block is the target of the break expr</span>
</span>
<span class="line" id="L2167"></span>
<span class="line" id="L2168">                <span class="tok-kw">const</span> break_tag: Zir.Inst.Tag = <span class="tok-kw">if</span> (block_gz.is_inline)</span>
<span class="line" id="L2169">                    .break_inline</span>
<span class="line" id="L2170">                <span class="tok-kw">else</span></span>
<span class="line" id="L2171">                    .@&quot;break&quot;;</span>
<span class="line" id="L2172"></span>
<span class="line" id="L2173">                <span class="tok-kw">if</span> (rhs == <span class="tok-number">0</span>) {</span>
<span class="line" id="L2174">                    _ = <span class="tok-kw">try</span> rvalue(parent_gz, block_gz.break_result_info, .void_value, node);</span>
<span class="line" id="L2175"></span>
<span class="line" id="L2176">                    <span class="tok-kw">try</span> genDefers(parent_gz, scope, parent_scope, .normal_only);</span>
<span class="line" id="L2177"></span>
<span class="line" id="L2178">                    <span class="tok-comment">// As our last action before the break, &quot;pop&quot; the error trace if needed</span>
</span>
<span class="line" id="L2179">                    <span class="tok-kw">if</span> (!block_gz.is_comptime)</span>
<span class="line" id="L2180">                        _ = <span class="tok-kw">try</span> parent_gz.addRestoreErrRetIndex(.{ .block = block_inst }, .always, node);</span>
<span class="line" id="L2181"></span>
<span class="line" id="L2182">                    _ = <span class="tok-kw">try</span> parent_gz.addBreak(break_tag, block_inst, .void_value);</span>
<span class="line" id="L2183">                    <span class="tok-kw">return</span> Zir.Inst.Ref.unreachable_value;</span>
<span class="line" id="L2184">                }</span>
<span class="line" id="L2185"></span>
<span class="line" id="L2186">                <span class="tok-kw">const</span> operand = <span class="tok-kw">try</span> reachableExpr(parent_gz, parent_scope, block_gz.break_result_info, rhs, node);</span>
<span class="line" id="L2187"></span>
<span class="line" id="L2188">                <span class="tok-kw">try</span> genDefers(parent_gz, scope, parent_scope, .normal_only);</span>
<span class="line" id="L2189"></span>
<span class="line" id="L2190">                <span class="tok-comment">// As our last action before the break, &quot;pop&quot; the error trace if needed</span>
</span>
<span class="line" id="L2191">                <span class="tok-kw">if</span> (!block_gz.is_comptime)</span>
<span class="line" id="L2192">                    <span class="tok-kw">try</span> restoreErrRetIndex(parent_gz, .{ .block = block_inst }, block_gz.break_result_info, rhs, operand);</span>
<span class="line" id="L2193"></span>
<span class="line" id="L2194">                <span class="tok-kw">switch</span> (block_gz.break_result_info.rl) {</span>
<span class="line" id="L2195">                    .ptr =&gt; {</span>
<span class="line" id="L2196">                        <span class="tok-comment">// In this case we don't have any mechanism to intercept it;</span>
</span>
<span class="line" id="L2197">                        <span class="tok-comment">// we assume the result location is written, and we break with void.</span>
</span>
<span class="line" id="L2198">                        _ = <span class="tok-kw">try</span> parent_gz.addBreak(break_tag, block_inst, .void_value);</span>
<span class="line" id="L2199">                    },</span>
<span class="line" id="L2200">                    .discard =&gt; {</span>
<span class="line" id="L2201">                        _ = <span class="tok-kw">try</span> parent_gz.addBreak(break_tag, block_inst, .void_value);</span>
<span class="line" id="L2202">                    },</span>
<span class="line" id="L2203">                    <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L2204">                        _ = <span class="tok-kw">try</span> parent_gz.addBreakWithSrcNode(break_tag, block_inst, operand, rhs);</span>
<span class="line" id="L2205">                    },</span>
<span class="line" id="L2206">                }</span>
<span class="line" id="L2207">                <span class="tok-kw">return</span> Zir.Inst.Ref.unreachable_value;</span>
<span class="line" id="L2208">            },</span>
<span class="line" id="L2209">            .local_val =&gt; scope = scope.cast(Scope.LocalVal).?.parent,</span>
<span class="line" id="L2210">            .local_ptr =&gt; scope = scope.cast(Scope.LocalPtr).?.parent,</span>
<span class="line" id="L2211">            .namespace =&gt; <span class="tok-kw">break</span>,</span>
<span class="line" id="L2212">            .defer_normal, .defer_error =&gt; scope = scope.cast(Scope.Defer).?.parent,</span>
<span class="line" id="L2213">            .top =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L2214">        }</span>
<span class="line" id="L2215">    }</span>
<span class="line" id="L2216">    <span class="tok-kw">if</span> (break_label != <span class="tok-number">0</span>) {</span>
<span class="line" id="L2217">        <span class="tok-kw">const</span> label_name = <span class="tok-kw">try</span> astgen.identifierTokenString(break_label);</span>
<span class="line" id="L2218">        <span class="tok-kw">return</span> astgen.failTok(break_label, <span class="tok-str">&quot;label not found: '{s}'&quot;</span>, .{label_name});</span>
<span class="line" id="L2219">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2220">        <span class="tok-kw">return</span> astgen.failNode(node, <span class="tok-str">&quot;break expression outside loop&quot;</span>, .{});</span>
<span class="line" id="L2221">    }</span>
<span class="line" id="L2222">}</span>
<span class="line" id="L2223"></span>
<span class="line" id="L2224"><span class="tok-kw">fn</span> <span class="tok-fn">continueExpr</span>(parent_gz: *GenZir, parent_scope: *Scope, node: Ast.Node.Index) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L2225">    <span class="tok-kw">const</span> astgen = parent_gz.astgen;</span>
<span class="line" id="L2226">    <span class="tok-kw">const</span> tree = astgen.tree;</span>
<span class="line" id="L2227">    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);</span>
<span class="line" id="L2228">    <span class="tok-kw">const</span> break_label = node_datas[node].lhs;</span>
<span class="line" id="L2229"></span>
<span class="line" id="L2230">    <span class="tok-comment">// Look for the label in the scope.</span>
</span>
<span class="line" id="L2231">    <span class="tok-kw">var</span> scope = parent_scope;</span>
<span class="line" id="L2232">    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L2233">        <span class="tok-kw">switch</span> (scope.tag) {</span>
<span class="line" id="L2234">            .gen_zir =&gt; {</span>
<span class="line" id="L2235">                <span class="tok-kw">const</span> gen_zir = scope.cast(GenZir).?;</span>
<span class="line" id="L2236"></span>
<span class="line" id="L2237">                <span class="tok-kw">if</span> (gen_zir.cur_defer_node != <span class="tok-number">0</span>) {</span>
<span class="line" id="L2238">                    <span class="tok-kw">return</span> astgen.failNodeNotes(node, <span class="tok-str">&quot;cannot continue out of defer expression&quot;</span>, .{}, &amp;.{</span>
<span class="line" id="L2239">                        <span class="tok-kw">try</span> astgen.errNoteNode(</span>
<span class="line" id="L2240">                            gen_zir.cur_defer_node,</span>
<span class="line" id="L2241">                            <span class="tok-str">&quot;defer expression here&quot;</span>,</span>
<span class="line" id="L2242">                            .{},</span>
<span class="line" id="L2243">                        ),</span>
<span class="line" id="L2244">                    });</span>
<span class="line" id="L2245">                }</span>
<span class="line" id="L2246">                <span class="tok-kw">const</span> continue_block = gen_zir.continue_block.unwrap() <span class="tok-kw">orelse</span> {</span>
<span class="line" id="L2247">                    scope = gen_zir.parent;</span>
<span class="line" id="L2248">                    <span class="tok-kw">continue</span>;</span>
<span class="line" id="L2249">                };</span>
<span class="line" id="L2250">                <span class="tok-kw">if</span> (break_label != <span class="tok-number">0</span>) blk: {</span>
<span class="line" id="L2251">                    <span class="tok-kw">if</span> (gen_zir.label) |*label| {</span>
<span class="line" id="L2252">                        <span class="tok-kw">if</span> (<span class="tok-kw">try</span> astgen.tokenIdentEql(label.token, break_label)) {</span>
<span class="line" id="L2253">                            label.used = <span class="tok-null">true</span>;</span>
<span class="line" id="L2254">                            <span class="tok-kw">break</span> :blk;</span>
<span class="line" id="L2255">                        }</span>
<span class="line" id="L2256">                    }</span>
<span class="line" id="L2257">                    <span class="tok-comment">// found continue but either it has a different label, or no label</span>
</span>
<span class="line" id="L2258">                    scope = gen_zir.parent;</span>
<span class="line" id="L2259">                    <span class="tok-kw">continue</span>;</span>
<span class="line" id="L2260">                }</span>
<span class="line" id="L2261"></span>
<span class="line" id="L2262">                <span class="tok-kw">const</span> break_tag: Zir.Inst.Tag = <span class="tok-kw">if</span> (gen_zir.is_inline)</span>
<span class="line" id="L2263">                    .break_inline</span>
<span class="line" id="L2264">                <span class="tok-kw">else</span></span>
<span class="line" id="L2265">                    .@&quot;break&quot;;</span>
<span class="line" id="L2266">                <span class="tok-kw">if</span> (break_tag == .break_inline) {</span>
<span class="line" id="L2267">                    _ = <span class="tok-kw">try</span> parent_gz.addUnNode(.check_comptime_control_flow, continue_block.toRef(), node);</span>
<span class="line" id="L2268">                }</span>
<span class="line" id="L2269"></span>
<span class="line" id="L2270">                <span class="tok-comment">// As our last action before the continue, &quot;pop&quot; the error trace if needed</span>
</span>
<span class="line" id="L2271">                <span class="tok-kw">if</span> (!gen_zir.is_comptime)</span>
<span class="line" id="L2272">                    _ = <span class="tok-kw">try</span> parent_gz.addRestoreErrRetIndex(.{ .block = continue_block }, .always, node);</span>
<span class="line" id="L2273"></span>
<span class="line" id="L2274">                _ = <span class="tok-kw">try</span> parent_gz.addBreak(break_tag, continue_block, .void_value);</span>
<span class="line" id="L2275">                <span class="tok-kw">return</span> Zir.Inst.Ref.unreachable_value;</span>
<span class="line" id="L2276">            },</span>
<span class="line" id="L2277">            .local_val =&gt; scope = scope.cast(Scope.LocalVal).?.parent,</span>
<span class="line" id="L2278">            .local_ptr =&gt; scope = scope.cast(Scope.LocalPtr).?.parent,</span>
<span class="line" id="L2279">            .defer_normal =&gt; {</span>
<span class="line" id="L2280">                <span class="tok-kw">const</span> defer_scope = scope.cast(Scope.Defer).?;</span>
<span class="line" id="L2281">                scope = defer_scope.parent;</span>
<span class="line" id="L2282">                <span class="tok-kw">try</span> parent_gz.addDefer(defer_scope.index, defer_scope.len);</span>
<span class="line" id="L2283">            },</span>
<span class="line" id="L2284">            .defer_error =&gt; scope = scope.cast(Scope.Defer).?.parent,</span>
<span class="line" id="L2285">            .namespace =&gt; <span class="tok-kw">break</span>,</span>
<span class="line" id="L2286">            .top =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L2287">        }</span>
<span class="line" id="L2288">    }</span>
<span class="line" id="L2289">    <span class="tok-kw">if</span> (break_label != <span class="tok-number">0</span>) {</span>
<span class="line" id="L2290">        <span class="tok-kw">const</span> label_name = <span class="tok-kw">try</span> astgen.identifierTokenString(break_label);</span>
<span class="line" id="L2291">        <span class="tok-kw">return</span> astgen.failTok(break_label, <span class="tok-str">&quot;label not found: '{s}'&quot;</span>, .{label_name});</span>
<span class="line" id="L2292">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2293">        <span class="tok-kw">return</span> astgen.failNode(node, <span class="tok-str">&quot;continue expression outside loop&quot;</span>, .{});</span>
<span class="line" id="L2294">    }</span>
<span class="line" id="L2295">}</span>
<span class="line" id="L2296"></span>
<span class="line" id="L2297"><span class="tok-comment">/// Similar to `expr`, but intended for use when `gz` corresponds to a body</span></span>
<span class="line" id="L2298"><span class="tok-comment">/// which will contain only this node's code. Differs from `expr` in that if the</span></span>
<span class="line" id="L2299"><span class="tok-comment">/// root expression is an unlabeled block, does not emit an actual block.</span></span>
<span class="line" id="L2300"><span class="tok-comment">/// Instead, the block contents are emitted directly into `gz`.</span></span>
<span class="line" id="L2301"><span class="tok-kw">fn</span> <span class="tok-fn">fullBodyExpr</span>(</span>
<span class="line" id="L2302">    gz: *GenZir,</span>
<span class="line" id="L2303">    scope: *Scope,</span>
<span class="line" id="L2304">    ri: ResultInfo,</span>
<span class="line" id="L2305">    node: Ast.Node.Index,</span>
<span class="line" id="L2306">) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L2307">    <span class="tok-kw">const</span> tree = gz.astgen.tree;</span>
<span class="line" id="L2308">    <span class="tok-kw">const</span> node_tags = tree.nodes.items(.tag);</span>
<span class="line" id="L2309">    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);</span>
<span class="line" id="L2310">    <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);</span>
<span class="line" id="L2311">    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);</span>
<span class="line" id="L2312">    <span class="tok-kw">var</span> stmt_buf: [<span class="tok-number">2</span>]Ast.Node.Index = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L2313">    <span class="tok-kw">const</span> statements: []<span class="tok-kw">const</span> Ast.Node.Index = <span class="tok-kw">switch</span> (node_tags[node]) {</span>
<span class="line" id="L2314">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> expr(gz, scope, ri, node),</span>
<span class="line" id="L2315">        .block_two, .block_two_semicolon =&gt; <span class="tok-kw">if</span> (node_datas[node].lhs == <span class="tok-number">0</span>) s: {</span>
<span class="line" id="L2316">            <span class="tok-kw">break</span> :s &amp;.{};</span>
<span class="line" id="L2317">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (node_datas[node].rhs == <span class="tok-number">0</span>) s: {</span>
<span class="line" id="L2318">            stmt_buf[<span class="tok-number">0</span>] = node_datas[node].lhs;</span>
<span class="line" id="L2319">            <span class="tok-kw">break</span> :s stmt_buf[<span class="tok-number">0</span>..<span class="tok-number">1</span>];</span>
<span class="line" id="L2320">        } <span class="tok-kw">else</span> s: {</span>
<span class="line" id="L2321">            stmt_buf[<span class="tok-number">0</span>] = node_datas[node].lhs;</span>
<span class="line" id="L2322">            stmt_buf[<span class="tok-number">1</span>] = node_datas[node].rhs;</span>
<span class="line" id="L2323">            <span class="tok-kw">break</span> :s stmt_buf[<span class="tok-number">0</span>..<span class="tok-number">2</span>];</span>
<span class="line" id="L2324">        },</span>
<span class="line" id="L2325">        .block, .block_semicolon =&gt; tree.extra_data[node_datas[node].lhs..node_datas[node].rhs],</span>
<span class="line" id="L2326">    };</span>
<span class="line" id="L2327"></span>
<span class="line" id="L2328">    <span class="tok-kw">const</span> lbrace = main_tokens[node];</span>
<span class="line" id="L2329">    <span class="tok-kw">if</span> (token_tags[lbrace - <span class="tok-number">1</span>] == .colon <span class="tok-kw">and</span></span>
<span class="line" id="L2330">        token_tags[lbrace - <span class="tok-number">2</span>] == .identifier)</span>
<span class="line" id="L2331">    {</span>
<span class="line" id="L2332">        <span class="tok-comment">// Labeled blocks are tricky - forwarding result location information properly is non-trivial,</span>
</span>
<span class="line" id="L2333">        <span class="tok-comment">// plus if this block is exited with a `break_inline` we aren't allowed multiple breaks. This</span>
</span>
<span class="line" id="L2334">        <span class="tok-comment">// case is rare, so just treat it as a normal expression and create a nested block.</span>
</span>
<span class="line" id="L2335">        <span class="tok-kw">return</span> expr(gz, scope, ri, node);</span>
<span class="line" id="L2336">    }</span>
<span class="line" id="L2337"></span>
<span class="line" id="L2338">    <span class="tok-kw">var</span> sub_gz = gz.makeSubBlock(scope);</span>
<span class="line" id="L2339">    <span class="tok-kw">try</span> blockExprStmts(&amp;sub_gz, &amp;sub_gz.base, statements);</span>
<span class="line" id="L2340"></span>
<span class="line" id="L2341">    <span class="tok-kw">return</span> rvalue(gz, ri, .void_value, node);</span>
<span class="line" id="L2342">}</span>
<span class="line" id="L2343"></span>
<span class="line" id="L2344"><span class="tok-kw">fn</span> <span class="tok-fn">blockExpr</span>(</span>
<span class="line" id="L2345">    gz: *GenZir,</span>
<span class="line" id="L2346">    scope: *Scope,</span>
<span class="line" id="L2347">    ri: ResultInfo,</span>
<span class="line" id="L2348">    block_node: Ast.Node.Index,</span>
<span class="line" id="L2349">    statements: []<span class="tok-kw">const</span> Ast.Node.Index,</span>
<span class="line" id="L2350">) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L2351">    <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L2352">    <span class="tok-kw">const</span> tree = astgen.tree;</span>
<span class="line" id="L2353">    <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);</span>
<span class="line" id="L2354">    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);</span>
<span class="line" id="L2355"></span>
<span class="line" id="L2356">    <span class="tok-kw">const</span> lbrace = main_tokens[block_node];</span>
<span class="line" id="L2357">    <span class="tok-kw">if</span> (token_tags[lbrace - <span class="tok-number">1</span>] == .colon <span class="tok-kw">and</span></span>
<span class="line" id="L2358">        token_tags[lbrace - <span class="tok-number">2</span>] == .identifier)</span>
<span class="line" id="L2359">    {</span>
<span class="line" id="L2360">        <span class="tok-kw">return</span> labeledBlockExpr(gz, scope, ri, block_node, statements, <span class="tok-null">false</span>);</span>
<span class="line" id="L2361">    }</span>
<span class="line" id="L2362"></span>
<span class="line" id="L2363">    <span class="tok-kw">if</span> (!gz.is_comptime) {</span>
<span class="line" id="L2364">        <span class="tok-comment">// Since this block is unlabeled, its control flow is effectively linear and we</span>
</span>
<span class="line" id="L2365">        <span class="tok-comment">// can *almost* get away with inlining the block here. However, we actually need</span>
</span>
<span class="line" id="L2366">        <span class="tok-comment">// to preserve the .block for Sema, to properly pop the error return trace.</span>
</span>
<span class="line" id="L2367"></span>
<span class="line" id="L2368">        <span class="tok-kw">const</span> block_tag: Zir.Inst.Tag = .block;</span>
<span class="line" id="L2369">        <span class="tok-kw">const</span> block_inst = <span class="tok-kw">try</span> gz.makeBlockInst(block_tag, block_node);</span>
<span class="line" id="L2370">        <span class="tok-kw">try</span> gz.instructions.append(astgen.gpa, block_inst);</span>
<span class="line" id="L2371"></span>
<span class="line" id="L2372">        <span class="tok-kw">var</span> block_scope = gz.makeSubBlock(scope);</span>
<span class="line" id="L2373">        <span class="tok-kw">defer</span> block_scope.unstack();</span>
<span class="line" id="L2374"></span>
<span class="line" id="L2375">        <span class="tok-kw">try</span> blockExprStmts(&amp;block_scope, &amp;block_scope.base, statements);</span>
<span class="line" id="L2376"></span>
<span class="line" id="L2377">        <span class="tok-kw">if</span> (!block_scope.endsWithNoReturn()) {</span>
<span class="line" id="L2378">            <span class="tok-comment">// As our last action before the break, &quot;pop&quot; the error trace if needed</span>
</span>
<span class="line" id="L2379">            _ = <span class="tok-kw">try</span> gz.addRestoreErrRetIndex(.{ .block = block_inst }, .always, block_node);</span>
<span class="line" id="L2380">            _ = <span class="tok-kw">try</span> block_scope.addBreak(.@&quot;break&quot;, block_inst, .void_value);</span>
<span class="line" id="L2381">        }</span>
<span class="line" id="L2382"></span>
<span class="line" id="L2383">        <span class="tok-kw">try</span> block_scope.setBlockBody(block_inst);</span>
<span class="line" id="L2384">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2385">        <span class="tok-kw">var</span> sub_gz = gz.makeSubBlock(scope);</span>
<span class="line" id="L2386">        <span class="tok-kw">try</span> blockExprStmts(&amp;sub_gz, &amp;sub_gz.base, statements);</span>
<span class="line" id="L2387">    }</span>
<span class="line" id="L2388"></span>
<span class="line" id="L2389">    <span class="tok-kw">return</span> rvalue(gz, ri, .void_value, block_node);</span>
<span class="line" id="L2390">}</span>
<span class="line" id="L2391"></span>
<span class="line" id="L2392"><span class="tok-kw">fn</span> <span class="tok-fn">checkLabelRedefinition</span>(astgen: *AstGen, parent_scope: *Scope, label: Ast.TokenIndex) !<span class="tok-type">void</span> {</span>
<span class="line" id="L2393">    <span class="tok-comment">// Look for the label in the scope.</span>
</span>
<span class="line" id="L2394">    <span class="tok-kw">var</span> scope = parent_scope;</span>
<span class="line" id="L2395">    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L2396">        <span class="tok-kw">switch</span> (scope.tag) {</span>
<span class="line" id="L2397">            .gen_zir =&gt; {</span>
<span class="line" id="L2398">                <span class="tok-kw">const</span> gen_zir = scope.cast(GenZir).?;</span>
<span class="line" id="L2399">                <span class="tok-kw">if</span> (gen_zir.label) |prev_label| {</span>
<span class="line" id="L2400">                    <span class="tok-kw">if</span> (<span class="tok-kw">try</span> astgen.tokenIdentEql(label, prev_label.token)) {</span>
<span class="line" id="L2401">                        <span class="tok-kw">const</span> label_name = <span class="tok-kw">try</span> astgen.identifierTokenString(label);</span>
<span class="line" id="L2402">                        <span class="tok-kw">return</span> astgen.failTokNotes(label, <span class="tok-str">&quot;redefinition of label '{s}'&quot;</span>, .{</span>
<span class="line" id="L2403">                            label_name,</span>
<span class="line" id="L2404">                        }, &amp;[_]<span class="tok-type">u32</span>{</span>
<span class="line" id="L2405">                            <span class="tok-kw">try</span> astgen.errNoteTok(</span>
<span class="line" id="L2406">                                prev_label.token,</span>
<span class="line" id="L2407">                                <span class="tok-str">&quot;previous definition here&quot;</span>,</span>
<span class="line" id="L2408">                                .{},</span>
<span class="line" id="L2409">                            ),</span>
<span class="line" id="L2410">                        });</span>
<span class="line" id="L2411">                    }</span>
<span class="line" id="L2412">                }</span>
<span class="line" id="L2413">                scope = gen_zir.parent;</span>
<span class="line" id="L2414">            },</span>
<span class="line" id="L2415">            .local_val =&gt; scope = scope.cast(Scope.LocalVal).?.parent,</span>
<span class="line" id="L2416">            .local_ptr =&gt; scope = scope.cast(Scope.LocalPtr).?.parent,</span>
<span class="line" id="L2417">            .defer_normal, .defer_error =&gt; scope = scope.cast(Scope.Defer).?.parent,</span>
<span class="line" id="L2418">            .namespace =&gt; <span class="tok-kw">break</span>,</span>
<span class="line" id="L2419">            .top =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L2420">        }</span>
<span class="line" id="L2421">    }</span>
<span class="line" id="L2422">}</span>
<span class="line" id="L2423"></span>
<span class="line" id="L2424"><span class="tok-kw">fn</span> <span class="tok-fn">labeledBlockExpr</span>(</span>
<span class="line" id="L2425">    gz: *GenZir,</span>
<span class="line" id="L2426">    parent_scope: *Scope,</span>
<span class="line" id="L2427">    ri: ResultInfo,</span>
<span class="line" id="L2428">    block_node: Ast.Node.Index,</span>
<span class="line" id="L2429">    statements: []<span class="tok-kw">const</span> Ast.Node.Index,</span>
<span class="line" id="L2430">    force_comptime: <span class="tok-type">bool</span>,</span>
<span class="line" id="L2431">) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L2432">    <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L2433">    <span class="tok-kw">const</span> tree = astgen.tree;</span>
<span class="line" id="L2434">    <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);</span>
<span class="line" id="L2435">    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);</span>
<span class="line" id="L2436"></span>
<span class="line" id="L2437">    <span class="tok-kw">const</span> lbrace = main_tokens[block_node];</span>
<span class="line" id="L2438">    <span class="tok-kw">const</span> label_token = lbrace - <span class="tok-number">2</span>;</span>
<span class="line" id="L2439">    assert(token_tags[label_token] == .identifier);</span>
<span class="line" id="L2440"></span>
<span class="line" id="L2441">    <span class="tok-kw">try</span> astgen.checkLabelRedefinition(parent_scope, label_token);</span>
<span class="line" id="L2442"></span>
<span class="line" id="L2443">    <span class="tok-kw">const</span> need_rl = astgen.nodes_need_rl.contains(block_node);</span>
<span class="line" id="L2444">    <span class="tok-kw">const</span> block_ri: ResultInfo = <span class="tok-kw">if</span> (need_rl) ri <span class="tok-kw">else</span> .{</span>
<span class="line" id="L2445">        .rl = <span class="tok-kw">switch</span> (ri.rl) {</span>
<span class="line" id="L2446">            .ptr =&gt; .{ .ty = (<span class="tok-kw">try</span> ri.rl.resultType(gz, block_node)).? },</span>
<span class="line" id="L2447">            .inferred_ptr =&gt; .none,</span>
<span class="line" id="L2448">            <span class="tok-kw">else</span> =&gt; ri.rl,</span>
<span class="line" id="L2449">        },</span>
<span class="line" id="L2450">        .ctx = ri.ctx,</span>
<span class="line" id="L2451">    };</span>
<span class="line" id="L2452">    <span class="tok-comment">// We need to call `rvalue` to write through to the pointer only if we had a</span>
</span>
<span class="line" id="L2453">    <span class="tok-comment">// result pointer and aren't forwarding it.</span>
</span>
<span class="line" id="L2454">    <span class="tok-kw">const</span> LocTag = <span class="tok-builtin">@typeInfo</span>(ResultInfo.Loc).Union.tag_type.?;</span>
<span class="line" id="L2455">    <span class="tok-kw">const</span> need_result_rvalue = <span class="tok-builtin">@as</span>(LocTag, block_ri.rl) != <span class="tok-builtin">@as</span>(LocTag, ri.rl);</span>
<span class="line" id="L2456"></span>
<span class="line" id="L2457">    <span class="tok-comment">// Reserve the Block ZIR instruction index so that we can put it into the GenZir struct</span>
</span>
<span class="line" id="L2458">    <span class="tok-comment">// so that break statements can reference it.</span>
</span>
<span class="line" id="L2459">    <span class="tok-kw">const</span> block_tag: Zir.Inst.Tag = <span class="tok-kw">if</span> (force_comptime) .block_comptime <span class="tok-kw">else</span> .block;</span>
<span class="line" id="L2460">    <span class="tok-kw">const</span> block_inst = <span class="tok-kw">try</span> gz.makeBlockInst(block_tag, block_node);</span>
<span class="line" id="L2461">    <span class="tok-kw">try</span> gz.instructions.append(astgen.gpa, block_inst);</span>
<span class="line" id="L2462">    <span class="tok-kw">var</span> block_scope = gz.makeSubBlock(parent_scope);</span>
<span class="line" id="L2463">    block_scope.label = GenZir.Label{</span>
<span class="line" id="L2464">        .token = label_token,</span>
<span class="line" id="L2465">        .block_inst = block_inst,</span>
<span class="line" id="L2466">    };</span>
<span class="line" id="L2467">    block_scope.setBreakResultInfo(block_ri);</span>
<span class="line" id="L2468">    <span class="tok-kw">if</span> (force_comptime) block_scope.is_comptime = <span class="tok-null">true</span>;</span>
<span class="line" id="L2469">    <span class="tok-kw">defer</span> block_scope.unstack();</span>
<span class="line" id="L2470"></span>
<span class="line" id="L2471">    <span class="tok-kw">try</span> blockExprStmts(&amp;block_scope, &amp;block_scope.base, statements);</span>
<span class="line" id="L2472">    <span class="tok-kw">if</span> (!block_scope.endsWithNoReturn()) {</span>
<span class="line" id="L2473">        <span class="tok-comment">// As our last action before the return, &quot;pop&quot; the error trace if needed</span>
</span>
<span class="line" id="L2474">        _ = <span class="tok-kw">try</span> gz.addRestoreErrRetIndex(.{ .block = block_inst }, .always, block_node);</span>
<span class="line" id="L2475">        _ = <span class="tok-kw">try</span> block_scope.addBreak(.@&quot;break&quot;, block_inst, .void_value);</span>
<span class="line" id="L2476">    }</span>
<span class="line" id="L2477"></span>
<span class="line" id="L2478">    <span class="tok-kw">if</span> (!block_scope.label.?.used) {</span>
<span class="line" id="L2479">        <span class="tok-kw">try</span> astgen.appendErrorTok(label_token, <span class="tok-str">&quot;unused block label&quot;</span>, .{});</span>
<span class="line" id="L2480">    }</span>
<span class="line" id="L2481"></span>
<span class="line" id="L2482">    <span class="tok-kw">try</span> block_scope.setBlockBody(block_inst);</span>
<span class="line" id="L2483">    <span class="tok-kw">if</span> (need_result_rvalue) {</span>
<span class="line" id="L2484">        <span class="tok-kw">return</span> rvalue(gz, ri, block_inst.toRef(), block_node);</span>
<span class="line" id="L2485">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2486">        <span class="tok-kw">return</span> block_inst.toRef();</span>
<span class="line" id="L2487">    }</span>
<span class="line" id="L2488">}</span>
<span class="line" id="L2489"></span>
<span class="line" id="L2490"><span class="tok-kw">fn</span> <span class="tok-fn">blockExprStmts</span>(gz: *GenZir, parent_scope: *Scope, statements: []<span class="tok-kw">const</span> Ast.Node.Index) !<span class="tok-type">void</span> {</span>
<span class="line" id="L2491">    <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L2492">    <span class="tok-kw">const</span> tree = astgen.tree;</span>
<span class="line" id="L2493">    <span class="tok-kw">const</span> node_tags = tree.nodes.items(.tag);</span>
<span class="line" id="L2494">    <span class="tok-kw">const</span> node_data = tree.nodes.items(.data);</span>
<span class="line" id="L2495"></span>
<span class="line" id="L2496">    <span class="tok-kw">if</span> (statements.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span>;</span>
<span class="line" id="L2497"></span>
<span class="line" id="L2498">    <span class="tok-kw">var</span> block_arena = std.heap.ArenaAllocator.init(gz.astgen.gpa);</span>
<span class="line" id="L2499">    <span class="tok-kw">defer</span> block_arena.deinit();</span>
<span class="line" id="L2500">    <span class="tok-kw">const</span> block_arena_allocator = block_arena.allocator();</span>
<span class="line" id="L2501"></span>
<span class="line" id="L2502">    <span class="tok-kw">var</span> noreturn_src_node: Ast.Node.Index = <span class="tok-number">0</span>;</span>
<span class="line" id="L2503">    <span class="tok-kw">var</span> scope = parent_scope;</span>
<span class="line" id="L2504">    <span class="tok-kw">for</span> (statements) |statement| {</span>
<span class="line" id="L2505">        <span class="tok-kw">if</span> (noreturn_src_node != <span class="tok-number">0</span>) {</span>
<span class="line" id="L2506">            <span class="tok-kw">try</span> astgen.appendErrorNodeNotes(</span>
<span class="line" id="L2507">                statement,</span>
<span class="line" id="L2508">                <span class="tok-str">&quot;unreachable code&quot;</span>,</span>
<span class="line" id="L2509">                .{},</span>
<span class="line" id="L2510">                &amp;[_]<span class="tok-type">u32</span>{</span>
<span class="line" id="L2511">                    <span class="tok-kw">try</span> astgen.errNoteNode(</span>
<span class="line" id="L2512">                        noreturn_src_node,</span>
<span class="line" id="L2513">                        <span class="tok-str">&quot;control flow is diverted here&quot;</span>,</span>
<span class="line" id="L2514">                        .{},</span>
<span class="line" id="L2515">                    ),</span>
<span class="line" id="L2516">                },</span>
<span class="line" id="L2517">            );</span>
<span class="line" id="L2518">        }</span>
<span class="line" id="L2519">        <span class="tok-kw">var</span> inner_node = statement;</span>
<span class="line" id="L2520">        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L2521">            <span class="tok-kw">switch</span> (node_tags[inner_node]) {</span>
<span class="line" id="L2522">                <span class="tok-comment">// zig fmt: off</span>
</span>
<span class="line" id="L2523">                .global_var_decl,</span>
<span class="line" id="L2524">                .local_var_decl,</span>
<span class="line" id="L2525">                .simple_var_decl,</span>
<span class="line" id="L2526">                .aligned_var_decl, =&gt; scope = <span class="tok-kw">try</span> varDecl(gz, scope, statement, block_arena_allocator, tree.fullVarDecl(statement).?),</span>
<span class="line" id="L2527"></span>
<span class="line" id="L2528">                .assign_destructure =&gt; scope = <span class="tok-kw">try</span> assignDestructureMaybeDecls(gz, scope, statement, block_arena_allocator),</span>
<span class="line" id="L2529"></span>
<span class="line" id="L2530">                .@&quot;defer&quot;    =&gt; scope = <span class="tok-kw">try</span> deferStmt(gz, scope, statement, block_arena_allocator, .defer_normal),</span>
<span class="line" id="L2531">                .@&quot;errdefer&quot; =&gt; scope = <span class="tok-kw">try</span> deferStmt(gz, scope, statement, block_arena_allocator, .defer_error),</span>
<span class="line" id="L2532"></span>
<span class="line" id="L2533">                .assign =&gt; <span class="tok-kw">try</span> assign(gz, scope, statement),</span>
<span class="line" id="L2534"></span>
<span class="line" id="L2535">                .assign_shl =&gt; <span class="tok-kw">try</span> assignShift(gz, scope, statement, .shl),</span>
<span class="line" id="L2536">                .assign_shr =&gt; <span class="tok-kw">try</span> assignShift(gz, scope, statement, .shr),</span>
<span class="line" id="L2537"></span>
<span class="line" id="L2538">                .assign_bit_and  =&gt; <span class="tok-kw">try</span> assignOp(gz, scope, statement, .bit_and),</span>
<span class="line" id="L2539">                .assign_bit_or   =&gt; <span class="tok-kw">try</span> assignOp(gz, scope, statement, .bit_or),</span>
<span class="line" id="L2540">                .assign_bit_xor  =&gt; <span class="tok-kw">try</span> assignOp(gz, scope, statement, .xor),</span>
<span class="line" id="L2541">                .assign_div      =&gt; <span class="tok-kw">try</span> assignOp(gz, scope, statement, .div),</span>
<span class="line" id="L2542">                .assign_sub      =&gt; <span class="tok-kw">try</span> assignOp(gz, scope, statement, .sub),</span>
<span class="line" id="L2543">                .assign_sub_wrap =&gt; <span class="tok-kw">try</span> assignOp(gz, scope, statement, .subwrap),</span>
<span class="line" id="L2544">                .assign_mod      =&gt; <span class="tok-kw">try</span> assignOp(gz, scope, statement, .mod_rem),</span>
<span class="line" id="L2545">                .assign_add      =&gt; <span class="tok-kw">try</span> assignOp(gz, scope, statement, .add),</span>
<span class="line" id="L2546">                .assign_add_wrap =&gt; <span class="tok-kw">try</span> assignOp(gz, scope, statement, .addwrap),</span>
<span class="line" id="L2547">                .assign_mul      =&gt; <span class="tok-kw">try</span> assignOp(gz, scope, statement, .mul),</span>
<span class="line" id="L2548">                .assign_mul_wrap =&gt; <span class="tok-kw">try</span> assignOp(gz, scope, statement, .mulwrap),</span>
<span class="line" id="L2549"></span>
<span class="line" id="L2550">                .grouped_expression =&gt; {</span>
<span class="line" id="L2551">                    inner_node = node_data[statement].lhs;</span>
<span class="line" id="L2552">                    <span class="tok-kw">continue</span>;</span>
<span class="line" id="L2553">                },</span>
<span class="line" id="L2554"></span>
<span class="line" id="L2555">                .while_simple,</span>
<span class="line" id="L2556">                .while_cont,</span>
<span class="line" id="L2557">                .@&quot;while&quot;, =&gt; _ = <span class="tok-kw">try</span> whileExpr(gz, scope, .{ .rl = .none }, inner_node, tree.fullWhile(inner_node).?, <span class="tok-null">true</span>),</span>
<span class="line" id="L2558"></span>
<span class="line" id="L2559">                .for_simple,</span>
<span class="line" id="L2560">                .@&quot;for&quot;, =&gt; _ = <span class="tok-kw">try</span> forExpr(gz, scope, .{ .rl = .none }, inner_node, tree.fullFor(inner_node).?, <span class="tok-null">true</span>),</span>
<span class="line" id="L2561"></span>
<span class="line" id="L2562">                <span class="tok-kw">else</span> =&gt; noreturn_src_node = <span class="tok-kw">try</span> unusedResultExpr(gz, scope, inner_node),</span>
<span class="line" id="L2563">                <span class="tok-comment">// zig fmt: on</span>
</span>
<span class="line" id="L2564">            }</span>
<span class="line" id="L2565">            <span class="tok-kw">break</span>;</span>
<span class="line" id="L2566">        }</span>
<span class="line" id="L2567">    }</span>
<span class="line" id="L2568"></span>
<span class="line" id="L2569">    <span class="tok-kw">if</span> (noreturn_src_node == <span class="tok-number">0</span>) {</span>
<span class="line" id="L2570">        <span class="tok-kw">try</span> genDefers(gz, parent_scope, scope, .normal_only);</span>
<span class="line" id="L2571">    }</span>
<span class="line" id="L2572">    <span class="tok-kw">try</span> checkUsed(gz, parent_scope, scope);</span>
<span class="line" id="L2573">}</span>
<span class="line" id="L2574"></span>
<span class="line" id="L2575"><span class="tok-comment">/// Returns AST source node of the thing that is noreturn if the statement is</span></span>
<span class="line" id="L2576"><span class="tok-comment">/// definitely `noreturn`. Otherwise returns 0.</span></span>
<span class="line" id="L2577"><span class="tok-kw">fn</span> <span class="tok-fn">unusedResultExpr</span>(gz: *GenZir, scope: *Scope, statement: Ast.Node.Index) InnerError!Ast.Node.Index {</span>
<span class="line" id="L2578">    <span class="tok-kw">try</span> emitDbgNode(gz, statement);</span>
<span class="line" id="L2579">    <span class="tok-comment">// We need to emit an error if the result is not `noreturn` or `void`, but</span>
</span>
<span class="line" id="L2580">    <span class="tok-comment">// we want to avoid adding the ZIR instruction if possible for performance.</span>
</span>
<span class="line" id="L2581">    <span class="tok-kw">const</span> maybe_unused_result = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .none }, statement);</span>
<span class="line" id="L2582">    <span class="tok-kw">return</span> addEnsureResult(gz, maybe_unused_result, statement);</span>
<span class="line" id="L2583">}</span>
<span class="line" id="L2584"></span>
<span class="line" id="L2585"><span class="tok-kw">fn</span> <span class="tok-fn">addEnsureResult</span>(gz: *GenZir, maybe_unused_result: Zir.Inst.Ref, statement: Ast.Node.Index) InnerError!Ast.Node.Index {</span>
<span class="line" id="L2586">    <span class="tok-kw">var</span> noreturn_src_node: Ast.Node.Index = <span class="tok-number">0</span>;</span>
<span class="line" id="L2587">    <span class="tok-kw">const</span> elide_check = <span class="tok-kw">if</span> (maybe_unused_result.toIndex()) |inst| b: {</span>
<span class="line" id="L2588">        <span class="tok-comment">// Note that this array becomes invalid after appending more items to it</span>
</span>
<span class="line" id="L2589">        <span class="tok-comment">// in the above while loop.</span>
</span>
<span class="line" id="L2590">        <span class="tok-kw">const</span> zir_tags = gz.astgen.instructions.items(.tag);</span>
<span class="line" id="L2591">        <span class="tok-kw">switch</span> (zir_tags[<span class="tok-builtin">@intFromEnum</span>(inst)]) {</span>
<span class="line" id="L2592">            <span class="tok-comment">// For some instructions, modify the zir data</span>
</span>
<span class="line" id="L2593">            <span class="tok-comment">// so we can avoid a separate ensure_result_used instruction.</span>
</span>
<span class="line" id="L2594">            .call, .field_call =&gt; {</span>
<span class="line" id="L2595">                <span class="tok-kw">const</span> break_extra = gz.astgen.instructions.items(.data)[<span class="tok-builtin">@intFromEnum</span>(inst)].pl_node.payload_index;</span>
<span class="line" id="L2596">                <span class="tok-kw">comptime</span> assert(std.meta.fieldIndex(Zir.Inst.Call, <span class="tok-str">&quot;flags&quot;</span>) ==</span>
<span class="line" id="L2597">                    std.meta.fieldIndex(Zir.Inst.FieldCall, <span class="tok-str">&quot;flags&quot;</span>));</span>
<span class="line" id="L2598">                <span class="tok-kw">const</span> flags: *Zir.Inst.Call.Flags = <span class="tok-builtin">@ptrCast</span>(&amp;gz.astgen.extra.items[</span>
<span class="line" id="L2599">                    break_extra + std.meta.fieldIndex(Zir.Inst.Call, <span class="tok-str">&quot;flags&quot;</span>).?</span>
<span class="line" id="L2600">                ]);</span>
<span class="line" id="L2601">                flags.ensure_result_used = <span class="tok-null">true</span>;</span>
<span class="line" id="L2602">                <span class="tok-kw">break</span> :b <span class="tok-null">true</span>;</span>
<span class="line" id="L2603">            },</span>
<span class="line" id="L2604">            .builtin_call =&gt; {</span>
<span class="line" id="L2605">                <span class="tok-kw">const</span> break_extra = gz.astgen.instructions.items(.data)[<span class="tok-builtin">@intFromEnum</span>(inst)].pl_node.payload_index;</span>
<span class="line" id="L2606">                <span class="tok-kw">const</span> flags: *Zir.Inst.BuiltinCall.Flags = <span class="tok-builtin">@ptrCast</span>(&amp;gz.astgen.extra.items[</span>
<span class="line" id="L2607">                    break_extra + std.meta.fieldIndex(Zir.Inst.BuiltinCall, <span class="tok-str">&quot;flags&quot;</span>).?</span>
<span class="line" id="L2608">                ]);</span>
<span class="line" id="L2609">                flags.ensure_result_used = <span class="tok-null">true</span>;</span>
<span class="line" id="L2610">                <span class="tok-kw">break</span> :b <span class="tok-null">true</span>;</span>
<span class="line" id="L2611">            },</span>
<span class="line" id="L2612"></span>
<span class="line" id="L2613">            <span class="tok-comment">// ZIR instructions that might be a type other than `noreturn` or `void`.</span>
</span>
<span class="line" id="L2614">            .add,</span>
<span class="line" id="L2615">            .addwrap,</span>
<span class="line" id="L2616">            .add_sat,</span>
<span class="line" id="L2617">            .add_unsafe,</span>
<span class="line" id="L2618">            .param,</span>
<span class="line" id="L2619">            .param_comptime,</span>
<span class="line" id="L2620">            .param_anytype,</span>
<span class="line" id="L2621">            .param_anytype_comptime,</span>
<span class="line" id="L2622">            .alloc,</span>
<span class="line" id="L2623">            .alloc_mut,</span>
<span class="line" id="L2624">            .alloc_comptime_mut,</span>
<span class="line" id="L2625">            .alloc_inferred,</span>
<span class="line" id="L2626">            .alloc_inferred_mut,</span>
<span class="line" id="L2627">            .alloc_inferred_comptime,</span>
<span class="line" id="L2628">            .alloc_inferred_comptime_mut,</span>
<span class="line" id="L2629">            .make_ptr_const,</span>
<span class="line" id="L2630">            .array_cat,</span>
<span class="line" id="L2631">            .array_mul,</span>
<span class="line" id="L2632">            .array_type,</span>
<span class="line" id="L2633">            .array_type_sentinel,</span>
<span class="line" id="L2634">            .elem_type,</span>
<span class="line" id="L2635">            .indexable_ptr_elem_type,</span>
<span class="line" id="L2636">            .vector_elem_type,</span>
<span class="line" id="L2637">            .vector_type,</span>
<span class="line" id="L2638">            .indexable_ptr_len,</span>
<span class="line" id="L2639">            .anyframe_type,</span>
<span class="line" id="L2640">            .as_node,</span>
<span class="line" id="L2641">            .as_shift_operand,</span>
<span class="line" id="L2642">            .bit_and,</span>
<span class="line" id="L2643">            .bitcast,</span>
<span class="line" id="L2644">            .bit_or,</span>
<span class="line" id="L2645">            .block,</span>
<span class="line" id="L2646">            .block_comptime,</span>
<span class="line" id="L2647">            .block_inline,</span>
<span class="line" id="L2648">            .declaration,</span>
<span class="line" id="L2649">            .suspend_block,</span>
<span class="line" id="L2650">            .loop,</span>
<span class="line" id="L2651">            .bool_br_and,</span>
<span class="line" id="L2652">            .bool_br_or,</span>
<span class="line" id="L2653">            .bool_not,</span>
<span class="line" id="L2654">            .cmp_lt,</span>
<span class="line" id="L2655">            .cmp_lte,</span>
<span class="line" id="L2656">            .cmp_eq,</span>
<span class="line" id="L2657">            .cmp_gte,</span>
<span class="line" id="L2658">            .cmp_gt,</span>
<span class="line" id="L2659">            .cmp_neq,</span>
<span class="line" id="L2660">            .decl_ref,</span>
<span class="line" id="L2661">            .decl_val,</span>
<span class="line" id="L2662">            .load,</span>
<span class="line" id="L2663">            .div,</span>
<span class="line" id="L2664">            .elem_ptr,</span>
<span class="line" id="L2665">            .elem_val,</span>
<span class="line" id="L2666">            .elem_ptr_node,</span>
<span class="line" id="L2667">            .elem_val_node,</span>
<span class="line" id="L2668">            .elem_val_imm,</span>
<span class="line" id="L2669">            .field_ptr,</span>
<span class="line" id="L2670">            .field_val,</span>
<span class="line" id="L2671">            .field_ptr_named,</span>
<span class="line" id="L2672">            .field_val_named,</span>
<span class="line" id="L2673">            .func,</span>
<span class="line" id="L2674">            .func_inferred,</span>
<span class="line" id="L2675">            .func_fancy,</span>
<span class="line" id="L2676">            .int,</span>
<span class="line" id="L2677">            .int_big,</span>
<span class="line" id="L2678">            .float,</span>
<span class="line" id="L2679">            .float128,</span>
<span class="line" id="L2680">            .int_type,</span>
<span class="line" id="L2681">            .is_non_null,</span>
<span class="line" id="L2682">            .is_non_null_ptr,</span>
<span class="line" id="L2683">            .is_non_err,</span>
<span class="line" id="L2684">            .is_non_err_ptr,</span>
<span class="line" id="L2685">            .ret_is_non_err,</span>
<span class="line" id="L2686">            .mod_rem,</span>
<span class="line" id="L2687">            .mul,</span>
<span class="line" id="L2688">            .mulwrap,</span>
<span class="line" id="L2689">            .mul_sat,</span>
<span class="line" id="L2690">            .ref,</span>
<span class="line" id="L2691">            .shl,</span>
<span class="line" id="L2692">            .shl_sat,</span>
<span class="line" id="L2693">            .shr,</span>
<span class="line" id="L2694">            .str,</span>
<span class="line" id="L2695">            .sub,</span>
<span class="line" id="L2696">            .subwrap,</span>
<span class="line" id="L2697">            .sub_sat,</span>
<span class="line" id="L2698">            .negate,</span>
<span class="line" id="L2699">            .negate_wrap,</span>
<span class="line" id="L2700">            .typeof,</span>
<span class="line" id="L2701">            .typeof_builtin,</span>
<span class="line" id="L2702">            .xor,</span>
<span class="line" id="L2703">            .optional_type,</span>
<span class="line" id="L2704">            .optional_payload_safe,</span>
<span class="line" id="L2705">            .optional_payload_unsafe,</span>
<span class="line" id="L2706">            .optional_payload_safe_ptr,</span>
<span class="line" id="L2707">            .optional_payload_unsafe_ptr,</span>
<span class="line" id="L2708">            .err_union_payload_unsafe,</span>
<span class="line" id="L2709">            .err_union_payload_unsafe_ptr,</span>
<span class="line" id="L2710">            .err_union_code,</span>
<span class="line" id="L2711">            .err_union_code_ptr,</span>
<span class="line" id="L2712">            .ptr_type,</span>
<span class="line" id="L2713">            .enum_literal,</span>
<span class="line" id="L2714">            .merge_error_sets,</span>
<span class="line" id="L2715">            .error_union_type,</span>
<span class="line" id="L2716">            .bit_not,</span>
<span class="line" id="L2717">            .error_value,</span>
<span class="line" id="L2718">            .slice_start,</span>
<span class="line" id="L2719">            .slice_end,</span>
<span class="line" id="L2720">            .slice_sentinel,</span>
<span class="line" id="L2721">            .slice_length,</span>
<span class="line" id="L2722">            .import,</span>
<span class="line" id="L2723">            .switch_block,</span>
<span class="line" id="L2724">            .switch_block_ref,</span>
<span class="line" id="L2725">            .switch_block_err_union,</span>
<span class="line" id="L2726">            .union_init,</span>
<span class="line" id="L2727">            .field_type_ref,</span>
<span class="line" id="L2728">            .error_set_decl,</span>
<span class="line" id="L2729">            .error_set_decl_anon,</span>
<span class="line" id="L2730">            .error_set_decl_func,</span>
<span class="line" id="L2731">            .enum_from_int,</span>
<span class="line" id="L2732">            .int_from_enum,</span>
<span class="line" id="L2733">            .type_info,</span>
<span class="line" id="L2734">            .size_of,</span>
<span class="line" id="L2735">            .bit_size_of,</span>
<span class="line" id="L2736">            .typeof_log2_int_type,</span>
<span class="line" id="L2737">            .int_from_ptr,</span>
<span class="line" id="L2738">            .align_of,</span>
<span class="line" id="L2739">            .int_from_bool,</span>
<span class="line" id="L2740">            .embed_file,</span>
<span class="line" id="L2741">            .error_name,</span>
<span class="line" id="L2742">            .sqrt,</span>
<span class="line" id="L2743">            .sin,</span>
<span class="line" id="L2744">            .cos,</span>
<span class="line" id="L2745">            .tan,</span>
<span class="line" id="L2746">            .exp,</span>
<span class="line" id="L2747">            .exp2,</span>
<span class="line" id="L2748">            .log,</span>
<span class="line" id="L2749">            .log2,</span>
<span class="line" id="L2750">            .log10,</span>
<span class="line" id="L2751">            .abs,</span>
<span class="line" id="L2752">            .floor,</span>
<span class="line" id="L2753">            .ceil,</span>
<span class="line" id="L2754">            .trunc,</span>
<span class="line" id="L2755">            .round,</span>
<span class="line" id="L2756">            .tag_name,</span>
<span class="line" id="L2757">            .type_name,</span>
<span class="line" id="L2758">            .frame_type,</span>
<span class="line" id="L2759">            .frame_size,</span>
<span class="line" id="L2760">            .int_from_float,</span>
<span class="line" id="L2761">            .float_from_int,</span>
<span class="line" id="L2762">            .ptr_from_int,</span>
<span class="line" id="L2763">            .float_cast,</span>
<span class="line" id="L2764">            .int_cast,</span>
<span class="line" id="L2765">            .ptr_cast,</span>
<span class="line" id="L2766">            .truncate,</span>
<span class="line" id="L2767">            .has_decl,</span>
<span class="line" id="L2768">            .has_field,</span>
<span class="line" id="L2769">            .clz,</span>
<span class="line" id="L2770">            .ctz,</span>
<span class="line" id="L2771">            .pop_count,</span>
<span class="line" id="L2772">            .byte_swap,</span>
<span class="line" id="L2773">            .bit_reverse,</span>
<span class="line" id="L2774">            .div_exact,</span>
<span class="line" id="L2775">            .div_floor,</span>
<span class="line" id="L2776">            .div_trunc,</span>
<span class="line" id="L2777">            .mod,</span>
<span class="line" id="L2778">            .rem,</span>
<span class="line" id="L2779">            .shl_exact,</span>
<span class="line" id="L2780">            .shr_exact,</span>
<span class="line" id="L2781">            .bit_offset_of,</span>
<span class="line" id="L2782">            .offset_of,</span>
<span class="line" id="L2783">            .splat,</span>
<span class="line" id="L2784">            .reduce,</span>
<span class="line" id="L2785">            .shuffle,</span>
<span class="line" id="L2786">            .atomic_load,</span>
<span class="line" id="L2787">            .atomic_rmw,</span>
<span class="line" id="L2788">            .mul_add,</span>
<span class="line" id="L2789">            .field_parent_ptr,</span>
<span class="line" id="L2790">            .max,</span>
<span class="line" id="L2791">            .min,</span>
<span class="line" id="L2792">            .c_import,</span>
<span class="line" id="L2793">            .@&quot;resume&quot;,</span>
<span class="line" id="L2794">            .@&quot;await&quot;,</span>
<span class="line" id="L2795">            .ret_err_value_code,</span>
<span class="line" id="L2796">            .ret_ptr,</span>
<span class="line" id="L2797">            .ret_type,</span>
<span class="line" id="L2798">            .for_len,</span>
<span class="line" id="L2799">            .@&quot;try&quot;,</span>
<span class="line" id="L2800">            .try_ptr,</span>
<span class="line" id="L2801">            .opt_eu_base_ptr_init,</span>
<span class="line" id="L2802">            .coerce_ptr_elem_ty,</span>
<span class="line" id="L2803">            .struct_init_empty,</span>
<span class="line" id="L2804">            .struct_init_empty_result,</span>
<span class="line" id="L2805">            .struct_init_empty_ref_result,</span>
<span class="line" id="L2806">            .struct_init_anon,</span>
<span class="line" id="L2807">            .struct_init,</span>
<span class="line" id="L2808">            .struct_init_ref,</span>
<span class="line" id="L2809">            .struct_init_field_type,</span>
<span class="line" id="L2810">            .struct_init_field_ptr,</span>
<span class="line" id="L2811">            .array_init_anon,</span>
<span class="line" id="L2812">            .array_init,</span>
<span class="line" id="L2813">            .array_init_ref,</span>
<span class="line" id="L2814">            .validate_array_init_ref_ty,</span>
<span class="line" id="L2815">            .array_init_elem_type,</span>
<span class="line" id="L2816">            .array_init_elem_ptr,</span>
<span class="line" id="L2817">            =&gt; <span class="tok-kw">break</span> :b <span class="tok-null">false</span>,</span>
<span class="line" id="L2818"></span>
<span class="line" id="L2819">            .extended =&gt; <span class="tok-kw">switch</span> (gz.astgen.instructions.items(.data)[<span class="tok-builtin">@intFromEnum</span>(inst)].extended.opcode) {</span>
<span class="line" id="L2820">                .breakpoint,</span>
<span class="line" id="L2821">                .fence,</span>
<span class="line" id="L2822">                .set_float_mode,</span>
<span class="line" id="L2823">                .set_align_stack,</span>
<span class="line" id="L2824">                .set_cold,</span>
<span class="line" id="L2825">                =&gt; <span class="tok-kw">break</span> :b <span class="tok-null">true</span>,</span>
<span class="line" id="L2826">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">break</span> :b <span class="tok-null">false</span>,</span>
<span class="line" id="L2827">            },</span>
<span class="line" id="L2828"></span>
<span class="line" id="L2829">            <span class="tok-comment">// ZIR instructions that are always `noreturn`.</span>
</span>
<span class="line" id="L2830">            .@&quot;break&quot;,</span>
<span class="line" id="L2831">            .break_inline,</span>
<span class="line" id="L2832">            .condbr,</span>
<span class="line" id="L2833">            .condbr_inline,</span>
<span class="line" id="L2834">            .compile_error,</span>
<span class="line" id="L2835">            .ret_node,</span>
<span class="line" id="L2836">            .ret_load,</span>
<span class="line" id="L2837">            .ret_implicit,</span>
<span class="line" id="L2838">            .ret_err_value,</span>
<span class="line" id="L2839">            .@&quot;unreachable&quot;,</span>
<span class="line" id="L2840">            .repeat,</span>
<span class="line" id="L2841">            .repeat_inline,</span>
<span class="line" id="L2842">            .panic,</span>
<span class="line" id="L2843">            .trap,</span>
<span class="line" id="L2844">            .check_comptime_control_flow,</span>
<span class="line" id="L2845">            =&gt; {</span>
<span class="line" id="L2846">                noreturn_src_node = statement;</span>
<span class="line" id="L2847">                <span class="tok-kw">break</span> :b <span class="tok-null">true</span>;</span>
<span class="line" id="L2848">            },</span>
<span class="line" id="L2849"></span>
<span class="line" id="L2850">            <span class="tok-comment">// ZIR instructions that are always `void`.</span>
</span>
<span class="line" id="L2851">            .dbg_stmt,</span>
<span class="line" id="L2852">            .dbg_var_ptr,</span>
<span class="line" id="L2853">            .dbg_var_val,</span>
<span class="line" id="L2854">            .ensure_result_used,</span>
<span class="line" id="L2855">            .ensure_result_non_error,</span>
<span class="line" id="L2856">            .ensure_err_union_payload_void,</span>
<span class="line" id="L2857">            .@&quot;export&quot;,</span>
<span class="line" id="L2858">            .export_value,</span>
<span class="line" id="L2859">            .set_eval_branch_quota,</span>
<span class="line" id="L2860">            .atomic_store,</span>
<span class="line" id="L2861">            .store_node,</span>
<span class="line" id="L2862">            .store_to_inferred_ptr,</span>
<span class="line" id="L2863">            .resolve_inferred_alloc,</span>
<span class="line" id="L2864">            .set_runtime_safety,</span>
<span class="line" id="L2865">            .memcpy,</span>
<span class="line" id="L2866">            .memset,</span>
<span class="line" id="L2867">            .validate_deref,</span>
<span class="line" id="L2868">            .validate_destructure,</span>
<span class="line" id="L2869">            .save_err_ret_index,</span>
<span class="line" id="L2870">            .restore_err_ret_index_unconditional,</span>
<span class="line" id="L2871">            .restore_err_ret_index_fn_entry,</span>
<span class="line" id="L2872">            .validate_struct_init_ty,</span>
<span class="line" id="L2873">            .validate_struct_init_result_ty,</span>
<span class="line" id="L2874">            .validate_ptr_struct_init,</span>
<span class="line" id="L2875">            .validate_array_init_ty,</span>
<span class="line" id="L2876">            .validate_array_init_result_ty,</span>
<span class="line" id="L2877">            .validate_ptr_array_init,</span>
<span class="line" id="L2878">            .validate_ref_ty,</span>
<span class="line" id="L2879">            =&gt; <span class="tok-kw">break</span> :b <span class="tok-null">true</span>,</span>
<span class="line" id="L2880"></span>
<span class="line" id="L2881">            .@&quot;defer&quot; =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L2882">            .defer_err_code =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L2883">        }</span>
<span class="line" id="L2884">    } <span class="tok-kw">else</span> <span class="tok-kw">switch</span> (maybe_unused_result) {</span>
<span class="line" id="L2885">        .none =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L2886"></span>
<span class="line" id="L2887">        .unreachable_value =&gt; b: {</span>
<span class="line" id="L2888">            noreturn_src_node = statement;</span>
<span class="line" id="L2889">            <span class="tok-kw">break</span> :b <span class="tok-null">true</span>;</span>
<span class="line" id="L2890">        },</span>
<span class="line" id="L2891"></span>
<span class="line" id="L2892">        .void_value =&gt; <span class="tok-null">true</span>,</span>
<span class="line" id="L2893"></span>
<span class="line" id="L2894">        <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,</span>
<span class="line" id="L2895">    };</span>
<span class="line" id="L2896">    <span class="tok-kw">if</span> (!elide_check) {</span>
<span class="line" id="L2897">        _ = <span class="tok-kw">try</span> gz.addUnNode(.ensure_result_used, maybe_unused_result, statement);</span>
<span class="line" id="L2898">    }</span>
<span class="line" id="L2899">    <span class="tok-kw">return</span> noreturn_src_node;</span>
<span class="line" id="L2900">}</span>
<span class="line" id="L2901"></span>
<span class="line" id="L2902"><span class="tok-kw">fn</span> <span class="tok-fn">countDefers</span>(outer_scope: *Scope, inner_scope: *Scope) <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2903">    have_any: <span class="tok-type">bool</span>,</span>
<span class="line" id="L2904">    have_normal: <span class="tok-type">bool</span>,</span>
<span class="line" id="L2905">    have_err: <span class="tok-type">bool</span>,</span>
<span class="line" id="L2906">    need_err_code: <span class="tok-type">bool</span>,</span>
<span class="line" id="L2907">} {</span>
<span class="line" id="L2908">    <span class="tok-kw">var</span> have_normal = <span class="tok-null">false</span>;</span>
<span class="line" id="L2909">    <span class="tok-kw">var</span> have_err = <span class="tok-null">false</span>;</span>
<span class="line" id="L2910">    <span class="tok-kw">var</span> need_err_code = <span class="tok-null">false</span>;</span>
<span class="line" id="L2911">    <span class="tok-kw">var</span> scope = inner_scope;</span>
<span class="line" id="L2912">    <span class="tok-kw">while</span> (scope != outer_scope) {</span>
<span class="line" id="L2913">        <span class="tok-kw">switch</span> (scope.tag) {</span>
<span class="line" id="L2914">            .gen_zir =&gt; scope = scope.cast(GenZir).?.parent,</span>
<span class="line" id="L2915">            .local_val =&gt; scope = scope.cast(Scope.LocalVal).?.parent,</span>
<span class="line" id="L2916">            .local_ptr =&gt; scope = scope.cast(Scope.LocalPtr).?.parent,</span>
<span class="line" id="L2917">            .defer_normal =&gt; {</span>
<span class="line" id="L2918">                <span class="tok-kw">const</span> defer_scope = scope.cast(Scope.Defer).?;</span>
<span class="line" id="L2919">                scope = defer_scope.parent;</span>
<span class="line" id="L2920"></span>
<span class="line" id="L2921">                have_normal = <span class="tok-null">true</span>;</span>
<span class="line" id="L2922">            },</span>
<span class="line" id="L2923">            .defer_error =&gt; {</span>
<span class="line" id="L2924">                <span class="tok-kw">const</span> defer_scope = scope.cast(Scope.Defer).?;</span>
<span class="line" id="L2925">                scope = defer_scope.parent;</span>
<span class="line" id="L2926"></span>
<span class="line" id="L2927">                have_err = <span class="tok-null">true</span>;</span>
<span class="line" id="L2928"></span>
<span class="line" id="L2929">                <span class="tok-kw">const</span> have_err_payload = defer_scope.remapped_err_code != .none;</span>
<span class="line" id="L2930">                need_err_code = need_err_code <span class="tok-kw">or</span> have_err_payload;</span>
<span class="line" id="L2931">            },</span>
<span class="line" id="L2932">            .namespace =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L2933">            .top =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L2934">        }</span>
<span class="line" id="L2935">    }</span>
<span class="line" id="L2936">    <span class="tok-kw">return</span> .{</span>
<span class="line" id="L2937">        .have_any = have_normal <span class="tok-kw">or</span> have_err,</span>
<span class="line" id="L2938">        .have_normal = have_normal,</span>
<span class="line" id="L2939">        .have_err = have_err,</span>
<span class="line" id="L2940">        .need_err_code = need_err_code,</span>
<span class="line" id="L2941">    };</span>
<span class="line" id="L2942">}</span>
<span class="line" id="L2943"></span>
<span class="line" id="L2944"><span class="tok-kw">const</span> DefersToEmit = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {</span>
<span class="line" id="L2945">    both: Zir.Inst.Ref, <span class="tok-comment">// err code</span>
</span>
<span class="line" id="L2946">    both_sans_err,</span>
<span class="line" id="L2947">    normal_only,</span>
<span class="line" id="L2948">};</span>
<span class="line" id="L2949"></span>
<span class="line" id="L2950"><span class="tok-kw">fn</span> <span class="tok-fn">genDefers</span>(</span>
<span class="line" id="L2951">    gz: *GenZir,</span>
<span class="line" id="L2952">    outer_scope: *Scope,</span>
<span class="line" id="L2953">    inner_scope: *Scope,</span>
<span class="line" id="L2954">    which_ones: DefersToEmit,</span>
<span class="line" id="L2955">) InnerError!<span class="tok-type">void</span> {</span>
<span class="line" id="L2956">    <span class="tok-kw">const</span> gpa = gz.astgen.gpa;</span>
<span class="line" id="L2957"></span>
<span class="line" id="L2958">    <span class="tok-kw">var</span> scope = inner_scope;</span>
<span class="line" id="L2959">    <span class="tok-kw">while</span> (scope != outer_scope) {</span>
<span class="line" id="L2960">        <span class="tok-kw">switch</span> (scope.tag) {</span>
<span class="line" id="L2961">            .gen_zir =&gt; scope = scope.cast(GenZir).?.parent,</span>
<span class="line" id="L2962">            .local_val =&gt; scope = scope.cast(Scope.LocalVal).?.parent,</span>
<span class="line" id="L2963">            .local_ptr =&gt; scope = scope.cast(Scope.LocalPtr).?.parent,</span>
<span class="line" id="L2964">            .defer_normal =&gt; {</span>
<span class="line" id="L2965">                <span class="tok-kw">const</span> defer_scope = scope.cast(Scope.Defer).?;</span>
<span class="line" id="L2966">                scope = defer_scope.parent;</span>
<span class="line" id="L2967">                <span class="tok-kw">try</span> gz.addDefer(defer_scope.index, defer_scope.len);</span>
<span class="line" id="L2968">            },</span>
<span class="line" id="L2969">            .defer_error =&gt; {</span>
<span class="line" id="L2970">                <span class="tok-kw">const</span> defer_scope = scope.cast(Scope.Defer).?;</span>
<span class="line" id="L2971">                scope = defer_scope.parent;</span>
<span class="line" id="L2972">                <span class="tok-kw">switch</span> (which_ones) {</span>
<span class="line" id="L2973">                    .both_sans_err =&gt; {</span>
<span class="line" id="L2974">                        <span class="tok-kw">try</span> gz.addDefer(defer_scope.index, defer_scope.len);</span>
<span class="line" id="L2975">                    },</span>
<span class="line" id="L2976">                    .both =&gt; |err_code| {</span>
<span class="line" id="L2977">                        <span class="tok-kw">if</span> (defer_scope.remapped_err_code.unwrap()) |remapped_err_code| {</span>
<span class="line" id="L2978">                            <span class="tok-kw">try</span> gz.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);</span>
<span class="line" id="L2979">                            <span class="tok-kw">try</span> gz.astgen.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);</span>
<span class="line" id="L2980"></span>
<span class="line" id="L2981">                            <span class="tok-kw">const</span> payload_index = <span class="tok-kw">try</span> gz.astgen.addExtra(Zir.Inst.DeferErrCode{</span>
<span class="line" id="L2982">                                .remapped_err_code = remapped_err_code,</span>
<span class="line" id="L2983">                                .index = defer_scope.index,</span>
<span class="line" id="L2984">                                .len = defer_scope.len,</span>
<span class="line" id="L2985">                            });</span>
<span class="line" id="L2986">                            <span class="tok-kw">const</span> new_index: Zir.Inst.Index = <span class="tok-builtin">@enumFromInt</span>(gz.astgen.instructions.len);</span>
<span class="line" id="L2987">                            gz.astgen.instructions.appendAssumeCapacity(.{</span>
<span class="line" id="L2988">                                .tag = .defer_err_code,</span>
<span class="line" id="L2989">                                .data = .{ .defer_err_code = .{</span>
<span class="line" id="L2990">                                    .err_code = err_code,</span>
<span class="line" id="L2991">                                    .payload_index = payload_index,</span>
<span class="line" id="L2992">                                } },</span>
<span class="line" id="L2993">                            });</span>
<span class="line" id="L2994">                            gz.instructions.appendAssumeCapacity(new_index);</span>
<span class="line" id="L2995">                        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2996">                            <span class="tok-kw">try</span> gz.addDefer(defer_scope.index, defer_scope.len);</span>
<span class="line" id="L2997">                        }</span>
<span class="line" id="L2998">                    },</span>
<span class="line" id="L2999">                    .normal_only =&gt; <span class="tok-kw">continue</span>,</span>
<span class="line" id="L3000">                }</span>
<span class="line" id="L3001">            },</span>
<span class="line" id="L3002">            .namespace =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L3003">            .top =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L3004">        }</span>
<span class="line" id="L3005">    }</span>
<span class="line" id="L3006">}</span>
<span class="line" id="L3007"></span>
<span class="line" id="L3008"><span class="tok-kw">fn</span> <span class="tok-fn">checkUsed</span>(gz: *GenZir, outer_scope: *Scope, inner_scope: *Scope) InnerError!<span class="tok-type">void</span> {</span>
<span class="line" id="L3009">    <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L3010"></span>
<span class="line" id="L3011">    <span class="tok-kw">var</span> scope = inner_scope;</span>
<span class="line" id="L3012">    <span class="tok-kw">while</span> (scope != outer_scope) {</span>
<span class="line" id="L3013">        <span class="tok-kw">switch</span> (scope.tag) {</span>
<span class="line" id="L3014">            .gen_zir =&gt; scope = scope.cast(GenZir).?.parent,</span>
<span class="line" id="L3015">            .local_val =&gt; {</span>
<span class="line" id="L3016">                <span class="tok-kw">const</span> s = scope.cast(Scope.LocalVal).?;</span>
<span class="line" id="L3017">                <span class="tok-kw">if</span> (s.used == <span class="tok-number">0</span> <span class="tok-kw">and</span> s.discarded == <span class="tok-number">0</span>) {</span>
<span class="line" id="L3018">                    <span class="tok-kw">try</span> astgen.appendErrorTok(s.token_src, <span class="tok-str">&quot;unused {s}&quot;</span>, .{<span class="tok-builtin">@tagName</span>(s.id_cat)});</span>
<span class="line" id="L3019">                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (s.used != <span class="tok-number">0</span> <span class="tok-kw">and</span> s.discarded != <span class="tok-number">0</span>) {</span>
<span class="line" id="L3020">                    <span class="tok-kw">try</span> astgen.appendErrorTokNotes(s.discarded, <span class="tok-str">&quot;pointless discard of {s}&quot;</span>, .{<span class="tok-builtin">@tagName</span>(s.id_cat)}, &amp;[_]<span class="tok-type">u32</span>{</span>
<span class="line" id="L3021">                        <span class="tok-kw">try</span> gz.astgen.errNoteTok(s.used, <span class="tok-str">&quot;used here&quot;</span>, .{}),</span>
<span class="line" id="L3022">                    });</span>
<span class="line" id="L3023">                }</span>
<span class="line" id="L3024">                scope = s.parent;</span>
<span class="line" id="L3025">            },</span>
<span class="line" id="L3026">            .local_ptr =&gt; {</span>
<span class="line" id="L3027">                <span class="tok-kw">const</span> s = scope.cast(Scope.LocalPtr).?;</span>
<span class="line" id="L3028">                <span class="tok-kw">if</span> (s.used == <span class="tok-number">0</span> <span class="tok-kw">and</span> s.discarded == <span class="tok-number">0</span>) {</span>
<span class="line" id="L3029">                    <span class="tok-kw">try</span> astgen.appendErrorTok(s.token_src, <span class="tok-str">&quot;unused {s}&quot;</span>, .{<span class="tok-builtin">@tagName</span>(s.id_cat)});</span>
<span class="line" id="L3030">                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L3031">                    <span class="tok-kw">if</span> (s.used != <span class="tok-number">0</span> <span class="tok-kw">and</span> s.discarded != <span class="tok-number">0</span>) {</span>
<span class="line" id="L3032">                        <span class="tok-kw">try</span> astgen.appendErrorTokNotes(s.discarded, <span class="tok-str">&quot;pointless discard of {s}&quot;</span>, .{<span class="tok-builtin">@tagName</span>(s.id_cat)}, &amp;[_]<span class="tok-type">u32</span>{</span>
<span class="line" id="L3033">                            <span class="tok-kw">try</span> astgen.errNoteTok(s.used, <span class="tok-str">&quot;used here&quot;</span>, .{}),</span>
<span class="line" id="L3034">                        });</span>
<span class="line" id="L3035">                    }</span>
<span class="line" id="L3036">                    <span class="tok-kw">if</span> (s.id_cat == .@&quot;local variable&quot; <span class="tok-kw">and</span> !s.used_as_lvalue) {</span>
<span class="line" id="L3037">                        <span class="tok-kw">try</span> astgen.appendErrorTokNotes(s.token_src, <span class="tok-str">&quot;local variable is never mutated&quot;</span>, .{}, &amp;.{</span>
<span class="line" id="L3038">                            <span class="tok-kw">try</span> astgen.errNoteTok(s.token_src, <span class="tok-str">&quot;consider using 'const'&quot;</span>, .{}),</span>
<span class="line" id="L3039">                        });</span>
<span class="line" id="L3040">                    }</span>
<span class="line" id="L3041">                }</span>
<span class="line" id="L3042"></span>
<span class="line" id="L3043">                scope = s.parent;</span>
<span class="line" id="L3044">            },</span>
<span class="line" id="L3045">            .defer_normal, .defer_error =&gt; scope = scope.cast(Scope.Defer).?.parent,</span>
<span class="line" id="L3046">            .namespace =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L3047">            .top =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L3048">        }</span>
<span class="line" id="L3049">    }</span>
<span class="line" id="L3050">}</span>
<span class="line" id="L3051"></span>
<span class="line" id="L3052"><span class="tok-kw">fn</span> <span class="tok-fn">deferStmt</span>(</span>
<span class="line" id="L3053">    gz: *GenZir,</span>
<span class="line" id="L3054">    scope: *Scope,</span>
<span class="line" id="L3055">    node: Ast.Node.Index,</span>
<span class="line" id="L3056">    block_arena: Allocator,</span>
<span class="line" id="L3057">    scope_tag: Scope.Tag,</span>
<span class="line" id="L3058">) InnerError!*Scope {</span>
<span class="line" id="L3059">    <span class="tok-kw">var</span> defer_gen = gz.makeSubBlock(scope);</span>
<span class="line" id="L3060">    defer_gen.cur_defer_node = node;</span>
<span class="line" id="L3061">    defer_gen.any_defer_node = node;</span>
<span class="line" id="L3062">    <span class="tok-kw">defer</span> defer_gen.unstack();</span>
<span class="line" id="L3063"></span>
<span class="line" id="L3064">    <span class="tok-kw">const</span> tree = gz.astgen.tree;</span>
<span class="line" id="L3065">    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);</span>
<span class="line" id="L3066">    <span class="tok-kw">const</span> expr_node = node_datas[node].rhs;</span>
<span class="line" id="L3067"></span>
<span class="line" id="L3068">    <span class="tok-kw">const</span> payload_token = node_datas[node].lhs;</span>
<span class="line" id="L3069">    <span class="tok-kw">var</span> local_val_scope: Scope.LocalVal = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L3070">    <span class="tok-kw">var</span> opt_remapped_err_code: Zir.Inst.OptionalIndex = .none;</span>
<span class="line" id="L3071">    <span class="tok-kw">const</span> have_err_code = scope_tag == .defer_error <span class="tok-kw">and</span> payload_token != <span class="tok-number">0</span>;</span>
<span class="line" id="L3072">    <span class="tok-kw">const</span> sub_scope = <span class="tok-kw">if</span> (!have_err_code) &amp;defer_gen.base <span class="tok-kw">else</span> blk: {</span>
<span class="line" id="L3073">        <span class="tok-kw">const</span> ident_name = <span class="tok-kw">try</span> gz.astgen.identAsString(payload_token);</span>
<span class="line" id="L3074">        <span class="tok-kw">const</span> remapped_err_code: Zir.Inst.Index = <span class="tok-builtin">@enumFromInt</span>(gz.astgen.instructions.len);</span>
<span class="line" id="L3075">        opt_remapped_err_code = remapped_err_code.toOptional();</span>
<span class="line" id="L3076">        <span class="tok-kw">try</span> gz.astgen.instructions.append(gz.astgen.gpa, .{</span>
<span class="line" id="L3077">            .tag = .extended,</span>
<span class="line" id="L3078">            .data = .{ .extended = .{</span>
<span class="line" id="L3079">                .opcode = .value_placeholder,</span>
<span class="line" id="L3080">                .small = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L3081">                .operand = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L3082">            } },</span>
<span class="line" id="L3083">        });</span>
<span class="line" id="L3084">        <span class="tok-kw">const</span> remapped_err_code_ref = remapped_err_code.toRef();</span>
<span class="line" id="L3085">        local_val_scope = .{</span>
<span class="line" id="L3086">            .parent = &amp;defer_gen.base,</span>
<span class="line" id="L3087">            .gen_zir = gz,</span>
<span class="line" id="L3088">            .name = ident_name,</span>
<span class="line" id="L3089">            .inst = remapped_err_code_ref,</span>
<span class="line" id="L3090">            .token_src = payload_token,</span>
<span class="line" id="L3091">            .id_cat = .capture,</span>
<span class="line" id="L3092">        };</span>
<span class="line" id="L3093">        <span class="tok-kw">try</span> gz.addDbgVar(.dbg_var_val, ident_name, remapped_err_code_ref);</span>
<span class="line" id="L3094">        <span class="tok-kw">break</span> :blk &amp;local_val_scope.base;</span>
<span class="line" id="L3095">    };</span>
<span class="line" id="L3096">    _ = <span class="tok-kw">try</span> unusedResultExpr(&amp;defer_gen, sub_scope, expr_node);</span>
<span class="line" id="L3097">    <span class="tok-kw">try</span> checkUsed(gz, scope, sub_scope);</span>
<span class="line" id="L3098">    _ = <span class="tok-kw">try</span> defer_gen.addBreak(.break_inline, <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">0</span>), .void_value);</span>
<span class="line" id="L3099"></span>
<span class="line" id="L3100">    <span class="tok-comment">// We must handle ref_table for remapped_err_code manually.</span>
</span>
<span class="line" id="L3101">    <span class="tok-kw">const</span> body = defer_gen.instructionsSlice();</span>
<span class="line" id="L3102">    <span class="tok-kw">const</span> body_len = blk: {</span>
<span class="line" id="L3103">        <span class="tok-kw">var</span> refs: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L3104">        <span class="tok-kw">if</span> (opt_remapped_err_code.unwrap()) |remapped_err_code| {</span>
<span class="line" id="L3105">            <span class="tok-kw">var</span> cur_inst = remapped_err_code;</span>
<span class="line" id="L3106">            <span class="tok-kw">while</span> (gz.astgen.ref_table.get(cur_inst)) |ref_inst| {</span>
<span class="line" id="L3107">                refs += <span class="tok-number">1</span>;</span>
<span class="line" id="L3108">                cur_inst = ref_inst;</span>
<span class="line" id="L3109">            }</span>
<span class="line" id="L3110">        }</span>
<span class="line" id="L3111">        <span class="tok-kw">break</span> :blk gz.astgen.countBodyLenAfterFixups(body) + refs;</span>
<span class="line" id="L3112">    };</span>
<span class="line" id="L3113"></span>
<span class="line" id="L3114">    <span class="tok-kw">const</span> index: <span class="tok-type">u32</span> = <span class="tok-builtin">@intCast</span>(gz.astgen.extra.items.len);</span>
<span class="line" id="L3115">    <span class="tok-kw">try</span> gz.astgen.extra.ensureUnusedCapacity(gz.astgen.gpa, body_len);</span>
<span class="line" id="L3116">    <span class="tok-kw">if</span> (opt_remapped_err_code.unwrap()) |remapped_err_code| {</span>
<span class="line" id="L3117">        <span class="tok-kw">if</span> (gz.astgen.ref_table.fetchRemove(remapped_err_code)) |kv| {</span>
<span class="line" id="L3118">            gz.astgen.appendPossiblyRefdBodyInst(&amp;gz.astgen.extra, kv.value);</span>
<span class="line" id="L3119">        }</span>
<span class="line" id="L3120">    }</span>
<span class="line" id="L3121">    gz.astgen.appendBodyWithFixups(body);</span>
<span class="line" id="L3122"></span>
<span class="line" id="L3123">    <span class="tok-kw">const</span> defer_scope = <span class="tok-kw">try</span> block_arena.create(Scope.Defer);</span>
<span class="line" id="L3124"></span>
<span class="line" id="L3125">    defer_scope.* = .{</span>
<span class="line" id="L3126">        .base = .{ .tag = scope_tag },</span>
<span class="line" id="L3127">        .parent = scope,</span>
<span class="line" id="L3128">        .index = index,</span>
<span class="line" id="L3129">        .len = body_len,</span>
<span class="line" id="L3130">        .remapped_err_code = opt_remapped_err_code,</span>
<span class="line" id="L3131">    };</span>
<span class="line" id="L3132">    <span class="tok-kw">return</span> &amp;defer_scope.base;</span>
<span class="line" id="L3133">}</span>
<span class="line" id="L3134"></span>
<span class="line" id="L3135"><span class="tok-kw">fn</span> <span class="tok-fn">varDecl</span>(</span>
<span class="line" id="L3136">    gz: *GenZir,</span>
<span class="line" id="L3137">    scope: *Scope,</span>
<span class="line" id="L3138">    node: Ast.Node.Index,</span>
<span class="line" id="L3139">    block_arena: Allocator,</span>
<span class="line" id="L3140">    var_decl: Ast.full.VarDecl,</span>
<span class="line" id="L3141">) InnerError!*Scope {</span>
<span class="line" id="L3142">    <span class="tok-kw">try</span> emitDbgNode(gz, node);</span>
<span class="line" id="L3143">    <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L3144">    <span class="tok-kw">const</span> tree = astgen.tree;</span>
<span class="line" id="L3145">    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);</span>
<span class="line" id="L3146">    <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);</span>
<span class="line" id="L3147"></span>
<span class="line" id="L3148">    <span class="tok-kw">const</span> name_token = var_decl.ast.mut_token + <span class="tok-number">1</span>;</span>
<span class="line" id="L3149">    <span class="tok-kw">const</span> ident_name_raw = tree.tokenSlice(name_token);</span>
<span class="line" id="L3150">    <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, ident_name_raw, <span class="tok-str">&quot;_&quot;</span>)) {</span>
<span class="line" id="L3151">        <span class="tok-kw">return</span> astgen.failTok(name_token, <span class="tok-str">&quot;'_' used as an identifier without @\&quot;_\&quot; syntax&quot;</span>, .{});</span>
<span class="line" id="L3152">    }</span>
<span class="line" id="L3153">    <span class="tok-kw">const</span> ident_name = <span class="tok-kw">try</span> astgen.identAsString(name_token);</span>
<span class="line" id="L3154"></span>
<span class="line" id="L3155">    <span class="tok-kw">try</span> astgen.detectLocalShadowing(</span>
<span class="line" id="L3156">        scope,</span>
<span class="line" id="L3157">        ident_name,</span>
<span class="line" id="L3158">        name_token,</span>
<span class="line" id="L3159">        ident_name_raw,</span>
<span class="line" id="L3160">        <span class="tok-kw">if</span> (token_tags[var_decl.ast.mut_token] == .keyword_const) .@&quot;local constant&quot; <span class="tok-kw">else</span> .@&quot;local variable&quot;,</span>
<span class="line" id="L3161">    );</span>
<span class="line" id="L3162"></span>
<span class="line" id="L3163">    <span class="tok-kw">if</span> (var_decl.ast.init_node == <span class="tok-number">0</span>) {</span>
<span class="line" id="L3164">        <span class="tok-kw">return</span> astgen.failNode(node, <span class="tok-str">&quot;variables must be initialized&quot;</span>, .{});</span>
<span class="line" id="L3165">    }</span>
<span class="line" id="L3166"></span>
<span class="line" id="L3167">    <span class="tok-kw">if</span> (var_decl.ast.addrspace_node != <span class="tok-number">0</span>) {</span>
<span class="line" id="L3168">        <span class="tok-kw">return</span> astgen.failTok(main_tokens[var_decl.ast.addrspace_node], <span class="tok-str">&quot;cannot set address space of local variable '{s}'&quot;</span>, .{ident_name_raw});</span>
<span class="line" id="L3169">    }</span>
<span class="line" id="L3170"></span>
<span class="line" id="L3171">    <span class="tok-kw">if</span> (var_decl.ast.section_node != <span class="tok-number">0</span>) {</span>
<span class="line" id="L3172">        <span class="tok-kw">return</span> astgen.failTok(main_tokens[var_decl.ast.section_node], <span class="tok-str">&quot;cannot set section of local variable '{s}'&quot;</span>, .{ident_name_raw});</span>
<span class="line" id="L3173">    }</span>
<span class="line" id="L3174"></span>
<span class="line" id="L3175">    <span class="tok-kw">const</span> align_inst: Zir.Inst.Ref = <span class="tok-kw">if</span> (var_decl.ast.align_node != <span class="tok-number">0</span>)</span>
<span class="line" id="L3176">        <span class="tok-kw">try</span> expr(gz, scope, coerced_align_ri, var_decl.ast.align_node)</span>
<span class="line" id="L3177">    <span class="tok-kw">else</span></span>
<span class="line" id="L3178">        .none;</span>
<span class="line" id="L3179"></span>
<span class="line" id="L3180">    <span class="tok-kw">switch</span> (token_tags[var_decl.ast.mut_token]) {</span>
<span class="line" id="L3181">        .keyword_const =&gt; {</span>
<span class="line" id="L3182">            <span class="tok-kw">if</span> (var_decl.comptime_token) |comptime_token| {</span>
<span class="line" id="L3183">                <span class="tok-kw">try</span> astgen.appendErrorTok(comptime_token, <span class="tok-str">&quot;'comptime const' is redundant; instead wrap the initialization expression with 'comptime'&quot;</span>, .{});</span>
<span class="line" id="L3184">            }</span>
<span class="line" id="L3185"></span>
<span class="line" id="L3186">            <span class="tok-comment">// Depending on the type of AST the initialization expression is, we may need an lvalue</span>
</span>
<span class="line" id="L3187">            <span class="tok-comment">// or an rvalue as a result location. If it is an rvalue, we can use the instruction as</span>
</span>
<span class="line" id="L3188">            <span class="tok-comment">// the variable, no memory location needed.</span>
</span>
<span class="line" id="L3189">            <span class="tok-kw">const</span> type_node = var_decl.ast.type_node;</span>
<span class="line" id="L3190">            <span class="tok-kw">if</span> (align_inst == .none <span class="tok-kw">and</span></span>
<span class="line" id="L3191">                !astgen.nodes_need_rl.contains(node))</span>
<span class="line" id="L3192">            {</span>
<span class="line" id="L3193">                <span class="tok-kw">const</span> result_info: ResultInfo = <span class="tok-kw">if</span> (type_node != <span class="tok-number">0</span>) .{</span>
<span class="line" id="L3194">                    .rl = .{ .ty = <span class="tok-kw">try</span> typeExpr(gz, scope, type_node) },</span>
<span class="line" id="L3195">                    .ctx = .const_init,</span>
<span class="line" id="L3196">                } <span class="tok-kw">else</span> .{ .rl = .none, .ctx = .const_init };</span>
<span class="line" id="L3197">                <span class="tok-kw">const</span> prev_anon_name_strategy = gz.anon_name_strategy;</span>
<span class="line" id="L3198">                gz.anon_name_strategy = .dbg_var;</span>
<span class="line" id="L3199">                <span class="tok-kw">const</span> init_inst = <span class="tok-kw">try</span> reachableExpr(gz, scope, result_info, var_decl.ast.init_node, node);</span>
<span class="line" id="L3200">                gz.anon_name_strategy = prev_anon_name_strategy;</span>
<span class="line" id="L3201"></span>
<span class="line" id="L3202">                <span class="tok-kw">try</span> gz.addDbgVar(.dbg_var_val, ident_name, init_inst);</span>
<span class="line" id="L3203"></span>
<span class="line" id="L3204">                <span class="tok-comment">// The const init expression may have modified the error return trace, so signal</span>
</span>
<span class="line" id="L3205">                <span class="tok-comment">// to Sema that it should save the new index for restoring later.</span>
</span>
<span class="line" id="L3206">                <span class="tok-kw">if</span> (nodeMayAppendToErrorTrace(tree, var_decl.ast.init_node))</span>
<span class="line" id="L3207">                    _ = <span class="tok-kw">try</span> gz.addSaveErrRetIndex(.{ .if_of_error_type = init_inst });</span>
<span class="line" id="L3208"></span>
<span class="line" id="L3209">                <span class="tok-kw">const</span> sub_scope = <span class="tok-kw">try</span> block_arena.create(Scope.LocalVal);</span>
<span class="line" id="L3210">                sub_scope.* = .{</span>
<span class="line" id="L3211">                    .parent = scope,</span>
<span class="line" id="L3212">                    .gen_zir = gz,</span>
<span class="line" id="L3213">                    .name = ident_name,</span>
<span class="line" id="L3214">                    .inst = init_inst,</span>
<span class="line" id="L3215">                    .token_src = name_token,</span>
<span class="line" id="L3216">                    .id_cat = .@&quot;local constant&quot;,</span>
<span class="line" id="L3217">                };</span>
<span class="line" id="L3218">                <span class="tok-kw">return</span> &amp;sub_scope.base;</span>
<span class="line" id="L3219">            }</span>
<span class="line" id="L3220"></span>
<span class="line" id="L3221">            <span class="tok-kw">const</span> is_comptime = gz.is_comptime <span class="tok-kw">or</span></span>
<span class="line" id="L3222">                tree.nodes.items(.tag)[var_decl.ast.init_node] == .@&quot;comptime&quot;;</span>
<span class="line" id="L3223"></span>
<span class="line" id="L3224">            <span class="tok-kw">var</span> resolve_inferred_alloc: Zir.Inst.Ref = .none;</span>
<span class="line" id="L3225">            <span class="tok-kw">var</span> opt_type_inst: Zir.Inst.Ref = .none;</span>
<span class="line" id="L3226">            <span class="tok-kw">const</span> init_rl: ResultInfo.Loc = <span class="tok-kw">if</span> (type_node != <span class="tok-number">0</span>) init_rl: {</span>
<span class="line" id="L3227">                <span class="tok-kw">const</span> type_inst = <span class="tok-kw">try</span> typeExpr(gz, scope, type_node);</span>
<span class="line" id="L3228">                opt_type_inst = type_inst;</span>
<span class="line" id="L3229">                <span class="tok-kw">if</span> (align_inst == .none) {</span>
<span class="line" id="L3230">                    <span class="tok-kw">break</span> :init_rl .{ .ptr = .{ .inst = <span class="tok-kw">try</span> gz.addUnNode(.alloc, type_inst, node) } };</span>
<span class="line" id="L3231">                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L3232">                    <span class="tok-kw">break</span> :init_rl .{ .ptr = .{ .inst = <span class="tok-kw">try</span> gz.addAllocExtended(.{</span>
<span class="line" id="L3233">                        .node = node,</span>
<span class="line" id="L3234">                        .type_inst = type_inst,</span>
<span class="line" id="L3235">                        .align_inst = align_inst,</span>
<span class="line" id="L3236">                        .is_const = <span class="tok-null">true</span>,</span>
<span class="line" id="L3237">                        .is_comptime = is_comptime,</span>
<span class="line" id="L3238">                    }) } };</span>
<span class="line" id="L3239">                }</span>
<span class="line" id="L3240">            } <span class="tok-kw">else</span> init_rl: {</span>
<span class="line" id="L3241">                <span class="tok-kw">const</span> alloc_inst = <span class="tok-kw">if</span> (align_inst == .none) ptr: {</span>
<span class="line" id="L3242">                    <span class="tok-kw">const</span> tag: Zir.Inst.Tag = <span class="tok-kw">if</span> (is_comptime)</span>
<span class="line" id="L3243">                        .alloc_inferred_comptime</span>
<span class="line" id="L3244">                    <span class="tok-kw">else</span></span>
<span class="line" id="L3245">                        .alloc_inferred;</span>
<span class="line" id="L3246">                    <span class="tok-kw">break</span> :ptr <span class="tok-kw">try</span> gz.addNode(tag, node);</span>
<span class="line" id="L3247">                } <span class="tok-kw">else</span> ptr: {</span>
<span class="line" id="L3248">                    <span class="tok-kw">break</span> :ptr <span class="tok-kw">try</span> gz.addAllocExtended(.{</span>
<span class="line" id="L3249">                        .node = node,</span>
<span class="line" id="L3250">                        .type_inst = .none,</span>
<span class="line" id="L3251">                        .align_inst = align_inst,</span>
<span class="line" id="L3252">                        .is_const = <span class="tok-null">true</span>,</span>
<span class="line" id="L3253">                        .is_comptime = is_comptime,</span>
<span class="line" id="L3254">                    });</span>
<span class="line" id="L3255">                };</span>
<span class="line" id="L3256">                resolve_inferred_alloc = alloc_inst;</span>
<span class="line" id="L3257">                <span class="tok-kw">break</span> :init_rl .{ .inferred_ptr = alloc_inst };</span>
<span class="line" id="L3258">            };</span>
<span class="line" id="L3259">            <span class="tok-kw">const</span> var_ptr = <span class="tok-kw">switch</span> (init_rl) {</span>
<span class="line" id="L3260">                .ptr =&gt; |ptr| ptr.inst,</span>
<span class="line" id="L3261">                .inferred_ptr =&gt; |inst| inst,</span>
<span class="line" id="L3262">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L3263">            };</span>
<span class="line" id="L3264">            <span class="tok-kw">const</span> init_result_info: ResultInfo = .{ .rl = init_rl, .ctx = .const_init };</span>
<span class="line" id="L3265"></span>
<span class="line" id="L3266">            <span class="tok-kw">const</span> prev_anon_name_strategy = gz.anon_name_strategy;</span>
<span class="line" id="L3267">            gz.anon_name_strategy = .dbg_var;</span>
<span class="line" id="L3268">            <span class="tok-kw">defer</span> gz.anon_name_strategy = prev_anon_name_strategy;</span>
<span class="line" id="L3269">            <span class="tok-kw">const</span> init_inst = <span class="tok-kw">try</span> reachableExpr(gz, scope, init_result_info, var_decl.ast.init_node, node);</span>
<span class="line" id="L3270"></span>
<span class="line" id="L3271">            <span class="tok-comment">// The const init expression may have modified the error return trace, so signal</span>
</span>
<span class="line" id="L3272">            <span class="tok-comment">// to Sema that it should save the new index for restoring later.</span>
</span>
<span class="line" id="L3273">            <span class="tok-kw">if</span> (nodeMayAppendToErrorTrace(tree, var_decl.ast.init_node))</span>
<span class="line" id="L3274">                _ = <span class="tok-kw">try</span> gz.addSaveErrRetIndex(.{ .if_of_error_type = init_inst });</span>
<span class="line" id="L3275"></span>
<span class="line" id="L3276">            <span class="tok-kw">const</span> const_ptr = <span class="tok-kw">if</span> (resolve_inferred_alloc != .none) p: {</span>
<span class="line" id="L3277">                _ = <span class="tok-kw">try</span> gz.addUnNode(.resolve_inferred_alloc, resolve_inferred_alloc, node);</span>
<span class="line" id="L3278">                <span class="tok-kw">break</span> :p var_ptr;</span>
<span class="line" id="L3279">            } <span class="tok-kw">else</span> <span class="tok-kw">try</span> gz.addUnNode(.make_ptr_const, var_ptr, node);</span>
<span class="line" id="L3280"></span>
<span class="line" id="L3281">            <span class="tok-kw">try</span> gz.addDbgVar(.dbg_var_ptr, ident_name, const_ptr);</span>
<span class="line" id="L3282"></span>
<span class="line" id="L3283">            <span class="tok-kw">const</span> sub_scope = <span class="tok-kw">try</span> block_arena.create(Scope.LocalPtr);</span>
<span class="line" id="L3284">            sub_scope.* = .{</span>
<span class="line" id="L3285">                .parent = scope,</span>
<span class="line" id="L3286">                .gen_zir = gz,</span>
<span class="line" id="L3287">                .name = ident_name,</span>
<span class="line" id="L3288">                .ptr = const_ptr,</span>
<span class="line" id="L3289">                .token_src = name_token,</span>
<span class="line" id="L3290">                .maybe_comptime = <span class="tok-null">true</span>,</span>
<span class="line" id="L3291">                .id_cat = .@&quot;local constant&quot;,</span>
<span class="line" id="L3292">            };</span>
<span class="line" id="L3293">            <span class="tok-kw">return</span> &amp;sub_scope.base;</span>
<span class="line" id="L3294">        },</span>
<span class="line" id="L3295">        .keyword_var =&gt; {</span>
<span class="line" id="L3296">            <span class="tok-kw">if</span> (var_decl.comptime_token != <span class="tok-null">null</span> <span class="tok-kw">and</span> gz.is_comptime)</span>
<span class="line" id="L3297">                <span class="tok-kw">return</span> astgen.failTok(var_decl.comptime_token.?, <span class="tok-str">&quot;'comptime var' is redundant in comptime scope&quot;</span>, .{});</span>
<span class="line" id="L3298">            <span class="tok-kw">const</span> is_comptime = var_decl.comptime_token != <span class="tok-null">null</span> <span class="tok-kw">or</span> gz.is_comptime;</span>
<span class="line" id="L3299">            <span class="tok-kw">var</span> resolve_inferred_alloc: Zir.Inst.Ref = .none;</span>
<span class="line" id="L3300">            <span class="tok-kw">const</span> alloc: Zir.Inst.Ref, <span class="tok-kw">const</span> result_info: ResultInfo = <span class="tok-kw">if</span> (var_decl.ast.type_node != <span class="tok-number">0</span>) a: {</span>
<span class="line" id="L3301">                <span class="tok-kw">const</span> type_inst = <span class="tok-kw">try</span> typeExpr(gz, scope, var_decl.ast.type_node);</span>
<span class="line" id="L3302">                <span class="tok-kw">const</span> alloc = alloc: {</span>
<span class="line" id="L3303">                    <span class="tok-kw">if</span> (align_inst == .none) {</span>
<span class="line" id="L3304">                        <span class="tok-kw">const</span> tag: Zir.Inst.Tag = <span class="tok-kw">if</span> (is_comptime)</span>
<span class="line" id="L3305">                            .alloc_comptime_mut</span>
<span class="line" id="L3306">                        <span class="tok-kw">else</span></span>
<span class="line" id="L3307">                            .alloc_mut;</span>
<span class="line" id="L3308">                        <span class="tok-kw">break</span> :alloc <span class="tok-kw">try</span> gz.addUnNode(tag, type_inst, node);</span>
<span class="line" id="L3309">                    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L3310">                        <span class="tok-kw">break</span> :alloc <span class="tok-kw">try</span> gz.addAllocExtended(.{</span>
<span class="line" id="L3311">                            .node = node,</span>
<span class="line" id="L3312">                            .type_inst = type_inst,</span>
<span class="line" id="L3313">                            .align_inst = align_inst,</span>
<span class="line" id="L3314">                            .is_const = <span class="tok-null">false</span>,</span>
<span class="line" id="L3315">                            .is_comptime = is_comptime,</span>
<span class="line" id="L3316">                        });</span>
<span class="line" id="L3317">                    }</span>
<span class="line" id="L3318">                };</span>
<span class="line" id="L3319">                <span class="tok-kw">break</span> :a .{ alloc, .{ .rl = .{ .ptr = .{ .inst = alloc } } } };</span>
<span class="line" id="L3320">            } <span class="tok-kw">else</span> a: {</span>
<span class="line" id="L3321">                <span class="tok-kw">const</span> alloc = alloc: {</span>
<span class="line" id="L3322">                    <span class="tok-kw">if</span> (align_inst == .none) {</span>
<span class="line" id="L3323">                        <span class="tok-kw">const</span> tag: Zir.Inst.Tag = <span class="tok-kw">if</span> (is_comptime)</span>
<span class="line" id="L3324">                            .alloc_inferred_comptime_mut</span>
<span class="line" id="L3325">                        <span class="tok-kw">else</span></span>
<span class="line" id="L3326">                            .alloc_inferred_mut;</span>
<span class="line" id="L3327">                        <span class="tok-kw">break</span> :alloc <span class="tok-kw">try</span> gz.addNode(tag, node);</span>
<span class="line" id="L3328">                    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L3329">                        <span class="tok-kw">break</span> :alloc <span class="tok-kw">try</span> gz.addAllocExtended(.{</span>
<span class="line" id="L3330">                            .node = node,</span>
<span class="line" id="L3331">                            .type_inst = .none,</span>
<span class="line" id="L3332">                            .align_inst = align_inst,</span>
<span class="line" id="L3333">                            .is_const = <span class="tok-null">false</span>,</span>
<span class="line" id="L3334">                            .is_comptime = is_comptime,</span>
<span class="line" id="L3335">                        });</span>
<span class="line" id="L3336">                    }</span>
<span class="line" id="L3337">                };</span>
<span class="line" id="L3338">                resolve_inferred_alloc = alloc;</span>
<span class="line" id="L3339">                <span class="tok-kw">break</span> :a .{ alloc, .{ .rl = .{ .inferred_ptr = alloc } } };</span>
<span class="line" id="L3340">            };</span>
<span class="line" id="L3341">            <span class="tok-kw">const</span> prev_anon_name_strategy = gz.anon_name_strategy;</span>
<span class="line" id="L3342">            gz.anon_name_strategy = .dbg_var;</span>
<span class="line" id="L3343">            _ = <span class="tok-kw">try</span> reachableExprComptime(gz, scope, result_info, var_decl.ast.init_node, node, is_comptime);</span>
<span class="line" id="L3344">            gz.anon_name_strategy = prev_anon_name_strategy;</span>
<span class="line" id="L3345">            <span class="tok-kw">if</span> (resolve_inferred_alloc != .none) {</span>
<span class="line" id="L3346">                _ = <span class="tok-kw">try</span> gz.addUnNode(.resolve_inferred_alloc, resolve_inferred_alloc, node);</span>
<span class="line" id="L3347">            }</span>
<span class="line" id="L3348"></span>
<span class="line" id="L3349">            <span class="tok-kw">try</span> gz.addDbgVar(.dbg_var_ptr, ident_name, alloc);</span>
<span class="line" id="L3350"></span>
<span class="line" id="L3351">            <span class="tok-kw">const</span> sub_scope = <span class="tok-kw">try</span> block_arena.create(Scope.LocalPtr);</span>
<span class="line" id="L3352">            sub_scope.* = .{</span>
<span class="line" id="L3353">                .parent = scope,</span>
<span class="line" id="L3354">                .gen_zir = gz,</span>
<span class="line" id="L3355">                .name = ident_name,</span>
<span class="line" id="L3356">                .ptr = alloc,</span>
<span class="line" id="L3357">                .token_src = name_token,</span>
<span class="line" id="L3358">                .maybe_comptime = is_comptime,</span>
<span class="line" id="L3359">                .id_cat = .@&quot;local variable&quot;,</span>
<span class="line" id="L3360">            };</span>
<span class="line" id="L3361">            <span class="tok-kw">return</span> &amp;sub_scope.base;</span>
<span class="line" id="L3362">        },</span>
<span class="line" id="L3363">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L3364">    }</span>
<span class="line" id="L3365">}</span>
<span class="line" id="L3366"></span>
<span class="line" id="L3367"><span class="tok-kw">fn</span> <span class="tok-fn">emitDbgNode</span>(gz: *GenZir, node: Ast.Node.Index) !<span class="tok-type">void</span> {</span>
<span class="line" id="L3368">    <span class="tok-comment">// The instruction emitted here is for debugging runtime code.</span>
</span>
<span class="line" id="L3369">    <span class="tok-comment">// If the current block will be evaluated only during semantic analysis</span>
</span>
<span class="line" id="L3370">    <span class="tok-comment">// then no dbg_stmt ZIR instruction is needed.</span>
</span>
<span class="line" id="L3371">    <span class="tok-kw">if</span> (gz.is_comptime) <span class="tok-kw">return</span>;</span>
<span class="line" id="L3372">    <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L3373">    astgen.advanceSourceCursorToNode(node);</span>
<span class="line" id="L3374">    <span class="tok-kw">const</span> line = astgen.source_line - gz.decl_line;</span>
<span class="line" id="L3375">    <span class="tok-kw">const</span> column = astgen.source_column;</span>
<span class="line" id="L3376">    <span class="tok-kw">try</span> emitDbgStmt(gz, .{ line, column });</span>
<span class="line" id="L3377">}</span>
<span class="line" id="L3378"></span>
<span class="line" id="L3379"><span class="tok-kw">fn</span> <span class="tok-fn">assign</span>(gz: *GenZir, scope: *Scope, infix_node: Ast.Node.Index) InnerError!<span class="tok-type">void</span> {</span>
<span class="line" id="L3380">    <span class="tok-kw">try</span> emitDbgNode(gz, infix_node);</span>
<span class="line" id="L3381">    <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L3382">    <span class="tok-kw">const</span> tree = astgen.tree;</span>
<span class="line" id="L3383">    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);</span>
<span class="line" id="L3384">    <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);</span>
<span class="line" id="L3385">    <span class="tok-kw">const</span> node_tags = tree.nodes.items(.tag);</span>
<span class="line" id="L3386"></span>
<span class="line" id="L3387">    <span class="tok-kw">const</span> lhs = node_datas[infix_node].lhs;</span>
<span class="line" id="L3388">    <span class="tok-kw">const</span> rhs = node_datas[infix_node].rhs;</span>
<span class="line" id="L3389">    <span class="tok-kw">if</span> (node_tags[lhs] == .identifier) {</span>
<span class="line" id="L3390">        <span class="tok-comment">// This intentionally does not support `@&quot;_&quot;` syntax.</span>
</span>
<span class="line" id="L3391">        <span class="tok-kw">const</span> ident_name = tree.tokenSlice(main_tokens[lhs]);</span>
<span class="line" id="L3392">        <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, ident_name, <span class="tok-str">&quot;_&quot;</span>)) {</span>
<span class="line" id="L3393">            _ = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .discard, .ctx = .assignment }, rhs);</span>
<span class="line" id="L3394">            <span class="tok-kw">return</span>;</span>
<span class="line" id="L3395">        }</span>
<span class="line" id="L3396">    }</span>
<span class="line" id="L3397">    <span class="tok-kw">const</span> lvalue = <span class="tok-kw">try</span> lvalExpr(gz, scope, lhs);</span>
<span class="line" id="L3398">    _ = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .{ .ptr = .{</span>
<span class="line" id="L3399">        .inst = lvalue,</span>
<span class="line" id="L3400">        .src_node = infix_node,</span>
<span class="line" id="L3401">    } } }, rhs);</span>
<span class="line" id="L3402">}</span>
<span class="line" id="L3403"></span>
<span class="line" id="L3404"><span class="tok-comment">/// Handles destructure assignments where no LHS is a `const` or `var` decl.</span></span>
<span class="line" id="L3405"><span class="tok-kw">fn</span> <span class="tok-fn">assignDestructure</span>(gz: *GenZir, scope: *Scope, node: Ast.Node.Index) InnerError!<span class="tok-type">void</span> {</span>
<span class="line" id="L3406">    <span class="tok-kw">try</span> emitDbgNode(gz, node);</span>
<span class="line" id="L3407">    <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L3408">    <span class="tok-kw">const</span> tree = astgen.tree;</span>
<span class="line" id="L3409">    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);</span>
<span class="line" id="L3410">    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);</span>
<span class="line" id="L3411">    <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);</span>
<span class="line" id="L3412">    <span class="tok-kw">const</span> node_tags = tree.nodes.items(.tag);</span>
<span class="line" id="L3413"></span>
<span class="line" id="L3414">    <span class="tok-kw">const</span> extra_index = node_datas[node].lhs;</span>
<span class="line" id="L3415">    <span class="tok-kw">const</span> lhs_count = tree.extra_data[extra_index];</span>
<span class="line" id="L3416">    <span class="tok-kw">const</span> lhs_nodes: []<span class="tok-kw">const</span> Ast.Node.Index = <span class="tok-builtin">@ptrCast</span>(tree.extra_data[extra_index + <span class="tok-number">1</span> ..][<span class="tok-number">0</span>..lhs_count]);</span>
<span class="line" id="L3417">    <span class="tok-kw">const</span> rhs = node_datas[node].rhs;</span>
<span class="line" id="L3418"></span>
<span class="line" id="L3419">    <span class="tok-kw">const</span> maybe_comptime_token = tree.firstToken(node) - <span class="tok-number">1</span>;</span>
<span class="line" id="L3420">    <span class="tok-kw">const</span> declared_comptime = token_tags[maybe_comptime_token] == .keyword_comptime;</span>
<span class="line" id="L3421"></span>
<span class="line" id="L3422">    <span class="tok-kw">if</span> (declared_comptime <span class="tok-kw">and</span> gz.is_comptime) {</span>
<span class="line" id="L3423">        <span class="tok-kw">return</span> astgen.failNode(node, <span class="tok-str">&quot;redundant comptime keyword in already comptime scope&quot;</span>, .{});</span>
<span class="line" id="L3424">    }</span>
<span class="line" id="L3425"></span>
<span class="line" id="L3426">    <span class="tok-comment">// If this expression is marked comptime, we must wrap the whole thing in a comptime block.</span>
</span>
<span class="line" id="L3427">    <span class="tok-kw">var</span> gz_buf: GenZir = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L3428">    <span class="tok-kw">const</span> inner_gz = <span class="tok-kw">if</span> (declared_comptime) bs: {</span>
<span class="line" id="L3429">        gz_buf = gz.makeSubBlock(scope);</span>
<span class="line" id="L3430">        gz_buf.is_comptime = <span class="tok-null">true</span>;</span>
<span class="line" id="L3431">        <span class="tok-kw">break</span> :bs &amp;gz_buf;</span>
<span class="line" id="L3432">    } <span class="tok-kw">else</span> gz;</span>
<span class="line" id="L3433">    <span class="tok-kw">defer</span> <span class="tok-kw">if</span> (declared_comptime) inner_gz.unstack();</span>
<span class="line" id="L3434"></span>
<span class="line" id="L3435">    <span class="tok-kw">const</span> rl_components = <span class="tok-kw">try</span> astgen.arena.alloc(ResultInfo.Loc.DestructureComponent, lhs_nodes.len);</span>
<span class="line" id="L3436">    <span class="tok-kw">for</span> (rl_components, lhs_nodes) |*lhs_rl, lhs_node| {</span>
<span class="line" id="L3437">        <span class="tok-kw">if</span> (node_tags[lhs_node] == .identifier) {</span>
<span class="line" id="L3438">            <span class="tok-comment">// This intentionally does not support `@&quot;_&quot;` syntax.</span>
</span>
<span class="line" id="L3439">            <span class="tok-kw">const</span> ident_name = tree.tokenSlice(main_tokens[lhs_node]);</span>
<span class="line" id="L3440">            <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, ident_name, <span class="tok-str">&quot;_&quot;</span>)) {</span>
<span class="line" id="L3441">                lhs_rl.* = .discard;</span>
<span class="line" id="L3442">                <span class="tok-kw">continue</span>;</span>
<span class="line" id="L3443">            }</span>
<span class="line" id="L3444">        }</span>
<span class="line" id="L3445">        lhs_rl.* = .{ .typed_ptr = .{</span>
<span class="line" id="L3446">            .inst = <span class="tok-kw">try</span> lvalExpr(inner_gz, scope, lhs_node),</span>
<span class="line" id="L3447">            .src_node = lhs_node,</span>
<span class="line" id="L3448">        } };</span>
<span class="line" id="L3449">    }</span>
<span class="line" id="L3450"></span>
<span class="line" id="L3451">    <span class="tok-kw">const</span> ri: ResultInfo = .{ .rl = .{ .destructure = .{</span>
<span class="line" id="L3452">        .src_node = node,</span>
<span class="line" id="L3453">        .components = rl_components,</span>
<span class="line" id="L3454">    } } };</span>
<span class="line" id="L3455"></span>
<span class="line" id="L3456">    _ = <span class="tok-kw">try</span> expr(inner_gz, scope, ri, rhs);</span>
<span class="line" id="L3457"></span>
<span class="line" id="L3458">    <span class="tok-kw">if</span> (declared_comptime) {</span>
<span class="line" id="L3459">        <span class="tok-kw">const</span> comptime_block_inst = <span class="tok-kw">try</span> gz.makeBlockInst(.block_comptime, node);</span>
<span class="line" id="L3460">        _ = <span class="tok-kw">try</span> inner_gz.addBreak(.@&quot;break&quot;, comptime_block_inst, .void_value);</span>
<span class="line" id="L3461">        <span class="tok-kw">try</span> inner_gz.setBlockBody(comptime_block_inst);</span>
<span class="line" id="L3462">        <span class="tok-kw">try</span> gz.instructions.append(gz.astgen.gpa, comptime_block_inst);</span>
<span class="line" id="L3463">    }</span>
<span class="line" id="L3464">}</span>
<span class="line" id="L3465"></span>
<span class="line" id="L3466"><span class="tok-comment">/// Handles destructure assignments where the LHS may contain `const` or `var` decls.</span></span>
<span class="line" id="L3467"><span class="tok-kw">fn</span> <span class="tok-fn">assignDestructureMaybeDecls</span>(</span>
<span class="line" id="L3468">    gz: *GenZir,</span>
<span class="line" id="L3469">    scope: *Scope,</span>
<span class="line" id="L3470">    node: Ast.Node.Index,</span>
<span class="line" id="L3471">    block_arena: Allocator,</span>
<span class="line" id="L3472">) InnerError!*Scope {</span>
<span class="line" id="L3473">    <span class="tok-kw">try</span> emitDbgNode(gz, node);</span>
<span class="line" id="L3474">    <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L3475">    <span class="tok-kw">const</span> tree = astgen.tree;</span>
<span class="line" id="L3476">    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);</span>
<span class="line" id="L3477">    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);</span>
<span class="line" id="L3478">    <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);</span>
<span class="line" id="L3479">    <span class="tok-kw">const</span> node_tags = tree.nodes.items(.tag);</span>
<span class="line" id="L3480"></span>
<span class="line" id="L3481">    <span class="tok-kw">const</span> extra_index = node_datas[node].lhs;</span>
<span class="line" id="L3482">    <span class="tok-kw">const</span> lhs_count = tree.extra_data[extra_index];</span>
<span class="line" id="L3483">    <span class="tok-kw">const</span> lhs_nodes: []<span class="tok-kw">const</span> Ast.Node.Index = <span class="tok-builtin">@ptrCast</span>(tree.extra_data[extra_index + <span class="tok-number">1</span> ..][<span class="tok-number">0</span>..lhs_count]);</span>
<span class="line" id="L3484">    <span class="tok-kw">const</span> rhs = node_datas[node].rhs;</span>
<span class="line" id="L3485"></span>
<span class="line" id="L3486">    <span class="tok-kw">const</span> maybe_comptime_token = tree.firstToken(node) - <span class="tok-number">1</span>;</span>
<span class="line" id="L3487">    <span class="tok-kw">const</span> declared_comptime = token_tags[maybe_comptime_token] == .keyword_comptime;</span>
<span class="line" id="L3488">    <span class="tok-kw">if</span> (declared_comptime <span class="tok-kw">and</span> gz.is_comptime) {</span>
<span class="line" id="L3489">        <span class="tok-kw">return</span> astgen.failNode(node, <span class="tok-str">&quot;redundant comptime keyword in already comptime scope&quot;</span>, .{});</span>
<span class="line" id="L3490">    }</span>
<span class="line" id="L3491"></span>
<span class="line" id="L3492">    <span class="tok-kw">const</span> is_comptime = declared_comptime <span class="tok-kw">or</span> gz.is_comptime;</span>
<span class="line" id="L3493">    <span class="tok-kw">const</span> rhs_is_comptime = tree.nodes.items(.tag)[rhs] == .@&quot;comptime&quot;;</span>
<span class="line" id="L3494"></span>
<span class="line" id="L3495">    <span class="tok-comment">// When declaring consts via a destructure, we always use a result pointer.</span>
</span>
<span class="line" id="L3496">    <span class="tok-comment">// This avoids the need to create tuple types, and is also likely easier to</span>
</span>
<span class="line" id="L3497">    <span class="tok-comment">// optimize, since it's a bit tricky for the optimizer to &quot;split up&quot; the</span>
</span>
<span class="line" id="L3498">    <span class="tok-comment">// value into individual pointer writes down the line.</span>
</span>
<span class="line" id="L3499"></span>
<span class="line" id="L3500">    <span class="tok-comment">// We know this rl information won't live past the evaluation of this</span>
</span>
<span class="line" id="L3501">    <span class="tok-comment">// expression, so it may as well go in the block arena.</span>
</span>
<span class="line" id="L3502">    <span class="tok-kw">const</span> rl_components = <span class="tok-kw">try</span> block_arena.alloc(ResultInfo.Loc.DestructureComponent, lhs_nodes.len);</span>
<span class="line" id="L3503">    <span class="tok-kw">var</span> any_non_const_lhs = <span class="tok-null">false</span>;</span>
<span class="line" id="L3504">    <span class="tok-kw">var</span> any_lvalue_expr = <span class="tok-null">false</span>;</span>
<span class="line" id="L3505">    <span class="tok-kw">for</span> (rl_components, lhs_nodes) |*lhs_rl, lhs_node| {</span>
<span class="line" id="L3506">        <span class="tok-kw">switch</span> (node_tags[lhs_node]) {</span>
<span class="line" id="L3507">            .identifier =&gt; {</span>
<span class="line" id="L3508">                <span class="tok-comment">// This intentionally does not support `@&quot;_&quot;` syntax.</span>
</span>
<span class="line" id="L3509">                <span class="tok-kw">const</span> ident_name = tree.tokenSlice(main_tokens[lhs_node]);</span>
<span class="line" id="L3510">                <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, ident_name, <span class="tok-str">&quot;_&quot;</span>)) {</span>
<span class="line" id="L3511">                    any_non_const_lhs = <span class="tok-null">true</span>;</span>
<span class="line" id="L3512">                    lhs_rl.* = .discard;</span>
<span class="line" id="L3513">                    <span class="tok-kw">continue</span>;</span>
<span class="line" id="L3514">                }</span>
<span class="line" id="L3515">            },</span>
<span class="line" id="L3516">            .global_var_decl, .local_var_decl, .simple_var_decl, .aligned_var_decl =&gt; {</span>
<span class="line" id="L3517">                <span class="tok-kw">const</span> full = tree.fullVarDecl(lhs_node).?;</span>
<span class="line" id="L3518"></span>
<span class="line" id="L3519">                <span class="tok-kw">const</span> name_token = full.ast.mut_token + <span class="tok-number">1</span>;</span>
<span class="line" id="L3520">                <span class="tok-kw">const</span> ident_name_raw = tree.tokenSlice(name_token);</span>
<span class="line" id="L3521">                <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, ident_name_raw, <span class="tok-str">&quot;_&quot;</span>)) {</span>
<span class="line" id="L3522">                    <span class="tok-kw">return</span> astgen.failTok(name_token, <span class="tok-str">&quot;'_' used as an identifier without @\&quot;_\&quot; syntax&quot;</span>, .{});</span>
<span class="line" id="L3523">                }</span>
<span class="line" id="L3524"></span>
<span class="line" id="L3525">                <span class="tok-comment">// We detect shadowing in the second pass over these, while we're creating scopes.</span>
</span>
<span class="line" id="L3526"></span>
<span class="line" id="L3527">                <span class="tok-kw">if</span> (full.ast.addrspace_node != <span class="tok-number">0</span>) {</span>
<span class="line" id="L3528">                    <span class="tok-kw">return</span> astgen.failTok(main_tokens[full.ast.addrspace_node], <span class="tok-str">&quot;cannot set address space of local variable '{s}'&quot;</span>, .{ident_name_raw});</span>
<span class="line" id="L3529">                }</span>
<span class="line" id="L3530">                <span class="tok-kw">if</span> (full.ast.section_node != <span class="tok-number">0</span>) {</span>
<span class="line" id="L3531">                    <span class="tok-kw">return</span> astgen.failTok(main_tokens[full.ast.section_node], <span class="tok-str">&quot;cannot set section of local variable '{s}'&quot;</span>, .{ident_name_raw});</span>
<span class="line" id="L3532">                }</span>
<span class="line" id="L3533"></span>
<span class="line" id="L3534">                <span class="tok-kw">const</span> is_const = <span class="tok-kw">switch</span> (token_tags[full.ast.mut_token]) {</span>
<span class="line" id="L3535">                    .keyword_var =&gt; <span class="tok-null">false</span>,</span>
<span class="line" id="L3536">                    .keyword_const =&gt; <span class="tok-null">true</span>,</span>
<span class="line" id="L3537">                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L3538">                };</span>
<span class="line" id="L3539">                <span class="tok-kw">if</span> (!is_const) any_non_const_lhs = <span class="tok-null">true</span>;</span>
<span class="line" id="L3540"></span>
<span class="line" id="L3541">                <span class="tok-comment">// We also mark `const`s as comptime if the RHS is definitely comptime-known.</span>
</span>
<span class="line" id="L3542">                <span class="tok-kw">const</span> this_lhs_comptime = is_comptime <span class="tok-kw">or</span> (is_const <span class="tok-kw">and</span> rhs_is_comptime);</span>
<span class="line" id="L3543"></span>
<span class="line" id="L3544">                <span class="tok-kw">const</span> align_inst: Zir.Inst.Ref = <span class="tok-kw">if</span> (full.ast.align_node != <span class="tok-number">0</span>)</span>
<span class="line" id="L3545">                    <span class="tok-kw">try</span> expr(gz, scope, coerced_align_ri, full.ast.align_node)</span>
<span class="line" id="L3546">                <span class="tok-kw">else</span></span>
<span class="line" id="L3547">                    .none;</span>
<span class="line" id="L3548"></span>
<span class="line" id="L3549">                <span class="tok-kw">if</span> (full.ast.type_node != <span class="tok-number">0</span>) {</span>
<span class="line" id="L3550">                    <span class="tok-comment">// Typed alloc</span>
</span>
<span class="line" id="L3551">                    <span class="tok-kw">const</span> type_inst = <span class="tok-kw">try</span> typeExpr(gz, scope, full.ast.type_node);</span>
<span class="line" id="L3552">                    <span class="tok-kw">const</span> ptr = <span class="tok-kw">if</span> (align_inst == .none) ptr: {</span>
<span class="line" id="L3553">                        <span class="tok-kw">const</span> tag: Zir.Inst.Tag = <span class="tok-kw">if</span> (is_const)</span>
<span class="line" id="L3554">                            .alloc</span>
<span class="line" id="L3555">                        <span class="tok-kw">else</span> <span class="tok-kw">if</span> (this_lhs_comptime)</span>
<span class="line" id="L3556">                            .alloc_comptime_mut</span>
<span class="line" id="L3557">                        <span class="tok-kw">else</span></span>
<span class="line" id="L3558">                            .alloc_mut;</span>
<span class="line" id="L3559">                        <span class="tok-kw">break</span> :ptr <span class="tok-kw">try</span> gz.addUnNode(tag, type_inst, node);</span>
<span class="line" id="L3560">                    } <span class="tok-kw">else</span> <span class="tok-kw">try</span> gz.addAllocExtended(.{</span>
<span class="line" id="L3561">                        .node = node,</span>
<span class="line" id="L3562">                        .type_inst = type_inst,</span>
<span class="line" id="L3563">                        .align_inst = align_inst,</span>
<span class="line" id="L3564">                        .is_const = is_const,</span>
<span class="line" id="L3565">                        .is_comptime = this_lhs_comptime,</span>
<span class="line" id="L3566">                    });</span>
<span class="line" id="L3567">                    lhs_rl.* = .{ .typed_ptr = .{ .inst = ptr } };</span>
<span class="line" id="L3568">                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L3569">                    <span class="tok-comment">// Inferred alloc</span>
</span>
<span class="line" id="L3570">                    <span class="tok-kw">const</span> ptr = <span class="tok-kw">if</span> (align_inst == .none) ptr: {</span>
<span class="line" id="L3571">                        <span class="tok-kw">const</span> tag: Zir.Inst.Tag = <span class="tok-kw">if</span> (is_const) tag: {</span>
<span class="line" id="L3572">                            <span class="tok-kw">break</span> :tag <span class="tok-kw">if</span> (this_lhs_comptime) .alloc_inferred_comptime <span class="tok-kw">else</span> .alloc_inferred;</span>
<span class="line" id="L3573">                        } <span class="tok-kw">else</span> tag: {</span>
<span class="line" id="L3574">                            <span class="tok-kw">break</span> :tag <span class="tok-kw">if</span> (this_lhs_comptime) .alloc_inferred_comptime_mut <span class="tok-kw">else</span> .alloc_inferred_mut;</span>
<span class="line" id="L3575">                        };</span>
<span class="line" id="L3576">                        <span class="tok-kw">break</span> :ptr <span class="tok-kw">try</span> gz.addNode(tag, node);</span>
<span class="line" id="L3577">                    } <span class="tok-kw">else</span> <span class="tok-kw">try</span> gz.addAllocExtended(.{</span>
<span class="line" id="L3578">                        .node = node,</span>
<span class="line" id="L3579">                        .type_inst = .none,</span>
<span class="line" id="L3580">                        .align_inst = align_inst,</span>
<span class="line" id="L3581">                        .is_const = is_const,</span>
<span class="line" id="L3582">                        .is_comptime = this_lhs_comptime,</span>
<span class="line" id="L3583">                    });</span>
<span class="line" id="L3584">                    lhs_rl.* = .{ .inferred_ptr = ptr };</span>
<span class="line" id="L3585">                }</span>
<span class="line" id="L3586"></span>
<span class="line" id="L3587">                <span class="tok-kw">continue</span>;</span>
<span class="line" id="L3588">            },</span>
<span class="line" id="L3589">            <span class="tok-kw">else</span> =&gt; {},</span>
<span class="line" id="L3590">        }</span>
<span class="line" id="L3591">        <span class="tok-comment">// This LHS is just an lvalue expression.</span>
</span>
<span class="line" id="L3592">        <span class="tok-comment">// We will fill in its result pointer later, inside a comptime block.</span>
</span>
<span class="line" id="L3593">        any_non_const_lhs = <span class="tok-null">true</span>;</span>
<span class="line" id="L3594">        any_lvalue_expr = <span class="tok-null">true</span>;</span>
<span class="line" id="L3595">        lhs_rl.* = .{ .typed_ptr = .{</span>
<span class="line" id="L3596">            .inst = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L3597">            .src_node = lhs_node,</span>
<span class="line" id="L3598">        } };</span>
<span class="line" id="L3599">    }</span>
<span class="line" id="L3600"></span>
<span class="line" id="L3601">    <span class="tok-kw">if</span> (declared_comptime <span class="tok-kw">and</span> !any_non_const_lhs) {</span>
<span class="line" id="L3602">        <span class="tok-kw">try</span> astgen.appendErrorTok(maybe_comptime_token, <span class="tok-str">&quot;'comptime const' is redundant; instead wrap the initialization expression with 'comptime'&quot;</span>, .{});</span>
<span class="line" id="L3603">    }</span>
<span class="line" id="L3604"></span>
<span class="line" id="L3605">    <span class="tok-comment">// If this expression is marked comptime, we must wrap it in a comptime block.</span>
</span>
<span class="line" id="L3606">    <span class="tok-kw">var</span> gz_buf: GenZir = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L3607">    <span class="tok-kw">const</span> inner_gz = <span class="tok-kw">if</span> (declared_comptime) bs: {</span>
<span class="line" id="L3608">        gz_buf = gz.makeSubBlock(scope);</span>
<span class="line" id="L3609">        gz_buf.is_comptime = <span class="tok-null">true</span>;</span>
<span class="line" id="L3610">        <span class="tok-kw">break</span> :bs &amp;gz_buf;</span>
<span class="line" id="L3611">    } <span class="tok-kw">else</span> gz;</span>
<span class="line" id="L3612">    <span class="tok-kw">defer</span> <span class="tok-kw">if</span> (declared_comptime) inner_gz.unstack();</span>
<span class="line" id="L3613"></span>
<span class="line" id="L3614">    <span class="tok-kw">if</span> (any_lvalue_expr) {</span>
<span class="line" id="L3615">        <span class="tok-comment">// At least one LHS was an lvalue expr. Iterate again in order to</span>
</span>
<span class="line" id="L3616">        <span class="tok-comment">// evaluate the lvalues from within the possible block_comptime.</span>
</span>
<span class="line" id="L3617">        <span class="tok-kw">for</span> (rl_components, lhs_nodes) |*lhs_rl, lhs_node| {</span>
<span class="line" id="L3618">            <span class="tok-kw">if</span> (lhs_rl.* != .typed_ptr) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L3619">            <span class="tok-kw">switch</span> (node_tags[lhs_node]) {</span>
<span class="line" id="L3620">                .global_var_decl, .local_var_decl, .simple_var_decl, .aligned_var_decl =&gt; <span class="tok-kw">continue</span>,</span>
<span class="line" id="L3621">                <span class="tok-kw">else</span> =&gt; {},</span>
<span class="line" id="L3622">            }</span>
<span class="line" id="L3623">            lhs_rl.typed_ptr.inst = <span class="tok-kw">try</span> lvalExpr(inner_gz, scope, lhs_node);</span>
<span class="line" id="L3624">        }</span>
<span class="line" id="L3625">    }</span>
<span class="line" id="L3626"></span>
<span class="line" id="L3627">    <span class="tok-comment">// We can't give a reasonable anon name strategy for destructured inits, so</span>
</span>
<span class="line" id="L3628">    <span class="tok-comment">// leave it at its default of `.anon`.</span>
</span>
<span class="line" id="L3629">    _ = <span class="tok-kw">try</span> reachableExpr(inner_gz, scope, .{ .rl = .{ .destructure = .{</span>
<span class="line" id="L3630">        .src_node = node,</span>
<span class="line" id="L3631">        .components = rl_components,</span>
<span class="line" id="L3632">    } } }, rhs, node);</span>
<span class="line" id="L3633"></span>
<span class="line" id="L3634">    <span class="tok-kw">if</span> (declared_comptime) {</span>
<span class="line" id="L3635">        <span class="tok-comment">// Finish the block_comptime. Inferred alloc resolution etc will occur</span>
</span>
<span class="line" id="L3636">        <span class="tok-comment">// in the parent block.</span>
</span>
<span class="line" id="L3637">        <span class="tok-kw">const</span> comptime_block_inst = <span class="tok-kw">try</span> gz.makeBlockInst(.block_comptime, node);</span>
<span class="line" id="L3638">        _ = <span class="tok-kw">try</span> inner_gz.addBreak(.@&quot;break&quot;, comptime_block_inst, .void_value);</span>
<span class="line" id="L3639">        <span class="tok-kw">try</span> inner_gz.setBlockBody(comptime_block_inst);</span>
<span class="line" id="L3640">        <span class="tok-kw">try</span> gz.instructions.append(gz.astgen.gpa, comptime_block_inst);</span>
<span class="line" id="L3641">    }</span>
<span class="line" id="L3642"></span>
<span class="line" id="L3643">    <span class="tok-comment">// Now, iterate over the LHS exprs to construct any new scopes.</span>
</span>
<span class="line" id="L3644">    <span class="tok-comment">// If there were any inferred allocations, resolve them.</span>
</span>
<span class="line" id="L3645">    <span class="tok-comment">// If there were any `const` decls, make the pointer constant.</span>
</span>
<span class="line" id="L3646">    <span class="tok-kw">var</span> cur_scope = scope;</span>
<span class="line" id="L3647">    <span class="tok-kw">for</span> (rl_components, lhs_nodes) |lhs_rl, lhs_node| {</span>
<span class="line" id="L3648">        <span class="tok-kw">switch</span> (node_tags[lhs_node]) {</span>
<span class="line" id="L3649">            .local_var_decl, .simple_var_decl, .aligned_var_decl =&gt; {},</span>
<span class="line" id="L3650">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">continue</span>, <span class="tok-comment">// We were mutating an existing lvalue - nothing to do</span>
</span>
<span class="line" id="L3651">        }</span>
<span class="line" id="L3652">        <span class="tok-kw">const</span> full = tree.fullVarDecl(lhs_node).?;</span>
<span class="line" id="L3653">        <span class="tok-kw">const</span> raw_ptr = <span class="tok-kw">switch</span> (lhs_rl) {</span>
<span class="line" id="L3654">            .discard =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L3655">            .typed_ptr =&gt; |typed_ptr| typed_ptr.inst,</span>
<span class="line" id="L3656">            .inferred_ptr =&gt; |ptr_inst| ptr_inst,</span>
<span class="line" id="L3657">        };</span>
<span class="line" id="L3658">        <span class="tok-comment">// If the alloc was inferred, resolve it.</span>
</span>
<span class="line" id="L3659">        <span class="tok-kw">if</span> (full.ast.type_node == <span class="tok-number">0</span>) {</span>
<span class="line" id="L3660">            _ = <span class="tok-kw">try</span> gz.addUnNode(.resolve_inferred_alloc, raw_ptr, lhs_node);</span>
<span class="line" id="L3661">        }</span>
<span class="line" id="L3662">        <span class="tok-kw">const</span> is_const = <span class="tok-kw">switch</span> (token_tags[full.ast.mut_token]) {</span>
<span class="line" id="L3663">            .keyword_var =&gt; <span class="tok-null">false</span>,</span>
<span class="line" id="L3664">            .keyword_const =&gt; <span class="tok-null">true</span>,</span>
<span class="line" id="L3665">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L3666">        };</span>
<span class="line" id="L3667">        <span class="tok-comment">// If the alloc was const, make it const.</span>
</span>
<span class="line" id="L3668">        <span class="tok-kw">const</span> var_ptr = <span class="tok-kw">if</span> (is_const <span class="tok-kw">and</span> full.ast.type_node != <span class="tok-number">0</span>) make_const: {</span>
<span class="line" id="L3669">            <span class="tok-comment">// Note that we don't do this if type_node == 0 since `resolve_inferred_alloc`</span>
</span>
<span class="line" id="L3670">            <span class="tok-comment">// handles it for us.</span>
</span>
<span class="line" id="L3671">            <span class="tok-kw">break</span> :make_const <span class="tok-kw">try</span> gz.addUnNode(.make_ptr_const, raw_ptr, node);</span>
<span class="line" id="L3672">        } <span class="tok-kw">else</span> raw_ptr;</span>
<span class="line" id="L3673">        <span class="tok-kw">const</span> name_token = full.ast.mut_token + <span class="tok-number">1</span>;</span>
<span class="line" id="L3674">        <span class="tok-kw">const</span> ident_name_raw = tree.tokenSlice(name_token);</span>
<span class="line" id="L3675">        <span class="tok-kw">const</span> ident_name = <span class="tok-kw">try</span> astgen.identAsString(name_token);</span>
<span class="line" id="L3676">        <span class="tok-kw">try</span> astgen.detectLocalShadowing(</span>
<span class="line" id="L3677">            cur_scope,</span>
<span class="line" id="L3678">            ident_name,</span>
<span class="line" id="L3679">            name_token,</span>
<span class="line" id="L3680">            ident_name_raw,</span>
<span class="line" id="L3681">            <span class="tok-kw">if</span> (is_const) .@&quot;local constant&quot; <span class="tok-kw">else</span> .@&quot;local variable&quot;,</span>
<span class="line" id="L3682">        );</span>
<span class="line" id="L3683">        <span class="tok-kw">try</span> gz.addDbgVar(.dbg_var_ptr, ident_name, var_ptr);</span>
<span class="line" id="L3684">        <span class="tok-comment">// Finally, create the scope.</span>
</span>
<span class="line" id="L3685">        <span class="tok-kw">const</span> sub_scope = <span class="tok-kw">try</span> block_arena.create(Scope.LocalPtr);</span>
<span class="line" id="L3686">        sub_scope.* = .{</span>
<span class="line" id="L3687">            .parent = cur_scope,</span>
<span class="line" id="L3688">            .gen_zir = gz,</span>
<span class="line" id="L3689">            .name = ident_name,</span>
<span class="line" id="L3690">            .ptr = var_ptr,</span>
<span class="line" id="L3691">            .token_src = name_token,</span>
<span class="line" id="L3692">            .maybe_comptime = is_const <span class="tok-kw">or</span> is_comptime,</span>
<span class="line" id="L3693">            .id_cat = <span class="tok-kw">if</span> (is_const) .@&quot;local constant&quot; <span class="tok-kw">else</span> .@&quot;local variable&quot;,</span>
<span class="line" id="L3694">        };</span>
<span class="line" id="L3695">        cur_scope = &amp;sub_scope.base;</span>
<span class="line" id="L3696">    }</span>
<span class="line" id="L3697"></span>
<span class="line" id="L3698">    <span class="tok-kw">return</span> cur_scope;</span>
<span class="line" id="L3699">}</span>
<span class="line" id="L3700"></span>
<span class="line" id="L3701"><span class="tok-kw">fn</span> <span class="tok-fn">assignOp</span>(</span>
<span class="line" id="L3702">    gz: *GenZir,</span>
<span class="line" id="L3703">    scope: *Scope,</span>
<span class="line" id="L3704">    infix_node: Ast.Node.Index,</span>
<span class="line" id="L3705">    op_inst_tag: Zir.Inst.Tag,</span>
<span class="line" id="L3706">) InnerError!<span class="tok-type">void</span> {</span>
<span class="line" id="L3707">    <span class="tok-kw">try</span> emitDbgNode(gz, infix_node);</span>
<span class="line" id="L3708">    <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L3709">    <span class="tok-kw">const</span> tree = astgen.tree;</span>
<span class="line" id="L3710">    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);</span>
<span class="line" id="L3711"></span>
<span class="line" id="L3712">    <span class="tok-kw">const</span> lhs_ptr = <span class="tok-kw">try</span> lvalExpr(gz, scope, node_datas[infix_node].lhs);</span>
<span class="line" id="L3713"></span>
<span class="line" id="L3714">    <span class="tok-kw">const</span> cursor = <span class="tok-kw">switch</span> (op_inst_tag) {</span>
<span class="line" id="L3715">        .add, .sub, .mul, .div, .mod_rem =&gt; maybeAdvanceSourceCursorToMainToken(gz, infix_node),</span>
<span class="line" id="L3716">        <span class="tok-kw">else</span> =&gt; <span class="tok-null">undefined</span>,</span>
<span class="line" id="L3717">    };</span>
<span class="line" id="L3718">    <span class="tok-kw">const</span> lhs = <span class="tok-kw">try</span> gz.addUnNode(.load, lhs_ptr, infix_node);</span>
<span class="line" id="L3719">    <span class="tok-kw">const</span> lhs_type = <span class="tok-kw">try</span> gz.addUnNode(.typeof, lhs, infix_node);</span>
<span class="line" id="L3720">    <span class="tok-kw">const</span> rhs = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .{ .coerced_ty = lhs_type } }, node_datas[infix_node].rhs);</span>
<span class="line" id="L3721"></span>
<span class="line" id="L3722">    <span class="tok-kw">switch</span> (op_inst_tag) {</span>
<span class="line" id="L3723">        .add, .sub, .mul, .div, .mod_rem =&gt; {</span>
<span class="line" id="L3724">            <span class="tok-kw">try</span> emitDbgStmt(gz, cursor);</span>
<span class="line" id="L3725">        },</span>
<span class="line" id="L3726">        <span class="tok-kw">else</span> =&gt; {},</span>
<span class="line" id="L3727">    }</span>
<span class="line" id="L3728">    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addPlNode(op_inst_tag, infix_node, Zir.Inst.Bin{</span>
<span class="line" id="L3729">        .lhs = lhs,</span>
<span class="line" id="L3730">        .rhs = rhs,</span>
<span class="line" id="L3731">    });</span>
<span class="line" id="L3732">    _ = <span class="tok-kw">try</span> gz.addPlNode(.store_node, infix_node, Zir.Inst.Bin{</span>
<span class="line" id="L3733">        .lhs = lhs_ptr,</span>
<span class="line" id="L3734">        .rhs = result,</span>
<span class="line" id="L3735">    });</span>
<span class="line" id="L3736">}</span>
<span class="line" id="L3737"></span>
<span class="line" id="L3738"><span class="tok-kw">fn</span> <span class="tok-fn">assignShift</span>(</span>
<span class="line" id="L3739">    gz: *GenZir,</span>
<span class="line" id="L3740">    scope: *Scope,</span>
<span class="line" id="L3741">    infix_node: Ast.Node.Index,</span>
<span class="line" id="L3742">    op_inst_tag: Zir.Inst.Tag,</span>
<span class="line" id="L3743">) InnerError!<span class="tok-type">void</span> {</span>
<span class="line" id="L3744">    <span class="tok-kw">try</span> emitDbgNode(gz, infix_node);</span>
<span class="line" id="L3745">    <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L3746">    <span class="tok-kw">const</span> tree = astgen.tree;</span>
<span class="line" id="L3747">    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);</span>
<span class="line" id="L3748"></span>
<span class="line" id="L3749">    <span class="tok-kw">const</span> lhs_ptr = <span class="tok-kw">try</span> lvalExpr(gz, scope, node_datas[infix_node].lhs);</span>
<span class="line" id="L3750">    <span class="tok-kw">const</span> lhs = <span class="tok-kw">try</span> gz.addUnNode(.load, lhs_ptr, infix_node);</span>
<span class="line" id="L3751">    <span class="tok-kw">const</span> rhs_type = <span class="tok-kw">try</span> gz.addUnNode(.typeof_log2_int_type, lhs, infix_node);</span>
<span class="line" id="L3752">    <span class="tok-kw">const</span> rhs = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .{ .ty = rhs_type } }, node_datas[infix_node].rhs);</span>
<span class="line" id="L3753"></span>
<span class="line" id="L3754">    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addPlNode(op_inst_tag, infix_node, Zir.Inst.Bin{</span>
<span class="line" id="L3755">        .lhs = lhs,</span>
<span class="line" id="L3756">        .rhs = rhs,</span>
<span class="line" id="L3757">    });</span>
<span class="line" id="L3758">    _ = <span class="tok-kw">try</span> gz.addPlNode(.store_node, infix_node, Zir.Inst.Bin{</span>
<span class="line" id="L3759">        .lhs = lhs_ptr,</span>
<span class="line" id="L3760">        .rhs = result,</span>
<span class="line" id="L3761">    });</span>
<span class="line" id="L3762">}</span>
<span class="line" id="L3763"></span>
<span class="line" id="L3764"><span class="tok-kw">fn</span> <span class="tok-fn">assignShiftSat</span>(gz: *GenZir, scope: *Scope, infix_node: Ast.Node.Index) InnerError!<span class="tok-type">void</span> {</span>
<span class="line" id="L3765">    <span class="tok-kw">try</span> emitDbgNode(gz, infix_node);</span>
<span class="line" id="L3766">    <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L3767">    <span class="tok-kw">const</span> tree = astgen.tree;</span>
<span class="line" id="L3768">    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);</span>
<span class="line" id="L3769"></span>
<span class="line" id="L3770">    <span class="tok-kw">const</span> lhs_ptr = <span class="tok-kw">try</span> lvalExpr(gz, scope, node_datas[infix_node].lhs);</span>
<span class="line" id="L3771">    <span class="tok-kw">const</span> lhs = <span class="tok-kw">try</span> gz.addUnNode(.load, lhs_ptr, infix_node);</span>
<span class="line" id="L3772">    <span class="tok-comment">// Saturating shift-left allows any integer type for both the LHS and RHS.</span>
</span>
<span class="line" id="L3773">    <span class="tok-kw">const</span> rhs = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .none }, node_datas[infix_node].rhs);</span>
<span class="line" id="L3774"></span>
<span class="line" id="L3775">    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addPlNode(.shl_sat, infix_node, Zir.Inst.Bin{</span>
<span class="line" id="L3776">        .lhs = lhs,</span>
<span class="line" id="L3777">        .rhs = rhs,</span>
<span class="line" id="L3778">    });</span>
<span class="line" id="L3779">    _ = <span class="tok-kw">try</span> gz.addPlNode(.store_node, infix_node, Zir.Inst.Bin{</span>
<span class="line" id="L3780">        .lhs = lhs_ptr,</span>
<span class="line" id="L3781">        .rhs = result,</span>
<span class="line" id="L3782">    });</span>
<span class="line" id="L3783">}</span>
<span class="line" id="L3784"></span>
<span class="line" id="L3785"><span class="tok-kw">fn</span> <span class="tok-fn">ptrType</span>(</span>
<span class="line" id="L3786">    gz: *GenZir,</span>
<span class="line" id="L3787">    scope: *Scope,</span>
<span class="line" id="L3788">    ri: ResultInfo,</span>
<span class="line" id="L3789">    node: Ast.Node.Index,</span>
<span class="line" id="L3790">    ptr_info: Ast.full.PtrType,</span>
<span class="line" id="L3791">) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L3792">    <span class="tok-kw">if</span> (ptr_info.size == .C <span class="tok-kw">and</span> ptr_info.allowzero_token != <span class="tok-null">null</span>) {</span>
<span class="line" id="L3793">        <span class="tok-kw">return</span> gz.astgen.failTok(ptr_info.allowzero_token.?, <span class="tok-str">&quot;C pointers always allow address zero&quot;</span>, .{});</span>
<span class="line" id="L3794">    }</span>
<span class="line" id="L3795"></span>
<span class="line" id="L3796">    <span class="tok-kw">const</span> source_offset = gz.astgen.source_offset;</span>
<span class="line" id="L3797">    <span class="tok-kw">const</span> source_line = gz.astgen.source_line;</span>
<span class="line" id="L3798">    <span class="tok-kw">const</span> source_column = gz.astgen.source_column;</span>
<span class="line" id="L3799">    <span class="tok-kw">const</span> elem_type = <span class="tok-kw">try</span> typeExpr(gz, scope, ptr_info.ast.child_type);</span>
<span class="line" id="L3800"></span>
<span class="line" id="L3801">    <span class="tok-kw">var</span> sentinel_ref: Zir.Inst.Ref = .none;</span>
<span class="line" id="L3802">    <span class="tok-kw">var</span> align_ref: Zir.Inst.Ref = .none;</span>
<span class="line" id="L3803">    <span class="tok-kw">var</span> addrspace_ref: Zir.Inst.Ref = .none;</span>
<span class="line" id="L3804">    <span class="tok-kw">var</span> bit_start_ref: Zir.Inst.Ref = .none;</span>
<span class="line" id="L3805">    <span class="tok-kw">var</span> bit_end_ref: Zir.Inst.Ref = .none;</span>
<span class="line" id="L3806">    <span class="tok-kw">var</span> trailing_count: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L3807"></span>
<span class="line" id="L3808">    <span class="tok-kw">if</span> (ptr_info.ast.sentinel != <span class="tok-number">0</span>) {</span>
<span class="line" id="L3809">        <span class="tok-comment">// These attributes can appear in any order and they all come before the</span>
</span>
<span class="line" id="L3810">        <span class="tok-comment">// element type so we need to reset the source cursor before generating them.</span>
</span>
<span class="line" id="L3811">        gz.astgen.source_offset = source_offset;</span>
<span class="line" id="L3812">        gz.astgen.source_line = source_line;</span>
<span class="line" id="L3813">        gz.astgen.source_column = source_column;</span>
<span class="line" id="L3814"></span>
<span class="line" id="L3815">        sentinel_ref = <span class="tok-kw">try</span> comptimeExpr(gz, scope, .{ .rl = .{ .ty = elem_type } }, ptr_info.ast.sentinel);</span>
<span class="line" id="L3816">        trailing_count += <span class="tok-number">1</span>;</span>
<span class="line" id="L3817">    }</span>
<span class="line" id="L3818">    <span class="tok-kw">if</span> (ptr_info.ast.addrspace_node != <span class="tok-number">0</span>) {</span>
<span class="line" id="L3819">        gz.astgen.source_offset = source_offset;</span>
<span class="line" id="L3820">        gz.astgen.source_line = source_line;</span>
<span class="line" id="L3821">        gz.astgen.source_column = source_column;</span>
<span class="line" id="L3822"></span>
<span class="line" id="L3823">        addrspace_ref = <span class="tok-kw">try</span> expr(gz, scope, coerced_addrspace_ri, ptr_info.ast.addrspace_node);</span>
<span class="line" id="L3824">        trailing_count += <span class="tok-number">1</span>;</span>
<span class="line" id="L3825">    }</span>
<span class="line" id="L3826">    <span class="tok-kw">if</span> (ptr_info.ast.align_node != <span class="tok-number">0</span>) {</span>
<span class="line" id="L3827">        gz.astgen.source_offset = source_offset;</span>
<span class="line" id="L3828">        gz.astgen.source_line = source_line;</span>
<span class="line" id="L3829">        gz.astgen.source_column = source_column;</span>
<span class="line" id="L3830"></span>
<span class="line" id="L3831">        align_ref = <span class="tok-kw">try</span> expr(gz, scope, coerced_align_ri, ptr_info.ast.align_node);</span>
<span class="line" id="L3832">        trailing_count += <span class="tok-number">1</span>;</span>
<span class="line" id="L3833">    }</span>
<span class="line" id="L3834">    <span class="tok-kw">if</span> (ptr_info.ast.bit_range_start != <span class="tok-number">0</span>) {</span>
<span class="line" id="L3835">        assert(ptr_info.ast.bit_range_end != <span class="tok-number">0</span>);</span>
<span class="line" id="L3836">        bit_start_ref = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .{ .coerced_ty = .u16_type } }, ptr_info.ast.bit_range_start);</span>
<span class="line" id="L3837">        bit_end_ref = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .{ .coerced_ty = .u16_type } }, ptr_info.ast.bit_range_end);</span>
<span class="line" id="L3838">        trailing_count += <span class="tok-number">2</span>;</span>
<span class="line" id="L3839">    }</span>
<span class="line" id="L3840"></span>
<span class="line" id="L3841">    <span class="tok-kw">const</span> gpa = gz.astgen.gpa;</span>
<span class="line" id="L3842">    <span class="tok-kw">try</span> gz.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);</span>
<span class="line" id="L3843">    <span class="tok-kw">try</span> gz.astgen.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);</span>
<span class="line" id="L3844">    <span class="tok-kw">try</span> gz.astgen.extra.ensureUnusedCapacity(gpa, <span class="tok-builtin">@typeInfo</span>(Zir.Inst.PtrType).Struct.fields.len +</span>
<span class="line" id="L3845">        trailing_count);</span>
<span class="line" id="L3846"></span>
<span class="line" id="L3847">    <span class="tok-kw">const</span> payload_index = gz.astgen.addExtraAssumeCapacity(Zir.Inst.PtrType{</span>
<span class="line" id="L3848">        .elem_type = elem_type,</span>
<span class="line" id="L3849">        .src_node = gz.nodeIndexToRelative(node),</span>
<span class="line" id="L3850">    });</span>
<span class="line" id="L3851">    <span class="tok-kw">if</span> (sentinel_ref != .none) {</span>
<span class="line" id="L3852">        gz.astgen.extra.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(sentinel_ref));</span>
<span class="line" id="L3853">    }</span>
<span class="line" id="L3854">    <span class="tok-kw">if</span> (align_ref != .none) {</span>
<span class="line" id="L3855">        gz.astgen.extra.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(align_ref));</span>
<span class="line" id="L3856">    }</span>
<span class="line" id="L3857">    <span class="tok-kw">if</span> (addrspace_ref != .none) {</span>
<span class="line" id="L3858">        gz.astgen.extra.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(addrspace_ref));</span>
<span class="line" id="L3859">    }</span>
<span class="line" id="L3860">    <span class="tok-kw">if</span> (bit_start_ref != .none) {</span>
<span class="line" id="L3861">        gz.astgen.extra.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(bit_start_ref));</span>
<span class="line" id="L3862">        gz.astgen.extra.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(bit_end_ref));</span>
<span class="line" id="L3863">    }</span>
<span class="line" id="L3864"></span>
<span class="line" id="L3865">    <span class="tok-kw">const</span> new_index: Zir.Inst.Index = <span class="tok-builtin">@enumFromInt</span>(gz.astgen.instructions.len);</span>
<span class="line" id="L3866">    <span class="tok-kw">const</span> result = new_index.toRef();</span>
<span class="line" id="L3867">    gz.astgen.instructions.appendAssumeCapacity(.{ .tag = .ptr_type, .data = .{</span>
<span class="line" id="L3868">        .ptr_type = .{</span>
<span class="line" id="L3869">            .flags = .{</span>
<span class="line" id="L3870">                .is_allowzero = ptr_info.allowzero_token != <span class="tok-null">null</span>,</span>
<span class="line" id="L3871">                .is_mutable = ptr_info.const_token == <span class="tok-null">null</span>,</span>
<span class="line" id="L3872">                .is_volatile = ptr_info.volatile_token != <span class="tok-null">null</span>,</span>
<span class="line" id="L3873">                .has_sentinel = sentinel_ref != .none,</span>
<span class="line" id="L3874">                .has_align = align_ref != .none,</span>
<span class="line" id="L3875">                .has_addrspace = addrspace_ref != .none,</span>
<span class="line" id="L3876">                .has_bit_range = bit_start_ref != .none,</span>
<span class="line" id="L3877">            },</span>
<span class="line" id="L3878">            .size = ptr_info.size,</span>
<span class="line" id="L3879">            .payload_index = payload_index,</span>
<span class="line" id="L3880">        },</span>
<span class="line" id="L3881">    } });</span>
<span class="line" id="L3882">    gz.instructions.appendAssumeCapacity(new_index);</span>
<span class="line" id="L3883"></span>
<span class="line" id="L3884">    <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L3885">}</span>
<span class="line" id="L3886"></span>
<span class="line" id="L3887"><span class="tok-kw">fn</span> <span class="tok-fn">arrayType</span>(gz: *GenZir, scope: *Scope, ri: ResultInfo, node: Ast.Node.Index) !Zir.Inst.Ref {</span>
<span class="line" id="L3888">    <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L3889">    <span class="tok-kw">const</span> tree = astgen.tree;</span>
<span class="line" id="L3890">    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);</span>
<span class="line" id="L3891">    <span class="tok-kw">const</span> node_tags = tree.nodes.items(.tag);</span>
<span class="line" id="L3892">    <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);</span>
<span class="line" id="L3893"></span>
<span class="line" id="L3894">    <span class="tok-kw">const</span> len_node = node_datas[node].lhs;</span>
<span class="line" id="L3895">    <span class="tok-kw">if</span> (node_tags[len_node] == .identifier <span class="tok-kw">and</span></span>
<span class="line" id="L3896">        mem.eql(<span class="tok-type">u8</span>, tree.tokenSlice(main_tokens[len_node]), <span class="tok-str">&quot;_&quot;</span>))</span>
<span class="line" id="L3897">    {</span>
<span class="line" id="L3898">        <span class="tok-kw">return</span> astgen.failNode(len_node, <span class="tok-str">&quot;unable to infer array size&quot;</span>, .{});</span>
<span class="line" id="L3899">    }</span>
<span class="line" id="L3900">    <span class="tok-kw">const</span> len = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .{ .coerced_ty = .usize_type } }, len_node);</span>
<span class="line" id="L3901">    <span class="tok-kw">const</span> elem_type = <span class="tok-kw">try</span> typeExpr(gz, scope, node_datas[node].rhs);</span>
<span class="line" id="L3902"></span>
<span class="line" id="L3903">    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addPlNode(.array_type, node, Zir.Inst.Bin{</span>
<span class="line" id="L3904">        .lhs = len,</span>
<span class="line" id="L3905">        .rhs = elem_type,</span>
<span class="line" id="L3906">    });</span>
<span class="line" id="L3907">    <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L3908">}</span>
<span class="line" id="L3909"></span>
<span class="line" id="L3910"><span class="tok-kw">fn</span> <span class="tok-fn">arrayTypeSentinel</span>(gz: *GenZir, scope: *Scope, ri: ResultInfo, node: Ast.Node.Index) !Zir.Inst.Ref {</span>
<span class="line" id="L3911">    <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L3912">    <span class="tok-kw">const</span> tree = astgen.tree;</span>
<span class="line" id="L3913">    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);</span>
<span class="line" id="L3914">    <span class="tok-kw">const</span> node_tags = tree.nodes.items(.tag);</span>
<span class="line" id="L3915">    <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);</span>
<span class="line" id="L3916">    <span class="tok-kw">const</span> extra = tree.extraData(node_datas[node].rhs, Ast.Node.ArrayTypeSentinel);</span>
<span class="line" id="L3917"></span>
<span class="line" id="L3918">    <span class="tok-kw">const</span> len_node = node_datas[node].lhs;</span>
<span class="line" id="L3919">    <span class="tok-kw">if</span> (node_tags[len_node] == .identifier <span class="tok-kw">and</span></span>
<span class="line" id="L3920">        mem.eql(<span class="tok-type">u8</span>, tree.tokenSlice(main_tokens[len_node]), <span class="tok-str">&quot;_&quot;</span>))</span>
<span class="line" id="L3921">    {</span>
<span class="line" id="L3922">        <span class="tok-kw">return</span> astgen.failNode(len_node, <span class="tok-str">&quot;unable to infer array size&quot;</span>, .{});</span>
<span class="line" id="L3923">    }</span>
<span class="line" id="L3924">    <span class="tok-kw">const</span> len = <span class="tok-kw">try</span> reachableExpr(gz, scope, .{ .rl = .{ .coerced_ty = .usize_type } }, len_node, node);</span>
<span class="line" id="L3925">    <span class="tok-kw">const</span> elem_type = <span class="tok-kw">try</span> typeExpr(gz, scope, extra.elem_type);</span>
<span class="line" id="L3926">    <span class="tok-kw">const</span> sentinel = <span class="tok-kw">try</span> reachableExprComptime(gz, scope, .{ .rl = .{ .coerced_ty = elem_type } }, extra.sentinel, node, <span class="tok-null">true</span>);</span>
<span class="line" id="L3927"></span>
<span class="line" id="L3928">    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addPlNode(.array_type_sentinel, node, Zir.Inst.ArrayTypeSentinel{</span>
<span class="line" id="L3929">        .len = len,</span>
<span class="line" id="L3930">        .elem_type = elem_type,</span>
<span class="line" id="L3931">        .sentinel = sentinel,</span>
<span class="line" id="L3932">    });</span>
<span class="line" id="L3933">    <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L3934">}</span>
<span class="line" id="L3935"></span>
<span class="line" id="L3936"><span class="tok-kw">const</span> WipMembers = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L3937">    payload: *ArrayListUnmanaged(<span class="tok-type">u32</span>),</span>
<span class="line" id="L3938">    payload_top: <span class="tok-type">usize</span>,</span>
<span class="line" id="L3939">    field_bits_start: <span class="tok-type">u32</span>,</span>
<span class="line" id="L3940">    fields_start: <span class="tok-type">u32</span>,</span>
<span class="line" id="L3941">    fields_end: <span class="tok-type">u32</span>,</span>
<span class="line" id="L3942">    decl_index: <span class="tok-type">u32</span> = <span class="tok-number">0</span>,</span>
<span class="line" id="L3943">    field_index: <span class="tok-type">u32</span> = <span class="tok-number">0</span>,</span>
<span class="line" id="L3944"></span>
<span class="line" id="L3945">    <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();</span>
<span class="line" id="L3946"></span>
<span class="line" id="L3947">    <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(gpa: Allocator, payload: *ArrayListUnmanaged(<span class="tok-type">u32</span>), decl_count: <span class="tok-type">u32</span>, field_count: <span class="tok-type">u32</span>, <span class="tok-kw">comptime</span> bits_per_field: <span class="tok-type">u32</span>, <span class="tok-kw">comptime</span> max_field_size: <span class="tok-type">u32</span>) Allocator.Error!Self {</span>
<span class="line" id="L3948">        <span class="tok-kw">const</span> payload_top: <span class="tok-type">u32</span> = <span class="tok-builtin">@intCast</span>(payload.items.len);</span>
<span class="line" id="L3949">        <span class="tok-kw">const</span> field_bits_start = payload_top + decl_count;</span>
<span class="line" id="L3950">        <span class="tok-kw">const</span> fields_start = field_bits_start + <span class="tok-kw">if</span> (bits_per_field &gt; <span class="tok-number">0</span>) blk: {</span>
<span class="line" id="L3951">            <span class="tok-kw">const</span> fields_per_u32 = <span class="tok-number">32</span> / bits_per_field;</span>
<span class="line" id="L3952">            <span class="tok-kw">break</span> :blk (field_count + fields_per_u32 - <span class="tok-number">1</span>) / fields_per_u32;</span>
<span class="line" id="L3953">        } <span class="tok-kw">else</span> <span class="tok-number">0</span>;</span>
<span class="line" id="L3954">        <span class="tok-kw">const</span> payload_end = fields_start + field_count * max_field_size;</span>
<span class="line" id="L3955">        <span class="tok-kw">try</span> payload.resize(gpa, payload_end);</span>
<span class="line" id="L3956">        <span class="tok-kw">return</span> .{</span>
<span class="line" id="L3957">            .payload = payload,</span>
<span class="line" id="L3958">            .payload_top = payload_top,</span>
<span class="line" id="L3959">            .field_bits_start = field_bits_start,</span>
<span class="line" id="L3960">            .fields_start = fields_start,</span>
<span class="line" id="L3961">            .fields_end = fields_start,</span>
<span class="line" id="L3962">        };</span>
<span class="line" id="L3963">    }</span>
<span class="line" id="L3964"></span>
<span class="line" id="L3965">    <span class="tok-kw">fn</span> <span class="tok-fn">nextDecl</span>(self: *Self, decl_inst: Zir.Inst.Index) <span class="tok-type">void</span> {</span>
<span class="line" id="L3966">        self.payload.items[self.payload_top + self.decl_index] = <span class="tok-builtin">@intFromEnum</span>(decl_inst);</span>
<span class="line" id="L3967">        self.decl_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L3968">    }</span>
<span class="line" id="L3969"></span>
<span class="line" id="L3970">    <span class="tok-kw">fn</span> <span class="tok-fn">nextField</span>(self: *Self, <span class="tok-kw">comptime</span> bits_per_field: <span class="tok-type">u32</span>, bits: [bits_per_field]<span class="tok-type">bool</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L3971">        <span class="tok-kw">const</span> fields_per_u32 = <span class="tok-number">32</span> / bits_per_field;</span>
<span class="line" id="L3972">        <span class="tok-kw">const</span> index = self.field_bits_start + self.field_index / fields_per_u32;</span>
<span class="line" id="L3973">        assert(index &lt; self.fields_start);</span>
<span class="line" id="L3974">        <span class="tok-kw">var</span> bit_bag: <span class="tok-type">u32</span> = <span class="tok-kw">if</span> (self.field_index % fields_per_u32 == <span class="tok-number">0</span>) <span class="tok-number">0</span> <span class="tok-kw">else</span> self.payload.items[index];</span>
<span class="line" id="L3975">        bit_bag &gt;&gt;= bits_per_field;</span>
<span class="line" id="L3976">        <span class="tok-kw">comptime</span> <span class="tok-kw">var</span> i = <span class="tok-number">0</span>;</span>
<span class="line" id="L3977">        <span class="tok-kw">inline</span> <span class="tok-kw">while</span> (i &lt; bits_per_field) : (i += <span class="tok-number">1</span>) {</span>
<span class="line" id="L3978">            bit_bag |= <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@intFromBool</span>(bits[i])) &lt;&lt; (<span class="tok-number">32</span> - bits_per_field + i);</span>
<span class="line" id="L3979">        }</span>
<span class="line" id="L3980">        self.payload.items[index] = bit_bag;</span>
<span class="line" id="L3981">        self.field_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L3982">    }</span>
<span class="line" id="L3983"></span>
<span class="line" id="L3984">    <span class="tok-kw">fn</span> <span class="tok-fn">appendToField</span>(self: *Self, data: <span class="tok-type">u32</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L3985">        assert(self.fields_end &lt; self.payload.items.len);</span>
<span class="line" id="L3986">        self.payload.items[self.fields_end] = data;</span>
<span class="line" id="L3987">        self.fields_end += <span class="tok-number">1</span>;</span>
<span class="line" id="L3988">    }</span>
<span class="line" id="L3989"></span>
<span class="line" id="L3990">    <span class="tok-kw">fn</span> <span class="tok-fn">finishBits</span>(self: *Self, <span class="tok-kw">comptime</span> bits_per_field: <span class="tok-type">u32</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L3991">        <span class="tok-kw">if</span> (bits_per_field &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L3992">            <span class="tok-kw">const</span> fields_per_u32 = <span class="tok-number">32</span> / bits_per_field;</span>
<span class="line" id="L3993">            <span class="tok-kw">const</span> empty_field_slots = fields_per_u32 - (self.field_index % fields_per_u32);</span>
<span class="line" id="L3994">            <span class="tok-kw">if</span> (self.field_index &gt; <span class="tok-number">0</span> <span class="tok-kw">and</span> empty_field_slots &lt; fields_per_u32) {</span>
<span class="line" id="L3995">                <span class="tok-kw">const</span> index = self.field_bits_start + self.field_index / fields_per_u32;</span>
<span class="line" id="L3996">                self.payload.items[index] &gt;&gt;= <span class="tok-builtin">@intCast</span>(empty_field_slots * bits_per_field);</span>
<span class="line" id="L3997">            }</span>
<span class="line" id="L3998">        }</span>
<span class="line" id="L3999">    }</span>
<span class="line" id="L4000"></span>
<span class="line" id="L4001">    <span class="tok-kw">fn</span> <span class="tok-fn">declsSlice</span>(self: *Self) []<span class="tok-type">u32</span> {</span>
<span class="line" id="L4002">        <span class="tok-kw">return</span> self.payload.items[self.payload_top..][<span class="tok-number">0</span>..self.decl_index];</span>
<span class="line" id="L4003">    }</span>
<span class="line" id="L4004"></span>
<span class="line" id="L4005">    <span class="tok-kw">fn</span> <span class="tok-fn">fieldsSlice</span>(self: *Self) []<span class="tok-type">u32</span> {</span>
<span class="line" id="L4006">        <span class="tok-kw">return</span> self.payload.items[self.field_bits_start..self.fields_end];</span>
<span class="line" id="L4007">    }</span>
<span class="line" id="L4008"></span>
<span class="line" id="L4009">    <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *Self) <span class="tok-type">void</span> {</span>
<span class="line" id="L4010">        self.payload.items.len = self.payload_top;</span>
<span class="line" id="L4011">    }</span>
<span class="line" id="L4012">};</span>
<span class="line" id="L4013"></span>
<span class="line" id="L4014"><span class="tok-kw">fn</span> <span class="tok-fn">fnDecl</span>(</span>
<span class="line" id="L4015">    astgen: *AstGen,</span>
<span class="line" id="L4016">    gz: *GenZir,</span>
<span class="line" id="L4017">    scope: *Scope,</span>
<span class="line" id="L4018">    wip_members: *WipMembers,</span>
<span class="line" id="L4019">    decl_node: Ast.Node.Index,</span>
<span class="line" id="L4020">    body_node: Ast.Node.Index,</span>
<span class="line" id="L4021">    fn_proto: Ast.full.FnProto,</span>
<span class="line" id="L4022">) InnerError!<span class="tok-type">void</span> {</span>
<span class="line" id="L4023">    <span class="tok-kw">const</span> tree = astgen.tree;</span>
<span class="line" id="L4024">    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);</span>
<span class="line" id="L4025"></span>
<span class="line" id="L4026">    <span class="tok-comment">// missing function name already happened in scanDecls()</span>
</span>
<span class="line" id="L4027">    <span class="tok-kw">const</span> fn_name_token = fn_proto.name_token <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AnalysisFail;</span>
<span class="line" id="L4028"></span>
<span class="line" id="L4029">    <span class="tok-comment">// We insert this at the beginning so that its instruction index marks the</span>
</span>
<span class="line" id="L4030">    <span class="tok-comment">// start of the top level declaration.</span>
</span>
<span class="line" id="L4031">    <span class="tok-kw">const</span> decl_inst = <span class="tok-kw">try</span> gz.makeBlockInst(.declaration, fn_proto.ast.proto_node);</span>
<span class="line" id="L4032">    astgen.advanceSourceCursorToNode(decl_node);</span>
<span class="line" id="L4033"></span>
<span class="line" id="L4034">    <span class="tok-kw">var</span> decl_gz: GenZir = .{</span>
<span class="line" id="L4035">        .is_comptime = <span class="tok-null">true</span>,</span>
<span class="line" id="L4036">        .decl_node_index = fn_proto.ast.proto_node,</span>
<span class="line" id="L4037">        .decl_line = astgen.source_line,</span>
<span class="line" id="L4038">        .parent = scope,</span>
<span class="line" id="L4039">        .astgen = astgen,</span>
<span class="line" id="L4040">        .instructions = gz.instructions,</span>
<span class="line" id="L4041">        .instructions_top = gz.instructions.items.len,</span>
<span class="line" id="L4042">    };</span>
<span class="line" id="L4043">    <span class="tok-kw">defer</span> decl_gz.unstack();</span>
<span class="line" id="L4044"></span>
<span class="line" id="L4045">    <span class="tok-kw">var</span> fn_gz: GenZir = .{</span>
<span class="line" id="L4046">        .is_comptime = <span class="tok-null">false</span>,</span>
<span class="line" id="L4047">        .decl_node_index = fn_proto.ast.proto_node,</span>
<span class="line" id="L4048">        .decl_line = decl_gz.decl_line,</span>
<span class="line" id="L4049">        .parent = &amp;decl_gz.base,</span>
<span class="line" id="L4050">        .astgen = astgen,</span>
<span class="line" id="L4051">        .instructions = gz.instructions,</span>
<span class="line" id="L4052">        .instructions_top = GenZir.unstacked_top,</span>
<span class="line" id="L4053">    };</span>
<span class="line" id="L4054">    <span class="tok-kw">defer</span> fn_gz.unstack();</span>
<span class="line" id="L4055"></span>
<span class="line" id="L4056">    <span class="tok-comment">// Set this now, since parameter types, return type, etc may be generic.</span>
</span>
<span class="line" id="L4057">    <span class="tok-kw">const</span> prev_within_fn = astgen.within_fn;</span>
<span class="line" id="L4058">    <span class="tok-kw">defer</span> astgen.within_fn = prev_within_fn;</span>
<span class="line" id="L4059">    astgen.within_fn = <span class="tok-null">true</span>;</span>
<span class="line" id="L4060"></span>
<span class="line" id="L4061">    <span class="tok-kw">const</span> is_pub = fn_proto.visib_token != <span class="tok-null">null</span>;</span>
<span class="line" id="L4062">    <span class="tok-kw">const</span> is_export = blk: {</span>
<span class="line" id="L4063">        <span class="tok-kw">const</span> maybe_export_token = fn_proto.extern_export_inline_token <span class="tok-kw">orelse</span> <span class="tok-kw">break</span> :blk <span class="tok-null">false</span>;</span>
<span class="line" id="L4064">        <span class="tok-kw">break</span> :blk token_tags[maybe_export_token] == .keyword_export;</span>
<span class="line" id="L4065">    };</span>
<span class="line" id="L4066">    <span class="tok-kw">const</span> is_extern = blk: {</span>
<span class="line" id="L4067">        <span class="tok-kw">const</span> maybe_extern_token = fn_proto.extern_export_inline_token <span class="tok-kw">orelse</span> <span class="tok-kw">break</span> :blk <span class="tok-null">false</span>;</span>
<span class="line" id="L4068">        <span class="tok-kw">break</span> :blk token_tags[maybe_extern_token] == .keyword_extern;</span>
<span class="line" id="L4069">    };</span>
<span class="line" id="L4070">    <span class="tok-kw">const</span> has_inline_keyword = blk: {</span>
<span class="line" id="L4071">        <span class="tok-kw">const</span> maybe_inline_token = fn_proto.extern_export_inline_token <span class="tok-kw">orelse</span> <span class="tok-kw">break</span> :blk <span class="tok-null">false</span>;</span>
<span class="line" id="L4072">        <span class="tok-kw">break</span> :blk token_tags[maybe_inline_token] == .keyword_inline;</span>
<span class="line" id="L4073">    };</span>
<span class="line" id="L4074">    <span class="tok-kw">const</span> is_noinline = blk: {</span>
<span class="line" id="L4075">        <span class="tok-kw">const</span> maybe_noinline_token = fn_proto.extern_export_inline_token <span class="tok-kw">orelse</span> <span class="tok-kw">break</span> :blk <span class="tok-null">false</span>;</span>
<span class="line" id="L4076">        <span class="tok-kw">break</span> :blk token_tags[maybe_noinline_token] == .keyword_noinline;</span>
<span class="line" id="L4077">    };</span>
<span class="line" id="L4078"></span>
<span class="line" id="L4079">    <span class="tok-kw">const</span> doc_comment_index = <span class="tok-kw">try</span> astgen.docCommentAsString(fn_proto.firstToken());</span>
<span class="line" id="L4080"></span>
<span class="line" id="L4081">    wip_members.nextDecl(decl_inst);</span>
<span class="line" id="L4082"></span>
<span class="line" id="L4083">    <span class="tok-kw">var</span> noalias_bits: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L4084">    <span class="tok-kw">var</span> params_scope = &amp;fn_gz.base;</span>
<span class="line" id="L4085">    <span class="tok-kw">const</span> is_var_args = is_var_args: {</span>
<span class="line" id="L4086">        <span class="tok-kw">var</span> param_type_i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L4087">        <span class="tok-kw">var</span> it = fn_proto.iterate(tree);</span>
<span class="line" id="L4088">        <span class="tok-kw">while</span> (it.next()) |param| : (param_type_i += <span class="tok-number">1</span>) {</span>
<span class="line" id="L4089">            <span class="tok-kw">const</span> is_comptime = <span class="tok-kw">if</span> (param.comptime_noalias) |token| <span class="tok-kw">switch</span> (token_tags[token]) {</span>
<span class="line" id="L4090">                .keyword_noalias =&gt; is_comptime: {</span>
<span class="line" id="L4091">                    noalias_bits |= <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>) &lt;&lt; (std.math.cast(<span class="tok-type">u5</span>, param_type_i) <span class="tok-kw">orelse</span></span>
<span class="line" id="L4092">                        <span class="tok-kw">return</span> astgen.failTok(token, <span class="tok-str">&quot;this compiler implementation only supports 'noalias' on the first 32 parameters&quot;</span>, .{}));</span>
<span class="line" id="L4093">                    <span class="tok-kw">break</span> :is_comptime <span class="tok-null">false</span>;</span>
<span class="line" id="L4094">                },</span>
<span class="line" id="L4095">                .keyword_comptime =&gt; <span class="tok-null">true</span>,</span>
<span class="line" id="L4096">                <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,</span>
<span class="line" id="L4097">            } <span class="tok-kw">else</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L4098"></span>
<span class="line" id="L4099">            <span class="tok-kw">const</span> is_anytype = <span class="tok-kw">if</span> (param.anytype_ellipsis3) |token| blk: {</span>
<span class="line" id="L4100">                <span class="tok-kw">switch</span> (token_tags[token]) {</span>
<span class="line" id="L4101">                    .keyword_anytype =&gt; <span class="tok-kw">break</span> :blk <span class="tok-null">true</span>,</span>
<span class="line" id="L4102">                    .ellipsis3 =&gt; <span class="tok-kw">break</span> :is_var_args <span class="tok-null">true</span>,</span>
<span class="line" id="L4103">                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L4104">                }</span>
<span class="line" id="L4105">            } <span class="tok-kw">else</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L4106"></span>
<span class="line" id="L4107">            <span class="tok-kw">const</span> param_name: Zir.NullTerminatedString = <span class="tok-kw">if</span> (param.name_token) |name_token| blk: {</span>
<span class="line" id="L4108">                <span class="tok-kw">const</span> name_bytes = tree.tokenSlice(name_token);</span>
<span class="line" id="L4109">                <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, <span class="tok-str">&quot;_&quot;</span>, name_bytes))</span>
<span class="line" id="L4110">                    <span class="tok-kw">break</span> :blk .empty;</span>
<span class="line" id="L4111"></span>
<span class="line" id="L4112">                <span class="tok-kw">const</span> param_name = <span class="tok-kw">try</span> astgen.identAsString(name_token);</span>
<span class="line" id="L4113">                <span class="tok-kw">if</span> (!is_extern) {</span>
<span class="line" id="L4114">                    <span class="tok-kw">try</span> astgen.detectLocalShadowing(params_scope, param_name, name_token, name_bytes, .@&quot;function parameter&quot;);</span>
<span class="line" id="L4115">                }</span>
<span class="line" id="L4116">                <span class="tok-kw">break</span> :blk param_name;</span>
<span class="line" id="L4117">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (!is_extern) {</span>
<span class="line" id="L4118">                <span class="tok-kw">if</span> (param.anytype_ellipsis3) |tok| {</span>
<span class="line" id="L4119">                    <span class="tok-kw">return</span> astgen.failTok(tok, <span class="tok-str">&quot;missing parameter name&quot;</span>, .{});</span>
<span class="line" id="L4120">                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L4121">                    ambiguous: {</span>
<span class="line" id="L4122">                        <span class="tok-kw">if</span> (tree.nodes.items(.tag)[param.type_expr] != .identifier) <span class="tok-kw">break</span> :ambiguous;</span>
<span class="line" id="L4123">                        <span class="tok-kw">const</span> main_token = tree.nodes.items(.main_token)[param.type_expr];</span>
<span class="line" id="L4124">                        <span class="tok-kw">const</span> identifier_str = tree.tokenSlice(main_token);</span>
<span class="line" id="L4125">                        <span class="tok-kw">if</span> (isPrimitive(identifier_str)) <span class="tok-kw">break</span> :ambiguous;</span>
<span class="line" id="L4126">                        <span class="tok-kw">return</span> astgen.failNodeNotes(</span>
<span class="line" id="L4127">                            param.type_expr,</span>
<span class="line" id="L4128">                            <span class="tok-str">&quot;missing parameter name or type&quot;</span>,</span>
<span class="line" id="L4129">                            .{},</span>
<span class="line" id="L4130">                            &amp;[_]<span class="tok-type">u32</span>{</span>
<span class="line" id="L4131">                                <span class="tok-kw">try</span> astgen.errNoteNode(</span>
<span class="line" id="L4132">                                    param.type_expr,</span>
<span class="line" id="L4133">                                    <span class="tok-str">&quot;if this is a name, annotate its type '{s}: T'&quot;</span>,</span>
<span class="line" id="L4134">                                    .{identifier_str},</span>
<span class="line" id="L4135">                                ),</span>
<span class="line" id="L4136">                                <span class="tok-kw">try</span> astgen.errNoteNode(</span>
<span class="line" id="L4137">                                    param.type_expr,</span>
<span class="line" id="L4138">                                    <span class="tok-str">&quot;if this is a type, give it a name '&lt;name&gt;: {s}'&quot;</span>,</span>
<span class="line" id="L4139">                                    .{identifier_str},</span>
<span class="line" id="L4140">                                ),</span>
<span class="line" id="L4141">                            },</span>
<span class="line" id="L4142">                        );</span>
<span class="line" id="L4143">                    }</span>
<span class="line" id="L4144">                    <span class="tok-kw">return</span> astgen.failNode(param.type_expr, <span class="tok-str">&quot;missing parameter name&quot;</span>, .{});</span>
<span class="line" id="L4145">                }</span>
<span class="line" id="L4146">            } <span class="tok-kw">else</span> .empty;</span>
<span class="line" id="L4147"></span>
<span class="line" id="L4148">            <span class="tok-kw">const</span> param_inst = <span class="tok-kw">if</span> (is_anytype) param: {</span>
<span class="line" id="L4149">                <span class="tok-kw">const</span> name_token = param.name_token <span class="tok-kw">orelse</span> param.anytype_ellipsis3.?;</span>
<span class="line" id="L4150">                <span class="tok-kw">const</span> tag: Zir.Inst.Tag = <span class="tok-kw">if</span> (is_comptime)</span>
<span class="line" id="L4151">                    .param_anytype_comptime</span>
<span class="line" id="L4152">                <span class="tok-kw">else</span></span>
<span class="line" id="L4153">                    .param_anytype;</span>
<span class="line" id="L4154">                <span class="tok-kw">break</span> :param <span class="tok-kw">try</span> decl_gz.addStrTok(tag, param_name, name_token);</span>
<span class="line" id="L4155">            } <span class="tok-kw">else</span> param: {</span>
<span class="line" id="L4156">                <span class="tok-kw">const</span> param_type_node = param.type_expr;</span>
<span class="line" id="L4157">                assert(param_type_node != <span class="tok-number">0</span>);</span>
<span class="line" id="L4158">                <span class="tok-kw">var</span> param_gz = decl_gz.makeSubBlock(scope);</span>
<span class="line" id="L4159">                <span class="tok-kw">defer</span> param_gz.unstack();</span>
<span class="line" id="L4160">                <span class="tok-kw">const</span> param_type = <span class="tok-kw">try</span> fullBodyExpr(&amp;param_gz, params_scope, coerced_type_ri, param_type_node);</span>
<span class="line" id="L4161">                <span class="tok-kw">const</span> param_inst_expected: Zir.Inst.Index = <span class="tok-builtin">@enumFromInt</span>(astgen.instructions.len + <span class="tok-number">1</span>);</span>
<span class="line" id="L4162">                _ = <span class="tok-kw">try</span> param_gz.addBreakWithSrcNode(.break_inline, param_inst_expected, param_type, param_type_node);</span>
<span class="line" id="L4163"></span>
<span class="line" id="L4164">                <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);</span>
<span class="line" id="L4165">                <span class="tok-kw">const</span> name_token = param.name_token <span class="tok-kw">orelse</span> main_tokens[param_type_node];</span>
<span class="line" id="L4166">                <span class="tok-kw">const</span> tag: Zir.Inst.Tag = <span class="tok-kw">if</span> (is_comptime) .param_comptime <span class="tok-kw">else</span> .param;</span>
<span class="line" id="L4167">                <span class="tok-kw">const</span> param_inst = <span class="tok-kw">try</span> decl_gz.addParam(&amp;param_gz, tag, name_token, param_name, param.first_doc_comment);</span>
<span class="line" id="L4168">                assert(param_inst_expected == param_inst);</span>
<span class="line" id="L4169">                <span class="tok-kw">break</span> :param param_inst.toRef();</span>
<span class="line" id="L4170">            };</span>
<span class="line" id="L4171"></span>
<span class="line" id="L4172">            <span class="tok-kw">if</span> (param_name == .empty <span class="tok-kw">or</span> is_extern) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L4173"></span>
<span class="line" id="L4174">            <span class="tok-kw">const</span> sub_scope = <span class="tok-kw">try</span> astgen.arena.create(Scope.LocalVal);</span>
<span class="line" id="L4175">            sub_scope.* = .{</span>
<span class="line" id="L4176">                .parent = params_scope,</span>
<span class="line" id="L4177">                .gen_zir = &amp;decl_gz,</span>
<span class="line" id="L4178">                .name = param_name,</span>
<span class="line" id="L4179">                .inst = param_inst,</span>
<span class="line" id="L4180">                .token_src = param.name_token.?,</span>
<span class="line" id="L4181">                .id_cat = .@&quot;function parameter&quot;,</span>
<span class="line" id="L4182">            };</span>
<span class="line" id="L4183">            params_scope = &amp;sub_scope.base;</span>
<span class="line" id="L4184">        }</span>
<span class="line" id="L4185">        <span class="tok-kw">break</span> :is_var_args <span class="tok-null">false</span>;</span>
<span class="line" id="L4186">    };</span>
<span class="line" id="L4187"></span>
<span class="line" id="L4188">    <span class="tok-kw">const</span> lib_name = <span class="tok-kw">if</span> (fn_proto.lib_name) |lib_name_token| blk: {</span>
<span class="line" id="L4189">        <span class="tok-kw">const</span> lib_name_str = <span class="tok-kw">try</span> astgen.strLitAsString(lib_name_token);</span>
<span class="line" id="L4190">        <span class="tok-kw">const</span> lib_name_slice = astgen.string_bytes.items[<span class="tok-builtin">@intFromEnum</span>(lib_name_str.index)..][<span class="tok-number">0</span>..lib_name_str.len];</span>
<span class="line" id="L4191">        <span class="tok-kw">if</span> (mem.indexOfScalar(<span class="tok-type">u8</span>, lib_name_slice, <span class="tok-number">0</span>) != <span class="tok-null">null</span>) {</span>
<span class="line" id="L4192">            <span class="tok-kw">return</span> astgen.failTok(lib_name_token, <span class="tok-str">&quot;library name cannot contain null bytes&quot;</span>, .{});</span>
<span class="line" id="L4193">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (lib_name_str.len == <span class="tok-number">0</span>) {</span>
<span class="line" id="L4194">            <span class="tok-kw">return</span> astgen.failTok(lib_name_token, <span class="tok-str">&quot;library name cannot be empty&quot;</span>, .{});</span>
<span class="line" id="L4195">        }</span>
<span class="line" id="L4196">        <span class="tok-kw">break</span> :blk lib_name_str.index;</span>
<span class="line" id="L4197">    } <span class="tok-kw">else</span> .empty;</span>
<span class="line" id="L4198"></span>
<span class="line" id="L4199">    <span class="tok-kw">const</span> maybe_bang = tree.firstToken(fn_proto.ast.return_type) - <span class="tok-number">1</span>;</span>
<span class="line" id="L4200">    <span class="tok-kw">const</span> is_inferred_error = token_tags[maybe_bang] == .bang;</span>
<span class="line" id="L4201"></span>
<span class="line" id="L4202">    <span class="tok-comment">// After creating the function ZIR instruction, it will need to update the break</span>
</span>
<span class="line" id="L4203">    <span class="tok-comment">// instructions inside the expression blocks for align, addrspace, cc, and ret_ty</span>
</span>
<span class="line" id="L4204">    <span class="tok-comment">// to use the function instruction as the &quot;block&quot; to break from.</span>
</span>
<span class="line" id="L4205"></span>
<span class="line" id="L4206">    <span class="tok-kw">var</span> align_gz = decl_gz.makeSubBlock(params_scope);</span>
<span class="line" id="L4207">    <span class="tok-kw">defer</span> align_gz.unstack();</span>
<span class="line" id="L4208">    <span class="tok-kw">const</span> align_ref: Zir.Inst.Ref = <span class="tok-kw">if</span> (fn_proto.ast.align_expr == <span class="tok-number">0</span>) .none <span class="tok-kw">else</span> inst: {</span>
<span class="line" id="L4209">        <span class="tok-kw">const</span> inst = <span class="tok-kw">try</span> expr(&amp;decl_gz, params_scope, coerced_align_ri, fn_proto.ast.align_expr);</span>
<span class="line" id="L4210">        <span class="tok-kw">if</span> (align_gz.instructionsSlice().len == <span class="tok-number">0</span>) {</span>
<span class="line" id="L4211">            <span class="tok-comment">// In this case we will send a len=0 body which can be encoded more efficiently.</span>
</span>
<span class="line" id="L4212">            <span class="tok-kw">break</span> :inst inst;</span>
<span class="line" id="L4213">        }</span>
<span class="line" id="L4214">        _ = <span class="tok-kw">try</span> align_gz.addBreak(.break_inline, <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">0</span>), inst);</span>
<span class="line" id="L4215">        <span class="tok-kw">break</span> :inst inst;</span>
<span class="line" id="L4216">    };</span>
<span class="line" id="L4217"></span>
<span class="line" id="L4218">    <span class="tok-kw">var</span> addrspace_gz = decl_gz.makeSubBlock(params_scope);</span>
<span class="line" id="L4219">    <span class="tok-kw">defer</span> addrspace_gz.unstack();</span>
<span class="line" id="L4220">    <span class="tok-kw">const</span> addrspace_ref: Zir.Inst.Ref = <span class="tok-kw">if</span> (fn_proto.ast.addrspace_expr == <span class="tok-number">0</span>) .none <span class="tok-kw">else</span> inst: {</span>
<span class="line" id="L4221">        <span class="tok-kw">const</span> inst = <span class="tok-kw">try</span> expr(&amp;decl_gz, params_scope, coerced_addrspace_ri, fn_proto.ast.addrspace_expr);</span>
<span class="line" id="L4222">        <span class="tok-kw">if</span> (addrspace_gz.instructionsSlice().len == <span class="tok-number">0</span>) {</span>
<span class="line" id="L4223">            <span class="tok-comment">// In this case we will send a len=0 body which can be encoded more efficiently.</span>
</span>
<span class="line" id="L4224">            <span class="tok-kw">break</span> :inst inst;</span>
<span class="line" id="L4225">        }</span>
<span class="line" id="L4226">        _ = <span class="tok-kw">try</span> addrspace_gz.addBreak(.break_inline, <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">0</span>), inst);</span>
<span class="line" id="L4227">        <span class="tok-kw">break</span> :inst inst;</span>
<span class="line" id="L4228">    };</span>
<span class="line" id="L4229"></span>
<span class="line" id="L4230">    <span class="tok-kw">var</span> section_gz = decl_gz.makeSubBlock(params_scope);</span>
<span class="line" id="L4231">    <span class="tok-kw">defer</span> section_gz.unstack();</span>
<span class="line" id="L4232">    <span class="tok-kw">const</span> section_ref: Zir.Inst.Ref = <span class="tok-kw">if</span> (fn_proto.ast.section_expr == <span class="tok-number">0</span>) .none <span class="tok-kw">else</span> inst: {</span>
<span class="line" id="L4233">        <span class="tok-kw">const</span> inst = <span class="tok-kw">try</span> expr(&amp;decl_gz, params_scope, .{ .rl = .{ .coerced_ty = .slice_const_u8_type } }, fn_proto.ast.section_expr);</span>
<span class="line" id="L4234">        <span class="tok-kw">if</span> (section_gz.instructionsSlice().len == <span class="tok-number">0</span>) {</span>
<span class="line" id="L4235">            <span class="tok-comment">// In this case we will send a len=0 body which can be encoded more efficiently.</span>
</span>
<span class="line" id="L4236">            <span class="tok-kw">break</span> :inst inst;</span>
<span class="line" id="L4237">        }</span>
<span class="line" id="L4238">        _ = <span class="tok-kw">try</span> section_gz.addBreak(.break_inline, <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">0</span>), inst);</span>
<span class="line" id="L4239">        <span class="tok-kw">break</span> :inst inst;</span>
<span class="line" id="L4240">    };</span>
<span class="line" id="L4241"></span>
<span class="line" id="L4242">    <span class="tok-kw">var</span> cc_gz = decl_gz.makeSubBlock(params_scope);</span>
<span class="line" id="L4243">    <span class="tok-kw">defer</span> cc_gz.unstack();</span>
<span class="line" id="L4244">    <span class="tok-kw">const</span> cc_ref: Zir.Inst.Ref = blk: {</span>
<span class="line" id="L4245">        <span class="tok-kw">if</span> (fn_proto.ast.callconv_expr != <span class="tok-number">0</span>) {</span>
<span class="line" id="L4246">            <span class="tok-kw">if</span> (has_inline_keyword) {</span>
<span class="line" id="L4247">                <span class="tok-kw">return</span> astgen.failNode(</span>
<span class="line" id="L4248">                    fn_proto.ast.callconv_expr,</span>
<span class="line" id="L4249">                    <span class="tok-str">&quot;explicit callconv incompatible with inline keyword&quot;</span>,</span>
<span class="line" id="L4250">                    .{},</span>
<span class="line" id="L4251">                );</span>
<span class="line" id="L4252">            }</span>
<span class="line" id="L4253">            <span class="tok-kw">const</span> inst = <span class="tok-kw">try</span> expr(</span>
<span class="line" id="L4254">                &amp;decl_gz,</span>
<span class="line" id="L4255">                params_scope,</span>
<span class="line" id="L4256">                .{ .rl = .{ .coerced_ty = .calling_convention_type } },</span>
<span class="line" id="L4257">                fn_proto.ast.callconv_expr,</span>
<span class="line" id="L4258">            );</span>
<span class="line" id="L4259">            <span class="tok-kw">if</span> (cc_gz.instructionsSlice().len == <span class="tok-number">0</span>) {</span>
<span class="line" id="L4260">                <span class="tok-comment">// In this case we will send a len=0 body which can be encoded more efficiently.</span>
</span>
<span class="line" id="L4261">                <span class="tok-kw">break</span> :blk inst;</span>
<span class="line" id="L4262">            }</span>
<span class="line" id="L4263">            _ = <span class="tok-kw">try</span> cc_gz.addBreak(.break_inline, <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">0</span>), inst);</span>
<span class="line" id="L4264">            <span class="tok-kw">break</span> :blk inst;</span>
<span class="line" id="L4265">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (is_extern) {</span>
<span class="line" id="L4266">            <span class="tok-comment">// note: https://github.com/ziglang/zig/issues/5269</span>
</span>
<span class="line" id="L4267">            <span class="tok-kw">break</span> :blk .calling_convention_c;</span>
<span class="line" id="L4268">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (has_inline_keyword) {</span>
<span class="line" id="L4269">            <span class="tok-kw">break</span> :blk .calling_convention_inline;</span>
<span class="line" id="L4270">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L4271">            <span class="tok-kw">break</span> :blk .none;</span>
<span class="line" id="L4272">        }</span>
<span class="line" id="L4273">    };</span>
<span class="line" id="L4274"></span>
<span class="line" id="L4275">    <span class="tok-kw">var</span> ret_gz = decl_gz.makeSubBlock(params_scope);</span>
<span class="line" id="L4276">    <span class="tok-kw">defer</span> ret_gz.unstack();</span>
<span class="line" id="L4277">    <span class="tok-kw">const</span> ret_ref: Zir.Inst.Ref = inst: {</span>
<span class="line" id="L4278">        <span class="tok-kw">const</span> inst = <span class="tok-kw">try</span> fullBodyExpr(&amp;ret_gz, params_scope, coerced_type_ri, fn_proto.ast.return_type);</span>
<span class="line" id="L4279">        <span class="tok-kw">if</span> (ret_gz.instructionsSlice().len == <span class="tok-number">0</span>) {</span>
<span class="line" id="L4280">            <span class="tok-comment">// In this case we will send a len=0 body which can be encoded more efficiently.</span>
</span>
<span class="line" id="L4281">            <span class="tok-kw">break</span> :inst inst;</span>
<span class="line" id="L4282">        }</span>
<span class="line" id="L4283">        _ = <span class="tok-kw">try</span> ret_gz.addBreak(.break_inline, <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">0</span>), inst);</span>
<span class="line" id="L4284">        <span class="tok-kw">break</span> :inst inst;</span>
<span class="line" id="L4285">    };</span>
<span class="line" id="L4286"></span>
<span class="line" id="L4287">    <span class="tok-kw">const</span> func_inst: Zir.Inst.Ref = <span class="tok-kw">if</span> (body_node == <span class="tok-number">0</span>) func: {</span>
<span class="line" id="L4288">        <span class="tok-kw">if</span> (!is_extern) {</span>
<span class="line" id="L4289">            <span class="tok-kw">return</span> astgen.failTok(fn_proto.ast.fn_token, <span class="tok-str">&quot;non-extern function has no body&quot;</span>, .{});</span>
<span class="line" id="L4290">        }</span>
<span class="line" id="L4291">        <span class="tok-kw">if</span> (is_inferred_error) {</span>
<span class="line" id="L4292">            <span class="tok-kw">return</span> astgen.failTok(maybe_bang, <span class="tok-str">&quot;function prototype may not have inferred error set&quot;</span>, .{});</span>
<span class="line" id="L4293">        }</span>
<span class="line" id="L4294">        <span class="tok-kw">break</span> :func <span class="tok-kw">try</span> decl_gz.addFunc(.{</span>
<span class="line" id="L4295">            .src_node = decl_node,</span>
<span class="line" id="L4296">            .cc_ref = cc_ref,</span>
<span class="line" id="L4297">            .cc_gz = &amp;cc_gz,</span>
<span class="line" id="L4298">            .align_ref = align_ref,</span>
<span class="line" id="L4299">            .align_gz = &amp;align_gz,</span>
<span class="line" id="L4300">            .ret_ref = ret_ref,</span>
<span class="line" id="L4301">            .ret_gz = &amp;ret_gz,</span>
<span class="line" id="L4302">            .section_ref = section_ref,</span>
<span class="line" id="L4303">            .section_gz = &amp;section_gz,</span>
<span class="line" id="L4304">            .addrspace_ref = addrspace_ref,</span>
<span class="line" id="L4305">            .addrspace_gz = &amp;addrspace_gz,</span>
<span class="line" id="L4306">            .param_block = decl_inst,</span>
<span class="line" id="L4307">            .body_gz = <span class="tok-null">null</span>,</span>
<span class="line" id="L4308">            .lib_name = lib_name,</span>
<span class="line" id="L4309">            .is_var_args = is_var_args,</span>
<span class="line" id="L4310">            .is_inferred_error = <span class="tok-null">false</span>,</span>
<span class="line" id="L4311">            .is_test = <span class="tok-null">false</span>,</span>
<span class="line" id="L4312">            .is_extern = <span class="tok-null">true</span>,</span>
<span class="line" id="L4313">            .is_noinline = is_noinline,</span>
<span class="line" id="L4314">            .noalias_bits = noalias_bits,</span>
<span class="line" id="L4315">        });</span>
<span class="line" id="L4316">    } <span class="tok-kw">else</span> func: {</span>
<span class="line" id="L4317">        <span class="tok-comment">// as a scope, fn_gz encloses ret_gz, but for instruction list, fn_gz stacks on ret_gz</span>
</span>
<span class="line" id="L4318">        fn_gz.instructions_top = ret_gz.instructions.items.len;</span>
<span class="line" id="L4319"></span>
<span class="line" id="L4320">        <span class="tok-kw">const</span> prev_fn_block = astgen.fn_block;</span>
<span class="line" id="L4321">        <span class="tok-kw">const</span> prev_fn_ret_ty = astgen.fn_ret_ty;</span>
<span class="line" id="L4322">        <span class="tok-kw">defer</span> {</span>
<span class="line" id="L4323">            astgen.fn_block = prev_fn_block;</span>
<span class="line" id="L4324">            astgen.fn_ret_ty = prev_fn_ret_ty;</span>
<span class="line" id="L4325">        }</span>
<span class="line" id="L4326">        astgen.fn_block = &amp;fn_gz;</span>
<span class="line" id="L4327">        astgen.fn_ret_ty = <span class="tok-kw">if</span> (is_inferred_error <span class="tok-kw">or</span> ret_ref.toIndex() != <span class="tok-null">null</span>) r: {</span>
<span class="line" id="L4328">            <span class="tok-comment">// We're essentially guaranteed to need the return type at some point,</span>
</span>
<span class="line" id="L4329">            <span class="tok-comment">// since the return type is likely not `void` or `noreturn` so there</span>
</span>
<span class="line" id="L4330">            <span class="tok-comment">// will probably be an explicit return requiring RLS. Fetch this</span>
</span>
<span class="line" id="L4331">            <span class="tok-comment">// return type now so the rest of the function can use it.</span>
</span>
<span class="line" id="L4332">            <span class="tok-kw">break</span> :r <span class="tok-kw">try</span> fn_gz.addNode(.ret_type, decl_node);</span>
<span class="line" id="L4333">        } <span class="tok-kw">else</span> ret_ref;</span>
<span class="line" id="L4334"></span>
<span class="line" id="L4335">        <span class="tok-kw">const</span> prev_var_args = astgen.fn_var_args;</span>
<span class="line" id="L4336">        astgen.fn_var_args = is_var_args;</span>
<span class="line" id="L4337">        <span class="tok-kw">defer</span> astgen.fn_var_args = prev_var_args;</span>
<span class="line" id="L4338"></span>
<span class="line" id="L4339">        astgen.advanceSourceCursorToNode(body_node);</span>
<span class="line" id="L4340">        <span class="tok-kw">const</span> lbrace_line = astgen.source_line - decl_gz.decl_line;</span>
<span class="line" id="L4341">        <span class="tok-kw">const</span> lbrace_column = astgen.source_column;</span>
<span class="line" id="L4342"></span>
<span class="line" id="L4343">        _ = <span class="tok-kw">try</span> fullBodyExpr(&amp;fn_gz, params_scope, .{ .rl = .none }, body_node);</span>
<span class="line" id="L4344">        <span class="tok-kw">try</span> checkUsed(gz, &amp;fn_gz.base, params_scope);</span>
<span class="line" id="L4345"></span>
<span class="line" id="L4346">        <span class="tok-kw">if</span> (!fn_gz.endsWithNoReturn()) {</span>
<span class="line" id="L4347">            <span class="tok-comment">// As our last action before the return, &quot;pop&quot; the error trace if needed</span>
</span>
<span class="line" id="L4348">            _ = <span class="tok-kw">try</span> fn_gz.addRestoreErrRetIndex(.ret, .always, decl_node);</span>
<span class="line" id="L4349"></span>
<span class="line" id="L4350">            <span class="tok-comment">// Add implicit return at end of function.</span>
</span>
<span class="line" id="L4351">            _ = <span class="tok-kw">try</span> fn_gz.addUnTok(.ret_implicit, .void_value, tree.lastToken(body_node));</span>
<span class="line" id="L4352">        }</span>
<span class="line" id="L4353"></span>
<span class="line" id="L4354">        <span class="tok-kw">break</span> :func <span class="tok-kw">try</span> decl_gz.addFunc(.{</span>
<span class="line" id="L4355">            .src_node = decl_node,</span>
<span class="line" id="L4356">            .cc_ref = cc_ref,</span>
<span class="line" id="L4357">            .cc_gz = &amp;cc_gz,</span>
<span class="line" id="L4358">            .align_ref = align_ref,</span>
<span class="line" id="L4359">            .align_gz = &amp;align_gz,</span>
<span class="line" id="L4360">            .ret_ref = ret_ref,</span>
<span class="line" id="L4361">            .ret_gz = &amp;ret_gz,</span>
<span class="line" id="L4362">            .section_ref = section_ref,</span>
<span class="line" id="L4363">            .section_gz = &amp;section_gz,</span>
<span class="line" id="L4364">            .addrspace_ref = addrspace_ref,</span>
<span class="line" id="L4365">            .addrspace_gz = &amp;addrspace_gz,</span>
<span class="line" id="L4366">            .lbrace_line = lbrace_line,</span>
<span class="line" id="L4367">            .lbrace_column = lbrace_column,</span>
<span class="line" id="L4368">            .param_block = decl_inst,</span>
<span class="line" id="L4369">            .body_gz = &amp;fn_gz,</span>
<span class="line" id="L4370">            .lib_name = lib_name,</span>
<span class="line" id="L4371">            .is_var_args = is_var_args,</span>
<span class="line" id="L4372">            .is_inferred_error = is_inferred_error,</span>
<span class="line" id="L4373">            .is_test = <span class="tok-null">false</span>,</span>
<span class="line" id="L4374">            .is_extern = <span class="tok-null">false</span>,</span>
<span class="line" id="L4375">            .is_noinline = is_noinline,</span>
<span class="line" id="L4376">            .noalias_bits = noalias_bits,</span>
<span class="line" id="L4377">        });</span>
<span class="line" id="L4378">    };</span>
<span class="line" id="L4379"></span>
<span class="line" id="L4380">    <span class="tok-comment">// We add this at the end so that its instruction index marks the end range</span>
</span>
<span class="line" id="L4381">    <span class="tok-comment">// of the top level declaration. addFunc already unstacked fn_gz and ret_gz.</span>
</span>
<span class="line" id="L4382">    _ = <span class="tok-kw">try</span> decl_gz.addBreak(.break_inline, decl_inst, func_inst);</span>
<span class="line" id="L4383"></span>
<span class="line" id="L4384">    <span class="tok-kw">try</span> setDeclaration(</span>
<span class="line" id="L4385">        decl_inst,</span>
<span class="line" id="L4386">        std.zig.hashSrc(tree.getNodeSource(decl_node)),</span>
<span class="line" id="L4387">        .{ .named = fn_name_token },</span>
<span class="line" id="L4388">        decl_gz.decl_line - gz.decl_line,</span>
<span class="line" id="L4389">        is_pub,</span>
<span class="line" id="L4390">        is_export,</span>
<span class="line" id="L4391">        doc_comment_index,</span>
<span class="line" id="L4392">        &amp;decl_gz,</span>
<span class="line" id="L4393">        <span class="tok-comment">// align, linksection, and addrspace are passed in the func instruction in this case.</span>
</span>
<span class="line" id="L4394">        <span class="tok-comment">// TODO: move them from the function instruction to the declaration instruction?</span>
</span>
<span class="line" id="L4395">        <span class="tok-null">null</span>,</span>
<span class="line" id="L4396">    );</span>
<span class="line" id="L4397">}</span>
<span class="line" id="L4398"></span>
<span class="line" id="L4399"><span class="tok-kw">fn</span> <span class="tok-fn">globalVarDecl</span>(</span>
<span class="line" id="L4400">    astgen: *AstGen,</span>
<span class="line" id="L4401">    gz: *GenZir,</span>
<span class="line" id="L4402">    scope: *Scope,</span>
<span class="line" id="L4403">    wip_members: *WipMembers,</span>
<span class="line" id="L4404">    node: Ast.Node.Index,</span>
<span class="line" id="L4405">    var_decl: Ast.full.VarDecl,</span>
<span class="line" id="L4406">) InnerError!<span class="tok-type">void</span> {</span>
<span class="line" id="L4407">    <span class="tok-kw">const</span> tree = astgen.tree;</span>
<span class="line" id="L4408">    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);</span>
<span class="line" id="L4409"></span>
<span class="line" id="L4410">    <span class="tok-kw">const</span> is_mutable = token_tags[var_decl.ast.mut_token] == .keyword_var;</span>
<span class="line" id="L4411">    <span class="tok-comment">// We do this at the beginning so that the instruction index marks the range start</span>
</span>
<span class="line" id="L4412">    <span class="tok-comment">// of the top level declaration.</span>
</span>
<span class="line" id="L4413">    <span class="tok-kw">const</span> decl_inst = <span class="tok-kw">try</span> gz.makeBlockInst(.declaration, node);</span>
<span class="line" id="L4414"></span>
<span class="line" id="L4415">    <span class="tok-kw">const</span> name_token = var_decl.ast.mut_token + <span class="tok-number">1</span>;</span>
<span class="line" id="L4416">    astgen.advanceSourceCursorToNode(node);</span>
<span class="line" id="L4417"></span>
<span class="line" id="L4418">    <span class="tok-kw">var</span> block_scope: GenZir = .{</span>
<span class="line" id="L4419">        .parent = scope,</span>
<span class="line" id="L4420">        .decl_node_index = node,</span>
<span class="line" id="L4421">        .decl_line = astgen.source_line,</span>
<span class="line" id="L4422">        .astgen = astgen,</span>
<span class="line" id="L4423">        .is_comptime = <span class="tok-null">true</span>,</span>
<span class="line" id="L4424">        .anon_name_strategy = .parent,</span>
<span class="line" id="L4425">        .instructions = gz.instructions,</span>
<span class="line" id="L4426">        .instructions_top = gz.instructions.items.len,</span>
<span class="line" id="L4427">    };</span>
<span class="line" id="L4428">    <span class="tok-kw">defer</span> block_scope.unstack();</span>
<span class="line" id="L4429"></span>
<span class="line" id="L4430">    <span class="tok-kw">const</span> is_pub = var_decl.visib_token != <span class="tok-null">null</span>;</span>
<span class="line" id="L4431">    <span class="tok-kw">const</span> is_export = blk: {</span>
<span class="line" id="L4432">        <span class="tok-kw">const</span> maybe_export_token = var_decl.extern_export_token <span class="tok-kw">orelse</span> <span class="tok-kw">break</span> :blk <span class="tok-null">false</span>;</span>
<span class="line" id="L4433">        <span class="tok-kw">break</span> :blk token_tags[maybe_export_token] == .keyword_export;</span>
<span class="line" id="L4434">    };</span>
<span class="line" id="L4435">    <span class="tok-kw">const</span> is_extern = blk: {</span>
<span class="line" id="L4436">        <span class="tok-kw">const</span> maybe_extern_token = var_decl.extern_export_token <span class="tok-kw">orelse</span> <span class="tok-kw">break</span> :blk <span class="tok-null">false</span>;</span>
<span class="line" id="L4437">        <span class="tok-kw">break</span> :blk token_tags[maybe_extern_token] == .keyword_extern;</span>
<span class="line" id="L4438">    };</span>
<span class="line" id="L4439">    wip_members.nextDecl(decl_inst);</span>
<span class="line" id="L4440"></span>
<span class="line" id="L4441">    <span class="tok-kw">const</span> is_threadlocal = <span class="tok-kw">if</span> (var_decl.threadlocal_token) |tok| blk: {</span>
<span class="line" id="L4442">        <span class="tok-kw">if</span> (!is_mutable) {</span>
<span class="line" id="L4443">            <span class="tok-kw">return</span> astgen.failTok(tok, <span class="tok-str">&quot;threadlocal variable cannot be constant&quot;</span>, .{});</span>
<span class="line" id="L4444">        }</span>
<span class="line" id="L4445">        <span class="tok-kw">break</span> :blk <span class="tok-null">true</span>;</span>
<span class="line" id="L4446">    } <span class="tok-kw">else</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L4447"></span>
<span class="line" id="L4448">    <span class="tok-kw">const</span> lib_name = <span class="tok-kw">if</span> (var_decl.lib_name) |lib_name_token| blk: {</span>
<span class="line" id="L4449">        <span class="tok-kw">const</span> lib_name_str = <span class="tok-kw">try</span> astgen.strLitAsString(lib_name_token);</span>
<span class="line" id="L4450">        <span class="tok-kw">const</span> lib_name_slice = astgen.string_bytes.items[<span class="tok-builtin">@intFromEnum</span>(lib_name_str.index)..][<span class="tok-number">0</span>..lib_name_str.len];</span>
<span class="line" id="L4451">        <span class="tok-kw">if</span> (mem.indexOfScalar(<span class="tok-type">u8</span>, lib_name_slice, <span class="tok-number">0</span>) != <span class="tok-null">null</span>) {</span>
<span class="line" id="L4452">            <span class="tok-kw">return</span> astgen.failTok(lib_name_token, <span class="tok-str">&quot;library name cannot contain null bytes&quot;</span>, .{});</span>
<span class="line" id="L4453">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (lib_name_str.len == <span class="tok-number">0</span>) {</span>
<span class="line" id="L4454">            <span class="tok-kw">return</span> astgen.failTok(lib_name_token, <span class="tok-str">&quot;library name cannot be empty&quot;</span>, .{});</span>
<span class="line" id="L4455">        }</span>
<span class="line" id="L4456">        <span class="tok-kw">break</span> :blk lib_name_str.index;</span>
<span class="line" id="L4457">    } <span class="tok-kw">else</span> .empty;</span>
<span class="line" id="L4458"></span>
<span class="line" id="L4459">    <span class="tok-kw">const</span> doc_comment_index = <span class="tok-kw">try</span> astgen.docCommentAsString(var_decl.firstToken());</span>
<span class="line" id="L4460"></span>
<span class="line" id="L4461">    assert(var_decl.comptime_token == <span class="tok-null">null</span>); <span class="tok-comment">// handled by parser</span>
</span>
<span class="line" id="L4462"></span>
<span class="line" id="L4463">    <span class="tok-kw">const</span> var_inst: Zir.Inst.Ref = <span class="tok-kw">if</span> (var_decl.ast.init_node != <span class="tok-number">0</span>) vi: {</span>
<span class="line" id="L4464">        <span class="tok-kw">if</span> (is_extern) {</span>
<span class="line" id="L4465">            <span class="tok-kw">return</span> astgen.failNode(</span>
<span class="line" id="L4466">                var_decl.ast.init_node,</span>
<span class="line" id="L4467">                <span class="tok-str">&quot;extern variables have no initializers&quot;</span>,</span>
<span class="line" id="L4468">                .{},</span>
<span class="line" id="L4469">            );</span>
<span class="line" id="L4470">        }</span>
<span class="line" id="L4471"></span>
<span class="line" id="L4472">        <span class="tok-kw">const</span> type_inst: Zir.Inst.Ref = <span class="tok-kw">if</span> (var_decl.ast.type_node != <span class="tok-number">0</span>)</span>
<span class="line" id="L4473">            <span class="tok-kw">try</span> expr(</span>
<span class="line" id="L4474">                &amp;block_scope,</span>
<span class="line" id="L4475">                &amp;block_scope.base,</span>
<span class="line" id="L4476">                coerced_type_ri,</span>
<span class="line" id="L4477">                var_decl.ast.type_node,</span>
<span class="line" id="L4478">            )</span>
<span class="line" id="L4479">        <span class="tok-kw">else</span></span>
<span class="line" id="L4480">            .none;</span>
<span class="line" id="L4481"></span>
<span class="line" id="L4482">        <span class="tok-kw">const</span> init_inst = <span class="tok-kw">try</span> expr(</span>
<span class="line" id="L4483">            &amp;block_scope,</span>
<span class="line" id="L4484">            &amp;block_scope.base,</span>
<span class="line" id="L4485">            <span class="tok-kw">if</span> (type_inst != .none) .{ .rl = .{ .ty = type_inst } } <span class="tok-kw">else</span> .{ .rl = .none },</span>
<span class="line" id="L4486">            var_decl.ast.init_node,</span>
<span class="line" id="L4487">        );</span>
<span class="line" id="L4488"></span>
<span class="line" id="L4489">        <span class="tok-kw">if</span> (is_mutable) {</span>
<span class="line" id="L4490">            <span class="tok-kw">const</span> var_inst = <span class="tok-kw">try</span> block_scope.addVar(.{</span>
<span class="line" id="L4491">                .var_type = type_inst,</span>
<span class="line" id="L4492">                .lib_name = .empty,</span>
<span class="line" id="L4493">                .align_inst = .none, <span class="tok-comment">// passed via the decls data</span>
</span>
<span class="line" id="L4494">                .init = init_inst,</span>
<span class="line" id="L4495">                .is_extern = <span class="tok-null">false</span>,</span>
<span class="line" id="L4496">                .is_const = !is_mutable,</span>
<span class="line" id="L4497">                .is_threadlocal = is_threadlocal,</span>
<span class="line" id="L4498">            });</span>
<span class="line" id="L4499">            <span class="tok-kw">break</span> :vi var_inst;</span>
<span class="line" id="L4500">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L4501">            <span class="tok-kw">break</span> :vi init_inst;</span>
<span class="line" id="L4502">        }</span>
<span class="line" id="L4503">    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (!is_extern) {</span>
<span class="line" id="L4504">        <span class="tok-kw">return</span> astgen.failNode(node, <span class="tok-str">&quot;variables must be initialized&quot;</span>, .{});</span>
<span class="line" id="L4505">    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (var_decl.ast.type_node != <span class="tok-number">0</span>) vi: {</span>
<span class="line" id="L4506">        <span class="tok-comment">// Extern variable which has an explicit type.</span>
</span>
<span class="line" id="L4507">        <span class="tok-kw">const</span> type_inst = <span class="tok-kw">try</span> typeExpr(&amp;block_scope, &amp;block_scope.base, var_decl.ast.type_node);</span>
<span class="line" id="L4508"></span>
<span class="line" id="L4509">        <span class="tok-kw">const</span> var_inst = <span class="tok-kw">try</span> block_scope.addVar(.{</span>
<span class="line" id="L4510">            .var_type = type_inst,</span>
<span class="line" id="L4511">            .lib_name = lib_name,</span>
<span class="line" id="L4512">            .align_inst = .none, <span class="tok-comment">// passed via the decls data</span>
</span>
<span class="line" id="L4513">            .init = .none,</span>
<span class="line" id="L4514">            .is_extern = <span class="tok-null">true</span>,</span>
<span class="line" id="L4515">            .is_const = !is_mutable,</span>
<span class="line" id="L4516">            .is_threadlocal = is_threadlocal,</span>
<span class="line" id="L4517">        });</span>
<span class="line" id="L4518">        <span class="tok-kw">break</span> :vi var_inst;</span>
<span class="line" id="L4519">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L4520">        <span class="tok-kw">return</span> astgen.failNode(node, <span class="tok-str">&quot;unable to infer variable type&quot;</span>, .{});</span>
<span class="line" id="L4521">    };</span>
<span class="line" id="L4522"></span>
<span class="line" id="L4523">    <span class="tok-comment">// We do this at the end so that the instruction index marks the end</span>
</span>
<span class="line" id="L4524">    <span class="tok-comment">// range of a top level declaration.</span>
</span>
<span class="line" id="L4525">    _ = <span class="tok-kw">try</span> block_scope.addBreakWithSrcNode(.break_inline, decl_inst, var_inst, node);</span>
<span class="line" id="L4526"></span>
<span class="line" id="L4527">    <span class="tok-kw">var</span> align_gz = block_scope.makeSubBlock(scope);</span>
<span class="line" id="L4528">    <span class="tok-kw">if</span> (var_decl.ast.align_node != <span class="tok-number">0</span>) {</span>
<span class="line" id="L4529">        <span class="tok-kw">const</span> align_inst = <span class="tok-kw">try</span> fullBodyExpr(&amp;align_gz, &amp;align_gz.base, coerced_align_ri, var_decl.ast.align_node);</span>
<span class="line" id="L4530">        _ = <span class="tok-kw">try</span> align_gz.addBreakWithSrcNode(.break_inline, decl_inst, align_inst, node);</span>
<span class="line" id="L4531">    }</span>
<span class="line" id="L4532"></span>
<span class="line" id="L4533">    <span class="tok-kw">var</span> linksection_gz = align_gz.makeSubBlock(scope);</span>
<span class="line" id="L4534">    <span class="tok-kw">if</span> (var_decl.ast.section_node != <span class="tok-number">0</span>) {</span>
<span class="line" id="L4535">        <span class="tok-kw">const</span> linksection_inst = <span class="tok-kw">try</span> fullBodyExpr(&amp;linksection_gz, &amp;linksection_gz.base, coerced_linksection_ri, var_decl.ast.section_node);</span>
<span class="line" id="L4536">        _ = <span class="tok-kw">try</span> linksection_gz.addBreakWithSrcNode(.break_inline, decl_inst, linksection_inst, node);</span>
<span class="line" id="L4537">    }</span>
<span class="line" id="L4538"></span>
<span class="line" id="L4539">    <span class="tok-kw">var</span> addrspace_gz = linksection_gz.makeSubBlock(scope);</span>
<span class="line" id="L4540">    <span class="tok-kw">if</span> (var_decl.ast.addrspace_node != <span class="tok-number">0</span>) {</span>
<span class="line" id="L4541">        <span class="tok-kw">const</span> addrspace_inst = <span class="tok-kw">try</span> fullBodyExpr(&amp;addrspace_gz, &amp;addrspace_gz.base, coerced_addrspace_ri, var_decl.ast.addrspace_node);</span>
<span class="line" id="L4542">        _ = <span class="tok-kw">try</span> addrspace_gz.addBreakWithSrcNode(.break_inline, decl_inst, addrspace_inst, node);</span>
<span class="line" id="L4543">    }</span>
<span class="line" id="L4544"></span>
<span class="line" id="L4545">    <span class="tok-kw">try</span> setDeclaration(</span>
<span class="line" id="L4546">        decl_inst,</span>
<span class="line" id="L4547">        std.zig.hashSrc(tree.getNodeSource(node)),</span>
<span class="line" id="L4548">        .{ .named = name_token },</span>
<span class="line" id="L4549">        block_scope.decl_line - gz.decl_line,</span>
<span class="line" id="L4550">        is_pub,</span>
<span class="line" id="L4551">        is_export,</span>
<span class="line" id="L4552">        doc_comment_index,</span>
<span class="line" id="L4553">        &amp;block_scope,</span>
<span class="line" id="L4554">        .{</span>
<span class="line" id="L4555">            .align_gz = &amp;align_gz,</span>
<span class="line" id="L4556">            .linksection_gz = &amp;linksection_gz,</span>
<span class="line" id="L4557">            .addrspace_gz = &amp;addrspace_gz,</span>
<span class="line" id="L4558">        },</span>
<span class="line" id="L4559">    );</span>
<span class="line" id="L4560">}</span>
<span class="line" id="L4561"></span>
<span class="line" id="L4562"><span class="tok-kw">fn</span> <span class="tok-fn">comptimeDecl</span>(</span>
<span class="line" id="L4563">    astgen: *AstGen,</span>
<span class="line" id="L4564">    gz: *GenZir,</span>
<span class="line" id="L4565">    scope: *Scope,</span>
<span class="line" id="L4566">    wip_members: *WipMembers,</span>
<span class="line" id="L4567">    node: Ast.Node.Index,</span>
<span class="line" id="L4568">) InnerError!<span class="tok-type">void</span> {</span>
<span class="line" id="L4569">    <span class="tok-kw">const</span> tree = astgen.tree;</span>
<span class="line" id="L4570">    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);</span>
<span class="line" id="L4571">    <span class="tok-kw">const</span> body_node = node_datas[node].lhs;</span>
<span class="line" id="L4572"></span>
<span class="line" id="L4573">    <span class="tok-comment">// Up top so the ZIR instruction index marks the start range of this</span>
</span>
<span class="line" id="L4574">    <span class="tok-comment">// top-level declaration.</span>
</span>
<span class="line" id="L4575">    <span class="tok-kw">const</span> decl_inst = <span class="tok-kw">try</span> gz.makeBlockInst(.declaration, node);</span>
<span class="line" id="L4576">    wip_members.nextDecl(decl_inst);</span>
<span class="line" id="L4577">    astgen.advanceSourceCursorToNode(node);</span>
<span class="line" id="L4578"></span>
<span class="line" id="L4579">    <span class="tok-kw">var</span> decl_block: GenZir = .{</span>
<span class="line" id="L4580">        .is_comptime = <span class="tok-null">true</span>,</span>
<span class="line" id="L4581">        .decl_node_index = node,</span>
<span class="line" id="L4582">        .decl_line = astgen.source_line,</span>
<span class="line" id="L4583">        .parent = scope,</span>
<span class="line" id="L4584">        .astgen = astgen,</span>
<span class="line" id="L4585">        .instructions = gz.instructions,</span>
<span class="line" id="L4586">        .instructions_top = gz.instructions.items.len,</span>
<span class="line" id="L4587">    };</span>
<span class="line" id="L4588">    <span class="tok-kw">defer</span> decl_block.unstack();</span>
<span class="line" id="L4589"></span>
<span class="line" id="L4590">    <span class="tok-kw">const</span> block_result = <span class="tok-kw">try</span> fullBodyExpr(&amp;decl_block, &amp;decl_block.base, .{ .rl = .none }, body_node);</span>
<span class="line" id="L4591">    <span class="tok-kw">if</span> (decl_block.isEmpty() <span class="tok-kw">or</span> !decl_block.refIsNoReturn(block_result)) {</span>
<span class="line" id="L4592">        _ = <span class="tok-kw">try</span> decl_block.addBreak(.break_inline, decl_inst, .void_value);</span>
<span class="line" id="L4593">    }</span>
<span class="line" id="L4594"></span>
<span class="line" id="L4595">    <span class="tok-kw">try</span> setDeclaration(</span>
<span class="line" id="L4596">        decl_inst,</span>
<span class="line" id="L4597">        std.zig.hashSrc(tree.getNodeSource(node)),</span>
<span class="line" id="L4598">        .@&quot;comptime&quot;,</span>
<span class="line" id="L4599">        decl_block.decl_line - gz.decl_line,</span>
<span class="line" id="L4600">        <span class="tok-null">false</span>,</span>
<span class="line" id="L4601">        <span class="tok-null">false</span>,</span>
<span class="line" id="L4602">        .empty,</span>
<span class="line" id="L4603">        &amp;decl_block,</span>
<span class="line" id="L4604">        <span class="tok-null">null</span>,</span>
<span class="line" id="L4605">    );</span>
<span class="line" id="L4606">}</span>
<span class="line" id="L4607"></span>
<span class="line" id="L4608"><span class="tok-kw">fn</span> <span class="tok-fn">usingnamespaceDecl</span>(</span>
<span class="line" id="L4609">    astgen: *AstGen,</span>
<span class="line" id="L4610">    gz: *GenZir,</span>
<span class="line" id="L4611">    scope: *Scope,</span>
<span class="line" id="L4612">    wip_members: *WipMembers,</span>
<span class="line" id="L4613">    node: Ast.Node.Index,</span>
<span class="line" id="L4614">) InnerError!<span class="tok-type">void</span> {</span>
<span class="line" id="L4615">    <span class="tok-kw">const</span> tree = astgen.tree;</span>
<span class="line" id="L4616">    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);</span>
<span class="line" id="L4617"></span>
<span class="line" id="L4618">    <span class="tok-kw">const</span> type_expr = node_datas[node].lhs;</span>
<span class="line" id="L4619">    <span class="tok-kw">const</span> is_pub = blk: {</span>
<span class="line" id="L4620">        <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);</span>
<span class="line" id="L4621">        <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);</span>
<span class="line" id="L4622">        <span class="tok-kw">const</span> main_token = main_tokens[node];</span>
<span class="line" id="L4623">        <span class="tok-kw">break</span> :blk (main_token &gt; <span class="tok-number">0</span> <span class="tok-kw">and</span> token_tags[main_token - <span class="tok-number">1</span>] == .keyword_pub);</span>
<span class="line" id="L4624">    };</span>
<span class="line" id="L4625">    <span class="tok-comment">// Up top so the ZIR instruction index marks the start range of this</span>
</span>
<span class="line" id="L4626">    <span class="tok-comment">// top-level declaration.</span>
</span>
<span class="line" id="L4627">    <span class="tok-kw">const</span> decl_inst = <span class="tok-kw">try</span> gz.makeBlockInst(.declaration, node);</span>
<span class="line" id="L4628">    wip_members.nextDecl(decl_inst);</span>
<span class="line" id="L4629">    astgen.advanceSourceCursorToNode(node);</span>
<span class="line" id="L4630"></span>
<span class="line" id="L4631">    <span class="tok-kw">var</span> decl_block: GenZir = .{</span>
<span class="line" id="L4632">        .is_comptime = <span class="tok-null">true</span>,</span>
<span class="line" id="L4633">        .decl_node_index = node,</span>
<span class="line" id="L4634">        .decl_line = astgen.source_line,</span>
<span class="line" id="L4635">        .parent = scope,</span>
<span class="line" id="L4636">        .astgen = astgen,</span>
<span class="line" id="L4637">        .instructions = gz.instructions,</span>
<span class="line" id="L4638">        .instructions_top = gz.instructions.items.len,</span>
<span class="line" id="L4639">    };</span>
<span class="line" id="L4640">    <span class="tok-kw">defer</span> decl_block.unstack();</span>
<span class="line" id="L4641"></span>
<span class="line" id="L4642">    <span class="tok-kw">const</span> namespace_inst = <span class="tok-kw">try</span> typeExpr(&amp;decl_block, &amp;decl_block.base, type_expr);</span>
<span class="line" id="L4643">    _ = <span class="tok-kw">try</span> decl_block.addBreak(.break_inline, decl_inst, namespace_inst);</span>
<span class="line" id="L4644"></span>
<span class="line" id="L4645">    <span class="tok-kw">try</span> setDeclaration(</span>
<span class="line" id="L4646">        decl_inst,</span>
<span class="line" id="L4647">        std.zig.hashSrc(tree.getNodeSource(node)),</span>
<span class="line" id="L4648">        .@&quot;usingnamespace&quot;,</span>
<span class="line" id="L4649">        decl_block.decl_line - gz.decl_line,</span>
<span class="line" id="L4650">        is_pub,</span>
<span class="line" id="L4651">        <span class="tok-null">false</span>,</span>
<span class="line" id="L4652">        .empty,</span>
<span class="line" id="L4653">        &amp;decl_block,</span>
<span class="line" id="L4654">        <span class="tok-null">null</span>,</span>
<span class="line" id="L4655">    );</span>
<span class="line" id="L4656">}</span>
<span class="line" id="L4657"></span>
<span class="line" id="L4658"><span class="tok-kw">fn</span> <span class="tok-fn">testDecl</span>(</span>
<span class="line" id="L4659">    astgen: *AstGen,</span>
<span class="line" id="L4660">    gz: *GenZir,</span>
<span class="line" id="L4661">    scope: *Scope,</span>
<span class="line" id="L4662">    wip_members: *WipMembers,</span>
<span class="line" id="L4663">    node: Ast.Node.Index,</span>
<span class="line" id="L4664">) InnerError!<span class="tok-type">void</span> {</span>
<span class="line" id="L4665">    <span class="tok-kw">const</span> tree = astgen.tree;</span>
<span class="line" id="L4666">    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);</span>
<span class="line" id="L4667">    <span class="tok-kw">const</span> body_node = node_datas[node].rhs;</span>
<span class="line" id="L4668"></span>
<span class="line" id="L4669">    <span class="tok-comment">// Up top so the ZIR instruction index marks the start range of this</span>
</span>
<span class="line" id="L4670">    <span class="tok-comment">// top-level declaration.</span>
</span>
<span class="line" id="L4671">    <span class="tok-kw">const</span> decl_inst = <span class="tok-kw">try</span> gz.makeBlockInst(.declaration, node);</span>
<span class="line" id="L4672"></span>
<span class="line" id="L4673">    wip_members.nextDecl(decl_inst);</span>
<span class="line" id="L4674">    astgen.advanceSourceCursorToNode(node);</span>
<span class="line" id="L4675"></span>
<span class="line" id="L4676">    <span class="tok-kw">var</span> decl_block: GenZir = .{</span>
<span class="line" id="L4677">        .is_comptime = <span class="tok-null">true</span>,</span>
<span class="line" id="L4678">        .decl_node_index = node,</span>
<span class="line" id="L4679">        .decl_line = astgen.source_line,</span>
<span class="line" id="L4680">        .parent = scope,</span>
<span class="line" id="L4681">        .astgen = astgen,</span>
<span class="line" id="L4682">        .instructions = gz.instructions,</span>
<span class="line" id="L4683">        .instructions_top = gz.instructions.items.len,</span>
<span class="line" id="L4684">    };</span>
<span class="line" id="L4685">    <span class="tok-kw">defer</span> decl_block.unstack();</span>
<span class="line" id="L4686"></span>
<span class="line" id="L4687">    <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);</span>
<span class="line" id="L4688">    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);</span>
<span class="line" id="L4689">    <span class="tok-kw">const</span> test_token = main_tokens[node];</span>
<span class="line" id="L4690">    <span class="tok-kw">const</span> test_name_token = test_token + <span class="tok-number">1</span>;</span>
<span class="line" id="L4691">    <span class="tok-kw">const</span> test_name: DeclarationName = <span class="tok-kw">switch</span> (token_tags[test_name_token]) {</span>
<span class="line" id="L4692">        <span class="tok-kw">else</span> =&gt; .unnamed_test,</span>
<span class="line" id="L4693">        .string_literal =&gt; .{ .named_test = test_name_token },</span>
<span class="line" id="L4694">        .identifier =&gt; blk: {</span>
<span class="line" id="L4695">            <span class="tok-kw">const</span> ident_name_raw = tree.tokenSlice(test_name_token);</span>
<span class="line" id="L4696"></span>
<span class="line" id="L4697">            <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, ident_name_raw, <span class="tok-str">&quot;_&quot;</span>)) <span class="tok-kw">return</span> astgen.failTok(test_name_token, <span class="tok-str">&quot;'_' used as an identifier without @\&quot;_\&quot; syntax&quot;</span>, .{});</span>
<span class="line" id="L4698"></span>
<span class="line" id="L4699">            <span class="tok-comment">// if not @&quot;&quot; syntax, just use raw token slice</span>
</span>
<span class="line" id="L4700">            <span class="tok-kw">if</span> (ident_name_raw[<span class="tok-number">0</span>] != <span class="tok-str">'@'</span>) {</span>
<span class="line" id="L4701">                <span class="tok-kw">if</span> (isPrimitive(ident_name_raw)) <span class="tok-kw">return</span> astgen.failTok(test_name_token, <span class="tok-str">&quot;cannot test a primitive&quot;</span>, .{});</span>
<span class="line" id="L4702">            }</span>
<span class="line" id="L4703"></span>
<span class="line" id="L4704">            <span class="tok-comment">// Local variables, including function parameters.</span>
</span>
<span class="line" id="L4705">            <span class="tok-kw">const</span> name_str_index = <span class="tok-kw">try</span> astgen.identAsString(test_name_token);</span>
<span class="line" id="L4706">            <span class="tok-kw">var</span> s = scope;</span>
<span class="line" id="L4707">            <span class="tok-kw">var</span> found_already: ?Ast.Node.Index = <span class="tok-null">null</span>; <span class="tok-comment">// we have found a decl with the same name already</span>
</span>
<span class="line" id="L4708">            <span class="tok-kw">var</span> num_namespaces_out: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L4709">            <span class="tok-kw">var</span> capturing_namespace: ?*Scope.Namespace = <span class="tok-null">null</span>;</span>
<span class="line" id="L4710">            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) <span class="tok-kw">switch</span> (s.tag) {</span>
<span class="line" id="L4711">                .local_val =&gt; {</span>
<span class="line" id="L4712">                    <span class="tok-kw">const</span> local_val = s.cast(Scope.LocalVal).?;</span>
<span class="line" id="L4713">                    <span class="tok-kw">if</span> (local_val.name == name_str_index) {</span>
<span class="line" id="L4714">                        local_val.used = test_name_token;</span>
<span class="line" id="L4715">                        <span class="tok-kw">return</span> astgen.failTokNotes(test_name_token, <span class="tok-str">&quot;cannot test a {s}&quot;</span>, .{</span>
<span class="line" id="L4716">                            <span class="tok-builtin">@tagName</span>(local_val.id_cat),</span>
<span class="line" id="L4717">                        }, &amp;[_]<span class="tok-type">u32</span>{</span>
<span class="line" id="L4718">                            <span class="tok-kw">try</span> astgen.errNoteTok(local_val.token_src, <span class="tok-str">&quot;{s} declared here&quot;</span>, .{</span>
<span class="line" id="L4719">                                <span class="tok-builtin">@tagName</span>(local_val.id_cat),</span>
<span class="line" id="L4720">                            }),</span>
<span class="line" id="L4721">                        });</span>
<span class="line" id="L4722">                    }</span>
<span class="line" id="L4723">                    s = local_val.parent;</span>
<span class="line" id="L4724">                },</span>
<span class="line" id="L4725">                .local_ptr =&gt; {</span>
<span class="line" id="L4726">                    <span class="tok-kw">const</span> local_ptr = s.cast(Scope.LocalPtr).?;</span>
<span class="line" id="L4727">                    <span class="tok-kw">if</span> (local_ptr.name == name_str_index) {</span>
<span class="line" id="L4728">                        local_ptr.used = test_name_token;</span>
<span class="line" id="L4729">                        <span class="tok-kw">return</span> astgen.failTokNotes(test_name_token, <span class="tok-str">&quot;cannot test a {s}&quot;</span>, .{</span>
<span class="line" id="L4730">                            <span class="tok-builtin">@tagName</span>(local_ptr.id_cat),</span>
<span class="line" id="L4731">                        }, &amp;[_]<span class="tok-type">u32</span>{</span>
<span class="line" id="L4732">                            <span class="tok-kw">try</span> astgen.errNoteTok(local_ptr.token_src, <span class="tok-str">&quot;{s} declared here&quot;</span>, .{</span>
<span class="line" id="L4733">                                <span class="tok-builtin">@tagName</span>(local_ptr.id_cat),</span>
<span class="line" id="L4734">                            }),</span>
<span class="line" id="L4735">                        });</span>
<span class="line" id="L4736">                    }</span>
<span class="line" id="L4737">                    s = local_ptr.parent;</span>
<span class="line" id="L4738">                },</span>
<span class="line" id="L4739">                .gen_zir =&gt; s = s.cast(GenZir).?.parent,</span>
<span class="line" id="L4740">                .defer_normal, .defer_error =&gt; s = s.cast(Scope.Defer).?.parent,</span>
<span class="line" id="L4741">                .namespace =&gt; {</span>
<span class="line" id="L4742">                    <span class="tok-kw">const</span> ns = s.cast(Scope.Namespace).?;</span>
<span class="line" id="L4743">                    <span class="tok-kw">if</span> (ns.decls.get(name_str_index)) |i| {</span>
<span class="line" id="L4744">                        <span class="tok-kw">if</span> (found_already) |f| {</span>
<span class="line" id="L4745">                            <span class="tok-kw">return</span> astgen.failTokNotes(test_name_token, <span class="tok-str">&quot;ambiguous reference&quot;</span>, .{}, &amp;.{</span>
<span class="line" id="L4746">                                <span class="tok-kw">try</span> astgen.errNoteNode(f, <span class="tok-str">&quot;declared here&quot;</span>, .{}),</span>
<span class="line" id="L4747">                                <span class="tok-kw">try</span> astgen.errNoteNode(i, <span class="tok-str">&quot;also declared here&quot;</span>, .{}),</span>
<span class="line" id="L4748">                            });</span>
<span class="line" id="L4749">                        }</span>
<span class="line" id="L4750">                        <span class="tok-comment">// We found a match but must continue looking for ambiguous references to decls.</span>
</span>
<span class="line" id="L4751">                        found_already = i;</span>
<span class="line" id="L4752">                    }</span>
<span class="line" id="L4753">                    num_namespaces_out += <span class="tok-number">1</span>;</span>
<span class="line" id="L4754">                    capturing_namespace = ns;</span>
<span class="line" id="L4755">                    s = ns.parent;</span>
<span class="line" id="L4756">                },</span>
<span class="line" id="L4757">                .top =&gt; <span class="tok-kw">break</span>,</span>
<span class="line" id="L4758">            };</span>
<span class="line" id="L4759">            <span class="tok-kw">if</span> (found_already == <span class="tok-null">null</span>) {</span>
<span class="line" id="L4760">                <span class="tok-kw">const</span> ident_name = <span class="tok-kw">try</span> astgen.identifierTokenString(test_name_token);</span>
<span class="line" id="L4761">                <span class="tok-kw">return</span> astgen.failTok(test_name_token, <span class="tok-str">&quot;use of undeclared identifier '{s}'&quot;</span>, .{ident_name});</span>
<span class="line" id="L4762">            }</span>
<span class="line" id="L4763"></span>
<span class="line" id="L4764">            <span class="tok-kw">break</span> :blk .{ .decltest = name_str_index };</span>
<span class="line" id="L4765">        },</span>
<span class="line" id="L4766">    };</span>
<span class="line" id="L4767"></span>
<span class="line" id="L4768">    <span class="tok-kw">var</span> fn_block: GenZir = .{</span>
<span class="line" id="L4769">        .is_comptime = <span class="tok-null">false</span>,</span>
<span class="line" id="L4770">        .decl_node_index = node,</span>
<span class="line" id="L4771">        .decl_line = decl_block.decl_line,</span>
<span class="line" id="L4772">        .parent = &amp;decl_block.base,</span>
<span class="line" id="L4773">        .astgen = astgen,</span>
<span class="line" id="L4774">        .instructions = decl_block.instructions,</span>
<span class="line" id="L4775">        .instructions_top = decl_block.instructions.items.len,</span>
<span class="line" id="L4776">    };</span>
<span class="line" id="L4777">    <span class="tok-kw">defer</span> fn_block.unstack();</span>
<span class="line" id="L4778"></span>
<span class="line" id="L4779">    <span class="tok-kw">const</span> prev_within_fn = astgen.within_fn;</span>
<span class="line" id="L4780">    <span class="tok-kw">const</span> prev_fn_block = astgen.fn_block;</span>
<span class="line" id="L4781">    <span class="tok-kw">const</span> prev_fn_ret_ty = astgen.fn_ret_ty;</span>
<span class="line" id="L4782">    astgen.within_fn = <span class="tok-null">true</span>;</span>
<span class="line" id="L4783">    astgen.fn_block = &amp;fn_block;</span>
<span class="line" id="L4784">    astgen.fn_ret_ty = .anyerror_void_error_union_type;</span>
<span class="line" id="L4785">    <span class="tok-kw">defer</span> {</span>
<span class="line" id="L4786">        astgen.within_fn = prev_within_fn;</span>
<span class="line" id="L4787">        astgen.fn_block = prev_fn_block;</span>
<span class="line" id="L4788">        astgen.fn_ret_ty = prev_fn_ret_ty;</span>
<span class="line" id="L4789">    }</span>
<span class="line" id="L4790"></span>
<span class="line" id="L4791">    astgen.advanceSourceCursorToNode(body_node);</span>
<span class="line" id="L4792">    <span class="tok-kw">const</span> lbrace_line = astgen.source_line - decl_block.decl_line;</span>
<span class="line" id="L4793">    <span class="tok-kw">const</span> lbrace_column = astgen.source_column;</span>
<span class="line" id="L4794"></span>
<span class="line" id="L4795">    <span class="tok-kw">const</span> block_result = <span class="tok-kw">try</span> fullBodyExpr(&amp;fn_block, &amp;fn_block.base, .{ .rl = .none }, body_node);</span>
<span class="line" id="L4796">    <span class="tok-kw">if</span> (fn_block.isEmpty() <span class="tok-kw">or</span> !fn_block.refIsNoReturn(block_result)) {</span>
<span class="line" id="L4797"></span>
<span class="line" id="L4798">        <span class="tok-comment">// As our last action before the return, &quot;pop&quot; the error trace if needed</span>
</span>
<span class="line" id="L4799">        _ = <span class="tok-kw">try</span> fn_block.addRestoreErrRetIndex(.ret, .always, node);</span>
<span class="line" id="L4800"></span>
<span class="line" id="L4801">        <span class="tok-comment">// Add implicit return at end of function.</span>
</span>
<span class="line" id="L4802">        _ = <span class="tok-kw">try</span> fn_block.addUnTok(.ret_implicit, .void_value, tree.lastToken(body_node));</span>
<span class="line" id="L4803">    }</span>
<span class="line" id="L4804"></span>
<span class="line" id="L4805">    <span class="tok-kw">const</span> func_inst = <span class="tok-kw">try</span> decl_block.addFunc(.{</span>
<span class="line" id="L4806">        .src_node = node,</span>
<span class="line" id="L4807"></span>
<span class="line" id="L4808">        .cc_ref = .none,</span>
<span class="line" id="L4809">        .cc_gz = <span class="tok-null">null</span>,</span>
<span class="line" id="L4810">        .align_ref = .none,</span>
<span class="line" id="L4811">        .align_gz = <span class="tok-null">null</span>,</span>
<span class="line" id="L4812">        .ret_ref = .anyerror_void_error_union_type,</span>
<span class="line" id="L4813">        .ret_gz = <span class="tok-null">null</span>,</span>
<span class="line" id="L4814">        .section_ref = .none,</span>
<span class="line" id="L4815">        .section_gz = <span class="tok-null">null</span>,</span>
<span class="line" id="L4816">        .addrspace_ref = .none,</span>
<span class="line" id="L4817">        .addrspace_gz = <span class="tok-null">null</span>,</span>
<span class="line" id="L4818"></span>
<span class="line" id="L4819">        .lbrace_line = lbrace_line,</span>
<span class="line" id="L4820">        .lbrace_column = lbrace_column,</span>
<span class="line" id="L4821">        .param_block = decl_inst,</span>
<span class="line" id="L4822">        .body_gz = &amp;fn_block,</span>
<span class="line" id="L4823">        .lib_name = .empty,</span>
<span class="line" id="L4824">        .is_var_args = <span class="tok-null">false</span>,</span>
<span class="line" id="L4825">        .is_inferred_error = <span class="tok-null">false</span>,</span>
<span class="line" id="L4826">        .is_test = <span class="tok-null">true</span>,</span>
<span class="line" id="L4827">        .is_extern = <span class="tok-null">false</span>,</span>
<span class="line" id="L4828">        .is_noinline = <span class="tok-null">false</span>,</span>
<span class="line" id="L4829">        .noalias_bits = <span class="tok-number">0</span>,</span>
<span class="line" id="L4830">    });</span>
<span class="line" id="L4831"></span>
<span class="line" id="L4832">    _ = <span class="tok-kw">try</span> decl_block.addBreak(.break_inline, decl_inst, func_inst);</span>
<span class="line" id="L4833"></span>
<span class="line" id="L4834">    <span class="tok-kw">try</span> setDeclaration(</span>
<span class="line" id="L4835">        decl_inst,</span>
<span class="line" id="L4836">        std.zig.hashSrc(tree.getNodeSource(node)),</span>
<span class="line" id="L4837">        test_name,</span>
<span class="line" id="L4838">        decl_block.decl_line - gz.decl_line,</span>
<span class="line" id="L4839">        <span class="tok-null">false</span>,</span>
<span class="line" id="L4840">        <span class="tok-null">false</span>,</span>
<span class="line" id="L4841">        .empty,</span>
<span class="line" id="L4842">        &amp;decl_block,</span>
<span class="line" id="L4843">        <span class="tok-null">null</span>,</span>
<span class="line" id="L4844">    );</span>
<span class="line" id="L4845">}</span>
<span class="line" id="L4846"></span>
<span class="line" id="L4847"><span class="tok-kw">fn</span> <span class="tok-fn">structDeclInner</span>(</span>
<span class="line" id="L4848">    gz: *GenZir,</span>
<span class="line" id="L4849">    scope: *Scope,</span>
<span class="line" id="L4850">    node: Ast.Node.Index,</span>
<span class="line" id="L4851">    container_decl: Ast.full.ContainerDecl,</span>
<span class="line" id="L4852">    layout: std.builtin.Type.ContainerLayout,</span>
<span class="line" id="L4853">    backing_int_node: Ast.Node.Index,</span>
<span class="line" id="L4854">) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L4855">    <span class="tok-kw">const</span> decl_inst = <span class="tok-kw">try</span> gz.reserveInstructionIndex();</span>
<span class="line" id="L4856"></span>
<span class="line" id="L4857">    <span class="tok-kw">if</span> (container_decl.ast.members.len == <span class="tok-number">0</span> <span class="tok-kw">and</span> backing_int_node == <span class="tok-number">0</span>) {</span>
<span class="line" id="L4858">        <span class="tok-kw">try</span> gz.setStruct(decl_inst, .{</span>
<span class="line" id="L4859">            .src_node = node,</span>
<span class="line" id="L4860">            .layout = layout,</span>
<span class="line" id="L4861">            .captures_len = <span class="tok-number">0</span>,</span>
<span class="line" id="L4862">            .fields_len = <span class="tok-number">0</span>,</span>
<span class="line" id="L4863">            .decls_len = <span class="tok-number">0</span>,</span>
<span class="line" id="L4864">            .has_backing_int = <span class="tok-null">false</span>,</span>
<span class="line" id="L4865">            .known_non_opv = <span class="tok-null">false</span>,</span>
<span class="line" id="L4866">            .known_comptime_only = <span class="tok-null">false</span>,</span>
<span class="line" id="L4867">            .is_tuple = <span class="tok-null">false</span>,</span>
<span class="line" id="L4868">            .any_comptime_fields = <span class="tok-null">false</span>,</span>
<span class="line" id="L4869">            .any_default_inits = <span class="tok-null">false</span>,</span>
<span class="line" id="L4870">            .any_aligned_fields = <span class="tok-null">false</span>,</span>
<span class="line" id="L4871">            .fields_hash = std.zig.hashSrc(<span class="tok-builtin">@tagName</span>(layout)),</span>
<span class="line" id="L4872">        });</span>
<span class="line" id="L4873">        <span class="tok-kw">return</span> decl_inst.toRef();</span>
<span class="line" id="L4874">    }</span>
<span class="line" id="L4875"></span>
<span class="line" id="L4876">    <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L4877">    <span class="tok-kw">const</span> gpa = astgen.gpa;</span>
<span class="line" id="L4878">    <span class="tok-kw">const</span> tree = astgen.tree;</span>
<span class="line" id="L4879"></span>
<span class="line" id="L4880">    <span class="tok-kw">var</span> namespace: Scope.Namespace = .{</span>
<span class="line" id="L4881">        .parent = scope,</span>
<span class="line" id="L4882">        .node = node,</span>
<span class="line" id="L4883">        .inst = decl_inst,</span>
<span class="line" id="L4884">        .declaring_gz = gz,</span>
<span class="line" id="L4885">        .maybe_generic = astgen.within_fn,</span>
<span class="line" id="L4886">    };</span>
<span class="line" id="L4887">    <span class="tok-kw">defer</span> namespace.deinit(gpa);</span>
<span class="line" id="L4888"></span>
<span class="line" id="L4889">    <span class="tok-comment">// The struct_decl instruction introduces a scope in which the decls of the struct</span>
</span>
<span class="line" id="L4890">    <span class="tok-comment">// are in scope, so that field types, alignments, and default value expressions</span>
</span>
<span class="line" id="L4891">    <span class="tok-comment">// can refer to decls within the struct itself.</span>
</span>
<span class="line" id="L4892">    astgen.advanceSourceCursorToNode(node);</span>
<span class="line" id="L4893">    <span class="tok-kw">var</span> block_scope: GenZir = .{</span>
<span class="line" id="L4894">        .parent = &amp;namespace.base,</span>
<span class="line" id="L4895">        .decl_node_index = node,</span>
<span class="line" id="L4896">        .decl_line = gz.decl_line,</span>
<span class="line" id="L4897">        .astgen = astgen,</span>
<span class="line" id="L4898">        .is_comptime = <span class="tok-null">true</span>,</span>
<span class="line" id="L4899">        .instructions = gz.instructions,</span>
<span class="line" id="L4900">        .instructions_top = gz.instructions.items.len,</span>
<span class="line" id="L4901">    };</span>
<span class="line" id="L4902">    <span class="tok-kw">defer</span> block_scope.unstack();</span>
<span class="line" id="L4903"></span>
<span class="line" id="L4904">    <span class="tok-kw">const</span> scratch_top = astgen.scratch.items.len;</span>
<span class="line" id="L4905">    <span class="tok-kw">defer</span> astgen.scratch.items.len = scratch_top;</span>
<span class="line" id="L4906"></span>
<span class="line" id="L4907">    <span class="tok-kw">var</span> backing_int_body_len: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L4908">    <span class="tok-kw">const</span> backing_int_ref: Zir.Inst.Ref = blk: {</span>
<span class="line" id="L4909">        <span class="tok-kw">if</span> (backing_int_node != <span class="tok-number">0</span>) {</span>
<span class="line" id="L4910">            <span class="tok-kw">if</span> (layout != .Packed) {</span>
<span class="line" id="L4911">                <span class="tok-kw">return</span> astgen.failNode(backing_int_node, <span class="tok-str">&quot;non-packed struct does not support backing integer type&quot;</span>, .{});</span>
<span class="line" id="L4912">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L4913">                <span class="tok-kw">const</span> backing_int_ref = <span class="tok-kw">try</span> typeExpr(&amp;block_scope, &amp;namespace.base, backing_int_node);</span>
<span class="line" id="L4914">                <span class="tok-kw">if</span> (!block_scope.isEmpty()) {</span>
<span class="line" id="L4915">                    <span class="tok-kw">if</span> (!block_scope.endsWithNoReturn()) {</span>
<span class="line" id="L4916">                        _ = <span class="tok-kw">try</span> block_scope.addBreak(.break_inline, decl_inst, backing_int_ref);</span>
<span class="line" id="L4917">                    }</span>
<span class="line" id="L4918"></span>
<span class="line" id="L4919">                    <span class="tok-kw">const</span> body = block_scope.instructionsSlice();</span>
<span class="line" id="L4920">                    <span class="tok-kw">const</span> old_scratch_len = astgen.scratch.items.len;</span>
<span class="line" id="L4921">                    <span class="tok-kw">try</span> astgen.scratch.ensureUnusedCapacity(gpa, countBodyLenAfterFixups(astgen, body));</span>
<span class="line" id="L4922">                    appendBodyWithFixupsArrayList(astgen, &amp;astgen.scratch, body);</span>
<span class="line" id="L4923">                    backing_int_body_len = astgen.scratch.items.len - old_scratch_len;</span>
<span class="line" id="L4924">                    block_scope.instructions.items.len = block_scope.instructions_top;</span>
<span class="line" id="L4925">                }</span>
<span class="line" id="L4926">                <span class="tok-kw">break</span> :blk backing_int_ref;</span>
<span class="line" id="L4927">            }</span>
<span class="line" id="L4928">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L4929">            <span class="tok-kw">break</span> :blk .none;</span>
<span class="line" id="L4930">        }</span>
<span class="line" id="L4931">    };</span>
<span class="line" id="L4932"></span>
<span class="line" id="L4933">    <span class="tok-kw">const</span> decl_count = <span class="tok-kw">try</span> astgen.scanDecls(&amp;namespace, container_decl.ast.members);</span>
<span class="line" id="L4934">    <span class="tok-kw">const</span> field_count: <span class="tok-type">u32</span> = <span class="tok-builtin">@intCast</span>(container_decl.ast.members.len - decl_count);</span>
<span class="line" id="L4935"></span>
<span class="line" id="L4936">    <span class="tok-kw">const</span> bits_per_field = <span class="tok-number">4</span>;</span>
<span class="line" id="L4937">    <span class="tok-kw">const</span> max_field_size = <span class="tok-number">5</span>;</span>
<span class="line" id="L4938">    <span class="tok-kw">var</span> wip_members = <span class="tok-kw">try</span> WipMembers.init(gpa, &amp;astgen.scratch, decl_count, field_count, bits_per_field, max_field_size);</span>
<span class="line" id="L4939">    <span class="tok-kw">defer</span> wip_members.deinit();</span>
<span class="line" id="L4940"></span>
<span class="line" id="L4941">    <span class="tok-comment">// We will use the scratch buffer, starting here, for the bodies:</span>
</span>
<span class="line" id="L4942">    <span class="tok-comment">//    bodies: { // for every fields_len</span>
</span>
<span class="line" id="L4943">    <span class="tok-comment">//        field_type_body_inst: Inst, // for each field_type_body_len</span>
</span>
<span class="line" id="L4944">    <span class="tok-comment">//        align_body_inst: Inst, // for each align_body_len</span>
</span>
<span class="line" id="L4945">    <span class="tok-comment">//        init_body_inst: Inst, // for each init_body_len</span>
</span>
<span class="line" id="L4946">    <span class="tok-comment">//    }</span>
</span>
<span class="line" id="L4947">    <span class="tok-comment">// Note that the scratch buffer is simultaneously being used by WipMembers, however</span>
</span>
<span class="line" id="L4948">    <span class="tok-comment">// it will not access any elements beyond this point in the ArrayList. It also</span>
</span>
<span class="line" id="L4949">    <span class="tok-comment">// accesses via the ArrayList items field so it can handle the scratch buffer being</span>
</span>
<span class="line" id="L4950">    <span class="tok-comment">// reallocated.</span>
</span>
<span class="line" id="L4951">    <span class="tok-comment">// No defer needed here because it is handled by `wip_members.deinit()` above.</span>
</span>
<span class="line" id="L4952">    <span class="tok-kw">const</span> bodies_start = astgen.scratch.items.len;</span>
<span class="line" id="L4953"></span>
<span class="line" id="L4954">    <span class="tok-kw">const</span> node_tags = tree.nodes.items(.tag);</span>
<span class="line" id="L4955">    <span class="tok-kw">const</span> is_tuple = <span class="tok-kw">for</span> (container_decl.ast.members) |member_node| {</span>
<span class="line" id="L4956">        <span class="tok-kw">const</span> container_field = tree.fullContainerField(member_node) <span class="tok-kw">orelse</span> <span class="tok-kw">continue</span>;</span>
<span class="line" id="L4957">        <span class="tok-kw">if</span> (container_field.ast.tuple_like) <span class="tok-kw">break</span> <span class="tok-null">true</span>;</span>
<span class="line" id="L4958">    } <span class="tok-kw">else</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L4959"></span>
<span class="line" id="L4960">    <span class="tok-kw">if</span> (is_tuple) <span class="tok-kw">switch</span> (layout) {</span>
<span class="line" id="L4961">        .Auto =&gt; {},</span>
<span class="line" id="L4962">        .Extern =&gt; <span class="tok-kw">return</span> astgen.failNode(node, <span class="tok-str">&quot;extern tuples are not supported&quot;</span>, .{}),</span>
<span class="line" id="L4963">        .Packed =&gt; <span class="tok-kw">return</span> astgen.failNode(node, <span class="tok-str">&quot;packed tuples are not supported&quot;</span>, .{}),</span>
<span class="line" id="L4964">    };</span>
<span class="line" id="L4965"></span>
<span class="line" id="L4966">    <span class="tok-kw">if</span> (is_tuple) <span class="tok-kw">for</span> (container_decl.ast.members) |member_node| {</span>
<span class="line" id="L4967">        <span class="tok-kw">switch</span> (node_tags[member_node]) {</span>
<span class="line" id="L4968">            .container_field_init,</span>
<span class="line" id="L4969">            .container_field_align,</span>
<span class="line" id="L4970">            .container_field,</span>
<span class="line" id="L4971">            .@&quot;comptime&quot;,</span>
<span class="line" id="L4972">            .test_decl,</span>
<span class="line" id="L4973">            =&gt; <span class="tok-kw">continue</span>,</span>
<span class="line" id="L4974">            <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L4975">                <span class="tok-kw">const</span> tuple_member = <span class="tok-kw">for</span> (container_decl.ast.members) |maybe_tuple| <span class="tok-kw">switch</span> (node_tags[maybe_tuple]) {</span>
<span class="line" id="L4976">                    .container_field_init,</span>
<span class="line" id="L4977">                    .container_field_align,</span>
<span class="line" id="L4978">                    .container_field,</span>
<span class="line" id="L4979">                    =&gt; <span class="tok-kw">break</span> maybe_tuple,</span>
<span class="line" id="L4980">                    <span class="tok-kw">else</span> =&gt; {},</span>
<span class="line" id="L4981">                } <span class="tok-kw">else</span> <span class="tok-kw">unreachable</span>;</span>
<span class="line" id="L4982">                <span class="tok-kw">return</span> astgen.failNodeNotes(</span>
<span class="line" id="L4983">                    member_node,</span>
<span class="line" id="L4984">                    <span class="tok-str">&quot;tuple declarations cannot contain declarations&quot;</span>,</span>
<span class="line" id="L4985">                    .{},</span>
<span class="line" id="L4986">                    &amp;[_]<span class="tok-type">u32</span>{</span>
<span class="line" id="L4987">                        <span class="tok-kw">try</span> astgen.errNoteNode(tuple_member, <span class="tok-str">&quot;tuple field here&quot;</span>, .{}),</span>
<span class="line" id="L4988">                    },</span>
<span class="line" id="L4989">                );</span>
<span class="line" id="L4990">            },</span>
<span class="line" id="L4991">        }</span>
<span class="line" id="L4992">    };</span>
<span class="line" id="L4993"></span>
<span class="line" id="L4994">    <span class="tok-kw">var</span> fields_hasher = std.zig.SrcHasher.init(.{});</span>
<span class="line" id="L4995">    fields_hasher.update(<span class="tok-builtin">@tagName</span>(layout));</span>
<span class="line" id="L4996">    <span class="tok-kw">if</span> (backing_int_node != <span class="tok-number">0</span>) {</span>
<span class="line" id="L4997">        fields_hasher.update(tree.getNodeSource(backing_int_node));</span>
<span class="line" id="L4998">    }</span>
<span class="line" id="L4999"></span>
<span class="line" id="L5000">    <span class="tok-kw">var</span> sfba = std.heap.stackFallback(<span class="tok-number">256</span>, astgen.arena);</span>
<span class="line" id="L5001">    <span class="tok-kw">const</span> sfba_allocator = sfba.get();</span>
<span class="line" id="L5002"></span>
<span class="line" id="L5003">    <span class="tok-kw">var</span> duplicate_names = std.AutoArrayHashMap(Zir.NullTerminatedString, std.ArrayListUnmanaged(Ast.TokenIndex)).init(sfba_allocator);</span>
<span class="line" id="L5004">    <span class="tok-kw">try</span> duplicate_names.ensureTotalCapacity(field_count);</span>
<span class="line" id="L5005"></span>
<span class="line" id="L5006">    <span class="tok-comment">// When there aren't errors, use this to avoid a second iteration.</span>
</span>
<span class="line" id="L5007">    <span class="tok-kw">var</span> any_duplicate = <span class="tok-null">false</span>;</span>
<span class="line" id="L5008"></span>
<span class="line" id="L5009">    <span class="tok-kw">var</span> known_non_opv = <span class="tok-null">false</span>;</span>
<span class="line" id="L5010">    <span class="tok-kw">var</span> known_comptime_only = <span class="tok-null">false</span>;</span>
<span class="line" id="L5011">    <span class="tok-kw">var</span> any_comptime_fields = <span class="tok-null">false</span>;</span>
<span class="line" id="L5012">    <span class="tok-kw">var</span> any_aligned_fields = <span class="tok-null">false</span>;</span>
<span class="line" id="L5013">    <span class="tok-kw">var</span> any_default_inits = <span class="tok-null">false</span>;</span>
<span class="line" id="L5014">    <span class="tok-kw">for</span> (container_decl.ast.members) |member_node| {</span>
<span class="line" id="L5015">        <span class="tok-kw">var</span> member = <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> containerMember(&amp;block_scope, &amp;namespace.base, &amp;wip_members, member_node)) {</span>
<span class="line" id="L5016">            .decl =&gt; <span class="tok-kw">continue</span>,</span>
<span class="line" id="L5017">            .field =&gt; |field| field,</span>
<span class="line" id="L5018">        };</span>
<span class="line" id="L5019"></span>
<span class="line" id="L5020">        fields_hasher.update(tree.getNodeSource(member_node));</span>
<span class="line" id="L5021"></span>
<span class="line" id="L5022">        <span class="tok-kw">if</span> (!is_tuple) {</span>
<span class="line" id="L5023">            <span class="tok-kw">const</span> field_name = <span class="tok-kw">try</span> astgen.identAsString(member.ast.main_token);</span>
<span class="line" id="L5024"></span>
<span class="line" id="L5025">            member.convertToNonTupleLike(astgen.tree.nodes);</span>
<span class="line" id="L5026">            assert(!member.ast.tuple_like);</span>
<span class="line" id="L5027"></span>
<span class="line" id="L5028">            wip_members.appendToField(<span class="tok-builtin">@intFromEnum</span>(field_name));</span>
<span class="line" id="L5029"></span>
<span class="line" id="L5030">            <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> duplicate_names.getOrPut(field_name);</span>
<span class="line" id="L5031"></span>
<span class="line" id="L5032">            <span class="tok-kw">if</span> (gop.found_existing) {</span>
<span class="line" id="L5033">                <span class="tok-kw">try</span> gop.value_ptr.append(sfba_allocator, member.ast.main_token);</span>
<span class="line" id="L5034">                any_duplicate = <span class="tok-null">true</span>;</span>
<span class="line" id="L5035">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L5036">                gop.value_ptr.* = .{};</span>
<span class="line" id="L5037">                <span class="tok-kw">try</span> gop.value_ptr.append(sfba_allocator, member.ast.main_token);</span>
<span class="line" id="L5038">            }</span>
<span class="line" id="L5039">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (!member.ast.tuple_like) {</span>
<span class="line" id="L5040">            <span class="tok-kw">return</span> astgen.failTok(member.ast.main_token, <span class="tok-str">&quot;tuple field has a name&quot;</span>, .{});</span>
<span class="line" id="L5041">        }</span>
<span class="line" id="L5042"></span>
<span class="line" id="L5043">        <span class="tok-kw">const</span> doc_comment_index = <span class="tok-kw">try</span> astgen.docCommentAsString(member.firstToken());</span>
<span class="line" id="L5044">        wip_members.appendToField(<span class="tok-builtin">@intFromEnum</span>(doc_comment_index));</span>
<span class="line" id="L5045"></span>
<span class="line" id="L5046">        <span class="tok-kw">if</span> (member.ast.type_expr == <span class="tok-number">0</span>) {</span>
<span class="line" id="L5047">            <span class="tok-kw">return</span> astgen.failTok(member.ast.main_token, <span class="tok-str">&quot;struct field missing type&quot;</span>, .{});</span>
<span class="line" id="L5048">        }</span>
<span class="line" id="L5049"></span>
<span class="line" id="L5050">        <span class="tok-kw">const</span> field_type = <span class="tok-kw">try</span> typeExpr(&amp;block_scope, &amp;namespace.base, member.ast.type_expr);</span>
<span class="line" id="L5051">        <span class="tok-kw">const</span> have_type_body = !block_scope.isEmpty();</span>
<span class="line" id="L5052">        <span class="tok-kw">const</span> have_align = member.ast.align_expr != <span class="tok-number">0</span>;</span>
<span class="line" id="L5053">        <span class="tok-kw">const</span> have_value = member.ast.value_expr != <span class="tok-number">0</span>;</span>
<span class="line" id="L5054">        <span class="tok-kw">const</span> is_comptime = member.comptime_token != <span class="tok-null">null</span>;</span>
<span class="line" id="L5055"></span>
<span class="line" id="L5056">        <span class="tok-kw">if</span> (is_comptime) {</span>
<span class="line" id="L5057">            <span class="tok-kw">switch</span> (layout) {</span>
<span class="line" id="L5058">                .Packed =&gt; <span class="tok-kw">return</span> astgen.failTok(member.comptime_token.?, <span class="tok-str">&quot;packed struct fields cannot be marked comptime&quot;</span>, .{}),</span>
<span class="line" id="L5059">                .Extern =&gt; <span class="tok-kw">return</span> astgen.failTok(member.comptime_token.?, <span class="tok-str">&quot;extern struct fields cannot be marked comptime&quot;</span>, .{}),</span>
<span class="line" id="L5060">                .Auto =&gt; any_comptime_fields = <span class="tok-null">true</span>,</span>
<span class="line" id="L5061">            }</span>
<span class="line" id="L5062">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L5063">            known_non_opv = known_non_opv <span class="tok-kw">or</span></span>
<span class="line" id="L5064">                nodeImpliesMoreThanOnePossibleValue(tree, member.ast.type_expr);</span>
<span class="line" id="L5065">            known_comptime_only = known_comptime_only <span class="tok-kw">or</span></span>
<span class="line" id="L5066">                nodeImpliesComptimeOnly(tree, member.ast.type_expr);</span>
<span class="line" id="L5067">        }</span>
<span class="line" id="L5068">        wip_members.nextField(bits_per_field, .{ have_align, have_value, is_comptime, have_type_body });</span>
<span class="line" id="L5069"></span>
<span class="line" id="L5070">        <span class="tok-kw">if</span> (have_type_body) {</span>
<span class="line" id="L5071">            <span class="tok-kw">if</span> (!block_scope.endsWithNoReturn()) {</span>
<span class="line" id="L5072">                _ = <span class="tok-kw">try</span> block_scope.addBreak(.break_inline, decl_inst, field_type);</span>
<span class="line" id="L5073">            }</span>
<span class="line" id="L5074">            <span class="tok-kw">const</span> body = block_scope.instructionsSlice();</span>
<span class="line" id="L5075">            <span class="tok-kw">const</span> old_scratch_len = astgen.scratch.items.len;</span>
<span class="line" id="L5076">            <span class="tok-kw">try</span> astgen.scratch.ensureUnusedCapacity(gpa, countBodyLenAfterFixups(astgen, body));</span>
<span class="line" id="L5077">            appendBodyWithFixupsArrayList(astgen, &amp;astgen.scratch, body);</span>
<span class="line" id="L5078">            wip_members.appendToField(<span class="tok-builtin">@intCast</span>(astgen.scratch.items.len - old_scratch_len));</span>
<span class="line" id="L5079">            block_scope.instructions.items.len = block_scope.instructions_top;</span>
<span class="line" id="L5080">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L5081">            wip_members.appendToField(<span class="tok-builtin">@intFromEnum</span>(field_type));</span>
<span class="line" id="L5082">        }</span>
<span class="line" id="L5083"></span>
<span class="line" id="L5084">        <span class="tok-kw">if</span> (have_align) {</span>
<span class="line" id="L5085">            <span class="tok-kw">if</span> (layout == .Packed) {</span>
<span class="line" id="L5086">                <span class="tok-kw">try</span> astgen.appendErrorNode(member.ast.align_expr, <span class="tok-str">&quot;unable to override alignment of packed struct fields&quot;</span>, .{});</span>
<span class="line" id="L5087">            }</span>
<span class="line" id="L5088">            any_aligned_fields = <span class="tok-null">true</span>;</span>
<span class="line" id="L5089">            <span class="tok-kw">const</span> align_ref = <span class="tok-kw">try</span> expr(&amp;block_scope, &amp;namespace.base, coerced_align_ri, member.ast.align_expr);</span>
<span class="line" id="L5090">            <span class="tok-kw">if</span> (!block_scope.endsWithNoReturn()) {</span>
<span class="line" id="L5091">                _ = <span class="tok-kw">try</span> block_scope.addBreak(.break_inline, decl_inst, align_ref);</span>
<span class="line" id="L5092">            }</span>
<span class="line" id="L5093">            <span class="tok-kw">const</span> body = block_scope.instructionsSlice();</span>
<span class="line" id="L5094">            <span class="tok-kw">const</span> old_scratch_len = astgen.scratch.items.len;</span>
<span class="line" id="L5095">            <span class="tok-kw">try</span> astgen.scratch.ensureUnusedCapacity(gpa, countBodyLenAfterFixups(astgen, body));</span>
<span class="line" id="L5096">            appendBodyWithFixupsArrayList(astgen, &amp;astgen.scratch, body);</span>
<span class="line" id="L5097">            wip_members.appendToField(<span class="tok-builtin">@intCast</span>(astgen.scratch.items.len - old_scratch_len));</span>
<span class="line" id="L5098">            block_scope.instructions.items.len = block_scope.instructions_top;</span>
<span class="line" id="L5099">        }</span>
<span class="line" id="L5100"></span>
<span class="line" id="L5101">        <span class="tok-kw">if</span> (have_value) {</span>
<span class="line" id="L5102">            any_default_inits = <span class="tok-null">true</span>;</span>
<span class="line" id="L5103"></span>
<span class="line" id="L5104">            <span class="tok-comment">// The decl_inst is used as here so that we can easily reconstruct a mapping</span>
</span>
<span class="line" id="L5105">            <span class="tok-comment">// between it and the field type when the fields inits are analzyed.</span>
</span>
<span class="line" id="L5106">            <span class="tok-kw">const</span> ri: ResultInfo = .{ .rl = <span class="tok-kw">if</span> (field_type == .none) .none <span class="tok-kw">else</span> .{ .coerced_ty = decl_inst.toRef() } };</span>
<span class="line" id="L5107"></span>
<span class="line" id="L5108">            <span class="tok-kw">const</span> default_inst = <span class="tok-kw">try</span> expr(&amp;block_scope, &amp;namespace.base, ri, member.ast.value_expr);</span>
<span class="line" id="L5109">            <span class="tok-kw">if</span> (!block_scope.endsWithNoReturn()) {</span>
<span class="line" id="L5110">                _ = <span class="tok-kw">try</span> block_scope.addBreak(.break_inline, decl_inst, default_inst);</span>
<span class="line" id="L5111">            }</span>
<span class="line" id="L5112">            <span class="tok-kw">const</span> body = block_scope.instructionsSlice();</span>
<span class="line" id="L5113">            <span class="tok-kw">const</span> old_scratch_len = astgen.scratch.items.len;</span>
<span class="line" id="L5114">            <span class="tok-kw">try</span> astgen.scratch.ensureUnusedCapacity(gpa, countBodyLenAfterFixups(astgen, body));</span>
<span class="line" id="L5115">            appendBodyWithFixupsArrayList(astgen, &amp;astgen.scratch, body);</span>
<span class="line" id="L5116">            wip_members.appendToField(<span class="tok-builtin">@intCast</span>(astgen.scratch.items.len - old_scratch_len));</span>
<span class="line" id="L5117">            block_scope.instructions.items.len = block_scope.instructions_top;</span>
<span class="line" id="L5118">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (member.comptime_token) |comptime_token| {</span>
<span class="line" id="L5119">            <span class="tok-kw">return</span> astgen.failTok(comptime_token, <span class="tok-str">&quot;comptime field without default initialization value&quot;</span>, .{});</span>
<span class="line" id="L5120">        }</span>
<span class="line" id="L5121">    }</span>
<span class="line" id="L5122"></span>
<span class="line" id="L5123">    <span class="tok-kw">if</span> (any_duplicate) {</span>
<span class="line" id="L5124">        <span class="tok-kw">var</span> it = duplicate_names.iterator();</span>
<span class="line" id="L5125"></span>
<span class="line" id="L5126">        <span class="tok-kw">while</span> (it.next()) |entry| {</span>
<span class="line" id="L5127">            <span class="tok-kw">const</span> record = entry.value_ptr.*;</span>
<span class="line" id="L5128">            <span class="tok-kw">if</span> (record.items.len &gt; <span class="tok-number">1</span>) {</span>
<span class="line" id="L5129">                <span class="tok-kw">var</span> error_notes = std.ArrayList(<span class="tok-type">u32</span>).init(astgen.arena);</span>
<span class="line" id="L5130"></span>
<span class="line" id="L5131">                <span class="tok-kw">for</span> (record.items[<span class="tok-number">1</span>..]) |duplicate| {</span>
<span class="line" id="L5132">                    <span class="tok-kw">try</span> error_notes.append(<span class="tok-kw">try</span> astgen.errNoteTok(duplicate, <span class="tok-str">&quot;duplicate field here&quot;</span>, .{}));</span>
<span class="line" id="L5133">                }</span>
<span class="line" id="L5134"></span>
<span class="line" id="L5135">                <span class="tok-kw">try</span> error_notes.append(<span class="tok-kw">try</span> astgen.errNoteNode(node, <span class="tok-str">&quot;struct declared here&quot;</span>, .{}));</span>
<span class="line" id="L5136"></span>
<span class="line" id="L5137">                <span class="tok-kw">try</span> astgen.appendErrorTokNotes(</span>
<span class="line" id="L5138">                    record.items[<span class="tok-number">0</span>],</span>
<span class="line" id="L5139">                    <span class="tok-str">&quot;duplicate struct field name&quot;</span>,</span>
<span class="line" id="L5140">                    .{},</span>
<span class="line" id="L5141">                    error_notes.items,</span>
<span class="line" id="L5142">                );</span>
<span class="line" id="L5143">            }</span>
<span class="line" id="L5144">        }</span>
<span class="line" id="L5145"></span>
<span class="line" id="L5146">        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AnalysisFail;</span>
<span class="line" id="L5147">    }</span>
<span class="line" id="L5148"></span>
<span class="line" id="L5149">    <span class="tok-kw">var</span> fields_hash: std.zig.SrcHash = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L5150">    fields_hasher.final(&amp;fields_hash);</span>
<span class="line" id="L5151"></span>
<span class="line" id="L5152">    <span class="tok-kw">try</span> gz.setStruct(decl_inst, .{</span>
<span class="line" id="L5153">        .src_node = node,</span>
<span class="line" id="L5154">        .layout = layout,</span>
<span class="line" id="L5155">        .captures_len = <span class="tok-builtin">@intCast</span>(namespace.captures.count()),</span>
<span class="line" id="L5156">        .fields_len = field_count,</span>
<span class="line" id="L5157">        .decls_len = decl_count,</span>
<span class="line" id="L5158">        .has_backing_int = backing_int_ref != .none,</span>
<span class="line" id="L5159">        .known_non_opv = known_non_opv,</span>
<span class="line" id="L5160">        .known_comptime_only = known_comptime_only,</span>
<span class="line" id="L5161">        .is_tuple = is_tuple,</span>
<span class="line" id="L5162">        .any_comptime_fields = any_comptime_fields,</span>
<span class="line" id="L5163">        .any_default_inits = any_default_inits,</span>
<span class="line" id="L5164">        .any_aligned_fields = any_aligned_fields,</span>
<span class="line" id="L5165">        .fields_hash = fields_hash,</span>
<span class="line" id="L5166">    });</span>
<span class="line" id="L5167"></span>
<span class="line" id="L5168">    wip_members.finishBits(bits_per_field);</span>
<span class="line" id="L5169">    <span class="tok-kw">const</span> decls_slice = wip_members.declsSlice();</span>
<span class="line" id="L5170">    <span class="tok-kw">const</span> fields_slice = wip_members.fieldsSlice();</span>
<span class="line" id="L5171">    <span class="tok-kw">const</span> bodies_slice = astgen.scratch.items[bodies_start..];</span>
<span class="line" id="L5172">    <span class="tok-kw">try</span> astgen.extra.ensureUnusedCapacity(gpa, backing_int_body_len + <span class="tok-number">2</span> +</span>
<span class="line" id="L5173">        decls_slice.len + namespace.captures.count() + fields_slice.len + bodies_slice.len);</span>
<span class="line" id="L5174">    astgen.extra.appendSliceAssumeCapacity(<span class="tok-builtin">@ptrCast</span>(namespace.captures.keys()));</span>
<span class="line" id="L5175">    <span class="tok-kw">if</span> (backing_int_ref != .none) {</span>
<span class="line" id="L5176">        astgen.extra.appendAssumeCapacity(<span class="tok-builtin">@intCast</span>(backing_int_body_len));</span>
<span class="line" id="L5177">        <span class="tok-kw">if</span> (backing_int_body_len == <span class="tok-number">0</span>) {</span>
<span class="line" id="L5178">            astgen.extra.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(backing_int_ref));</span>
<span class="line" id="L5179">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L5180">            astgen.extra.appendSliceAssumeCapacity(astgen.scratch.items[scratch_top..][<span class="tok-number">0</span>..backing_int_body_len]);</span>
<span class="line" id="L5181">        }</span>
<span class="line" id="L5182">    }</span>
<span class="line" id="L5183">    astgen.extra.appendSliceAssumeCapacity(decls_slice);</span>
<span class="line" id="L5184">    astgen.extra.appendSliceAssumeCapacity(fields_slice);</span>
<span class="line" id="L5185">    astgen.extra.appendSliceAssumeCapacity(bodies_slice);</span>
<span class="line" id="L5186"></span>
<span class="line" id="L5187">    block_scope.unstack();</span>
<span class="line" id="L5188">    <span class="tok-kw">return</span> decl_inst.toRef();</span>
<span class="line" id="L5189">}</span>
<span class="line" id="L5190"></span>
<span class="line" id="L5191"><span class="tok-kw">fn</span> <span class="tok-fn">unionDeclInner</span>(</span>
<span class="line" id="L5192">    gz: *GenZir,</span>
<span class="line" id="L5193">    scope: *Scope,</span>
<span class="line" id="L5194">    node: Ast.Node.Index,</span>
<span class="line" id="L5195">    members: []<span class="tok-kw">const</span> Ast.Node.Index,</span>
<span class="line" id="L5196">    layout: std.builtin.Type.ContainerLayout,</span>
<span class="line" id="L5197">    arg_node: Ast.Node.Index,</span>
<span class="line" id="L5198">    auto_enum_tok: ?Ast.TokenIndex,</span>
<span class="line" id="L5199">) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L5200">    <span class="tok-kw">const</span> decl_inst = <span class="tok-kw">try</span> gz.reserveInstructionIndex();</span>
<span class="line" id="L5201"></span>
<span class="line" id="L5202">    <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L5203">    <span class="tok-kw">const</span> gpa = astgen.gpa;</span>
<span class="line" id="L5204"></span>
<span class="line" id="L5205">    <span class="tok-kw">var</span> namespace: Scope.Namespace = .{</span>
<span class="line" id="L5206">        .parent = scope,</span>
<span class="line" id="L5207">        .node = node,</span>
<span class="line" id="L5208">        .inst = decl_inst,</span>
<span class="line" id="L5209">        .declaring_gz = gz,</span>
<span class="line" id="L5210">        .maybe_generic = astgen.within_fn,</span>
<span class="line" id="L5211">    };</span>
<span class="line" id="L5212">    <span class="tok-kw">defer</span> namespace.deinit(gpa);</span>
<span class="line" id="L5213"></span>
<span class="line" id="L5214">    <span class="tok-comment">// The union_decl instruction introduces a scope in which the decls of the union</span>
</span>
<span class="line" id="L5215">    <span class="tok-comment">// are in scope, so that field types, alignments, and default value expressions</span>
</span>
<span class="line" id="L5216">    <span class="tok-comment">// can refer to decls within the union itself.</span>
</span>
<span class="line" id="L5217">    astgen.advanceSourceCursorToNode(node);</span>
<span class="line" id="L5218">    <span class="tok-kw">var</span> block_scope: GenZir = .{</span>
<span class="line" id="L5219">        .parent = &amp;namespace.base,</span>
<span class="line" id="L5220">        .decl_node_index = node,</span>
<span class="line" id="L5221">        .decl_line = gz.decl_line,</span>
<span class="line" id="L5222">        .astgen = astgen,</span>
<span class="line" id="L5223">        .is_comptime = <span class="tok-null">true</span>,</span>
<span class="line" id="L5224">        .instructions = gz.instructions,</span>
<span class="line" id="L5225">        .instructions_top = gz.instructions.items.len,</span>
<span class="line" id="L5226">    };</span>
<span class="line" id="L5227">    <span class="tok-kw">defer</span> block_scope.unstack();</span>
<span class="line" id="L5228"></span>
<span class="line" id="L5229">    <span class="tok-kw">const</span> decl_count = <span class="tok-kw">try</span> astgen.scanDecls(&amp;namespace, members);</span>
<span class="line" id="L5230">    <span class="tok-kw">const</span> field_count: <span class="tok-type">u32</span> = <span class="tok-builtin">@intCast</span>(members.len - decl_count);</span>
<span class="line" id="L5231"></span>
<span class="line" id="L5232">    <span class="tok-kw">if</span> (layout != .Auto <span class="tok-kw">and</span> (auto_enum_tok != <span class="tok-null">null</span> <span class="tok-kw">or</span> arg_node != <span class="tok-number">0</span>)) {</span>
<span class="line" id="L5233">        <span class="tok-kw">const</span> layout_str = <span class="tok-kw">if</span> (layout == .Extern) <span class="tok-str">&quot;extern&quot;</span> <span class="tok-kw">else</span> <span class="tok-str">&quot;packed&quot;</span>;</span>
<span class="line" id="L5234">        <span class="tok-kw">if</span> (arg_node != <span class="tok-number">0</span>) {</span>
<span class="line" id="L5235">            <span class="tok-kw">return</span> astgen.failNode(arg_node, <span class="tok-str">&quot;{s} union does not support enum tag type&quot;</span>, .{layout_str});</span>
<span class="line" id="L5236">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L5237">            <span class="tok-kw">return</span> astgen.failTok(auto_enum_tok.?, <span class="tok-str">&quot;{s} union does not support enum tag type&quot;</span>, .{layout_str});</span>
<span class="line" id="L5238">        }</span>
<span class="line" id="L5239">    }</span>
<span class="line" id="L5240"></span>
<span class="line" id="L5241">    <span class="tok-kw">const</span> arg_inst: Zir.Inst.Ref = <span class="tok-kw">if</span> (arg_node != <span class="tok-number">0</span>)</span>
<span class="line" id="L5242">        <span class="tok-kw">try</span> typeExpr(&amp;block_scope, &amp;namespace.base, arg_node)</span>
<span class="line" id="L5243">    <span class="tok-kw">else</span></span>
<span class="line" id="L5244">        .none;</span>
<span class="line" id="L5245"></span>
<span class="line" id="L5246">    <span class="tok-kw">const</span> bits_per_field = <span class="tok-number">4</span>;</span>
<span class="line" id="L5247">    <span class="tok-kw">const</span> max_field_size = <span class="tok-number">5</span>;</span>
<span class="line" id="L5248">    <span class="tok-kw">var</span> any_aligned_fields = <span class="tok-null">false</span>;</span>
<span class="line" id="L5249">    <span class="tok-kw">var</span> wip_members = <span class="tok-kw">try</span> WipMembers.init(gpa, &amp;astgen.scratch, decl_count, field_count, bits_per_field, max_field_size);</span>
<span class="line" id="L5250">    <span class="tok-kw">defer</span> wip_members.deinit();</span>
<span class="line" id="L5251"></span>
<span class="line" id="L5252">    <span class="tok-kw">var</span> fields_hasher = std.zig.SrcHasher.init(.{});</span>
<span class="line" id="L5253">    fields_hasher.update(<span class="tok-builtin">@tagName</span>(layout));</span>
<span class="line" id="L5254">    fields_hasher.update(&amp;.{<span class="tok-builtin">@intFromBool</span>(auto_enum_tok != <span class="tok-null">null</span>)});</span>
<span class="line" id="L5255">    <span class="tok-kw">if</span> (arg_node != <span class="tok-number">0</span>) {</span>
<span class="line" id="L5256">        fields_hasher.update(astgen.tree.getNodeSource(arg_node));</span>
<span class="line" id="L5257">    }</span>
<span class="line" id="L5258"></span>
<span class="line" id="L5259">    <span class="tok-kw">var</span> sfba = std.heap.stackFallback(<span class="tok-number">256</span>, astgen.arena);</span>
<span class="line" id="L5260">    <span class="tok-kw">const</span> sfba_allocator = sfba.get();</span>
<span class="line" id="L5261"></span>
<span class="line" id="L5262">    <span class="tok-kw">var</span> duplicate_names = std.AutoArrayHashMap(Zir.NullTerminatedString, std.ArrayListUnmanaged(Ast.TokenIndex)).init(sfba_allocator);</span>
<span class="line" id="L5263">    <span class="tok-kw">try</span> duplicate_names.ensureTotalCapacity(field_count);</span>
<span class="line" id="L5264"></span>
<span class="line" id="L5265">    <span class="tok-comment">// When there aren't errors, use this to avoid a second iteration.</span>
</span>
<span class="line" id="L5266">    <span class="tok-kw">var</span> any_duplicate = <span class="tok-null">false</span>;</span>
<span class="line" id="L5267"></span>
<span class="line" id="L5268">    <span class="tok-kw">for</span> (members) |member_node| {</span>
<span class="line" id="L5269">        <span class="tok-kw">var</span> member = <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> containerMember(&amp;block_scope, &amp;namespace.base, &amp;wip_members, member_node)) {</span>
<span class="line" id="L5270">            .decl =&gt; <span class="tok-kw">continue</span>,</span>
<span class="line" id="L5271">            .field =&gt; |field| field,</span>
<span class="line" id="L5272">        };</span>
<span class="line" id="L5273">        fields_hasher.update(astgen.tree.getNodeSource(member_node));</span>
<span class="line" id="L5274">        member.convertToNonTupleLike(astgen.tree.nodes);</span>
<span class="line" id="L5275">        <span class="tok-kw">if</span> (member.ast.tuple_like) {</span>
<span class="line" id="L5276">            <span class="tok-kw">return</span> astgen.failTok(member.ast.main_token, <span class="tok-str">&quot;union field missing name&quot;</span>, .{});</span>
<span class="line" id="L5277">        }</span>
<span class="line" id="L5278">        <span class="tok-kw">if</span> (member.comptime_token) |comptime_token| {</span>
<span class="line" id="L5279">            <span class="tok-kw">return</span> astgen.failTok(comptime_token, <span class="tok-str">&quot;union fields cannot be marked comptime&quot;</span>, .{});</span>
<span class="line" id="L5280">        }</span>
<span class="line" id="L5281"></span>
<span class="line" id="L5282">        <span class="tok-kw">const</span> field_name = <span class="tok-kw">try</span> astgen.identAsString(member.ast.main_token);</span>
<span class="line" id="L5283">        wip_members.appendToField(<span class="tok-builtin">@intFromEnum</span>(field_name));</span>
<span class="line" id="L5284"></span>
<span class="line" id="L5285">        <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> duplicate_names.getOrPut(field_name);</span>
<span class="line" id="L5286"></span>
<span class="line" id="L5287">        <span class="tok-kw">if</span> (gop.found_existing) {</span>
<span class="line" id="L5288">            <span class="tok-kw">try</span> gop.value_ptr.append(sfba_allocator, member.ast.main_token);</span>
<span class="line" id="L5289">            any_duplicate = <span class="tok-null">true</span>;</span>
<span class="line" id="L5290">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L5291">            gop.value_ptr.* = .{};</span>
<span class="line" id="L5292">            <span class="tok-kw">try</span> gop.value_ptr.append(sfba_allocator, member.ast.main_token);</span>
<span class="line" id="L5293">        }</span>
<span class="line" id="L5294"></span>
<span class="line" id="L5295">        <span class="tok-kw">const</span> doc_comment_index = <span class="tok-kw">try</span> astgen.docCommentAsString(member.firstToken());</span>
<span class="line" id="L5296">        wip_members.appendToField(<span class="tok-builtin">@intFromEnum</span>(doc_comment_index));</span>
<span class="line" id="L5297"></span>
<span class="line" id="L5298">        <span class="tok-kw">const</span> have_type = member.ast.type_expr != <span class="tok-number">0</span>;</span>
<span class="line" id="L5299">        <span class="tok-kw">const</span> have_align = member.ast.align_expr != <span class="tok-number">0</span>;</span>
<span class="line" id="L5300">        <span class="tok-kw">const</span> have_value = member.ast.value_expr != <span class="tok-number">0</span>;</span>
<span class="line" id="L5301">        <span class="tok-kw">const</span> unused = <span class="tok-null">false</span>;</span>
<span class="line" id="L5302">        wip_members.nextField(bits_per_field, .{ have_type, have_align, have_value, unused });</span>
<span class="line" id="L5303"></span>
<span class="line" id="L5304">        <span class="tok-kw">if</span> (have_type) {</span>
<span class="line" id="L5305">            <span class="tok-kw">const</span> field_type = <span class="tok-kw">try</span> typeExpr(&amp;block_scope, &amp;namespace.base, member.ast.type_expr);</span>
<span class="line" id="L5306">            wip_members.appendToField(<span class="tok-builtin">@intFromEnum</span>(field_type));</span>
<span class="line" id="L5307">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (arg_inst == .none <span class="tok-kw">and</span> auto_enum_tok == <span class="tok-null">null</span>) {</span>
<span class="line" id="L5308">            <span class="tok-kw">return</span> astgen.failNode(member_node, <span class="tok-str">&quot;union field missing type&quot;</span>, .{});</span>
<span class="line" id="L5309">        }</span>
<span class="line" id="L5310">        <span class="tok-kw">if</span> (have_align) {</span>
<span class="line" id="L5311">            <span class="tok-kw">const</span> align_inst = <span class="tok-kw">try</span> expr(&amp;block_scope, &amp;block_scope.base, coerced_align_ri, member.ast.align_expr);</span>
<span class="line" id="L5312">            wip_members.appendToField(<span class="tok-builtin">@intFromEnum</span>(align_inst));</span>
<span class="line" id="L5313">            any_aligned_fields = <span class="tok-null">true</span>;</span>
<span class="line" id="L5314">        }</span>
<span class="line" id="L5315">        <span class="tok-kw">if</span> (have_value) {</span>
<span class="line" id="L5316">            <span class="tok-kw">if</span> (arg_inst == .none) {</span>
<span class="line" id="L5317">                <span class="tok-kw">return</span> astgen.failNodeNotes(</span>
<span class="line" id="L5318">                    node,</span>
<span class="line" id="L5319">                    <span class="tok-str">&quot;explicitly valued tagged union missing integer tag type&quot;</span>,</span>
<span class="line" id="L5320">                    .{},</span>
<span class="line" id="L5321">                    &amp;[_]<span class="tok-type">u32</span>{</span>
<span class="line" id="L5322">                        <span class="tok-kw">try</span> astgen.errNoteNode(</span>
<span class="line" id="L5323">                            member.ast.value_expr,</span>
<span class="line" id="L5324">                            <span class="tok-str">&quot;tag value specified here&quot;</span>,</span>
<span class="line" id="L5325">                            .{},</span>
<span class="line" id="L5326">                        ),</span>
<span class="line" id="L5327">                    },</span>
<span class="line" id="L5328">                );</span>
<span class="line" id="L5329">            }</span>
<span class="line" id="L5330">            <span class="tok-kw">if</span> (auto_enum_tok == <span class="tok-null">null</span>) {</span>
<span class="line" id="L5331">                <span class="tok-kw">return</span> astgen.failNodeNotes(</span>
<span class="line" id="L5332">                    node,</span>
<span class="line" id="L5333">                    <span class="tok-str">&quot;explicitly valued tagged union requires inferred enum tag type&quot;</span>,</span>
<span class="line" id="L5334">                    .{},</span>
<span class="line" id="L5335">                    &amp;[_]<span class="tok-type">u32</span>{</span>
<span class="line" id="L5336">                        <span class="tok-kw">try</span> astgen.errNoteNode(</span>
<span class="line" id="L5337">                            member.ast.value_expr,</span>
<span class="line" id="L5338">                            <span class="tok-str">&quot;tag value specified here&quot;</span>,</span>
<span class="line" id="L5339">                            .{},</span>
<span class="line" id="L5340">                        ),</span>
<span class="line" id="L5341">                    },</span>
<span class="line" id="L5342">                );</span>
<span class="line" id="L5343">            }</span>
<span class="line" id="L5344">            <span class="tok-kw">const</span> tag_value = <span class="tok-kw">try</span> expr(&amp;block_scope, &amp;block_scope.base, .{ .rl = .{ .ty = arg_inst } }, member.ast.value_expr);</span>
<span class="line" id="L5345">            wip_members.appendToField(<span class="tok-builtin">@intFromEnum</span>(tag_value));</span>
<span class="line" id="L5346">        }</span>
<span class="line" id="L5347">    }</span>
<span class="line" id="L5348"></span>
<span class="line" id="L5349">    <span class="tok-kw">if</span> (any_duplicate) {</span>
<span class="line" id="L5350">        <span class="tok-kw">var</span> it = duplicate_names.iterator();</span>
<span class="line" id="L5351"></span>
<span class="line" id="L5352">        <span class="tok-kw">while</span> (it.next()) |entry| {</span>
<span class="line" id="L5353">            <span class="tok-kw">const</span> record = entry.value_ptr.*;</span>
<span class="line" id="L5354">            <span class="tok-kw">if</span> (record.items.len &gt; <span class="tok-number">1</span>) {</span>
<span class="line" id="L5355">                <span class="tok-kw">var</span> error_notes = std.ArrayList(<span class="tok-type">u32</span>).init(astgen.arena);</span>
<span class="line" id="L5356"></span>
<span class="line" id="L5357">                <span class="tok-kw">for</span> (record.items[<span class="tok-number">1</span>..]) |duplicate| {</span>
<span class="line" id="L5358">                    <span class="tok-kw">try</span> error_notes.append(<span class="tok-kw">try</span> astgen.errNoteTok(duplicate, <span class="tok-str">&quot;duplicate field here&quot;</span>, .{}));</span>
<span class="line" id="L5359">                }</span>
<span class="line" id="L5360"></span>
<span class="line" id="L5361">                <span class="tok-kw">try</span> error_notes.append(<span class="tok-kw">try</span> astgen.errNoteNode(node, <span class="tok-str">&quot;union declared here&quot;</span>, .{}));</span>
<span class="line" id="L5362"></span>
<span class="line" id="L5363">                <span class="tok-kw">try</span> astgen.appendErrorTokNotes(</span>
<span class="line" id="L5364">                    record.items[<span class="tok-number">0</span>],</span>
<span class="line" id="L5365">                    <span class="tok-str">&quot;duplicate union field name&quot;</span>,</span>
<span class="line" id="L5366">                    .{},</span>
<span class="line" id="L5367">                    error_notes.items,</span>
<span class="line" id="L5368">                );</span>
<span class="line" id="L5369">            }</span>
<span class="line" id="L5370">        }</span>
<span class="line" id="L5371"></span>
<span class="line" id="L5372">        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AnalysisFail;</span>
<span class="line" id="L5373">    }</span>
<span class="line" id="L5374"></span>
<span class="line" id="L5375">    <span class="tok-kw">var</span> fields_hash: std.zig.SrcHash = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L5376">    fields_hasher.final(&amp;fields_hash);</span>
<span class="line" id="L5377"></span>
<span class="line" id="L5378">    <span class="tok-kw">if</span> (!block_scope.isEmpty()) {</span>
<span class="line" id="L5379">        _ = <span class="tok-kw">try</span> block_scope.addBreak(.break_inline, decl_inst, .void_value);</span>
<span class="line" id="L5380">    }</span>
<span class="line" id="L5381"></span>
<span class="line" id="L5382">    <span class="tok-kw">const</span> body = block_scope.instructionsSlice();</span>
<span class="line" id="L5383">    <span class="tok-kw">const</span> body_len = astgen.countBodyLenAfterFixups(body);</span>
<span class="line" id="L5384"></span>
<span class="line" id="L5385">    <span class="tok-kw">try</span> gz.setUnion(decl_inst, .{</span>
<span class="line" id="L5386">        .src_node = node,</span>
<span class="line" id="L5387">        .layout = layout,</span>
<span class="line" id="L5388">        .tag_type = arg_inst,</span>
<span class="line" id="L5389">        .captures_len = <span class="tok-builtin">@intCast</span>(namespace.captures.count()),</span>
<span class="line" id="L5390">        .body_len = body_len,</span>
<span class="line" id="L5391">        .fields_len = field_count,</span>
<span class="line" id="L5392">        .decls_len = decl_count,</span>
<span class="line" id="L5393">        .auto_enum_tag = auto_enum_tok != <span class="tok-null">null</span>,</span>
<span class="line" id="L5394">        .any_aligned_fields = any_aligned_fields,</span>
<span class="line" id="L5395">        .fields_hash = fields_hash,</span>
<span class="line" id="L5396">    });</span>
<span class="line" id="L5397"></span>
<span class="line" id="L5398">    wip_members.finishBits(bits_per_field);</span>
<span class="line" id="L5399">    <span class="tok-kw">const</span> decls_slice = wip_members.declsSlice();</span>
<span class="line" id="L5400">    <span class="tok-kw">const</span> fields_slice = wip_members.fieldsSlice();</span>
<span class="line" id="L5401">    <span class="tok-kw">try</span> astgen.extra.ensureUnusedCapacity(gpa, namespace.captures.count() + decls_slice.len + body_len + fields_slice.len);</span>
<span class="line" id="L5402">    astgen.extra.appendSliceAssumeCapacity(<span class="tok-builtin">@ptrCast</span>(namespace.captures.keys()));</span>
<span class="line" id="L5403">    astgen.extra.appendSliceAssumeCapacity(decls_slice);</span>
<span class="line" id="L5404">    astgen.appendBodyWithFixups(body);</span>
<span class="line" id="L5405">    astgen.extra.appendSliceAssumeCapacity(fields_slice);</span>
<span class="line" id="L5406"></span>
<span class="line" id="L5407">    block_scope.unstack();</span>
<span class="line" id="L5408">    <span class="tok-kw">return</span> decl_inst.toRef();</span>
<span class="line" id="L5409">}</span>
<span class="line" id="L5410"></span>
<span class="line" id="L5411"><span class="tok-kw">fn</span> <span class="tok-fn">containerDecl</span>(</span>
<span class="line" id="L5412">    gz: *GenZir,</span>
<span class="line" id="L5413">    scope: *Scope,</span>
<span class="line" id="L5414">    ri: ResultInfo,</span>
<span class="line" id="L5415">    node: Ast.Node.Index,</span>
<span class="line" id="L5416">    container_decl: Ast.full.ContainerDecl,</span>
<span class="line" id="L5417">) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L5418">    <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L5419">    <span class="tok-kw">const</span> gpa = astgen.gpa;</span>
<span class="line" id="L5420">    <span class="tok-kw">const</span> tree = astgen.tree;</span>
<span class="line" id="L5421">    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);</span>
<span class="line" id="L5422"></span>
<span class="line" id="L5423">    <span class="tok-kw">const</span> prev_fn_block = astgen.fn_block;</span>
<span class="line" id="L5424">    astgen.fn_block = <span class="tok-null">null</span>;</span>
<span class="line" id="L5425">    <span class="tok-kw">defer</span> astgen.fn_block = prev_fn_block;</span>
<span class="line" id="L5426"></span>
<span class="line" id="L5427">    <span class="tok-comment">// We must not create any types until Sema. Here the goal is only to generate</span>
</span>
<span class="line" id="L5428">    <span class="tok-comment">// ZIR for all the field types, alignments, and default value expressions.</span>
</span>
<span class="line" id="L5429"></span>
<span class="line" id="L5430">    <span class="tok-kw">switch</span> (token_tags[container_decl.ast.main_token]) {</span>
<span class="line" id="L5431">        .keyword_struct =&gt; {</span>
<span class="line" id="L5432">            <span class="tok-kw">const</span> layout = <span class="tok-kw">if</span> (container_decl.layout_token) |t| <span class="tok-kw">switch</span> (token_tags[t]) {</span>
<span class="line" id="L5433">                .keyword_packed =&gt; std.builtin.Type.ContainerLayout.Packed,</span>
<span class="line" id="L5434">                .keyword_extern =&gt; std.builtin.Type.ContainerLayout.Extern,</span>
<span class="line" id="L5435">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L5436">            } <span class="tok-kw">else</span> std.builtin.Type.ContainerLayout.Auto;</span>
<span class="line" id="L5437"></span>
<span class="line" id="L5438">            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> structDeclInner(gz, scope, node, container_decl, layout, container_decl.ast.arg);</span>
<span class="line" id="L5439">            <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L5440">        },</span>
<span class="line" id="L5441">        .keyword_union =&gt; {</span>
<span class="line" id="L5442">            <span class="tok-kw">const</span> layout = <span class="tok-kw">if</span> (container_decl.layout_token) |t| <span class="tok-kw">switch</span> (token_tags[t]) {</span>
<span class="line" id="L5443">                .keyword_packed =&gt; std.builtin.Type.ContainerLayout.Packed,</span>
<span class="line" id="L5444">                .keyword_extern =&gt; std.builtin.Type.ContainerLayout.Extern,</span>
<span class="line" id="L5445">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L5446">            } <span class="tok-kw">else</span> std.builtin.Type.ContainerLayout.Auto;</span>
<span class="line" id="L5447"></span>
<span class="line" id="L5448">            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> unionDeclInner(gz, scope, node, container_decl.ast.members, layout, container_decl.ast.arg, container_decl.ast.enum_token);</span>
<span class="line" id="L5449">            <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L5450">        },</span>
<span class="line" id="L5451">        .keyword_enum =&gt; {</span>
<span class="line" id="L5452">            <span class="tok-kw">if</span> (container_decl.layout_token) |t| {</span>
<span class="line" id="L5453">                <span class="tok-kw">return</span> astgen.failTok(t, <span class="tok-str">&quot;enums do not support 'packed' or 'extern'; instead provide an explicit integer tag type&quot;</span>, .{});</span>
<span class="line" id="L5454">            }</span>
<span class="line" id="L5455">            <span class="tok-comment">// Count total fields as well as how many have explicitly provided tag values.</span>
</span>
<span class="line" id="L5456">            <span class="tok-kw">const</span> counts = blk: {</span>
<span class="line" id="L5457">                <span class="tok-kw">var</span> values: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L5458">                <span class="tok-kw">var</span> total_fields: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L5459">                <span class="tok-kw">var</span> decls: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L5460">                <span class="tok-kw">var</span> nonexhaustive_node: Ast.Node.Index = <span class="tok-number">0</span>;</span>
<span class="line" id="L5461">                <span class="tok-kw">var</span> nonfinal_nonexhaustive = <span class="tok-null">false</span>;</span>
<span class="line" id="L5462">                <span class="tok-kw">for</span> (container_decl.ast.members) |member_node| {</span>
<span class="line" id="L5463">                    <span class="tok-kw">var</span> member = tree.fullContainerField(member_node) <span class="tok-kw">orelse</span> {</span>
<span class="line" id="L5464">                        decls += <span class="tok-number">1</span>;</span>
<span class="line" id="L5465">                        <span class="tok-kw">continue</span>;</span>
<span class="line" id="L5466">                    };</span>
<span class="line" id="L5467">                    member.convertToNonTupleLike(astgen.tree.nodes);</span>
<span class="line" id="L5468">                    <span class="tok-kw">if</span> (member.ast.tuple_like) {</span>
<span class="line" id="L5469">                        <span class="tok-kw">return</span> astgen.failTok(member.ast.main_token, <span class="tok-str">&quot;enum field missing name&quot;</span>, .{});</span>
<span class="line" id="L5470">                    }</span>
<span class="line" id="L5471">                    <span class="tok-kw">if</span> (member.comptime_token) |comptime_token| {</span>
<span class="line" id="L5472">                        <span class="tok-kw">return</span> astgen.failTok(comptime_token, <span class="tok-str">&quot;enum fields cannot be marked comptime&quot;</span>, .{});</span>
<span class="line" id="L5473">                    }</span>
<span class="line" id="L5474">                    <span class="tok-kw">if</span> (member.ast.type_expr != <span class="tok-number">0</span>) {</span>
<span class="line" id="L5475">                        <span class="tok-kw">return</span> astgen.failNodeNotes(</span>
<span class="line" id="L5476">                            member.ast.type_expr,</span>
<span class="line" id="L5477">                            <span class="tok-str">&quot;enum fields do not have types&quot;</span>,</span>
<span class="line" id="L5478">                            .{},</span>
<span class="line" id="L5479">                            &amp;[_]<span class="tok-type">u32</span>{</span>
<span class="line" id="L5480">                                <span class="tok-kw">try</span> astgen.errNoteNode(</span>
<span class="line" id="L5481">                                    node,</span>
<span class="line" id="L5482">                                    <span class="tok-str">&quot;consider 'union(enum)' here to make it a tagged union&quot;</span>,</span>
<span class="line" id="L5483">                                    .{},</span>
<span class="line" id="L5484">                                ),</span>
<span class="line" id="L5485">                            },</span>
<span class="line" id="L5486">                        );</span>
<span class="line" id="L5487">                    }</span>
<span class="line" id="L5488">                    <span class="tok-kw">if</span> (member.ast.align_expr != <span class="tok-number">0</span>) {</span>
<span class="line" id="L5489">                        <span class="tok-kw">return</span> astgen.failNode(member.ast.align_expr, <span class="tok-str">&quot;enum fields cannot be aligned&quot;</span>, .{});</span>
<span class="line" id="L5490">                    }</span>
<span class="line" id="L5491"></span>
<span class="line" id="L5492">                    <span class="tok-kw">const</span> name_token = member.ast.main_token;</span>
<span class="line" id="L5493">                    <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, tree.tokenSlice(name_token), <span class="tok-str">&quot;_&quot;</span>)) {</span>
<span class="line" id="L5494">                        <span class="tok-kw">if</span> (nonexhaustive_node != <span class="tok-number">0</span>) {</span>
<span class="line" id="L5495">                            <span class="tok-kw">return</span> astgen.failNodeNotes(</span>
<span class="line" id="L5496">                                member_node,</span>
<span class="line" id="L5497">                                <span class="tok-str">&quot;redundant non-exhaustive enum mark&quot;</span>,</span>
<span class="line" id="L5498">                                .{},</span>
<span class="line" id="L5499">                                &amp;[_]<span class="tok-type">u32</span>{</span>
<span class="line" id="L5500">                                    <span class="tok-kw">try</span> astgen.errNoteNode(</span>
<span class="line" id="L5501">                                        nonexhaustive_node,</span>
<span class="line" id="L5502">                                        <span class="tok-str">&quot;other mark here&quot;</span>,</span>
<span class="line" id="L5503">                                        .{},</span>
<span class="line" id="L5504">                                    ),</span>
<span class="line" id="L5505">                                },</span>
<span class="line" id="L5506">                            );</span>
<span class="line" id="L5507">                        }</span>
<span class="line" id="L5508">                        nonexhaustive_node = member_node;</span>
<span class="line" id="L5509">                        <span class="tok-kw">if</span> (member.ast.value_expr != <span class="tok-number">0</span>) {</span>
<span class="line" id="L5510">                            <span class="tok-kw">return</span> astgen.failNode(member.ast.value_expr, <span class="tok-str">&quot;'_' is used to mark an enum as non-exhaustive and cannot be assigned a value&quot;</span>, .{});</span>
<span class="line" id="L5511">                        }</span>
<span class="line" id="L5512">                        <span class="tok-kw">continue</span>;</span>
<span class="line" id="L5513">                    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (nonexhaustive_node != <span class="tok-number">0</span>) {</span>
<span class="line" id="L5514">                        nonfinal_nonexhaustive = <span class="tok-null">true</span>;</span>
<span class="line" id="L5515">                    }</span>
<span class="line" id="L5516">                    total_fields += <span class="tok-number">1</span>;</span>
<span class="line" id="L5517">                    <span class="tok-kw">if</span> (member.ast.value_expr != <span class="tok-number">0</span>) {</span>
<span class="line" id="L5518">                        <span class="tok-kw">if</span> (container_decl.ast.arg == <span class="tok-number">0</span>) {</span>
<span class="line" id="L5519">                            <span class="tok-kw">return</span> astgen.failNode(member.ast.value_expr, <span class="tok-str">&quot;value assigned to enum tag with inferred tag type&quot;</span>, .{});</span>
<span class="line" id="L5520">                        }</span>
<span class="line" id="L5521">                        values += <span class="tok-number">1</span>;</span>
<span class="line" id="L5522">                    }</span>
<span class="line" id="L5523">                }</span>
<span class="line" id="L5524">                <span class="tok-kw">if</span> (nonfinal_nonexhaustive) {</span>
<span class="line" id="L5525">                    <span class="tok-kw">return</span> astgen.failNode(nonexhaustive_node, <span class="tok-str">&quot;'_' field of non-exhaustive enum must be last&quot;</span>, .{});</span>
<span class="line" id="L5526">                }</span>
<span class="line" id="L5527">                <span class="tok-kw">break</span> :blk .{</span>
<span class="line" id="L5528">                    .total_fields = total_fields,</span>
<span class="line" id="L5529">                    .values = values,</span>
<span class="line" id="L5530">                    .decls = decls,</span>
<span class="line" id="L5531">                    .nonexhaustive_node = nonexhaustive_node,</span>
<span class="line" id="L5532">                };</span>
<span class="line" id="L5533">            };</span>
<span class="line" id="L5534">            <span class="tok-kw">if</span> (counts.nonexhaustive_node != <span class="tok-number">0</span> <span class="tok-kw">and</span> container_decl.ast.arg == <span class="tok-number">0</span>) {</span>
<span class="line" id="L5535">                <span class="tok-kw">try</span> astgen.appendErrorNodeNotes(</span>
<span class="line" id="L5536">                    node,</span>
<span class="line" id="L5537">                    <span class="tok-str">&quot;non-exhaustive enum missing integer tag type&quot;</span>,</span>
<span class="line" id="L5538">                    .{},</span>
<span class="line" id="L5539">                    &amp;[_]<span class="tok-type">u32</span>{</span>
<span class="line" id="L5540">                        <span class="tok-kw">try</span> astgen.errNoteNode(</span>
<span class="line" id="L5541">                            counts.nonexhaustive_node,</span>
<span class="line" id="L5542">                            <span class="tok-str">&quot;marked non-exhaustive here&quot;</span>,</span>
<span class="line" id="L5543">                            .{},</span>
<span class="line" id="L5544">                        ),</span>
<span class="line" id="L5545">                    },</span>
<span class="line" id="L5546">                );</span>
<span class="line" id="L5547">            }</span>
<span class="line" id="L5548">            <span class="tok-comment">// In this case we must generate ZIR code for the tag values, similar to</span>
</span>
<span class="line" id="L5549">            <span class="tok-comment">// how structs are handled above.</span>
</span>
<span class="line" id="L5550">            <span class="tok-kw">const</span> nonexhaustive = counts.nonexhaustive_node != <span class="tok-number">0</span>;</span>
<span class="line" id="L5551"></span>
<span class="line" id="L5552">            <span class="tok-kw">const</span> decl_inst = <span class="tok-kw">try</span> gz.reserveInstructionIndex();</span>
<span class="line" id="L5553"></span>
<span class="line" id="L5554">            <span class="tok-kw">var</span> namespace: Scope.Namespace = .{</span>
<span class="line" id="L5555">                .parent = scope,</span>
<span class="line" id="L5556">                .node = node,</span>
<span class="line" id="L5557">                .inst = decl_inst,</span>
<span class="line" id="L5558">                .declaring_gz = gz,</span>
<span class="line" id="L5559">                .maybe_generic = astgen.within_fn,</span>
<span class="line" id="L5560">            };</span>
<span class="line" id="L5561">            <span class="tok-kw">defer</span> namespace.deinit(gpa);</span>
<span class="line" id="L5562"></span>
<span class="line" id="L5563">            <span class="tok-comment">// The enum_decl instruction introduces a scope in which the decls of the enum</span>
</span>
<span class="line" id="L5564">            <span class="tok-comment">// are in scope, so that tag values can refer to decls within the enum itself.</span>
</span>
<span class="line" id="L5565">            astgen.advanceSourceCursorToNode(node);</span>
<span class="line" id="L5566">            <span class="tok-kw">var</span> block_scope: GenZir = .{</span>
<span class="line" id="L5567">                .parent = &amp;namespace.base,</span>
<span class="line" id="L5568">                .decl_node_index = node,</span>
<span class="line" id="L5569">                .decl_line = gz.decl_line,</span>
<span class="line" id="L5570">                .astgen = astgen,</span>
<span class="line" id="L5571">                .is_comptime = <span class="tok-null">true</span>,</span>
<span class="line" id="L5572">                .instructions = gz.instructions,</span>
<span class="line" id="L5573">                .instructions_top = gz.instructions.items.len,</span>
<span class="line" id="L5574">            };</span>
<span class="line" id="L5575">            <span class="tok-kw">defer</span> block_scope.unstack();</span>
<span class="line" id="L5576"></span>
<span class="line" id="L5577">            _ = <span class="tok-kw">try</span> astgen.scanDecls(&amp;namespace, container_decl.ast.members);</span>
<span class="line" id="L5578">            namespace.base.tag = .namespace;</span>
<span class="line" id="L5579"></span>
<span class="line" id="L5580">            <span class="tok-kw">const</span> arg_inst: Zir.Inst.Ref = <span class="tok-kw">if</span> (container_decl.ast.arg != <span class="tok-number">0</span>)</span>
<span class="line" id="L5581">                <span class="tok-kw">try</span> comptimeExpr(&amp;block_scope, &amp;namespace.base, coerced_type_ri, container_decl.ast.arg)</span>
<span class="line" id="L5582">            <span class="tok-kw">else</span></span>
<span class="line" id="L5583">                .none;</span>
<span class="line" id="L5584"></span>
<span class="line" id="L5585">            <span class="tok-kw">const</span> bits_per_field = <span class="tok-number">1</span>;</span>
<span class="line" id="L5586">            <span class="tok-kw">const</span> max_field_size = <span class="tok-number">3</span>;</span>
<span class="line" id="L5587">            <span class="tok-kw">var</span> wip_members = <span class="tok-kw">try</span> WipMembers.init(gpa, &amp;astgen.scratch, <span class="tok-builtin">@intCast</span>(counts.decls), <span class="tok-builtin">@intCast</span>(counts.total_fields), bits_per_field, max_field_size);</span>
<span class="line" id="L5588">            <span class="tok-kw">defer</span> wip_members.deinit();</span>
<span class="line" id="L5589"></span>
<span class="line" id="L5590">            <span class="tok-kw">var</span> fields_hasher = std.zig.SrcHasher.init(.{});</span>
<span class="line" id="L5591">            <span class="tok-kw">if</span> (container_decl.ast.arg != <span class="tok-number">0</span>) {</span>
<span class="line" id="L5592">                fields_hasher.update(tree.getNodeSource(container_decl.ast.arg));</span>
<span class="line" id="L5593">            }</span>
<span class="line" id="L5594">            fields_hasher.update(&amp;.{<span class="tok-builtin">@intFromBool</span>(nonexhaustive)});</span>
<span class="line" id="L5595"></span>
<span class="line" id="L5596">            <span class="tok-kw">var</span> sfba = std.heap.stackFallback(<span class="tok-number">256</span>, astgen.arena);</span>
<span class="line" id="L5597">            <span class="tok-kw">const</span> sfba_allocator = sfba.get();</span>
<span class="line" id="L5598"></span>
<span class="line" id="L5599">            <span class="tok-kw">var</span> duplicate_names = std.AutoArrayHashMap(Zir.NullTerminatedString, std.ArrayListUnmanaged(Ast.TokenIndex)).init(sfba_allocator);</span>
<span class="line" id="L5600">            <span class="tok-kw">try</span> duplicate_names.ensureTotalCapacity(counts.total_fields);</span>
<span class="line" id="L5601"></span>
<span class="line" id="L5602">            <span class="tok-comment">// When there aren't errors, use this to avoid a second iteration.</span>
</span>
<span class="line" id="L5603">            <span class="tok-kw">var</span> any_duplicate = <span class="tok-null">false</span>;</span>
<span class="line" id="L5604"></span>
<span class="line" id="L5605">            <span class="tok-kw">for</span> (container_decl.ast.members) |member_node| {</span>
<span class="line" id="L5606">                <span class="tok-kw">if</span> (member_node == counts.nonexhaustive_node)</span>
<span class="line" id="L5607">                    <span class="tok-kw">continue</span>;</span>
<span class="line" id="L5608">                fields_hasher.update(tree.getNodeSource(member_node));</span>
<span class="line" id="L5609">                <span class="tok-kw">var</span> member = <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> containerMember(&amp;block_scope, &amp;namespace.base, &amp;wip_members, member_node)) {</span>
<span class="line" id="L5610">                    .decl =&gt; <span class="tok-kw">continue</span>,</span>
<span class="line" id="L5611">                    .field =&gt; |field| field,</span>
<span class="line" id="L5612">                };</span>
<span class="line" id="L5613">                member.convertToNonTupleLike(astgen.tree.nodes);</span>
<span class="line" id="L5614">                assert(member.comptime_token == <span class="tok-null">null</span>);</span>
<span class="line" id="L5615">                assert(member.ast.type_expr == <span class="tok-number">0</span>);</span>
<span class="line" id="L5616">                assert(member.ast.align_expr == <span class="tok-number">0</span>);</span>
<span class="line" id="L5617"></span>
<span class="line" id="L5618">                <span class="tok-kw">const</span> field_name = <span class="tok-kw">try</span> astgen.identAsString(member.ast.main_token);</span>
<span class="line" id="L5619">                wip_members.appendToField(<span class="tok-builtin">@intFromEnum</span>(field_name));</span>
<span class="line" id="L5620"></span>
<span class="line" id="L5621">                <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> duplicate_names.getOrPut(field_name);</span>
<span class="line" id="L5622"></span>
<span class="line" id="L5623">                <span class="tok-kw">if</span> (gop.found_existing) {</span>
<span class="line" id="L5624">                    <span class="tok-kw">try</span> gop.value_ptr.append(sfba_allocator, member.ast.main_token);</span>
<span class="line" id="L5625">                    any_duplicate = <span class="tok-null">true</span>;</span>
<span class="line" id="L5626">                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L5627">                    gop.value_ptr.* = .{};</span>
<span class="line" id="L5628">                    <span class="tok-kw">try</span> gop.value_ptr.append(sfba_allocator, member.ast.main_token);</span>
<span class="line" id="L5629">                }</span>
<span class="line" id="L5630"></span>
<span class="line" id="L5631">                <span class="tok-kw">const</span> doc_comment_index = <span class="tok-kw">try</span> astgen.docCommentAsString(member.firstToken());</span>
<span class="line" id="L5632">                wip_members.appendToField(<span class="tok-builtin">@intFromEnum</span>(doc_comment_index));</span>
<span class="line" id="L5633"></span>
<span class="line" id="L5634">                <span class="tok-kw">const</span> have_value = member.ast.value_expr != <span class="tok-number">0</span>;</span>
<span class="line" id="L5635">                wip_members.nextField(bits_per_field, .{have_value});</span>
<span class="line" id="L5636"></span>
<span class="line" id="L5637">                <span class="tok-kw">if</span> (have_value) {</span>
<span class="line" id="L5638">                    <span class="tok-kw">if</span> (arg_inst == .none) {</span>
<span class="line" id="L5639">                        <span class="tok-kw">return</span> astgen.failNodeNotes(</span>
<span class="line" id="L5640">                            node,</span>
<span class="line" id="L5641">                            <span class="tok-str">&quot;explicitly valued enum missing integer tag type&quot;</span>,</span>
<span class="line" id="L5642">                            .{},</span>
<span class="line" id="L5643">                            &amp;[_]<span class="tok-type">u32</span>{</span>
<span class="line" id="L5644">                                <span class="tok-kw">try</span> astgen.errNoteNode(</span>
<span class="line" id="L5645">                                    member.ast.value_expr,</span>
<span class="line" id="L5646">                                    <span class="tok-str">&quot;tag value specified here&quot;</span>,</span>
<span class="line" id="L5647">                                    .{},</span>
<span class="line" id="L5648">                                ),</span>
<span class="line" id="L5649">                            },</span>
<span class="line" id="L5650">                        );</span>
<span class="line" id="L5651">                    }</span>
<span class="line" id="L5652">                    <span class="tok-kw">const</span> tag_value_inst = <span class="tok-kw">try</span> expr(&amp;block_scope, &amp;namespace.base, .{ .rl = .{ .ty = arg_inst } }, member.ast.value_expr);</span>
<span class="line" id="L5653">                    wip_members.appendToField(<span class="tok-builtin">@intFromEnum</span>(tag_value_inst));</span>
<span class="line" id="L5654">                }</span>
<span class="line" id="L5655">            }</span>
<span class="line" id="L5656"></span>
<span class="line" id="L5657">            <span class="tok-kw">if</span> (any_duplicate) {</span>
<span class="line" id="L5658">                <span class="tok-kw">var</span> it = duplicate_names.iterator();</span>
<span class="line" id="L5659"></span>
<span class="line" id="L5660">                <span class="tok-kw">while</span> (it.next()) |entry| {</span>
<span class="line" id="L5661">                    <span class="tok-kw">const</span> record = entry.value_ptr.*;</span>
<span class="line" id="L5662">                    <span class="tok-kw">if</span> (record.items.len &gt; <span class="tok-number">1</span>) {</span>
<span class="line" id="L5663">                        <span class="tok-kw">var</span> error_notes = std.ArrayList(<span class="tok-type">u32</span>).init(astgen.arena);</span>
<span class="line" id="L5664"></span>
<span class="line" id="L5665">                        <span class="tok-kw">for</span> (record.items[<span class="tok-number">1</span>..]) |duplicate| {</span>
<span class="line" id="L5666">                            <span class="tok-kw">try</span> error_notes.append(<span class="tok-kw">try</span> astgen.errNoteTok(duplicate, <span class="tok-str">&quot;duplicate field here&quot;</span>, .{}));</span>
<span class="line" id="L5667">                        }</span>
<span class="line" id="L5668"></span>
<span class="line" id="L5669">                        <span class="tok-kw">try</span> error_notes.append(<span class="tok-kw">try</span> astgen.errNoteNode(node, <span class="tok-str">&quot;enum declared here&quot;</span>, .{}));</span>
<span class="line" id="L5670"></span>
<span class="line" id="L5671">                        <span class="tok-kw">try</span> astgen.appendErrorTokNotes(</span>
<span class="line" id="L5672">                            record.items[<span class="tok-number">0</span>],</span>
<span class="line" id="L5673">                            <span class="tok-str">&quot;duplicate enum field name&quot;</span>,</span>
<span class="line" id="L5674">                            .{},</span>
<span class="line" id="L5675">                            error_notes.items,</span>
<span class="line" id="L5676">                        );</span>
<span class="line" id="L5677">                    }</span>
<span class="line" id="L5678">                }</span>
<span class="line" id="L5679"></span>
<span class="line" id="L5680">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AnalysisFail;</span>
<span class="line" id="L5681">            }</span>
<span class="line" id="L5682"></span>
<span class="line" id="L5683">            <span class="tok-kw">if</span> (!block_scope.isEmpty()) {</span>
<span class="line" id="L5684">                _ = <span class="tok-kw">try</span> block_scope.addBreak(.break_inline, decl_inst, .void_value);</span>
<span class="line" id="L5685">            }</span>
<span class="line" id="L5686"></span>
<span class="line" id="L5687">            <span class="tok-kw">var</span> fields_hash: std.zig.SrcHash = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L5688">            fields_hasher.final(&amp;fields_hash);</span>
<span class="line" id="L5689"></span>
<span class="line" id="L5690">            <span class="tok-kw">const</span> body = block_scope.instructionsSlice();</span>
<span class="line" id="L5691">            <span class="tok-kw">const</span> body_len = astgen.countBodyLenAfterFixups(body);</span>
<span class="line" id="L5692"></span>
<span class="line" id="L5693">            <span class="tok-kw">try</span> gz.setEnum(decl_inst, .{</span>
<span class="line" id="L5694">                .src_node = node,</span>
<span class="line" id="L5695">                .nonexhaustive = nonexhaustive,</span>
<span class="line" id="L5696">                .tag_type = arg_inst,</span>
<span class="line" id="L5697">                .captures_len = <span class="tok-builtin">@intCast</span>(namespace.captures.count()),</span>
<span class="line" id="L5698">                .body_len = body_len,</span>
<span class="line" id="L5699">                .fields_len = <span class="tok-builtin">@intCast</span>(counts.total_fields),</span>
<span class="line" id="L5700">                .decls_len = <span class="tok-builtin">@intCast</span>(counts.decls),</span>
<span class="line" id="L5701">                .fields_hash = fields_hash,</span>
<span class="line" id="L5702">            });</span>
<span class="line" id="L5703"></span>
<span class="line" id="L5704">            wip_members.finishBits(bits_per_field);</span>
<span class="line" id="L5705">            <span class="tok-kw">const</span> decls_slice = wip_members.declsSlice();</span>
<span class="line" id="L5706">            <span class="tok-kw">const</span> fields_slice = wip_members.fieldsSlice();</span>
<span class="line" id="L5707">            <span class="tok-kw">try</span> astgen.extra.ensureUnusedCapacity(gpa, namespace.captures.count() + decls_slice.len + body_len + fields_slice.len);</span>
<span class="line" id="L5708">            astgen.extra.appendSliceAssumeCapacity(<span class="tok-builtin">@ptrCast</span>(namespace.captures.keys()));</span>
<span class="line" id="L5709">            astgen.extra.appendSliceAssumeCapacity(decls_slice);</span>
<span class="line" id="L5710">            astgen.appendBodyWithFixups(body);</span>
<span class="line" id="L5711">            astgen.extra.appendSliceAssumeCapacity(fields_slice);</span>
<span class="line" id="L5712"></span>
<span class="line" id="L5713">            block_scope.unstack();</span>
<span class="line" id="L5714">            <span class="tok-kw">return</span> rvalue(gz, ri, decl_inst.toRef(), node);</span>
<span class="line" id="L5715">        },</span>
<span class="line" id="L5716">        .keyword_opaque =&gt; {</span>
<span class="line" id="L5717">            assert(container_decl.ast.arg == <span class="tok-number">0</span>);</span>
<span class="line" id="L5718"></span>
<span class="line" id="L5719">            <span class="tok-kw">const</span> decl_inst = <span class="tok-kw">try</span> gz.reserveInstructionIndex();</span>
<span class="line" id="L5720"></span>
<span class="line" id="L5721">            <span class="tok-kw">var</span> namespace: Scope.Namespace = .{</span>
<span class="line" id="L5722">                .parent = scope,</span>
<span class="line" id="L5723">                .node = node,</span>
<span class="line" id="L5724">                .inst = decl_inst,</span>
<span class="line" id="L5725">                .declaring_gz = gz,</span>
<span class="line" id="L5726">                .maybe_generic = astgen.within_fn,</span>
<span class="line" id="L5727">            };</span>
<span class="line" id="L5728">            <span class="tok-kw">defer</span> namespace.deinit(gpa);</span>
<span class="line" id="L5729"></span>
<span class="line" id="L5730">            astgen.advanceSourceCursorToNode(node);</span>
<span class="line" id="L5731">            <span class="tok-kw">var</span> block_scope: GenZir = .{</span>
<span class="line" id="L5732">                .parent = &amp;namespace.base,</span>
<span class="line" id="L5733">                .decl_node_index = node,</span>
<span class="line" id="L5734">                .decl_line = gz.decl_line,</span>
<span class="line" id="L5735">                .astgen = astgen,</span>
<span class="line" id="L5736">                .is_comptime = <span class="tok-null">true</span>,</span>
<span class="line" id="L5737">                .instructions = gz.instructions,</span>
<span class="line" id="L5738">                .instructions_top = gz.instructions.items.len,</span>
<span class="line" id="L5739">            };</span>
<span class="line" id="L5740">            <span class="tok-kw">defer</span> block_scope.unstack();</span>
<span class="line" id="L5741"></span>
<span class="line" id="L5742">            <span class="tok-kw">const</span> decl_count = <span class="tok-kw">try</span> astgen.scanDecls(&amp;namespace, container_decl.ast.members);</span>
<span class="line" id="L5743"></span>
<span class="line" id="L5744">            <span class="tok-kw">var</span> wip_members = <span class="tok-kw">try</span> WipMembers.init(gpa, &amp;astgen.scratch, decl_count, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L5745">            <span class="tok-kw">defer</span> wip_members.deinit();</span>
<span class="line" id="L5746"></span>
<span class="line" id="L5747">            <span class="tok-kw">for</span> (container_decl.ast.members) |member_node| {</span>
<span class="line" id="L5748">                <span class="tok-kw">const</span> res = <span class="tok-kw">try</span> containerMember(&amp;block_scope, &amp;namespace.base, &amp;wip_members, member_node);</span>
<span class="line" id="L5749">                <span class="tok-kw">if</span> (res == .field) {</span>
<span class="line" id="L5750">                    <span class="tok-kw">return</span> astgen.failNode(member_node, <span class="tok-str">&quot;opaque types cannot have fields&quot;</span>, .{});</span>
<span class="line" id="L5751">                }</span>
<span class="line" id="L5752">            }</span>
<span class="line" id="L5753"></span>
<span class="line" id="L5754">            <span class="tok-kw">try</span> gz.setOpaque(decl_inst, .{</span>
<span class="line" id="L5755">                .src_node = node,</span>
<span class="line" id="L5756">                .captures_len = <span class="tok-builtin">@intCast</span>(namespace.captures.count()),</span>
<span class="line" id="L5757">                .decls_len = decl_count,</span>
<span class="line" id="L5758">            });</span>
<span class="line" id="L5759"></span>
<span class="line" id="L5760">            wip_members.finishBits(<span class="tok-number">0</span>);</span>
<span class="line" id="L5761">            <span class="tok-kw">const</span> decls_slice = wip_members.declsSlice();</span>
<span class="line" id="L5762">            <span class="tok-kw">try</span> astgen.extra.ensureUnusedCapacity(gpa, namespace.captures.count() + decls_slice.len);</span>
<span class="line" id="L5763">            astgen.extra.appendSliceAssumeCapacity(<span class="tok-builtin">@ptrCast</span>(namespace.captures.keys()));</span>
<span class="line" id="L5764">            astgen.extra.appendSliceAssumeCapacity(decls_slice);</span>
<span class="line" id="L5765"></span>
<span class="line" id="L5766">            block_scope.unstack();</span>
<span class="line" id="L5767">            <span class="tok-kw">return</span> rvalue(gz, ri, decl_inst.toRef(), node);</span>
<span class="line" id="L5768">        },</span>
<span class="line" id="L5769">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L5770">    }</span>
<span class="line" id="L5771">}</span>
<span class="line" id="L5772"></span>
<span class="line" id="L5773"><span class="tok-kw">const</span> ContainerMemberResult = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) { decl, field: Ast.full.ContainerField };</span>
<span class="line" id="L5774"></span>
<span class="line" id="L5775"><span class="tok-kw">fn</span> <span class="tok-fn">containerMember</span>(</span>
<span class="line" id="L5776">    gz: *GenZir,</span>
<span class="line" id="L5777">    scope: *Scope,</span>
<span class="line" id="L5778">    wip_members: *WipMembers,</span>
<span class="line" id="L5779">    member_node: Ast.Node.Index,</span>
<span class="line" id="L5780">) InnerError!ContainerMemberResult {</span>
<span class="line" id="L5781">    <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L5782">    <span class="tok-kw">const</span> tree = astgen.tree;</span>
<span class="line" id="L5783">    <span class="tok-kw">const</span> node_tags = tree.nodes.items(.tag);</span>
<span class="line" id="L5784">    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);</span>
<span class="line" id="L5785">    <span class="tok-kw">switch</span> (node_tags[member_node]) {</span>
<span class="line" id="L5786">        .container_field_init,</span>
<span class="line" id="L5787">        .container_field_align,</span>
<span class="line" id="L5788">        .container_field,</span>
<span class="line" id="L5789">        =&gt; <span class="tok-kw">return</span> ContainerMemberResult{ .field = tree.fullContainerField(member_node).? },</span>
<span class="line" id="L5790"></span>
<span class="line" id="L5791">        .fn_proto,</span>
<span class="line" id="L5792">        .fn_proto_multi,</span>
<span class="line" id="L5793">        .fn_proto_one,</span>
<span class="line" id="L5794">        .fn_proto_simple,</span>
<span class="line" id="L5795">        .fn_decl,</span>
<span class="line" id="L5796">        =&gt; {</span>
<span class="line" id="L5797">            <span class="tok-kw">var</span> buf: [<span class="tok-number">1</span>]Ast.Node.Index = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L5798">            <span class="tok-kw">const</span> full = tree.fullFnProto(&amp;buf, member_node).?;</span>
<span class="line" id="L5799">            <span class="tok-kw">const</span> body = <span class="tok-kw">if</span> (node_tags[member_node] == .fn_decl) node_datas[member_node].rhs <span class="tok-kw">else</span> <span class="tok-number">0</span>;</span>
<span class="line" id="L5800"></span>
<span class="line" id="L5801">            astgen.fnDecl(gz, scope, wip_members, member_node, body, full) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L5802">                <span class="tok-kw">error</span>.OutOfMemory =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory,</span>
<span class="line" id="L5803">                <span class="tok-kw">error</span>.AnalysisFail =&gt; {},</span>
<span class="line" id="L5804">            };</span>
<span class="line" id="L5805">        },</span>
<span class="line" id="L5806"></span>
<span class="line" id="L5807">        .global_var_decl,</span>
<span class="line" id="L5808">        .local_var_decl,</span>
<span class="line" id="L5809">        .simple_var_decl,</span>
<span class="line" id="L5810">        .aligned_var_decl,</span>
<span class="line" id="L5811">        =&gt; {</span>
<span class="line" id="L5812">            astgen.globalVarDecl(gz, scope, wip_members, member_node, tree.fullVarDecl(member_node).?) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L5813">                <span class="tok-kw">error</span>.OutOfMemory =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory,</span>
<span class="line" id="L5814">                <span class="tok-kw">error</span>.AnalysisFail =&gt; {},</span>
<span class="line" id="L5815">            };</span>
<span class="line" id="L5816">        },</span>
<span class="line" id="L5817"></span>
<span class="line" id="L5818">        .@&quot;comptime&quot; =&gt; {</span>
<span class="line" id="L5819">            astgen.comptimeDecl(gz, scope, wip_members, member_node) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L5820">                <span class="tok-kw">error</span>.OutOfMemory =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory,</span>
<span class="line" id="L5821">                <span class="tok-kw">error</span>.AnalysisFail =&gt; {},</span>
<span class="line" id="L5822">            };</span>
<span class="line" id="L5823">        },</span>
<span class="line" id="L5824">        .@&quot;usingnamespace&quot; =&gt; {</span>
<span class="line" id="L5825">            astgen.usingnamespaceDecl(gz, scope, wip_members, member_node) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L5826">                <span class="tok-kw">error</span>.OutOfMemory =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory,</span>
<span class="line" id="L5827">                <span class="tok-kw">error</span>.AnalysisFail =&gt; {},</span>
<span class="line" id="L5828">            };</span>
<span class="line" id="L5829">        },</span>
<span class="line" id="L5830">        .test_decl =&gt; {</span>
<span class="line" id="L5831">            astgen.testDecl(gz, scope, wip_members, member_node) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L5832">                <span class="tok-kw">error</span>.OutOfMemory =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory,</span>
<span class="line" id="L5833">                <span class="tok-kw">error</span>.AnalysisFail =&gt; {},</span>
<span class="line" id="L5834">            };</span>
<span class="line" id="L5835">        },</span>
<span class="line" id="L5836">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L5837">    }</span>
<span class="line" id="L5838">    <span class="tok-kw">return</span> .decl;</span>
<span class="line" id="L5839">}</span>
<span class="line" id="L5840"></span>
<span class="line" id="L5841"><span class="tok-kw">fn</span> <span class="tok-fn">errorSetDecl</span>(gz: *GenZir, ri: ResultInfo, node: Ast.Node.Index) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L5842">    <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L5843">    <span class="tok-kw">const</span> gpa = astgen.gpa;</span>
<span class="line" id="L5844">    <span class="tok-kw">const</span> tree = astgen.tree;</span>
<span class="line" id="L5845">    <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);</span>
<span class="line" id="L5846">    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);</span>
<span class="line" id="L5847"></span>
<span class="line" id="L5848">    <span class="tok-kw">const</span> payload_index = <span class="tok-kw">try</span> reserveExtra(astgen, <span class="tok-builtin">@typeInfo</span>(Zir.Inst.ErrorSetDecl).Struct.fields.len);</span>
<span class="line" id="L5849">    <span class="tok-kw">var</span> fields_len: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L5850">    {</span>
<span class="line" id="L5851">        <span class="tok-kw">var</span> idents: std.AutoHashMapUnmanaged(Zir.NullTerminatedString, Ast.TokenIndex) = .{};</span>
<span class="line" id="L5852">        <span class="tok-kw">defer</span> idents.deinit(gpa);</span>
<span class="line" id="L5853"></span>
<span class="line" id="L5854">        <span class="tok-kw">const</span> error_token = main_tokens[node];</span>
<span class="line" id="L5855">        <span class="tok-kw">var</span> tok_i = error_token + <span class="tok-number">2</span>;</span>
<span class="line" id="L5856">        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) : (tok_i += <span class="tok-number">1</span>) {</span>
<span class="line" id="L5857">            <span class="tok-kw">switch</span> (token_tags[tok_i]) {</span>
<span class="line" id="L5858">                .doc_comment, .comma =&gt; {},</span>
<span class="line" id="L5859">                .identifier =&gt; {</span>
<span class="line" id="L5860">                    <span class="tok-kw">const</span> str_index = <span class="tok-kw">try</span> astgen.identAsString(tok_i);</span>
<span class="line" id="L5861">                    <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> idents.getOrPut(gpa, str_index);</span>
<span class="line" id="L5862">                    <span class="tok-kw">if</span> (gop.found_existing) {</span>
<span class="line" id="L5863">                        <span class="tok-kw">const</span> name = <span class="tok-kw">try</span> gpa.dupe(<span class="tok-type">u8</span>, mem.span(astgen.nullTerminatedString(str_index)));</span>
<span class="line" id="L5864">                        <span class="tok-kw">defer</span> gpa.free(name);</span>
<span class="line" id="L5865">                        <span class="tok-kw">return</span> astgen.failTokNotes(</span>
<span class="line" id="L5866">                            tok_i,</span>
<span class="line" id="L5867">                            <span class="tok-str">&quot;duplicate error set field '{s}'&quot;</span>,</span>
<span class="line" id="L5868">                            .{name},</span>
<span class="line" id="L5869">                            &amp;[_]<span class="tok-type">u32</span>{</span>
<span class="line" id="L5870">                                <span class="tok-kw">try</span> astgen.errNoteTok(</span>
<span class="line" id="L5871">                                    gop.value_ptr.*,</span>
<span class="line" id="L5872">                                    <span class="tok-str">&quot;previous declaration here&quot;</span>,</span>
<span class="line" id="L5873">                                    .{},</span>
<span class="line" id="L5874">                                ),</span>
<span class="line" id="L5875">                            },</span>
<span class="line" id="L5876">                        );</span>
<span class="line" id="L5877">                    }</span>
<span class="line" id="L5878">                    gop.value_ptr.* = tok_i;</span>
<span class="line" id="L5879"></span>
<span class="line" id="L5880">                    <span class="tok-kw">try</span> astgen.extra.ensureUnusedCapacity(gpa, <span class="tok-number">2</span>);</span>
<span class="line" id="L5881">                    astgen.extra.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(str_index));</span>
<span class="line" id="L5882">                    <span class="tok-kw">const</span> doc_comment_index = <span class="tok-kw">try</span> astgen.docCommentAsString(tok_i);</span>
<span class="line" id="L5883">                    astgen.extra.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(doc_comment_index));</span>
<span class="line" id="L5884">                    fields_len += <span class="tok-number">1</span>;</span>
<span class="line" id="L5885">                },</span>
<span class="line" id="L5886">                .r_brace =&gt; <span class="tok-kw">break</span>,</span>
<span class="line" id="L5887">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L5888">            }</span>
<span class="line" id="L5889">        }</span>
<span class="line" id="L5890">    }</span>
<span class="line" id="L5891"></span>
<span class="line" id="L5892">    setExtra(astgen, payload_index, Zir.Inst.ErrorSetDecl{</span>
<span class="line" id="L5893">        .fields_len = <span class="tok-builtin">@intCast</span>(fields_len),</span>
<span class="line" id="L5894">    });</span>
<span class="line" id="L5895">    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addPlNodePayloadIndex(.error_set_decl, node, payload_index);</span>
<span class="line" id="L5896">    <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L5897">}</span>
<span class="line" id="L5898"></span>
<span class="line" id="L5899"><span class="tok-kw">fn</span> <span class="tok-fn">tryExpr</span>(</span>
<span class="line" id="L5900">    parent_gz: *GenZir,</span>
<span class="line" id="L5901">    scope: *Scope,</span>
<span class="line" id="L5902">    ri: ResultInfo,</span>
<span class="line" id="L5903">    node: Ast.Node.Index,</span>
<span class="line" id="L5904">    operand_node: Ast.Node.Index,</span>
<span class="line" id="L5905">) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L5906">    <span class="tok-kw">const</span> astgen = parent_gz.astgen;</span>
<span class="line" id="L5907"></span>
<span class="line" id="L5908">    <span class="tok-kw">const</span> fn_block = astgen.fn_block <span class="tok-kw">orelse</span> {</span>
<span class="line" id="L5909">        <span class="tok-kw">return</span> astgen.failNode(node, <span class="tok-str">&quot;'try' outside function scope&quot;</span>, .{});</span>
<span class="line" id="L5910">    };</span>
<span class="line" id="L5911"></span>
<span class="line" id="L5912">    <span class="tok-kw">if</span> (parent_gz.any_defer_node != <span class="tok-number">0</span>) {</span>
<span class="line" id="L5913">        <span class="tok-kw">return</span> astgen.failNodeNotes(node, <span class="tok-str">&quot;'try' not allowed inside defer expression&quot;</span>, .{}, &amp;.{</span>
<span class="line" id="L5914">            <span class="tok-kw">try</span> astgen.errNoteNode(</span>
<span class="line" id="L5915">                parent_gz.any_defer_node,</span>
<span class="line" id="L5916">                <span class="tok-str">&quot;defer expression here&quot;</span>,</span>
<span class="line" id="L5917">                .{},</span>
<span class="line" id="L5918">            ),</span>
<span class="line" id="L5919">        });</span>
<span class="line" id="L5920">    }</span>
<span class="line" id="L5921"></span>
<span class="line" id="L5922">    <span class="tok-comment">// Ensure debug line/column information is emitted for this try expression.</span>
</span>
<span class="line" id="L5923">    <span class="tok-comment">// Then we will save the line/column so that we can emit another one that goes</span>
</span>
<span class="line" id="L5924">    <span class="tok-comment">// &quot;backwards&quot; because we want to evaluate the operand, but then put the debug</span>
</span>
<span class="line" id="L5925">    <span class="tok-comment">// info back at the try keyword for error return tracing.</span>
</span>
<span class="line" id="L5926">    <span class="tok-kw">if</span> (!parent_gz.is_comptime) {</span>
<span class="line" id="L5927">        <span class="tok-kw">try</span> emitDbgNode(parent_gz, node);</span>
<span class="line" id="L5928">    }</span>
<span class="line" id="L5929">    <span class="tok-kw">const</span> try_lc = LineColumn{ astgen.source_line - parent_gz.decl_line, astgen.source_column };</span>
<span class="line" id="L5930"></span>
<span class="line" id="L5931">    <span class="tok-kw">const</span> operand_ri: ResultInfo = <span class="tok-kw">switch</span> (ri.rl) {</span>
<span class="line" id="L5932">        .ref, .ref_coerced_ty =&gt; .{ .rl = .ref, .ctx = .error_handling_expr },</span>
<span class="line" id="L5933">        <span class="tok-kw">else</span> =&gt; .{ .rl = .none, .ctx = .error_handling_expr },</span>
<span class="line" id="L5934">    };</span>
<span class="line" id="L5935">    <span class="tok-comment">// This could be a pointer or value depending on the `ri` parameter.</span>
</span>
<span class="line" id="L5936">    <span class="tok-kw">const</span> operand = <span class="tok-kw">try</span> reachableExpr(parent_gz, scope, operand_ri, operand_node, node);</span>
<span class="line" id="L5937">    <span class="tok-kw">const</span> block_tag: Zir.Inst.Tag = <span class="tok-kw">if</span> (operand_ri.rl == .ref) .try_ptr <span class="tok-kw">else</span> .@&quot;try&quot;;</span>
<span class="line" id="L5938">    <span class="tok-kw">const</span> try_inst = <span class="tok-kw">try</span> parent_gz.makeBlockInst(block_tag, node);</span>
<span class="line" id="L5939">    <span class="tok-kw">try</span> parent_gz.instructions.append(astgen.gpa, try_inst);</span>
<span class="line" id="L5940"></span>
<span class="line" id="L5941">    <span class="tok-kw">var</span> else_scope = parent_gz.makeSubBlock(scope);</span>
<span class="line" id="L5942">    <span class="tok-kw">defer</span> else_scope.unstack();</span>
<span class="line" id="L5943"></span>
<span class="line" id="L5944">    <span class="tok-kw">const</span> err_tag = <span class="tok-kw">switch</span> (ri.rl) {</span>
<span class="line" id="L5945">        .ref, .ref_coerced_ty =&gt; Zir.Inst.Tag.err_union_code_ptr,</span>
<span class="line" id="L5946">        <span class="tok-kw">else</span> =&gt; Zir.Inst.Tag.err_union_code,</span>
<span class="line" id="L5947">    };</span>
<span class="line" id="L5948">    <span class="tok-kw">const</span> err_code = <span class="tok-kw">try</span> else_scope.addUnNode(err_tag, operand, node);</span>
<span class="line" id="L5949">    <span class="tok-kw">try</span> genDefers(&amp;else_scope, &amp;fn_block.base, scope, .{ .both = err_code });</span>
<span class="line" id="L5950">    <span class="tok-kw">try</span> emitDbgStmt(&amp;else_scope, try_lc);</span>
<span class="line" id="L5951">    _ = <span class="tok-kw">try</span> else_scope.addUnNode(.ret_node, err_code, node);</span>
<span class="line" id="L5952"></span>
<span class="line" id="L5953">    <span class="tok-kw">try</span> else_scope.setTryBody(try_inst, operand);</span>
<span class="line" id="L5954">    <span class="tok-kw">const</span> result = try_inst.toRef();</span>
<span class="line" id="L5955">    <span class="tok-kw">switch</span> (ri.rl) {</span>
<span class="line" id="L5956">        .ref, .ref_coerced_ty =&gt; <span class="tok-kw">return</span> result,</span>
<span class="line" id="L5957">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> rvalue(parent_gz, ri, result, node),</span>
<span class="line" id="L5958">    }</span>
<span class="line" id="L5959">}</span>
<span class="line" id="L5960"></span>
<span class="line" id="L5961"><span class="tok-kw">fn</span> <span class="tok-fn">orelseCatchExpr</span>(</span>
<span class="line" id="L5962">    parent_gz: *GenZir,</span>
<span class="line" id="L5963">    scope: *Scope,</span>
<span class="line" id="L5964">    ri: ResultInfo,</span>
<span class="line" id="L5965">    node: Ast.Node.Index,</span>
<span class="line" id="L5966">    lhs: Ast.Node.Index,</span>
<span class="line" id="L5967">    cond_op: Zir.Inst.Tag,</span>
<span class="line" id="L5968">    unwrap_op: Zir.Inst.Tag,</span>
<span class="line" id="L5969">    unwrap_code_op: Zir.Inst.Tag,</span>
<span class="line" id="L5970">    rhs: Ast.Node.Index,</span>
<span class="line" id="L5971">    payload_token: ?Ast.TokenIndex,</span>
<span class="line" id="L5972">) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L5973">    <span class="tok-kw">const</span> astgen = parent_gz.astgen;</span>
<span class="line" id="L5974">    <span class="tok-kw">const</span> tree = astgen.tree;</span>
<span class="line" id="L5975"></span>
<span class="line" id="L5976">    <span class="tok-kw">const</span> need_rl = astgen.nodes_need_rl.contains(node);</span>
<span class="line" id="L5977">    <span class="tok-kw">const</span> block_ri: ResultInfo = <span class="tok-kw">if</span> (need_rl) ri <span class="tok-kw">else</span> .{</span>
<span class="line" id="L5978">        .rl = <span class="tok-kw">switch</span> (ri.rl) {</span>
<span class="line" id="L5979">            .ptr =&gt; .{ .ty = (<span class="tok-kw">try</span> ri.rl.resultType(parent_gz, node)).? },</span>
<span class="line" id="L5980">            .inferred_ptr =&gt; .none,</span>
<span class="line" id="L5981">            <span class="tok-kw">else</span> =&gt; ri.rl,</span>
<span class="line" id="L5982">        },</span>
<span class="line" id="L5983">        .ctx = ri.ctx,</span>
<span class="line" id="L5984">    };</span>
<span class="line" id="L5985">    <span class="tok-comment">// We need to call `rvalue` to write through to the pointer only if we had a</span>
</span>
<span class="line" id="L5986">    <span class="tok-comment">// result pointer and aren't forwarding it.</span>
</span>
<span class="line" id="L5987">    <span class="tok-kw">const</span> LocTag = <span class="tok-builtin">@typeInfo</span>(ResultInfo.Loc).Union.tag_type.?;</span>
<span class="line" id="L5988">    <span class="tok-kw">const</span> need_result_rvalue = <span class="tok-builtin">@as</span>(LocTag, block_ri.rl) != <span class="tok-builtin">@as</span>(LocTag, ri.rl);</span>
<span class="line" id="L5989"></span>
<span class="line" id="L5990">    <span class="tok-kw">const</span> do_err_trace = astgen.fn_block != <span class="tok-null">null</span> <span class="tok-kw">and</span> (cond_op == .is_non_err <span class="tok-kw">or</span> cond_op == .is_non_err_ptr);</span>
<span class="line" id="L5991"></span>
<span class="line" id="L5992">    <span class="tok-kw">var</span> block_scope = parent_gz.makeSubBlock(scope);</span>
<span class="line" id="L5993">    block_scope.setBreakResultInfo(block_ri);</span>
<span class="line" id="L5994">    <span class="tok-kw">defer</span> block_scope.unstack();</span>
<span class="line" id="L5995"></span>
<span class="line" id="L5996">    <span class="tok-kw">const</span> operand_ri: ResultInfo = <span class="tok-kw">switch</span> (block_scope.break_result_info.rl) {</span>
<span class="line" id="L5997">        .ref, .ref_coerced_ty =&gt; .{ .rl = .ref, .ctx = <span class="tok-kw">if</span> (do_err_trace) .error_handling_expr <span class="tok-kw">else</span> .none },</span>
<span class="line" id="L5998">        <span class="tok-kw">else</span> =&gt; .{ .rl = .none, .ctx = <span class="tok-kw">if</span> (do_err_trace) .error_handling_expr <span class="tok-kw">else</span> .none },</span>
<span class="line" id="L5999">    };</span>
<span class="line" id="L6000">    <span class="tok-comment">// This could be a pointer or value depending on the `operand_ri` parameter.</span>
</span>
<span class="line" id="L6001">    <span class="tok-comment">// We cannot use `block_scope.break_result_info` because that has the bare</span>
</span>
<span class="line" id="L6002">    <span class="tok-comment">// type, whereas this expression has the optional type. Later we make</span>
</span>
<span class="line" id="L6003">    <span class="tok-comment">// up for this fact by calling rvalue on the else branch.</span>
</span>
<span class="line" id="L6004">    <span class="tok-kw">const</span> operand = <span class="tok-kw">try</span> reachableExpr(&amp;block_scope, &amp;block_scope.base, operand_ri, lhs, rhs);</span>
<span class="line" id="L6005">    <span class="tok-kw">const</span> cond = <span class="tok-kw">try</span> block_scope.addUnNode(cond_op, operand, node);</span>
<span class="line" id="L6006">    <span class="tok-kw">const</span> condbr = <span class="tok-kw">try</span> block_scope.addCondBr(.condbr, node);</span>
<span class="line" id="L6007"></span>
<span class="line" id="L6008">    <span class="tok-kw">const</span> block = <span class="tok-kw">try</span> parent_gz.makeBlockInst(.block, node);</span>
<span class="line" id="L6009">    <span class="tok-kw">try</span> block_scope.setBlockBody(block);</span>
<span class="line" id="L6010">    <span class="tok-comment">// block_scope unstacked now, can add new instructions to parent_gz</span>
</span>
<span class="line" id="L6011">    <span class="tok-kw">try</span> parent_gz.instructions.append(astgen.gpa, block);</span>
<span class="line" id="L6012"></span>
<span class="line" id="L6013">    <span class="tok-kw">var</span> then_scope = block_scope.makeSubBlock(scope);</span>
<span class="line" id="L6014">    <span class="tok-kw">defer</span> then_scope.unstack();</span>
<span class="line" id="L6015"></span>
<span class="line" id="L6016">    <span class="tok-comment">// This could be a pointer or value depending on `unwrap_op`.</span>
</span>
<span class="line" id="L6017">    <span class="tok-kw">const</span> unwrapped_payload = <span class="tok-kw">try</span> then_scope.addUnNode(unwrap_op, operand, node);</span>
<span class="line" id="L6018">    <span class="tok-kw">const</span> then_result = <span class="tok-kw">switch</span> (ri.rl) {</span>
<span class="line" id="L6019">        .ref, .ref_coerced_ty =&gt; unwrapped_payload,</span>
<span class="line" id="L6020">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">try</span> rvalue(&amp;then_scope, block_scope.break_result_info, unwrapped_payload, node),</span>
<span class="line" id="L6021">    };</span>
<span class="line" id="L6022">    _ = <span class="tok-kw">try</span> then_scope.addBreakWithSrcNode(.@&quot;break&quot;, block, then_result, node);</span>
<span class="line" id="L6023"></span>
<span class="line" id="L6024">    <span class="tok-kw">var</span> else_scope = block_scope.makeSubBlock(scope);</span>
<span class="line" id="L6025">    <span class="tok-kw">defer</span> else_scope.unstack();</span>
<span class="line" id="L6026"></span>
<span class="line" id="L6027">    <span class="tok-comment">// We know that the operand (almost certainly) modified the error return trace,</span>
</span>
<span class="line" id="L6028">    <span class="tok-comment">// so signal to Sema that it should save the new index for restoring later.</span>
</span>
<span class="line" id="L6029">    <span class="tok-kw">if</span> (do_err_trace <span class="tok-kw">and</span> nodeMayAppendToErrorTrace(tree, lhs))</span>
<span class="line" id="L6030">        _ = <span class="tok-kw">try</span> else_scope.addSaveErrRetIndex(.always);</span>
<span class="line" id="L6031"></span>
<span class="line" id="L6032">    <span class="tok-kw">var</span> err_val_scope: Scope.LocalVal = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L6033">    <span class="tok-kw">const</span> else_sub_scope = blk: {</span>
<span class="line" id="L6034">        <span class="tok-kw">const</span> payload = payload_token <span class="tok-kw">orelse</span> <span class="tok-kw">break</span> :blk &amp;else_scope.base;</span>
<span class="line" id="L6035">        <span class="tok-kw">const</span> err_str = tree.tokenSlice(payload);</span>
<span class="line" id="L6036">        <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, err_str, <span class="tok-str">&quot;_&quot;</span>)) {</span>
<span class="line" id="L6037">            <span class="tok-kw">return</span> astgen.failTok(payload, <span class="tok-str">&quot;discard of error capture; omit it instead&quot;</span>, .{});</span>
<span class="line" id="L6038">        }</span>
<span class="line" id="L6039">        <span class="tok-kw">const</span> err_name = <span class="tok-kw">try</span> astgen.identAsString(payload);</span>
<span class="line" id="L6040"></span>
<span class="line" id="L6041">        <span class="tok-kw">try</span> astgen.detectLocalShadowing(scope, err_name, payload, err_str, .capture);</span>
<span class="line" id="L6042"></span>
<span class="line" id="L6043">        err_val_scope = .{</span>
<span class="line" id="L6044">            .parent = &amp;else_scope.base,</span>
<span class="line" id="L6045">            .gen_zir = &amp;else_scope,</span>
<span class="line" id="L6046">            .name = err_name,</span>
<span class="line" id="L6047">            .inst = <span class="tok-kw">try</span> else_scope.addUnNode(unwrap_code_op, operand, node),</span>
<span class="line" id="L6048">            .token_src = payload,</span>
<span class="line" id="L6049">            .id_cat = .capture,</span>
<span class="line" id="L6050">        };</span>
<span class="line" id="L6051">        <span class="tok-kw">break</span> :blk &amp;err_val_scope.base;</span>
<span class="line" id="L6052">    };</span>
<span class="line" id="L6053"></span>
<span class="line" id="L6054">    <span class="tok-kw">const</span> else_result = <span class="tok-kw">try</span> fullBodyExpr(&amp;else_scope, else_sub_scope, block_scope.break_result_info, rhs);</span>
<span class="line" id="L6055">    <span class="tok-kw">if</span> (!else_scope.endsWithNoReturn()) {</span>
<span class="line" id="L6056">        <span class="tok-comment">// As our last action before the break, &quot;pop&quot; the error trace if needed</span>
</span>
<span class="line" id="L6057">        <span class="tok-kw">if</span> (do_err_trace)</span>
<span class="line" id="L6058">            <span class="tok-kw">try</span> restoreErrRetIndex(&amp;else_scope, .{ .block = block }, block_scope.break_result_info, rhs, else_result);</span>
<span class="line" id="L6059"></span>
<span class="line" id="L6060">        _ = <span class="tok-kw">try</span> else_scope.addBreakWithSrcNode(.@&quot;break&quot;, block, else_result, rhs);</span>
<span class="line" id="L6061">    }</span>
<span class="line" id="L6062">    <span class="tok-kw">try</span> checkUsed(parent_gz, &amp;else_scope.base, else_sub_scope);</span>
<span class="line" id="L6063"></span>
<span class="line" id="L6064">    <span class="tok-kw">try</span> setCondBrPayload(condbr, cond, &amp;then_scope, &amp;else_scope);</span>
<span class="line" id="L6065"></span>
<span class="line" id="L6066">    <span class="tok-kw">if</span> (need_result_rvalue) {</span>
<span class="line" id="L6067">        <span class="tok-kw">return</span> rvalue(parent_gz, ri, block.toRef(), node);</span>
<span class="line" id="L6068">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L6069">        <span class="tok-kw">return</span> block.toRef();</span>
<span class="line" id="L6070">    }</span>
<span class="line" id="L6071">}</span>
<span class="line" id="L6072"></span>
<span class="line" id="L6073"><span class="tok-comment">/// Return whether the identifier names of two tokens are equal. Resolves @&quot;&quot;</span></span>
<span class="line" id="L6074"><span class="tok-comment">/// tokens without allocating.</span></span>
<span class="line" id="L6075"><span class="tok-comment">/// OK in theory it could do it without allocating. This implementation</span></span>
<span class="line" id="L6076"><span class="tok-comment">/// allocates when the @&quot;&quot; form is used.</span></span>
<span class="line" id="L6077"><span class="tok-kw">fn</span> <span class="tok-fn">tokenIdentEql</span>(astgen: *AstGen, token1: Ast.TokenIndex, token2: Ast.TokenIndex) !<span class="tok-type">bool</span> {</span>
<span class="line" id="L6078">    <span class="tok-kw">const</span> ident_name_1 = <span class="tok-kw">try</span> astgen.identifierTokenString(token1);</span>
<span class="line" id="L6079">    <span class="tok-kw">const</span> ident_name_2 = <span class="tok-kw">try</span> astgen.identifierTokenString(token2);</span>
<span class="line" id="L6080">    <span class="tok-kw">return</span> mem.eql(<span class="tok-type">u8</span>, ident_name_1, ident_name_2);</span>
<span class="line" id="L6081">}</span>
<span class="line" id="L6082"></span>
<span class="line" id="L6083"><span class="tok-kw">fn</span> <span class="tok-fn">fieldAccess</span>(</span>
<span class="line" id="L6084">    gz: *GenZir,</span>
<span class="line" id="L6085">    scope: *Scope,</span>
<span class="line" id="L6086">    ri: ResultInfo,</span>
<span class="line" id="L6087">    node: Ast.Node.Index,</span>
<span class="line" id="L6088">) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L6089">    <span class="tok-kw">switch</span> (ri.rl) {</span>
<span class="line" id="L6090">        .ref, .ref_coerced_ty =&gt; <span class="tok-kw">return</span> addFieldAccess(.field_ptr, gz, scope, .{ .rl = .ref }, node),</span>
<span class="line" id="L6091">        <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L6092">            <span class="tok-kw">const</span> access = <span class="tok-kw">try</span> addFieldAccess(.field_val, gz, scope, .{ .rl = .none }, node);</span>
<span class="line" id="L6093">            <span class="tok-kw">return</span> rvalue(gz, ri, access, node);</span>
<span class="line" id="L6094">        },</span>
<span class="line" id="L6095">    }</span>
<span class="line" id="L6096">}</span>
<span class="line" id="L6097"></span>
<span class="line" id="L6098"><span class="tok-kw">fn</span> <span class="tok-fn">addFieldAccess</span>(</span>
<span class="line" id="L6099">    tag: Zir.Inst.Tag,</span>
<span class="line" id="L6100">    gz: *GenZir,</span>
<span class="line" id="L6101">    scope: *Scope,</span>
<span class="line" id="L6102">    lhs_ri: ResultInfo,</span>
<span class="line" id="L6103">    node: Ast.Node.Index,</span>
<span class="line" id="L6104">) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L6105">    <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L6106">    <span class="tok-kw">const</span> tree = astgen.tree;</span>
<span class="line" id="L6107">    <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);</span>
<span class="line" id="L6108">    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);</span>
<span class="line" id="L6109"></span>
<span class="line" id="L6110">    <span class="tok-kw">const</span> object_node = node_datas[node].lhs;</span>
<span class="line" id="L6111">    <span class="tok-kw">const</span> dot_token = main_tokens[node];</span>
<span class="line" id="L6112">    <span class="tok-kw">const</span> field_ident = dot_token + <span class="tok-number">1</span>;</span>
<span class="line" id="L6113">    <span class="tok-kw">const</span> str_index = <span class="tok-kw">try</span> astgen.identAsString(field_ident);</span>
<span class="line" id="L6114">    <span class="tok-kw">const</span> lhs = <span class="tok-kw">try</span> expr(gz, scope, lhs_ri, object_node);</span>
<span class="line" id="L6115"></span>
<span class="line" id="L6116">    <span class="tok-kw">const</span> cursor = maybeAdvanceSourceCursorToMainToken(gz, node);</span>
<span class="line" id="L6117">    <span class="tok-kw">try</span> emitDbgStmt(gz, cursor);</span>
<span class="line" id="L6118"></span>
<span class="line" id="L6119">    <span class="tok-kw">return</span> gz.addPlNode(tag, node, Zir.Inst.Field{</span>
<span class="line" id="L6120">        .lhs = lhs,</span>
<span class="line" id="L6121">        .field_name_start = str_index,</span>
<span class="line" id="L6122">    });</span>
<span class="line" id="L6123">}</span>
<span class="line" id="L6124"></span>
<span class="line" id="L6125"><span class="tok-kw">fn</span> <span class="tok-fn">arrayAccess</span>(</span>
<span class="line" id="L6126">    gz: *GenZir,</span>
<span class="line" id="L6127">    scope: *Scope,</span>
<span class="line" id="L6128">    ri: ResultInfo,</span>
<span class="line" id="L6129">    node: Ast.Node.Index,</span>
<span class="line" id="L6130">) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L6131">    <span class="tok-kw">const</span> tree = gz.astgen.tree;</span>
<span class="line" id="L6132">    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);</span>
<span class="line" id="L6133">    <span class="tok-kw">switch</span> (ri.rl) {</span>
<span class="line" id="L6134">        .ref, .ref_coerced_ty =&gt; {</span>
<span class="line" id="L6135">            <span class="tok-kw">const</span> lhs = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .ref }, node_datas[node].lhs);</span>
<span class="line" id="L6136"></span>
<span class="line" id="L6137">            <span class="tok-kw">const</span> cursor = maybeAdvanceSourceCursorToMainToken(gz, node);</span>
<span class="line" id="L6138"></span>
<span class="line" id="L6139">            <span class="tok-kw">const</span> rhs = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .{ .coerced_ty = .usize_type } }, node_datas[node].rhs);</span>
<span class="line" id="L6140">            <span class="tok-kw">try</span> emitDbgStmt(gz, cursor);</span>
<span class="line" id="L6141"></span>
<span class="line" id="L6142">            <span class="tok-kw">return</span> gz.addPlNode(.elem_ptr_node, node, Zir.Inst.Bin{ .lhs = lhs, .rhs = rhs });</span>
<span class="line" id="L6143">        },</span>
<span class="line" id="L6144">        <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L6145">            <span class="tok-kw">const</span> lhs = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .none }, node_datas[node].lhs);</span>
<span class="line" id="L6146"></span>
<span class="line" id="L6147">            <span class="tok-kw">const</span> cursor = maybeAdvanceSourceCursorToMainToken(gz, node);</span>
<span class="line" id="L6148"></span>
<span class="line" id="L6149">            <span class="tok-kw">const</span> rhs = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .{ .coerced_ty = .usize_type } }, node_datas[node].rhs);</span>
<span class="line" id="L6150">            <span class="tok-kw">try</span> emitDbgStmt(gz, cursor);</span>
<span class="line" id="L6151"></span>
<span class="line" id="L6152">            <span class="tok-kw">return</span> rvalue(gz, ri, <span class="tok-kw">try</span> gz.addPlNode(.elem_val_node, node, Zir.Inst.Bin{ .lhs = lhs, .rhs = rhs }), node);</span>
<span class="line" id="L6153">        },</span>
<span class="line" id="L6154">    }</span>
<span class="line" id="L6155">}</span>
<span class="line" id="L6156"></span>
<span class="line" id="L6157"><span class="tok-kw">fn</span> <span class="tok-fn">simpleBinOp</span>(</span>
<span class="line" id="L6158">    gz: *GenZir,</span>
<span class="line" id="L6159">    scope: *Scope,</span>
<span class="line" id="L6160">    ri: ResultInfo,</span>
<span class="line" id="L6161">    node: Ast.Node.Index,</span>
<span class="line" id="L6162">    op_inst_tag: Zir.Inst.Tag,</span>
<span class="line" id="L6163">) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L6164">    <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L6165">    <span class="tok-kw">const</span> tree = astgen.tree;</span>
<span class="line" id="L6166">    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);</span>
<span class="line" id="L6167"></span>
<span class="line" id="L6168">    <span class="tok-kw">if</span> (op_inst_tag == .cmp_neq <span class="tok-kw">or</span> op_inst_tag == .cmp_eq) {</span>
<span class="line" id="L6169">        <span class="tok-kw">const</span> node_tags = tree.nodes.items(.tag);</span>
<span class="line" id="L6170">        <span class="tok-kw">const</span> str = <span class="tok-kw">if</span> (op_inst_tag == .cmp_eq) <span class="tok-str">&quot;==&quot;</span> <span class="tok-kw">else</span> <span class="tok-str">&quot;!=&quot;</span>;</span>
<span class="line" id="L6171">        <span class="tok-kw">if</span> (node_tags[node_datas[node].lhs] == .string_literal <span class="tok-kw">or</span></span>
<span class="line" id="L6172">            node_tags[node_datas[node].rhs] == .string_literal)</span>
<span class="line" id="L6173">            <span class="tok-kw">return</span> astgen.failNode(node, <span class="tok-str">&quot;cannot compare strings with {s}&quot;</span>, .{str});</span>
<span class="line" id="L6174">    }</span>
<span class="line" id="L6175"></span>
<span class="line" id="L6176">    <span class="tok-kw">const</span> lhs = <span class="tok-kw">try</span> reachableExpr(gz, scope, .{ .rl = .none }, node_datas[node].lhs, node);</span>
<span class="line" id="L6177">    <span class="tok-kw">const</span> cursor = <span class="tok-kw">switch</span> (op_inst_tag) {</span>
<span class="line" id="L6178">        .add, .sub, .mul, .div, .mod_rem =&gt; maybeAdvanceSourceCursorToMainToken(gz, node),</span>
<span class="line" id="L6179">        <span class="tok-kw">else</span> =&gt; <span class="tok-null">undefined</span>,</span>
<span class="line" id="L6180">    };</span>
<span class="line" id="L6181">    <span class="tok-kw">const</span> rhs = <span class="tok-kw">try</span> reachableExpr(gz, scope, .{ .rl = .none }, node_datas[node].rhs, node);</span>
<span class="line" id="L6182"></span>
<span class="line" id="L6183">    <span class="tok-kw">switch</span> (op_inst_tag) {</span>
<span class="line" id="L6184">        .add, .sub, .mul, .div, .mod_rem =&gt; {</span>
<span class="line" id="L6185">            <span class="tok-kw">try</span> emitDbgStmt(gz, cursor);</span>
<span class="line" id="L6186">        },</span>
<span class="line" id="L6187">        <span class="tok-kw">else</span> =&gt; {},</span>
<span class="line" id="L6188">    }</span>
<span class="line" id="L6189">    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addPlNode(op_inst_tag, node, Zir.Inst.Bin{ .lhs = lhs, .rhs = rhs });</span>
<span class="line" id="L6190">    <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L6191">}</span>
<span class="line" id="L6192"></span>
<span class="line" id="L6193"><span class="tok-kw">fn</span> <span class="tok-fn">simpleStrTok</span>(</span>
<span class="line" id="L6194">    gz: *GenZir,</span>
<span class="line" id="L6195">    ri: ResultInfo,</span>
<span class="line" id="L6196">    ident_token: Ast.TokenIndex,</span>
<span class="line" id="L6197">    node: Ast.Node.Index,</span>
<span class="line" id="L6198">    op_inst_tag: Zir.Inst.Tag,</span>
<span class="line" id="L6199">) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L6200">    <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L6201">    <span class="tok-kw">const</span> str_index = <span class="tok-kw">try</span> astgen.identAsString(ident_token);</span>
<span class="line" id="L6202">    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addStrTok(op_inst_tag, str_index, ident_token);</span>
<span class="line" id="L6203">    <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L6204">}</span>
<span class="line" id="L6205"></span>
<span class="line" id="L6206"><span class="tok-kw">fn</span> <span class="tok-fn">boolBinOp</span>(</span>
<span class="line" id="L6207">    gz: *GenZir,</span>
<span class="line" id="L6208">    scope: *Scope,</span>
<span class="line" id="L6209">    ri: ResultInfo,</span>
<span class="line" id="L6210">    node: Ast.Node.Index,</span>
<span class="line" id="L6211">    zir_tag: Zir.Inst.Tag,</span>
<span class="line" id="L6212">) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L6213">    <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L6214">    <span class="tok-kw">const</span> tree = astgen.tree;</span>
<span class="line" id="L6215">    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);</span>
<span class="line" id="L6216"></span>
<span class="line" id="L6217">    <span class="tok-kw">const</span> lhs = <span class="tok-kw">try</span> expr(gz, scope, coerced_bool_ri, node_datas[node].lhs);</span>
<span class="line" id="L6218">    <span class="tok-kw">const</span> bool_br = (<span class="tok-kw">try</span> gz.addPlNodePayloadIndex(zir_tag, node, <span class="tok-null">undefined</span>)).toIndex().?;</span>
<span class="line" id="L6219"></span>
<span class="line" id="L6220">    <span class="tok-kw">var</span> rhs_scope = gz.makeSubBlock(scope);</span>
<span class="line" id="L6221">    <span class="tok-kw">defer</span> rhs_scope.unstack();</span>
<span class="line" id="L6222">    <span class="tok-kw">const</span> rhs = <span class="tok-kw">try</span> fullBodyExpr(&amp;rhs_scope, &amp;rhs_scope.base, coerced_bool_ri, node_datas[node].rhs);</span>
<span class="line" id="L6223">    <span class="tok-kw">if</span> (!gz.refIsNoReturn(rhs)) {</span>
<span class="line" id="L6224">        _ = <span class="tok-kw">try</span> rhs_scope.addBreakWithSrcNode(.break_inline, bool_br, rhs, node_datas[node].rhs);</span>
<span class="line" id="L6225">    }</span>
<span class="line" id="L6226">    <span class="tok-kw">try</span> rhs_scope.setBoolBrBody(bool_br, lhs);</span>
<span class="line" id="L6227"></span>
<span class="line" id="L6228">    <span class="tok-kw">const</span> block_ref = bool_br.toRef();</span>
<span class="line" id="L6229">    <span class="tok-kw">return</span> rvalue(gz, ri, block_ref, node);</span>
<span class="line" id="L6230">}</span>
<span class="line" id="L6231"></span>
<span class="line" id="L6232"><span class="tok-kw">fn</span> <span class="tok-fn">ifExpr</span>(</span>
<span class="line" id="L6233">    parent_gz: *GenZir,</span>
<span class="line" id="L6234">    scope: *Scope,</span>
<span class="line" id="L6235">    ri: ResultInfo,</span>
<span class="line" id="L6236">    node: Ast.Node.Index,</span>
<span class="line" id="L6237">    if_full: Ast.full.If,</span>
<span class="line" id="L6238">) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L6239">    <span class="tok-kw">const</span> astgen = parent_gz.astgen;</span>
<span class="line" id="L6240">    <span class="tok-kw">const</span> tree = astgen.tree;</span>
<span class="line" id="L6241">    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);</span>
<span class="line" id="L6242"></span>
<span class="line" id="L6243">    <span class="tok-kw">const</span> do_err_trace = astgen.fn_block != <span class="tok-null">null</span> <span class="tok-kw">and</span> if_full.error_token != <span class="tok-null">null</span>;</span>
<span class="line" id="L6244"></span>
<span class="line" id="L6245">    <span class="tok-kw">const</span> need_rl = astgen.nodes_need_rl.contains(node);</span>
<span class="line" id="L6246">    <span class="tok-kw">const</span> block_ri: ResultInfo = <span class="tok-kw">if</span> (need_rl) ri <span class="tok-kw">else</span> .{</span>
<span class="line" id="L6247">        .rl = <span class="tok-kw">switch</span> (ri.rl) {</span>
<span class="line" id="L6248">            .ptr =&gt; .{ .ty = (<span class="tok-kw">try</span> ri.rl.resultType(parent_gz, node)).? },</span>
<span class="line" id="L6249">            .inferred_ptr =&gt; .none,</span>
<span class="line" id="L6250">            <span class="tok-kw">else</span> =&gt; ri.rl,</span>
<span class="line" id="L6251">        },</span>
<span class="line" id="L6252">        .ctx = ri.ctx,</span>
<span class="line" id="L6253">    };</span>
<span class="line" id="L6254">    <span class="tok-comment">// We need to call `rvalue` to write through to the pointer only if we had a</span>
</span>
<span class="line" id="L6255">    <span class="tok-comment">// result pointer and aren't forwarding it.</span>
</span>
<span class="line" id="L6256">    <span class="tok-kw">const</span> LocTag = <span class="tok-builtin">@typeInfo</span>(ResultInfo.Loc).Union.tag_type.?;</span>
<span class="line" id="L6257">    <span class="tok-kw">const</span> need_result_rvalue = <span class="tok-builtin">@as</span>(LocTag, block_ri.rl) != <span class="tok-builtin">@as</span>(LocTag, ri.rl);</span>
<span class="line" id="L6258"></span>
<span class="line" id="L6259">    <span class="tok-kw">var</span> block_scope = parent_gz.makeSubBlock(scope);</span>
<span class="line" id="L6260">    block_scope.setBreakResultInfo(block_ri);</span>
<span class="line" id="L6261">    <span class="tok-kw">defer</span> block_scope.unstack();</span>
<span class="line" id="L6262"></span>
<span class="line" id="L6263">    <span class="tok-kw">const</span> payload_is_ref = <span class="tok-kw">if</span> (if_full.payload_token) |payload_token|</span>
<span class="line" id="L6264">        token_tags[payload_token] == .asterisk</span>
<span class="line" id="L6265">    <span class="tok-kw">else</span></span>
<span class="line" id="L6266">        <span class="tok-null">false</span>;</span>
<span class="line" id="L6267"></span>
<span class="line" id="L6268">    <span class="tok-kw">try</span> emitDbgNode(parent_gz, if_full.ast.cond_expr);</span>
<span class="line" id="L6269">    <span class="tok-kw">const</span> cond: <span class="tok-kw">struct</span> {</span>
<span class="line" id="L6270">        inst: Zir.Inst.Ref,</span>
<span class="line" id="L6271">        bool_bit: Zir.Inst.Ref,</span>
<span class="line" id="L6272">    } = c: {</span>
<span class="line" id="L6273">        <span class="tok-kw">if</span> (if_full.error_token) |_| {</span>
<span class="line" id="L6274">            <span class="tok-kw">const</span> cond_ri: ResultInfo = .{ .rl = <span class="tok-kw">if</span> (payload_is_ref) .ref <span class="tok-kw">else</span> .none, .ctx = .error_handling_expr };</span>
<span class="line" id="L6275">            <span class="tok-kw">const</span> err_union = <span class="tok-kw">try</span> expr(&amp;block_scope, &amp;block_scope.base, cond_ri, if_full.ast.cond_expr);</span>
<span class="line" id="L6276">            <span class="tok-kw">const</span> tag: Zir.Inst.Tag = <span class="tok-kw">if</span> (payload_is_ref) .is_non_err_ptr <span class="tok-kw">else</span> .is_non_err;</span>
<span class="line" id="L6277">            <span class="tok-kw">break</span> :c .{</span>
<span class="line" id="L6278">                .inst = err_union,</span>
<span class="line" id="L6279">                .bool_bit = <span class="tok-kw">try</span> block_scope.addUnNode(tag, err_union, if_full.ast.cond_expr),</span>
<span class="line" id="L6280">            };</span>
<span class="line" id="L6281">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (if_full.payload_token) |_| {</span>
<span class="line" id="L6282">            <span class="tok-kw">const</span> cond_ri: ResultInfo = .{ .rl = <span class="tok-kw">if</span> (payload_is_ref) .ref <span class="tok-kw">else</span> .none };</span>
<span class="line" id="L6283">            <span class="tok-kw">const</span> optional = <span class="tok-kw">try</span> expr(&amp;block_scope, &amp;block_scope.base, cond_ri, if_full.ast.cond_expr);</span>
<span class="line" id="L6284">            <span class="tok-kw">const</span> tag: Zir.Inst.Tag = <span class="tok-kw">if</span> (payload_is_ref) .is_non_null_ptr <span class="tok-kw">else</span> .is_non_null;</span>
<span class="line" id="L6285">            <span class="tok-kw">break</span> :c .{</span>
<span class="line" id="L6286">                .inst = optional,</span>
<span class="line" id="L6287">                .bool_bit = <span class="tok-kw">try</span> block_scope.addUnNode(tag, optional, if_full.ast.cond_expr),</span>
<span class="line" id="L6288">            };</span>
<span class="line" id="L6289">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L6290">            <span class="tok-kw">const</span> cond = <span class="tok-kw">try</span> expr(&amp;block_scope, &amp;block_scope.base, coerced_bool_ri, if_full.ast.cond_expr);</span>
<span class="line" id="L6291">            <span class="tok-kw">break</span> :c .{</span>
<span class="line" id="L6292">                .inst = cond,</span>
<span class="line" id="L6293">                .bool_bit = cond,</span>
<span class="line" id="L6294">            };</span>
<span class="line" id="L6295">        }</span>
<span class="line" id="L6296">    };</span>
<span class="line" id="L6297"></span>
<span class="line" id="L6298">    <span class="tok-kw">const</span> condbr = <span class="tok-kw">try</span> block_scope.addCondBr(.condbr, node);</span>
<span class="line" id="L6299"></span>
<span class="line" id="L6300">    <span class="tok-kw">const</span> block = <span class="tok-kw">try</span> parent_gz.makeBlockInst(.block, node);</span>
<span class="line" id="L6301">    <span class="tok-kw">try</span> block_scope.setBlockBody(block);</span>
<span class="line" id="L6302">    <span class="tok-comment">// block_scope unstacked now, can add new instructions to parent_gz</span>
</span>
<span class="line" id="L6303">    <span class="tok-kw">try</span> parent_gz.instructions.append(astgen.gpa, block);</span>
<span class="line" id="L6304"></span>
<span class="line" id="L6305">    <span class="tok-kw">var</span> then_scope = parent_gz.makeSubBlock(scope);</span>
<span class="line" id="L6306">    <span class="tok-kw">defer</span> then_scope.unstack();</span>
<span class="line" id="L6307"></span>
<span class="line" id="L6308">    <span class="tok-kw">var</span> payload_val_scope: Scope.LocalVal = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L6309"></span>
<span class="line" id="L6310">    <span class="tok-kw">const</span> then_node = if_full.ast.then_expr;</span>
<span class="line" id="L6311">    <span class="tok-kw">const</span> then_sub_scope = s: {</span>
<span class="line" id="L6312">        <span class="tok-kw">if</span> (if_full.error_token != <span class="tok-null">null</span>) {</span>
<span class="line" id="L6313">            <span class="tok-kw">if</span> (if_full.payload_token) |payload_token| {</span>
<span class="line" id="L6314">                <span class="tok-kw">const</span> tag: Zir.Inst.Tag = <span class="tok-kw">if</span> (payload_is_ref)</span>
<span class="line" id="L6315">                    .err_union_payload_unsafe_ptr</span>
<span class="line" id="L6316">                <span class="tok-kw">else</span></span>
<span class="line" id="L6317">                    .err_union_payload_unsafe;</span>
<span class="line" id="L6318">                <span class="tok-kw">const</span> payload_inst = <span class="tok-kw">try</span> then_scope.addUnNode(tag, cond.inst, then_node);</span>
<span class="line" id="L6319">                <span class="tok-kw">const</span> token_name_index = payload_token + <span class="tok-builtin">@intFromBool</span>(payload_is_ref);</span>
<span class="line" id="L6320">                <span class="tok-kw">const</span> ident_name = <span class="tok-kw">try</span> astgen.identAsString(token_name_index);</span>
<span class="line" id="L6321">                <span class="tok-kw">const</span> token_name_str = tree.tokenSlice(token_name_index);</span>
<span class="line" id="L6322">                <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, <span class="tok-str">&quot;_&quot;</span>, token_name_str))</span>
<span class="line" id="L6323">                    <span class="tok-kw">break</span> :s &amp;then_scope.base;</span>
<span class="line" id="L6324">                <span class="tok-kw">try</span> astgen.detectLocalShadowing(&amp;then_scope.base, ident_name, token_name_index, token_name_str, .capture);</span>
<span class="line" id="L6325">                payload_val_scope = .{</span>
<span class="line" id="L6326">                    .parent = &amp;then_scope.base,</span>
<span class="line" id="L6327">                    .gen_zir = &amp;then_scope,</span>
<span class="line" id="L6328">                    .name = ident_name,</span>
<span class="line" id="L6329">                    .inst = payload_inst,</span>
<span class="line" id="L6330">                    .token_src = token_name_index,</span>
<span class="line" id="L6331">                    .id_cat = .capture,</span>
<span class="line" id="L6332">                };</span>
<span class="line" id="L6333">                <span class="tok-kw">try</span> then_scope.addDbgVar(.dbg_var_val, ident_name, payload_inst);</span>
<span class="line" id="L6334">                <span class="tok-kw">break</span> :s &amp;payload_val_scope.base;</span>
<span class="line" id="L6335">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L6336">                _ = <span class="tok-kw">try</span> then_scope.addUnNode(.ensure_err_union_payload_void, cond.inst, node);</span>
<span class="line" id="L6337">                <span class="tok-kw">break</span> :s &amp;then_scope.base;</span>
<span class="line" id="L6338">            }</span>
<span class="line" id="L6339">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (if_full.payload_token) |payload_token| {</span>
<span class="line" id="L6340">            <span class="tok-kw">const</span> ident_token = <span class="tok-kw">if</span> (payload_is_ref) payload_token + <span class="tok-number">1</span> <span class="tok-kw">else</span> payload_token;</span>
<span class="line" id="L6341">            <span class="tok-kw">const</span> tag: Zir.Inst.Tag = <span class="tok-kw">if</span> (payload_is_ref)</span>
<span class="line" id="L6342">                .optional_payload_unsafe_ptr</span>
<span class="line" id="L6343">            <span class="tok-kw">else</span></span>
<span class="line" id="L6344">                .optional_payload_unsafe;</span>
<span class="line" id="L6345">            <span class="tok-kw">const</span> ident_bytes = tree.tokenSlice(ident_token);</span>
<span class="line" id="L6346">            <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, <span class="tok-str">&quot;_&quot;</span>, ident_bytes))</span>
<span class="line" id="L6347">                <span class="tok-kw">break</span> :s &amp;then_scope.base;</span>
<span class="line" id="L6348">            <span class="tok-kw">const</span> payload_inst = <span class="tok-kw">try</span> then_scope.addUnNode(tag, cond.inst, then_node);</span>
<span class="line" id="L6349">            <span class="tok-kw">const</span> ident_name = <span class="tok-kw">try</span> astgen.identAsString(ident_token);</span>
<span class="line" id="L6350">            <span class="tok-kw">try</span> astgen.detectLocalShadowing(&amp;then_scope.base, ident_name, ident_token, ident_bytes, .capture);</span>
<span class="line" id="L6351">            payload_val_scope = .{</span>
<span class="line" id="L6352">                .parent = &amp;then_scope.base,</span>
<span class="line" id="L6353">                .gen_zir = &amp;then_scope,</span>
<span class="line" id="L6354">                .name = ident_name,</span>
<span class="line" id="L6355">                .inst = payload_inst,</span>
<span class="line" id="L6356">                .token_src = ident_token,</span>
<span class="line" id="L6357">                .id_cat = .capture,</span>
<span class="line" id="L6358">            };</span>
<span class="line" id="L6359">            <span class="tok-kw">try</span> then_scope.addDbgVar(.dbg_var_val, ident_name, payload_inst);</span>
<span class="line" id="L6360">            <span class="tok-kw">break</span> :s &amp;payload_val_scope.base;</span>
<span class="line" id="L6361">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L6362">            <span class="tok-kw">break</span> :s &amp;then_scope.base;</span>
<span class="line" id="L6363">        }</span>
<span class="line" id="L6364">    };</span>
<span class="line" id="L6365"></span>
<span class="line" id="L6366">    <span class="tok-kw">const</span> then_result = <span class="tok-kw">try</span> fullBodyExpr(&amp;then_scope, then_sub_scope, block_scope.break_result_info, then_node);</span>
<span class="line" id="L6367">    <span class="tok-kw">try</span> checkUsed(parent_gz, &amp;then_scope.base, then_sub_scope);</span>
<span class="line" id="L6368">    <span class="tok-kw">if</span> (!then_scope.endsWithNoReturn()) {</span>
<span class="line" id="L6369">        _ = <span class="tok-kw">try</span> then_scope.addBreakWithSrcNode(.@&quot;break&quot;, block, then_result, then_node);</span>
<span class="line" id="L6370">    }</span>
<span class="line" id="L6371"></span>
<span class="line" id="L6372">    <span class="tok-kw">var</span> else_scope = parent_gz.makeSubBlock(scope);</span>
<span class="line" id="L6373">    <span class="tok-kw">defer</span> else_scope.unstack();</span>
<span class="line" id="L6374"></span>
<span class="line" id="L6375">    <span class="tok-comment">// We know that the operand (almost certainly) modified the error return trace,</span>
</span>
<span class="line" id="L6376">    <span class="tok-comment">// so signal to Sema that it should save the new index for restoring later.</span>
</span>
<span class="line" id="L6377">    <span class="tok-kw">if</span> (do_err_trace <span class="tok-kw">and</span> nodeMayAppendToErrorTrace(tree, if_full.ast.cond_expr))</span>
<span class="line" id="L6378">        _ = <span class="tok-kw">try</span> else_scope.addSaveErrRetIndex(.always);</span>
<span class="line" id="L6379"></span>
<span class="line" id="L6380">    <span class="tok-kw">const</span> else_node = if_full.ast.else_expr;</span>
<span class="line" id="L6381">    <span class="tok-kw">if</span> (else_node != <span class="tok-number">0</span>) {</span>
<span class="line" id="L6382">        <span class="tok-kw">const</span> sub_scope = s: {</span>
<span class="line" id="L6383">            <span class="tok-kw">if</span> (if_full.error_token) |error_token| {</span>
<span class="line" id="L6384">                <span class="tok-kw">const</span> tag: Zir.Inst.Tag = <span class="tok-kw">if</span> (payload_is_ref)</span>
<span class="line" id="L6385">                    .err_union_code_ptr</span>
<span class="line" id="L6386">                <span class="tok-kw">else</span></span>
<span class="line" id="L6387">                    .err_union_code;</span>
<span class="line" id="L6388">                <span class="tok-kw">const</span> payload_inst = <span class="tok-kw">try</span> else_scope.addUnNode(tag, cond.inst, if_full.ast.cond_expr);</span>
<span class="line" id="L6389">                <span class="tok-kw">const</span> ident_name = <span class="tok-kw">try</span> astgen.identAsString(error_token);</span>
<span class="line" id="L6390">                <span class="tok-kw">const</span> error_token_str = tree.tokenSlice(error_token);</span>
<span class="line" id="L6391">                <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, <span class="tok-str">&quot;_&quot;</span>, error_token_str))</span>
<span class="line" id="L6392">                    <span class="tok-kw">break</span> :s &amp;else_scope.base;</span>
<span class="line" id="L6393">                <span class="tok-kw">try</span> astgen.detectLocalShadowing(&amp;else_scope.base, ident_name, error_token, error_token_str, .capture);</span>
<span class="line" id="L6394">                payload_val_scope = .{</span>
<span class="line" id="L6395">                    .parent = &amp;else_scope.base,</span>
<span class="line" id="L6396">                    .gen_zir = &amp;else_scope,</span>
<span class="line" id="L6397">                    .name = ident_name,</span>
<span class="line" id="L6398">                    .inst = payload_inst,</span>
<span class="line" id="L6399">                    .token_src = error_token,</span>
<span class="line" id="L6400">                    .id_cat = .capture,</span>
<span class="line" id="L6401">                };</span>
<span class="line" id="L6402">                <span class="tok-kw">try</span> else_scope.addDbgVar(.dbg_var_val, ident_name, payload_inst);</span>
<span class="line" id="L6403">                <span class="tok-kw">break</span> :s &amp;payload_val_scope.base;</span>
<span class="line" id="L6404">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L6405">                <span class="tok-kw">break</span> :s &amp;else_scope.base;</span>
<span class="line" id="L6406">            }</span>
<span class="line" id="L6407">        };</span>
<span class="line" id="L6408">        <span class="tok-kw">const</span> else_result = <span class="tok-kw">try</span> fullBodyExpr(&amp;else_scope, sub_scope, block_scope.break_result_info, else_node);</span>
<span class="line" id="L6409">        <span class="tok-kw">if</span> (!else_scope.endsWithNoReturn()) {</span>
<span class="line" id="L6410">            <span class="tok-comment">// As our last action before the break, &quot;pop&quot; the error trace if needed</span>
</span>
<span class="line" id="L6411">            <span class="tok-kw">if</span> (do_err_trace)</span>
<span class="line" id="L6412">                <span class="tok-kw">try</span> restoreErrRetIndex(&amp;else_scope, .{ .block = block }, block_scope.break_result_info, else_node, else_result);</span>
<span class="line" id="L6413">            _ = <span class="tok-kw">try</span> else_scope.addBreakWithSrcNode(.@&quot;break&quot;, block, else_result, else_node);</span>
<span class="line" id="L6414">        }</span>
<span class="line" id="L6415">        <span class="tok-kw">try</span> checkUsed(parent_gz, &amp;else_scope.base, sub_scope);</span>
<span class="line" id="L6416">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L6417">        <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> rvalue(&amp;else_scope, ri, .void_value, node);</span>
<span class="line" id="L6418">        _ = <span class="tok-kw">try</span> else_scope.addBreak(.@&quot;break&quot;, block, result);</span>
<span class="line" id="L6419">    }</span>
<span class="line" id="L6420"></span>
<span class="line" id="L6421">    <span class="tok-kw">try</span> setCondBrPayload(condbr, cond.bool_bit, &amp;then_scope, &amp;else_scope);</span>
<span class="line" id="L6422"></span>
<span class="line" id="L6423">    <span class="tok-kw">if</span> (need_result_rvalue) {</span>
<span class="line" id="L6424">        <span class="tok-kw">return</span> rvalue(parent_gz, ri, block.toRef(), node);</span>
<span class="line" id="L6425">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L6426">        <span class="tok-kw">return</span> block.toRef();</span>
<span class="line" id="L6427">    }</span>
<span class="line" id="L6428">}</span>
<span class="line" id="L6429"></span>
<span class="line" id="L6430"><span class="tok-comment">/// Supports `else_scope` stacked on `then_scope`. Unstacks `else_scope` then `then_scope`.</span></span>
<span class="line" id="L6431"><span class="tok-kw">fn</span> <span class="tok-fn">setCondBrPayload</span>(</span>
<span class="line" id="L6432">    condbr: Zir.Inst.Index,</span>
<span class="line" id="L6433">    cond: Zir.Inst.Ref,</span>
<span class="line" id="L6434">    then_scope: *GenZir,</span>
<span class="line" id="L6435">    else_scope: *GenZir,</span>
<span class="line" id="L6436">) !<span class="tok-type">void</span> {</span>
<span class="line" id="L6437">    <span class="tok-kw">defer</span> then_scope.unstack();</span>
<span class="line" id="L6438">    <span class="tok-kw">defer</span> else_scope.unstack();</span>
<span class="line" id="L6439">    <span class="tok-kw">const</span> astgen = then_scope.astgen;</span>
<span class="line" id="L6440">    <span class="tok-kw">const</span> then_body = then_scope.instructionsSliceUpto(else_scope);</span>
<span class="line" id="L6441">    <span class="tok-kw">const</span> else_body = else_scope.instructionsSlice();</span>
<span class="line" id="L6442">    <span class="tok-kw">const</span> then_body_len = astgen.countBodyLenAfterFixups(then_body);</span>
<span class="line" id="L6443">    <span class="tok-kw">const</span> else_body_len = astgen.countBodyLenAfterFixups(else_body);</span>
<span class="line" id="L6444">    <span class="tok-kw">try</span> astgen.extra.ensureUnusedCapacity(</span>
<span class="line" id="L6445">        astgen.gpa,</span>
<span class="line" id="L6446">        <span class="tok-builtin">@typeInfo</span>(Zir.Inst.CondBr).Struct.fields.len + then_body_len + else_body_len,</span>
<span class="line" id="L6447">    );</span>
<span class="line" id="L6448"></span>
<span class="line" id="L6449">    <span class="tok-kw">const</span> zir_datas = astgen.instructions.items(.data);</span>
<span class="line" id="L6450">    zir_datas[<span class="tok-builtin">@intFromEnum</span>(condbr)].pl_node.payload_index = astgen.addExtraAssumeCapacity(Zir.Inst.CondBr{</span>
<span class="line" id="L6451">        .condition = cond,</span>
<span class="line" id="L6452">        .then_body_len = then_body_len,</span>
<span class="line" id="L6453">        .else_body_len = else_body_len,</span>
<span class="line" id="L6454">    });</span>
<span class="line" id="L6455">    astgen.appendBodyWithFixups(then_body);</span>
<span class="line" id="L6456">    astgen.appendBodyWithFixups(else_body);</span>
<span class="line" id="L6457">}</span>
<span class="line" id="L6458"></span>
<span class="line" id="L6459"><span class="tok-kw">fn</span> <span class="tok-fn">whileExpr</span>(</span>
<span class="line" id="L6460">    parent_gz: *GenZir,</span>
<span class="line" id="L6461">    scope: *Scope,</span>
<span class="line" id="L6462">    ri: ResultInfo,</span>
<span class="line" id="L6463">    node: Ast.Node.Index,</span>
<span class="line" id="L6464">    while_full: Ast.full.While,</span>
<span class="line" id="L6465">    is_statement: <span class="tok-type">bool</span>,</span>
<span class="line" id="L6466">) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L6467">    <span class="tok-kw">const</span> astgen = parent_gz.astgen;</span>
<span class="line" id="L6468">    <span class="tok-kw">const</span> tree = astgen.tree;</span>
<span class="line" id="L6469">    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);</span>
<span class="line" id="L6470"></span>
<span class="line" id="L6471">    <span class="tok-kw">const</span> need_rl = astgen.nodes_need_rl.contains(node);</span>
<span class="line" id="L6472">    <span class="tok-kw">const</span> block_ri: ResultInfo = <span class="tok-kw">if</span> (need_rl) ri <span class="tok-kw">else</span> .{</span>
<span class="line" id="L6473">        .rl = <span class="tok-kw">switch</span> (ri.rl) {</span>
<span class="line" id="L6474">            .ptr =&gt; .{ .ty = (<span class="tok-kw">try</span> ri.rl.resultType(parent_gz, node)).? },</span>
<span class="line" id="L6475">            .inferred_ptr =&gt; .none,</span>
<span class="line" id="L6476">            <span class="tok-kw">else</span> =&gt; ri.rl,</span>
<span class="line" id="L6477">        },</span>
<span class="line" id="L6478">        .ctx = ri.ctx,</span>
<span class="line" id="L6479">    };</span>
<span class="line" id="L6480">    <span class="tok-comment">// We need to call `rvalue` to write through to the pointer only if we had a</span>
</span>
<span class="line" id="L6481">    <span class="tok-comment">// result pointer and aren't forwarding it.</span>
</span>
<span class="line" id="L6482">    <span class="tok-kw">const</span> LocTag = <span class="tok-builtin">@typeInfo</span>(ResultInfo.Loc).Union.tag_type.?;</span>
<span class="line" id="L6483">    <span class="tok-kw">const</span> need_result_rvalue = <span class="tok-builtin">@as</span>(LocTag, block_ri.rl) != <span class="tok-builtin">@as</span>(LocTag, ri.rl);</span>
<span class="line" id="L6484"></span>
<span class="line" id="L6485">    <span class="tok-kw">if</span> (while_full.label_token) |label_token| {</span>
<span class="line" id="L6486">        <span class="tok-kw">try</span> astgen.checkLabelRedefinition(scope, label_token);</span>
<span class="line" id="L6487">    }</span>
<span class="line" id="L6488"></span>
<span class="line" id="L6489">    <span class="tok-kw">const</span> is_inline = while_full.inline_token != <span class="tok-null">null</span>;</span>
<span class="line" id="L6490">    <span class="tok-kw">if</span> (parent_gz.is_comptime <span class="tok-kw">and</span> is_inline) {</span>
<span class="line" id="L6491">        <span class="tok-kw">return</span> astgen.failTok(while_full.inline_token.?, <span class="tok-str">&quot;redundant inline keyword in comptime scope&quot;</span>, .{});</span>
<span class="line" id="L6492">    }</span>
<span class="line" id="L6493">    <span class="tok-kw">const</span> loop_tag: Zir.Inst.Tag = <span class="tok-kw">if</span> (is_inline) .block_inline <span class="tok-kw">else</span> .loop;</span>
<span class="line" id="L6494">    <span class="tok-kw">const</span> loop_block = <span class="tok-kw">try</span> parent_gz.makeBlockInst(loop_tag, node);</span>
<span class="line" id="L6495">    <span class="tok-kw">try</span> parent_gz.instructions.append(astgen.gpa, loop_block);</span>
<span class="line" id="L6496"></span>
<span class="line" id="L6497">    <span class="tok-kw">var</span> loop_scope = parent_gz.makeSubBlock(scope);</span>
<span class="line" id="L6498">    loop_scope.is_inline = is_inline;</span>
<span class="line" id="L6499">    loop_scope.setBreakResultInfo(block_ri);</span>
<span class="line" id="L6500">    <span class="tok-kw">defer</span> loop_scope.unstack();</span>
<span class="line" id="L6501"></span>
<span class="line" id="L6502">    <span class="tok-kw">var</span> cond_scope = parent_gz.makeSubBlock(&amp;loop_scope.base);</span>
<span class="line" id="L6503">    <span class="tok-kw">defer</span> cond_scope.unstack();</span>
<span class="line" id="L6504"></span>
<span class="line" id="L6505">    <span class="tok-kw">const</span> payload_is_ref = <span class="tok-kw">if</span> (while_full.payload_token) |payload_token|</span>
<span class="line" id="L6506">        token_tags[payload_token] == .asterisk</span>
<span class="line" id="L6507">    <span class="tok-kw">else</span></span>
<span class="line" id="L6508">        <span class="tok-null">false</span>;</span>
<span class="line" id="L6509"></span>
<span class="line" id="L6510">    <span class="tok-kw">try</span> emitDbgNode(parent_gz, while_full.ast.cond_expr);</span>
<span class="line" id="L6511">    <span class="tok-kw">const</span> cond: <span class="tok-kw">struct</span> {</span>
<span class="line" id="L6512">        inst: Zir.Inst.Ref,</span>
<span class="line" id="L6513">        bool_bit: Zir.Inst.Ref,</span>
<span class="line" id="L6514">    } = c: {</span>
<span class="line" id="L6515">        <span class="tok-kw">if</span> (while_full.error_token) |_| {</span>
<span class="line" id="L6516">            <span class="tok-kw">const</span> cond_ri: ResultInfo = .{ .rl = <span class="tok-kw">if</span> (payload_is_ref) .ref <span class="tok-kw">else</span> .none };</span>
<span class="line" id="L6517">            <span class="tok-kw">const</span> err_union = <span class="tok-kw">try</span> fullBodyExpr(&amp;cond_scope, &amp;cond_scope.base, cond_ri, while_full.ast.cond_expr);</span>
<span class="line" id="L6518">            <span class="tok-kw">const</span> tag: Zir.Inst.Tag = <span class="tok-kw">if</span> (payload_is_ref) .is_non_err_ptr <span class="tok-kw">else</span> .is_non_err;</span>
<span class="line" id="L6519">            <span class="tok-kw">break</span> :c .{</span>
<span class="line" id="L6520">                .inst = err_union,</span>
<span class="line" id="L6521">                .bool_bit = <span class="tok-kw">try</span> cond_scope.addUnNode(tag, err_union, while_full.ast.cond_expr),</span>
<span class="line" id="L6522">            };</span>
<span class="line" id="L6523">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (while_full.payload_token) |_| {</span>
<span class="line" id="L6524">            <span class="tok-kw">const</span> cond_ri: ResultInfo = .{ .rl = <span class="tok-kw">if</span> (payload_is_ref) .ref <span class="tok-kw">else</span> .none };</span>
<span class="line" id="L6525">            <span class="tok-kw">const</span> optional = <span class="tok-kw">try</span> fullBodyExpr(&amp;cond_scope, &amp;cond_scope.base, cond_ri, while_full.ast.cond_expr);</span>
<span class="line" id="L6526">            <span class="tok-kw">const</span> tag: Zir.Inst.Tag = <span class="tok-kw">if</span> (payload_is_ref) .is_non_null_ptr <span class="tok-kw">else</span> .is_non_null;</span>
<span class="line" id="L6527">            <span class="tok-kw">break</span> :c .{</span>
<span class="line" id="L6528">                .inst = optional,</span>
<span class="line" id="L6529">                .bool_bit = <span class="tok-kw">try</span> cond_scope.addUnNode(tag, optional, while_full.ast.cond_expr),</span>
<span class="line" id="L6530">            };</span>
<span class="line" id="L6531">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L6532">            <span class="tok-kw">const</span> cond = <span class="tok-kw">try</span> fullBodyExpr(&amp;cond_scope, &amp;cond_scope.base, coerced_bool_ri, while_full.ast.cond_expr);</span>
<span class="line" id="L6533">            <span class="tok-kw">break</span> :c .{</span>
<span class="line" id="L6534">                .inst = cond,</span>
<span class="line" id="L6535">                .bool_bit = cond,</span>
<span class="line" id="L6536">            };</span>
<span class="line" id="L6537">        }</span>
<span class="line" id="L6538">    };</span>
<span class="line" id="L6539"></span>
<span class="line" id="L6540">    <span class="tok-kw">const</span> condbr_tag: Zir.Inst.Tag = <span class="tok-kw">if</span> (is_inline) .condbr_inline <span class="tok-kw">else</span> .condbr;</span>
<span class="line" id="L6541">    <span class="tok-kw">const</span> condbr = <span class="tok-kw">try</span> cond_scope.addCondBr(condbr_tag, node);</span>
<span class="line" id="L6542">    <span class="tok-kw">const</span> block_tag: Zir.Inst.Tag = <span class="tok-kw">if</span> (is_inline) .block_inline <span class="tok-kw">else</span> .block;</span>
<span class="line" id="L6543">    <span class="tok-kw">const</span> cond_block = <span class="tok-kw">try</span> loop_scope.makeBlockInst(block_tag, node);</span>
<span class="line" id="L6544">    <span class="tok-kw">try</span> cond_scope.setBlockBody(cond_block);</span>
<span class="line" id="L6545">    <span class="tok-comment">// cond_scope unstacked now, can add new instructions to loop_scope</span>
</span>
<span class="line" id="L6546">    <span class="tok-kw">try</span> loop_scope.instructions.append(astgen.gpa, cond_block);</span>
<span class="line" id="L6547"></span>
<span class="line" id="L6548">    <span class="tok-comment">// make scope now but don't stack on parent_gz until loop_scope</span>
</span>
<span class="line" id="L6549">    <span class="tok-comment">// gets unstacked after cont_expr is emitted and added below</span>
</span>
<span class="line" id="L6550">    <span class="tok-kw">var</span> then_scope = parent_gz.makeSubBlock(&amp;cond_scope.base);</span>
<span class="line" id="L6551">    then_scope.instructions_top = GenZir.unstacked_top;</span>
<span class="line" id="L6552">    <span class="tok-kw">defer</span> then_scope.unstack();</span>
<span class="line" id="L6553"></span>
<span class="line" id="L6554">    <span class="tok-kw">var</span> dbg_var_name: Zir.NullTerminatedString = .empty;</span>
<span class="line" id="L6555">    <span class="tok-kw">var</span> dbg_var_inst: Zir.Inst.Ref = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L6556">    <span class="tok-kw">var</span> opt_payload_inst: Zir.Inst.OptionalIndex = .none;</span>
<span class="line" id="L6557">    <span class="tok-kw">var</span> payload_val_scope: Scope.LocalVal = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L6558">    <span class="tok-kw">const</span> then_sub_scope = s: {</span>
<span class="line" id="L6559">        <span class="tok-kw">if</span> (while_full.error_token != <span class="tok-null">null</span>) {</span>
<span class="line" id="L6560">            <span class="tok-kw">if</span> (while_full.payload_token) |payload_token| {</span>
<span class="line" id="L6561">                <span class="tok-kw">const</span> tag: Zir.Inst.Tag = <span class="tok-kw">if</span> (payload_is_ref)</span>
<span class="line" id="L6562">                    .err_union_payload_unsafe_ptr</span>
<span class="line" id="L6563">                <span class="tok-kw">else</span></span>
<span class="line" id="L6564">                    .err_union_payload_unsafe;</span>
<span class="line" id="L6565">                <span class="tok-comment">// will add this instruction to then_scope.instructions below</span>
</span>
<span class="line" id="L6566">                <span class="tok-kw">const</span> payload_inst = <span class="tok-kw">try</span> then_scope.makeUnNode(tag, cond.inst, while_full.ast.cond_expr);</span>
<span class="line" id="L6567">                opt_payload_inst = payload_inst.toOptional();</span>
<span class="line" id="L6568">                <span class="tok-kw">const</span> ident_token = payload_token + <span class="tok-builtin">@intFromBool</span>(payload_is_ref);</span>
<span class="line" id="L6569">                <span class="tok-kw">const</span> ident_bytes = tree.tokenSlice(ident_token);</span>
<span class="line" id="L6570">                <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, <span class="tok-str">&quot;_&quot;</span>, ident_bytes))</span>
<span class="line" id="L6571">                    <span class="tok-kw">break</span> :s &amp;then_scope.base;</span>
<span class="line" id="L6572">                <span class="tok-kw">const</span> ident_name = <span class="tok-kw">try</span> astgen.identAsString(ident_token);</span>
<span class="line" id="L6573">                <span class="tok-kw">try</span> astgen.detectLocalShadowing(&amp;then_scope.base, ident_name, ident_token, ident_bytes, .capture);</span>
<span class="line" id="L6574">                payload_val_scope = .{</span>
<span class="line" id="L6575">                    .parent = &amp;then_scope.base,</span>
<span class="line" id="L6576">                    .gen_zir = &amp;then_scope,</span>
<span class="line" id="L6577">                    .name = ident_name,</span>
<span class="line" id="L6578">                    .inst = payload_inst.toRef(),</span>
<span class="line" id="L6579">                    .token_src = ident_token,</span>
<span class="line" id="L6580">                    .id_cat = .capture,</span>
<span class="line" id="L6581">                };</span>
<span class="line" id="L6582">                dbg_var_name = ident_name;</span>
<span class="line" id="L6583">                dbg_var_inst = payload_inst.toRef();</span>
<span class="line" id="L6584">                <span class="tok-kw">break</span> :s &amp;payload_val_scope.base;</span>
<span class="line" id="L6585">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L6586">                _ = <span class="tok-kw">try</span> then_scope.addUnNode(.ensure_err_union_payload_void, cond.inst, node);</span>
<span class="line" id="L6587">                <span class="tok-kw">break</span> :s &amp;then_scope.base;</span>
<span class="line" id="L6588">            }</span>
<span class="line" id="L6589">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (while_full.payload_token) |payload_token| {</span>
<span class="line" id="L6590">            <span class="tok-kw">const</span> ident_token = <span class="tok-kw">if</span> (payload_is_ref) payload_token + <span class="tok-number">1</span> <span class="tok-kw">else</span> payload_token;</span>
<span class="line" id="L6591">            <span class="tok-kw">const</span> tag: Zir.Inst.Tag = <span class="tok-kw">if</span> (payload_is_ref)</span>
<span class="line" id="L6592">                .optional_payload_unsafe_ptr</span>
<span class="line" id="L6593">            <span class="tok-kw">else</span></span>
<span class="line" id="L6594">                .optional_payload_unsafe;</span>
<span class="line" id="L6595">            <span class="tok-comment">// will add this instruction to then_scope.instructions below</span>
</span>
<span class="line" id="L6596">            <span class="tok-kw">const</span> payload_inst = <span class="tok-kw">try</span> then_scope.makeUnNode(tag, cond.inst, while_full.ast.cond_expr);</span>
<span class="line" id="L6597">            opt_payload_inst = payload_inst.toOptional();</span>
<span class="line" id="L6598">            <span class="tok-kw">const</span> ident_name = <span class="tok-kw">try</span> astgen.identAsString(ident_token);</span>
<span class="line" id="L6599">            <span class="tok-kw">const</span> ident_bytes = tree.tokenSlice(ident_token);</span>
<span class="line" id="L6600">            <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, <span class="tok-str">&quot;_&quot;</span>, ident_bytes))</span>
<span class="line" id="L6601">                <span class="tok-kw">break</span> :s &amp;then_scope.base;</span>
<span class="line" id="L6602">            <span class="tok-kw">try</span> astgen.detectLocalShadowing(&amp;then_scope.base, ident_name, ident_token, ident_bytes, .capture);</span>
<span class="line" id="L6603">            payload_val_scope = .{</span>
<span class="line" id="L6604">                .parent = &amp;then_scope.base,</span>
<span class="line" id="L6605">                .gen_zir = &amp;then_scope,</span>
<span class="line" id="L6606">                .name = ident_name,</span>
<span class="line" id="L6607">                .inst = payload_inst.toRef(),</span>
<span class="line" id="L6608">                .token_src = ident_token,</span>
<span class="line" id="L6609">                .id_cat = .capture,</span>
<span class="line" id="L6610">            };</span>
<span class="line" id="L6611">            dbg_var_name = ident_name;</span>
<span class="line" id="L6612">            dbg_var_inst = payload_inst.toRef();</span>
<span class="line" id="L6613">            <span class="tok-kw">break</span> :s &amp;payload_val_scope.base;</span>
<span class="line" id="L6614">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L6615">            <span class="tok-kw">break</span> :s &amp;then_scope.base;</span>
<span class="line" id="L6616">        }</span>
<span class="line" id="L6617">    };</span>
<span class="line" id="L6618"></span>
<span class="line" id="L6619">    <span class="tok-kw">var</span> continue_scope = parent_gz.makeSubBlock(then_sub_scope);</span>
<span class="line" id="L6620">    continue_scope.instructions_top = GenZir.unstacked_top;</span>
<span class="line" id="L6621">    <span class="tok-kw">defer</span> continue_scope.unstack();</span>
<span class="line" id="L6622">    <span class="tok-kw">const</span> continue_block = <span class="tok-kw">try</span> then_scope.makeBlockInst(block_tag, node);</span>
<span class="line" id="L6623"></span>
<span class="line" id="L6624">    <span class="tok-kw">const</span> repeat_tag: Zir.Inst.Tag = <span class="tok-kw">if</span> (is_inline) .repeat_inline <span class="tok-kw">else</span> .repeat;</span>
<span class="line" id="L6625">    _ = <span class="tok-kw">try</span> loop_scope.addNode(repeat_tag, node);</span>
<span class="line" id="L6626"></span>
<span class="line" id="L6627">    <span class="tok-kw">try</span> loop_scope.setBlockBody(loop_block);</span>
<span class="line" id="L6628">    loop_scope.break_block = loop_block.toOptional();</span>
<span class="line" id="L6629">    loop_scope.continue_block = continue_block.toOptional();</span>
<span class="line" id="L6630">    <span class="tok-kw">if</span> (while_full.label_token) |label_token| {</span>
<span class="line" id="L6631">        loop_scope.label = .{</span>
<span class="line" id="L6632">            .token = label_token,</span>
<span class="line" id="L6633">            .block_inst = loop_block,</span>
<span class="line" id="L6634">        };</span>
<span class="line" id="L6635">    }</span>
<span class="line" id="L6636"></span>
<span class="line" id="L6637">    <span class="tok-comment">// done adding instructions to loop_scope, can now stack then_scope</span>
</span>
<span class="line" id="L6638">    then_scope.instructions_top = then_scope.instructions.items.len;</span>
<span class="line" id="L6639"></span>
<span class="line" id="L6640">    <span class="tok-kw">const</span> then_node = while_full.ast.then_expr;</span>
<span class="line" id="L6641">    <span class="tok-kw">if</span> (opt_payload_inst.unwrap()) |payload_inst| {</span>
<span class="line" id="L6642">        <span class="tok-kw">try</span> then_scope.instructions.append(astgen.gpa, payload_inst);</span>
<span class="line" id="L6643">    }</span>
<span class="line" id="L6644">    <span class="tok-kw">if</span> (dbg_var_name != .empty) <span class="tok-kw">try</span> then_scope.addDbgVar(.dbg_var_val, dbg_var_name, dbg_var_inst);</span>
<span class="line" id="L6645">    <span class="tok-kw">try</span> then_scope.instructions.append(astgen.gpa, continue_block);</span>
<span class="line" id="L6646">    <span class="tok-comment">// This code could be improved to avoid emitting the continue expr when there</span>
</span>
<span class="line" id="L6647">    <span class="tok-comment">// are no jumps to it. This happens when the last statement of a while body is noreturn</span>
</span>
<span class="line" id="L6648">    <span class="tok-comment">// and there are no `continue` statements.</span>
</span>
<span class="line" id="L6649">    <span class="tok-comment">// Tracking issue: https://github.com/ziglang/zig/issues/9185</span>
</span>
<span class="line" id="L6650">    <span class="tok-kw">if</span> (while_full.ast.cont_expr != <span class="tok-number">0</span>) {</span>
<span class="line" id="L6651">        _ = <span class="tok-kw">try</span> unusedResultExpr(&amp;then_scope, then_sub_scope, while_full.ast.cont_expr);</span>
<span class="line" id="L6652">    }</span>
<span class="line" id="L6653"></span>
<span class="line" id="L6654">    continue_scope.instructions_top = continue_scope.instructions.items.len;</span>
<span class="line" id="L6655">    {</span>
<span class="line" id="L6656">        <span class="tok-kw">try</span> emitDbgNode(&amp;continue_scope, then_node);</span>
<span class="line" id="L6657">        <span class="tok-kw">const</span> unused_result = <span class="tok-kw">try</span> fullBodyExpr(&amp;continue_scope, &amp;continue_scope.base, .{ .rl = .none }, then_node);</span>
<span class="line" id="L6658">        _ = <span class="tok-kw">try</span> addEnsureResult(&amp;continue_scope, unused_result, then_node);</span>
<span class="line" id="L6659">    }</span>
<span class="line" id="L6660">    <span class="tok-kw">try</span> checkUsed(parent_gz, &amp;then_scope.base, then_sub_scope);</span>
<span class="line" id="L6661">    <span class="tok-kw">const</span> break_tag: Zir.Inst.Tag = <span class="tok-kw">if</span> (is_inline) .break_inline <span class="tok-kw">else</span> .@&quot;break&quot;;</span>
<span class="line" id="L6662">    <span class="tok-kw">if</span> (!continue_scope.endsWithNoReturn()) {</span>
<span class="line" id="L6663">        _ = <span class="tok-kw">try</span> continue_scope.addBreak(break_tag, continue_block, .void_value);</span>
<span class="line" id="L6664">    }</span>
<span class="line" id="L6665">    <span class="tok-kw">try</span> continue_scope.setBlockBody(continue_block);</span>
<span class="line" id="L6666">    _ = <span class="tok-kw">try</span> then_scope.addBreak(break_tag, cond_block, .void_value);</span>
<span class="line" id="L6667"></span>
<span class="line" id="L6668">    <span class="tok-kw">var</span> else_scope = parent_gz.makeSubBlock(&amp;cond_scope.base);</span>
<span class="line" id="L6669">    <span class="tok-kw">defer</span> else_scope.unstack();</span>
<span class="line" id="L6670"></span>
<span class="line" id="L6671">    <span class="tok-kw">const</span> else_node = while_full.ast.else_expr;</span>
<span class="line" id="L6672">    <span class="tok-kw">if</span> (else_node != <span class="tok-number">0</span>) {</span>
<span class="line" id="L6673">        <span class="tok-kw">const</span> sub_scope = s: {</span>
<span class="line" id="L6674">            <span class="tok-kw">if</span> (while_full.error_token) |error_token| {</span>
<span class="line" id="L6675">                <span class="tok-kw">const</span> tag: Zir.Inst.Tag = <span class="tok-kw">if</span> (payload_is_ref)</span>
<span class="line" id="L6676">                    .err_union_code_ptr</span>
<span class="line" id="L6677">                <span class="tok-kw">else</span></span>
<span class="line" id="L6678">                    .err_union_code;</span>
<span class="line" id="L6679">                <span class="tok-kw">const</span> else_payload_inst = <span class="tok-kw">try</span> else_scope.addUnNode(tag, cond.inst, while_full.ast.cond_expr);</span>
<span class="line" id="L6680">                <span class="tok-kw">const</span> ident_name = <span class="tok-kw">try</span> astgen.identAsString(error_token);</span>
<span class="line" id="L6681">                <span class="tok-kw">const</span> ident_bytes = tree.tokenSlice(error_token);</span>
<span class="line" id="L6682">                <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, ident_bytes, <span class="tok-str">&quot;_&quot;</span>))</span>
<span class="line" id="L6683">                    <span class="tok-kw">break</span> :s &amp;else_scope.base;</span>
<span class="line" id="L6684">                <span class="tok-kw">try</span> astgen.detectLocalShadowing(&amp;else_scope.base, ident_name, error_token, ident_bytes, .capture);</span>
<span class="line" id="L6685">                payload_val_scope = .{</span>
<span class="line" id="L6686">                    .parent = &amp;else_scope.base,</span>
<span class="line" id="L6687">                    .gen_zir = &amp;else_scope,</span>
<span class="line" id="L6688">                    .name = ident_name,</span>
<span class="line" id="L6689">                    .inst = else_payload_inst,</span>
<span class="line" id="L6690">                    .token_src = error_token,</span>
<span class="line" id="L6691">                    .id_cat = .capture,</span>
<span class="line" id="L6692">                };</span>
<span class="line" id="L6693">                <span class="tok-kw">try</span> else_scope.addDbgVar(.dbg_var_val, ident_name, else_payload_inst);</span>
<span class="line" id="L6694">                <span class="tok-kw">break</span> :s &amp;payload_val_scope.base;</span>
<span class="line" id="L6695">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L6696">                <span class="tok-kw">break</span> :s &amp;else_scope.base;</span>
<span class="line" id="L6697">            }</span>
<span class="line" id="L6698">        };</span>
<span class="line" id="L6699">        <span class="tok-comment">// Remove the continue block and break block so that `continue` and `break`</span>
</span>
<span class="line" id="L6700">        <span class="tok-comment">// control flow apply to outer loops; not this one.</span>
</span>
<span class="line" id="L6701">        loop_scope.continue_block = .none;</span>
<span class="line" id="L6702">        loop_scope.break_block = .none;</span>
<span class="line" id="L6703">        <span class="tok-kw">const</span> else_result = <span class="tok-kw">try</span> fullBodyExpr(&amp;else_scope, sub_scope, loop_scope.break_result_info, else_node);</span>
<span class="line" id="L6704">        <span class="tok-kw">if</span> (is_statement) {</span>
<span class="line" id="L6705">            _ = <span class="tok-kw">try</span> addEnsureResult(&amp;else_scope, else_result, else_node);</span>
<span class="line" id="L6706">        }</span>
<span class="line" id="L6707"></span>
<span class="line" id="L6708">        <span class="tok-kw">try</span> checkUsed(parent_gz, &amp;else_scope.base, sub_scope);</span>
<span class="line" id="L6709">        <span class="tok-kw">if</span> (!else_scope.endsWithNoReturn()) {</span>
<span class="line" id="L6710">            _ = <span class="tok-kw">try</span> else_scope.addBreakWithSrcNode(break_tag, loop_block, else_result, else_node);</span>
<span class="line" id="L6711">        }</span>
<span class="line" id="L6712">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L6713">        <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> rvalue(&amp;else_scope, ri, .void_value, node);</span>
<span class="line" id="L6714">        _ = <span class="tok-kw">try</span> else_scope.addBreak(break_tag, loop_block, result);</span>
<span class="line" id="L6715">    }</span>
<span class="line" id="L6716"></span>
<span class="line" id="L6717">    <span class="tok-kw">if</span> (loop_scope.label) |some| {</span>
<span class="line" id="L6718">        <span class="tok-kw">if</span> (!some.used) {</span>
<span class="line" id="L6719">            <span class="tok-kw">try</span> astgen.appendErrorTok(some.token, <span class="tok-str">&quot;unused while loop label&quot;</span>, .{});</span>
<span class="line" id="L6720">        }</span>
<span class="line" id="L6721">    }</span>
<span class="line" id="L6722"></span>
<span class="line" id="L6723">    <span class="tok-kw">try</span> setCondBrPayload(condbr, cond.bool_bit, &amp;then_scope, &amp;else_scope);</span>
<span class="line" id="L6724"></span>
<span class="line" id="L6725">    <span class="tok-kw">const</span> result = <span class="tok-kw">if</span> (need_result_rvalue)</span>
<span class="line" id="L6726">        <span class="tok-kw">try</span> rvalue(parent_gz, ri, loop_block.toRef(), node)</span>
<span class="line" id="L6727">    <span class="tok-kw">else</span></span>
<span class="line" id="L6728">        loop_block.toRef();</span>
<span class="line" id="L6729"></span>
<span class="line" id="L6730">    <span class="tok-kw">if</span> (is_statement) {</span>
<span class="line" id="L6731">        _ = <span class="tok-kw">try</span> parent_gz.addUnNode(.ensure_result_used, result, node);</span>
<span class="line" id="L6732">    }</span>
<span class="line" id="L6733"></span>
<span class="line" id="L6734">    <span class="tok-kw">return</span> result;</span>
<span class="line" id="L6735">}</span>
<span class="line" id="L6736"></span>
<span class="line" id="L6737"><span class="tok-kw">fn</span> <span class="tok-fn">forExpr</span>(</span>
<span class="line" id="L6738">    parent_gz: *GenZir,</span>
<span class="line" id="L6739">    scope: *Scope,</span>
<span class="line" id="L6740">    ri: ResultInfo,</span>
<span class="line" id="L6741">    node: Ast.Node.Index,</span>
<span class="line" id="L6742">    for_full: Ast.full.For,</span>
<span class="line" id="L6743">    is_statement: <span class="tok-type">bool</span>,</span>
<span class="line" id="L6744">) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L6745">    <span class="tok-kw">const</span> astgen = parent_gz.astgen;</span>
<span class="line" id="L6746"></span>
<span class="line" id="L6747">    <span class="tok-kw">if</span> (for_full.label_token) |label_token| {</span>
<span class="line" id="L6748">        <span class="tok-kw">try</span> astgen.checkLabelRedefinition(scope, label_token);</span>
<span class="line" id="L6749">    }</span>
<span class="line" id="L6750"></span>
<span class="line" id="L6751">    <span class="tok-kw">const</span> need_rl = astgen.nodes_need_rl.contains(node);</span>
<span class="line" id="L6752">    <span class="tok-kw">const</span> block_ri: ResultInfo = <span class="tok-kw">if</span> (need_rl) ri <span class="tok-kw">else</span> .{</span>
<span class="line" id="L6753">        .rl = <span class="tok-kw">switch</span> (ri.rl) {</span>
<span class="line" id="L6754">            .ptr =&gt; .{ .ty = (<span class="tok-kw">try</span> ri.rl.resultType(parent_gz, node)).? },</span>
<span class="line" id="L6755">            .inferred_ptr =&gt; .none,</span>
<span class="line" id="L6756">            <span class="tok-kw">else</span> =&gt; ri.rl,</span>
<span class="line" id="L6757">        },</span>
<span class="line" id="L6758">        .ctx = ri.ctx,</span>
<span class="line" id="L6759">    };</span>
<span class="line" id="L6760">    <span class="tok-comment">// We need to call `rvalue` to write through to the pointer only if we had a</span>
</span>
<span class="line" id="L6761">    <span class="tok-comment">// result pointer and aren't forwarding it.</span>
</span>
<span class="line" id="L6762">    <span class="tok-kw">const</span> LocTag = <span class="tok-builtin">@typeInfo</span>(ResultInfo.Loc).Union.tag_type.?;</span>
<span class="line" id="L6763">    <span class="tok-kw">const</span> need_result_rvalue = <span class="tok-builtin">@as</span>(LocTag, block_ri.rl) != <span class="tok-builtin">@as</span>(LocTag, ri.rl);</span>
<span class="line" id="L6764"></span>
<span class="line" id="L6765">    <span class="tok-kw">const</span> is_inline = for_full.inline_token != <span class="tok-null">null</span>;</span>
<span class="line" id="L6766">    <span class="tok-kw">if</span> (parent_gz.is_comptime <span class="tok-kw">and</span> is_inline) {</span>
<span class="line" id="L6767">        <span class="tok-kw">return</span> astgen.failTok(for_full.inline_token.?, <span class="tok-str">&quot;redundant inline keyword in comptime scope&quot;</span>, .{});</span>
<span class="line" id="L6768">    }</span>
<span class="line" id="L6769">    <span class="tok-kw">const</span> tree = astgen.tree;</span>
<span class="line" id="L6770">    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);</span>
<span class="line" id="L6771">    <span class="tok-kw">const</span> node_tags = tree.nodes.items(.tag);</span>
<span class="line" id="L6772">    <span class="tok-kw">const</span> node_data = tree.nodes.items(.data);</span>
<span class="line" id="L6773">    <span class="tok-kw">const</span> gpa = astgen.gpa;</span>
<span class="line" id="L6774"></span>
<span class="line" id="L6775">    <span class="tok-comment">// For counters, this is the start value; for indexables, this is the base</span>
</span>
<span class="line" id="L6776">    <span class="tok-comment">// pointer that can be used with elem_ptr and similar instructions.</span>
</span>
<span class="line" id="L6777">    <span class="tok-comment">// Special value `none` means that this is a counter and its start value is</span>
</span>
<span class="line" id="L6778">    <span class="tok-comment">// zero, indicating that the main index counter can be used directly.</span>
</span>
<span class="line" id="L6779">    <span class="tok-kw">const</span> indexables = <span class="tok-kw">try</span> gpa.alloc(Zir.Inst.Ref, for_full.ast.inputs.len);</span>
<span class="line" id="L6780">    <span class="tok-kw">defer</span> gpa.free(indexables);</span>
<span class="line" id="L6781">    <span class="tok-comment">// elements of this array can be `none`, indicating no length check.</span>
</span>
<span class="line" id="L6782">    <span class="tok-kw">const</span> lens = <span class="tok-kw">try</span> gpa.alloc(Zir.Inst.Ref, for_full.ast.inputs.len);</span>
<span class="line" id="L6783">    <span class="tok-kw">defer</span> gpa.free(lens);</span>
<span class="line" id="L6784"></span>
<span class="line" id="L6785">    <span class="tok-comment">// We will use a single zero-based counter no matter how many indexables there are.</span>
</span>
<span class="line" id="L6786">    <span class="tok-kw">const</span> index_ptr = blk: {</span>
<span class="line" id="L6787">        <span class="tok-kw">const</span> alloc_tag: Zir.Inst.Tag = <span class="tok-kw">if</span> (is_inline) .alloc_comptime_mut <span class="tok-kw">else</span> .alloc;</span>
<span class="line" id="L6788">        <span class="tok-kw">const</span> index_ptr = <span class="tok-kw">try</span> parent_gz.addUnNode(alloc_tag, .usize_type, node);</span>
<span class="line" id="L6789">        <span class="tok-comment">// initialize to zero</span>
</span>
<span class="line" id="L6790">        _ = <span class="tok-kw">try</span> parent_gz.addPlNode(.store_node, node, Zir.Inst.Bin{</span>
<span class="line" id="L6791">            .lhs = index_ptr,</span>
<span class="line" id="L6792">            .rhs = .zero_usize,</span>
<span class="line" id="L6793">        });</span>
<span class="line" id="L6794">        <span class="tok-kw">break</span> :blk index_ptr;</span>
<span class="line" id="L6795">    };</span>
<span class="line" id="L6796"></span>
<span class="line" id="L6797">    <span class="tok-kw">var</span> any_len_checks = <span class="tok-null">false</span>;</span>
<span class="line" id="L6798"></span>
<span class="line" id="L6799">    {</span>
<span class="line" id="L6800">        <span class="tok-kw">var</span> capture_token = for_full.payload_token;</span>
<span class="line" id="L6801">        <span class="tok-kw">for</span> (for_full.ast.inputs, indexables, lens) |input, *indexable_ref, *len_ref| {</span>
<span class="line" id="L6802">            <span class="tok-kw">const</span> capture_is_ref = token_tags[capture_token] == .asterisk;</span>
<span class="line" id="L6803">            <span class="tok-kw">const</span> ident_tok = capture_token + <span class="tok-builtin">@intFromBool</span>(capture_is_ref);</span>
<span class="line" id="L6804">            <span class="tok-kw">const</span> is_discard = mem.eql(<span class="tok-type">u8</span>, tree.tokenSlice(ident_tok), <span class="tok-str">&quot;_&quot;</span>);</span>
<span class="line" id="L6805"></span>
<span class="line" id="L6806">            <span class="tok-kw">if</span> (is_discard <span class="tok-kw">and</span> capture_is_ref) {</span>
<span class="line" id="L6807">                <span class="tok-kw">return</span> astgen.failTok(capture_token, <span class="tok-str">&quot;pointer modifier invalid on discard&quot;</span>, .{});</span>
<span class="line" id="L6808">            }</span>
<span class="line" id="L6809">            <span class="tok-comment">// Skip over the comma, and on to the next capture (or the ending pipe character).</span>
</span>
<span class="line" id="L6810">            capture_token = ident_tok + <span class="tok-number">2</span>;</span>
<span class="line" id="L6811"></span>
<span class="line" id="L6812">            <span class="tok-kw">try</span> emitDbgNode(parent_gz, input);</span>
<span class="line" id="L6813">            <span class="tok-kw">if</span> (node_tags[input] == .for_range) {</span>
<span class="line" id="L6814">                <span class="tok-kw">if</span> (capture_is_ref) {</span>
<span class="line" id="L6815">                    <span class="tok-kw">return</span> astgen.failTok(ident_tok, <span class="tok-str">&quot;cannot capture reference to range&quot;</span>, .{});</span>
<span class="line" id="L6816">                }</span>
<span class="line" id="L6817">                <span class="tok-kw">const</span> start_node = node_data[input].lhs;</span>
<span class="line" id="L6818">                <span class="tok-kw">const</span> start_val = <span class="tok-kw">try</span> expr(parent_gz, scope, .{ .rl = .{ .ty = .usize_type } }, start_node);</span>
<span class="line" id="L6819"></span>
<span class="line" id="L6820">                <span class="tok-kw">const</span> end_node = node_data[input].rhs;</span>
<span class="line" id="L6821">                <span class="tok-kw">const</span> end_val = <span class="tok-kw">if</span> (end_node != <span class="tok-number">0</span>)</span>
<span class="line" id="L6822">                    <span class="tok-kw">try</span> expr(parent_gz, scope, .{ .rl = .{ .ty = .usize_type } }, node_data[input].rhs)</span>
<span class="line" id="L6823">                <span class="tok-kw">else</span></span>
<span class="line" id="L6824">                    .none;</span>
<span class="line" id="L6825"></span>
<span class="line" id="L6826">                <span class="tok-kw">if</span> (end_val == .none <span class="tok-kw">and</span> is_discard) {</span>
<span class="line" id="L6827">                    <span class="tok-kw">return</span> astgen.failTok(ident_tok, <span class="tok-str">&quot;discard of unbounded counter&quot;</span>, .{});</span>
<span class="line" id="L6828">                }</span>
<span class="line" id="L6829"></span>
<span class="line" id="L6830">                <span class="tok-kw">const</span> start_is_zero = nodeIsTriviallyZero(tree, start_node);</span>
<span class="line" id="L6831">                <span class="tok-kw">const</span> range_len = <span class="tok-kw">if</span> (end_val == .none <span class="tok-kw">or</span> start_is_zero)</span>
<span class="line" id="L6832">                    end_val</span>
<span class="line" id="L6833">                <span class="tok-kw">else</span></span>
<span class="line" id="L6834">                    <span class="tok-kw">try</span> parent_gz.addPlNode(.sub, input, Zir.Inst.Bin{</span>
<span class="line" id="L6835">                        .lhs = end_val,</span>
<span class="line" id="L6836">                        .rhs = start_val,</span>
<span class="line" id="L6837">                    });</span>
<span class="line" id="L6838"></span>
<span class="line" id="L6839">                any_len_checks = any_len_checks <span class="tok-kw">or</span> range_len != .none;</span>
<span class="line" id="L6840">                indexable_ref.* = <span class="tok-kw">if</span> (start_is_zero) .none <span class="tok-kw">else</span> start_val;</span>
<span class="line" id="L6841">                len_ref.* = range_len;</span>
<span class="line" id="L6842">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L6843">                <span class="tok-kw">const</span> indexable = <span class="tok-kw">try</span> expr(parent_gz, scope, .{ .rl = .none }, input);</span>
<span class="line" id="L6844"></span>
<span class="line" id="L6845">                any_len_checks = <span class="tok-null">true</span>;</span>
<span class="line" id="L6846">                indexable_ref.* = indexable;</span>
<span class="line" id="L6847">                len_ref.* = indexable;</span>
<span class="line" id="L6848">            }</span>
<span class="line" id="L6849">        }</span>
<span class="line" id="L6850">    }</span>
<span class="line" id="L6851"></span>
<span class="line" id="L6852">    <span class="tok-kw">if</span> (!any_len_checks) {</span>
<span class="line" id="L6853">        <span class="tok-kw">return</span> astgen.failNode(node, <span class="tok-str">&quot;unbounded for loop&quot;</span>, .{});</span>
<span class="line" id="L6854">    }</span>
<span class="line" id="L6855"></span>
<span class="line" id="L6856">    <span class="tok-comment">// We use a dedicated ZIR instruction to assert the lengths to assist with</span>
</span>
<span class="line" id="L6857">    <span class="tok-comment">// nicer error reporting as well as fewer ZIR bytes emitted.</span>
</span>
<span class="line" id="L6858">    <span class="tok-kw">const</span> len: Zir.Inst.Ref = len: {</span>
<span class="line" id="L6859">        <span class="tok-kw">const</span> lens_len: <span class="tok-type">u32</span> = <span class="tok-builtin">@intCast</span>(lens.len);</span>
<span class="line" id="L6860">        <span class="tok-kw">try</span> astgen.extra.ensureUnusedCapacity(gpa, <span class="tok-builtin">@typeInfo</span>(Zir.Inst.MultiOp).Struct.fields.len + lens_len);</span>
<span class="line" id="L6861">        <span class="tok-kw">const</span> len = <span class="tok-kw">try</span> parent_gz.addPlNode(.for_len, node, Zir.Inst.MultiOp{</span>
<span class="line" id="L6862">            .operands_len = lens_len,</span>
<span class="line" id="L6863">        });</span>
<span class="line" id="L6864">        appendRefsAssumeCapacity(astgen, lens);</span>
<span class="line" id="L6865">        <span class="tok-kw">break</span> :len len;</span>
<span class="line" id="L6866">    };</span>
<span class="line" id="L6867"></span>
<span class="line" id="L6868">    <span class="tok-kw">const</span> loop_tag: Zir.Inst.Tag = <span class="tok-kw">if</span> (is_inline) .block_inline <span class="tok-kw">else</span> .loop;</span>
<span class="line" id="L6869">    <span class="tok-kw">const</span> loop_block = <span class="tok-kw">try</span> parent_gz.makeBlockInst(loop_tag, node);</span>
<span class="line" id="L6870">    <span class="tok-kw">try</span> parent_gz.instructions.append(gpa, loop_block);</span>
<span class="line" id="L6871"></span>
<span class="line" id="L6872">    <span class="tok-kw">var</span> loop_scope = parent_gz.makeSubBlock(scope);</span>
<span class="line" id="L6873">    loop_scope.is_inline = is_inline;</span>
<span class="line" id="L6874">    loop_scope.setBreakResultInfo(block_ri);</span>
<span class="line" id="L6875">    <span class="tok-kw">defer</span> loop_scope.unstack();</span>
<span class="line" id="L6876"></span>
<span class="line" id="L6877">    <span class="tok-comment">// We need to finish loop_scope later once we have the deferred refs from then_scope. However, the</span>
</span>
<span class="line" id="L6878">    <span class="tok-comment">// load must be removed from instructions in the meantime or it appears to be part of parent_gz.</span>
</span>
<span class="line" id="L6879">    <span class="tok-kw">const</span> index = <span class="tok-kw">try</span> loop_scope.addUnNode(.load, index_ptr, node);</span>
<span class="line" id="L6880">    _ = loop_scope.instructions.pop();</span>
<span class="line" id="L6881"></span>
<span class="line" id="L6882">    <span class="tok-kw">var</span> cond_scope = parent_gz.makeSubBlock(&amp;loop_scope.base);</span>
<span class="line" id="L6883">    <span class="tok-kw">defer</span> cond_scope.unstack();</span>
<span class="line" id="L6884"></span>
<span class="line" id="L6885">    <span class="tok-comment">// Check the condition.</span>
</span>
<span class="line" id="L6886">    <span class="tok-kw">const</span> cond = <span class="tok-kw">try</span> cond_scope.addPlNode(.cmp_lt, node, Zir.Inst.Bin{</span>
<span class="line" id="L6887">        .lhs = index,</span>
<span class="line" id="L6888">        .rhs = len,</span>
<span class="line" id="L6889">    });</span>
<span class="line" id="L6890"></span>
<span class="line" id="L6891">    <span class="tok-kw">const</span> condbr_tag: Zir.Inst.Tag = <span class="tok-kw">if</span> (is_inline) .condbr_inline <span class="tok-kw">else</span> .condbr;</span>
<span class="line" id="L6892">    <span class="tok-kw">const</span> condbr = <span class="tok-kw">try</span> cond_scope.addCondBr(condbr_tag, node);</span>
<span class="line" id="L6893">    <span class="tok-kw">const</span> block_tag: Zir.Inst.Tag = <span class="tok-kw">if</span> (is_inline) .block_inline <span class="tok-kw">else</span> .block;</span>
<span class="line" id="L6894">    <span class="tok-kw">const</span> cond_block = <span class="tok-kw">try</span> loop_scope.makeBlockInst(block_tag, node);</span>
<span class="line" id="L6895">    <span class="tok-kw">try</span> cond_scope.setBlockBody(cond_block);</span>
<span class="line" id="L6896"></span>
<span class="line" id="L6897">    loop_scope.break_block = loop_block.toOptional();</span>
<span class="line" id="L6898">    loop_scope.continue_block = cond_block.toOptional();</span>
<span class="line" id="L6899">    <span class="tok-kw">if</span> (for_full.label_token) |label_token| {</span>
<span class="line" id="L6900">        loop_scope.label = .{</span>
<span class="line" id="L6901">            .token = label_token,</span>
<span class="line" id="L6902">            .block_inst = loop_block,</span>
<span class="line" id="L6903">        };</span>
<span class="line" id="L6904">    }</span>
<span class="line" id="L6905"></span>
<span class="line" id="L6906">    <span class="tok-kw">const</span> then_node = for_full.ast.then_expr;</span>
<span class="line" id="L6907">    <span class="tok-kw">var</span> then_scope = parent_gz.makeSubBlock(&amp;cond_scope.base);</span>
<span class="line" id="L6908">    <span class="tok-kw">defer</span> then_scope.unstack();</span>
<span class="line" id="L6909"></span>
<span class="line" id="L6910">    <span class="tok-kw">const</span> capture_scopes = <span class="tok-kw">try</span> gpa.alloc(Scope.LocalVal, for_full.ast.inputs.len);</span>
<span class="line" id="L6911">    <span class="tok-kw">defer</span> gpa.free(capture_scopes);</span>
<span class="line" id="L6912"></span>
<span class="line" id="L6913">    <span class="tok-kw">const</span> then_sub_scope = blk: {</span>
<span class="line" id="L6914">        <span class="tok-kw">var</span> capture_token = for_full.payload_token;</span>
<span class="line" id="L6915">        <span class="tok-kw">var</span> capture_sub_scope: *Scope = &amp;then_scope.base;</span>
<span class="line" id="L6916">        <span class="tok-kw">for</span> (for_full.ast.inputs, indexables, capture_scopes) |input, indexable_ref, *capture_scope| {</span>
<span class="line" id="L6917">            <span class="tok-kw">const</span> capture_is_ref = token_tags[capture_token] == .asterisk;</span>
<span class="line" id="L6918">            <span class="tok-kw">const</span> ident_tok = capture_token + <span class="tok-builtin">@intFromBool</span>(capture_is_ref);</span>
<span class="line" id="L6919">            <span class="tok-kw">const</span> capture_name = tree.tokenSlice(ident_tok);</span>
<span class="line" id="L6920">            <span class="tok-comment">// Skip over the comma, and on to the next capture (or the ending pipe character).</span>
</span>
<span class="line" id="L6921">            capture_token = ident_tok + <span class="tok-number">2</span>;</span>
<span class="line" id="L6922"></span>
<span class="line" id="L6923">            <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, capture_name, <span class="tok-str">&quot;_&quot;</span>)) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L6924"></span>
<span class="line" id="L6925">            <span class="tok-kw">const</span> name_str_index = <span class="tok-kw">try</span> astgen.identAsString(ident_tok);</span>
<span class="line" id="L6926">            <span class="tok-kw">try</span> astgen.detectLocalShadowing(capture_sub_scope, name_str_index, ident_tok, capture_name, .capture);</span>
<span class="line" id="L6927"></span>
<span class="line" id="L6928">            <span class="tok-kw">const</span> capture_inst = inst: {</span>
<span class="line" id="L6929">                <span class="tok-kw">const</span> is_counter = node_tags[input] == .for_range;</span>
<span class="line" id="L6930"></span>
<span class="line" id="L6931">                <span class="tok-kw">if</span> (indexable_ref == .none) {</span>
<span class="line" id="L6932">                    <span class="tok-comment">// Special case: the main index can be used directly.</span>
</span>
<span class="line" id="L6933">                    assert(is_counter);</span>
<span class="line" id="L6934">                    assert(!capture_is_ref);</span>
<span class="line" id="L6935">                    <span class="tok-kw">break</span> :inst index;</span>
<span class="line" id="L6936">                }</span>
<span class="line" id="L6937"></span>
<span class="line" id="L6938">                <span class="tok-comment">// For counters, we add the index variable to the start value; for</span>
</span>
<span class="line" id="L6939">                <span class="tok-comment">// indexables, we use it as an element index. This is so similar</span>
</span>
<span class="line" id="L6940">                <span class="tok-comment">// that they can share the same code paths, branching only on the</span>
</span>
<span class="line" id="L6941">                <span class="tok-comment">// ZIR tag.</span>
</span>
<span class="line" id="L6942">                <span class="tok-kw">const</span> switch_cond = (<span class="tok-builtin">@as</span>(<span class="tok-type">u2</span>, <span class="tok-builtin">@intFromBool</span>(capture_is_ref)) &lt;&lt; <span class="tok-number">1</span>) | <span class="tok-builtin">@intFromBool</span>(is_counter);</span>
<span class="line" id="L6943">                <span class="tok-kw">const</span> tag: Zir.Inst.Tag = <span class="tok-kw">switch</span> (switch_cond) {</span>
<span class="line" id="L6944">                    <span class="tok-number">0b00</span> =&gt; .elem_val,</span>
<span class="line" id="L6945">                    <span class="tok-number">0b01</span> =&gt; .add,</span>
<span class="line" id="L6946">                    <span class="tok-number">0b10</span> =&gt; .elem_ptr,</span>
<span class="line" id="L6947">                    <span class="tok-number">0b11</span> =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// compile error emitted already</span>
</span>
<span class="line" id="L6948">                };</span>
<span class="line" id="L6949">                <span class="tok-kw">break</span> :inst <span class="tok-kw">try</span> then_scope.addPlNode(tag, input, Zir.Inst.Bin{</span>
<span class="line" id="L6950">                    .lhs = indexable_ref,</span>
<span class="line" id="L6951">                    .rhs = index,</span>
<span class="line" id="L6952">                });</span>
<span class="line" id="L6953">            };</span>
<span class="line" id="L6954"></span>
<span class="line" id="L6955">            capture_scope.* = .{</span>
<span class="line" id="L6956">                .parent = capture_sub_scope,</span>
<span class="line" id="L6957">                .gen_zir = &amp;then_scope,</span>
<span class="line" id="L6958">                .name = name_str_index,</span>
<span class="line" id="L6959">                .inst = capture_inst,</span>
<span class="line" id="L6960">                .token_src = ident_tok,</span>
<span class="line" id="L6961">                .id_cat = .capture,</span>
<span class="line" id="L6962">            };</span>
<span class="line" id="L6963"></span>
<span class="line" id="L6964">            <span class="tok-kw">try</span> then_scope.addDbgVar(.dbg_var_val, name_str_index, capture_inst);</span>
<span class="line" id="L6965">            capture_sub_scope = &amp;capture_scope.base;</span>
<span class="line" id="L6966">        }</span>
<span class="line" id="L6967"></span>
<span class="line" id="L6968">        <span class="tok-kw">break</span> :blk capture_sub_scope;</span>
<span class="line" id="L6969">    };</span>
<span class="line" id="L6970"></span>
<span class="line" id="L6971">    <span class="tok-kw">const</span> then_result = <span class="tok-kw">try</span> fullBodyExpr(&amp;then_scope, then_sub_scope, .{ .rl = .none }, then_node);</span>
<span class="line" id="L6972">    _ = <span class="tok-kw">try</span> addEnsureResult(&amp;then_scope, then_result, then_node);</span>
<span class="line" id="L6973"></span>
<span class="line" id="L6974">    <span class="tok-kw">try</span> checkUsed(parent_gz, &amp;then_scope.base, then_sub_scope);</span>
<span class="line" id="L6975"></span>
<span class="line" id="L6976">    <span class="tok-kw">const</span> break_tag: Zir.Inst.Tag = <span class="tok-kw">if</span> (is_inline) .break_inline <span class="tok-kw">else</span> .@&quot;break&quot;;</span>
<span class="line" id="L6977"></span>
<span class="line" id="L6978">    _ = <span class="tok-kw">try</span> then_scope.addBreak(break_tag, cond_block, .void_value);</span>
<span class="line" id="L6979"></span>
<span class="line" id="L6980">    <span class="tok-kw">var</span> else_scope = parent_gz.makeSubBlock(&amp;cond_scope.base);</span>
<span class="line" id="L6981">    <span class="tok-kw">defer</span> else_scope.unstack();</span>
<span class="line" id="L6982"></span>
<span class="line" id="L6983">    <span class="tok-kw">const</span> else_node = for_full.ast.else_expr;</span>
<span class="line" id="L6984">    <span class="tok-kw">if</span> (else_node != <span class="tok-number">0</span>) {</span>
<span class="line" id="L6985">        <span class="tok-kw">const</span> sub_scope = &amp;else_scope.base;</span>
<span class="line" id="L6986">        <span class="tok-comment">// Remove the continue block and break block so that `continue` and `break`</span>
</span>
<span class="line" id="L6987">        <span class="tok-comment">// control flow apply to outer loops; not this one.</span>
</span>
<span class="line" id="L6988">        loop_scope.continue_block = .none;</span>
<span class="line" id="L6989">        loop_scope.break_block = .none;</span>
<span class="line" id="L6990">        <span class="tok-kw">const</span> else_result = <span class="tok-kw">try</span> fullBodyExpr(&amp;else_scope, sub_scope, loop_scope.break_result_info, else_node);</span>
<span class="line" id="L6991">        <span class="tok-kw">if</span> (is_statement) {</span>
<span class="line" id="L6992">            _ = <span class="tok-kw">try</span> addEnsureResult(&amp;else_scope, else_result, else_node);</span>
<span class="line" id="L6993">        }</span>
<span class="line" id="L6994">        <span class="tok-kw">if</span> (!else_scope.endsWithNoReturn()) {</span>
<span class="line" id="L6995">            _ = <span class="tok-kw">try</span> else_scope.addBreakWithSrcNode(break_tag, loop_block, else_result, else_node);</span>
<span class="line" id="L6996">        }</span>
<span class="line" id="L6997">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L6998">        <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> rvalue(&amp;else_scope, ri, .void_value, node);</span>
<span class="line" id="L6999">        _ = <span class="tok-kw">try</span> else_scope.addBreak(break_tag, loop_block, result);</span>
<span class="line" id="L7000">    }</span>
<span class="line" id="L7001"></span>
<span class="line" id="L7002">    <span class="tok-kw">if</span> (loop_scope.label) |some| {</span>
<span class="line" id="L7003">        <span class="tok-kw">if</span> (!some.used) {</span>
<span class="line" id="L7004">            <span class="tok-kw">try</span> astgen.appendErrorTok(some.token, <span class="tok-str">&quot;unused for loop label&quot;</span>, .{});</span>
<span class="line" id="L7005">        }</span>
<span class="line" id="L7006">    }</span>
<span class="line" id="L7007"></span>
<span class="line" id="L7008">    <span class="tok-kw">try</span> setCondBrPayload(condbr, cond, &amp;then_scope, &amp;else_scope);</span>
<span class="line" id="L7009"></span>
<span class="line" id="L7010">    <span class="tok-comment">// then_block and else_block unstacked now, can resurrect loop_scope to finally finish it</span>
</span>
<span class="line" id="L7011">    {</span>
<span class="line" id="L7012">        loop_scope.instructions_top = loop_scope.instructions.items.len;</span>
<span class="line" id="L7013">        <span class="tok-kw">try</span> loop_scope.instructions.appendSlice(gpa, &amp;.{ index.toIndex().?, cond_block });</span>
<span class="line" id="L7014"></span>
<span class="line" id="L7015">        <span class="tok-comment">// Increment the index variable.</span>
</span>
<span class="line" id="L7016">        <span class="tok-kw">const</span> index_plus_one = <span class="tok-kw">try</span> loop_scope.addPlNode(.add_unsafe, node, Zir.Inst.Bin{</span>
<span class="line" id="L7017">            .lhs = index,</span>
<span class="line" id="L7018">            .rhs = .one_usize,</span>
<span class="line" id="L7019">        });</span>
<span class="line" id="L7020">        _ = <span class="tok-kw">try</span> loop_scope.addPlNode(.store_node, node, Zir.Inst.Bin{</span>
<span class="line" id="L7021">            .lhs = index_ptr,</span>
<span class="line" id="L7022">            .rhs = index_plus_one,</span>
<span class="line" id="L7023">        });</span>
<span class="line" id="L7024">        <span class="tok-kw">const</span> repeat_tag: Zir.Inst.Tag = <span class="tok-kw">if</span> (is_inline) .repeat_inline <span class="tok-kw">else</span> .repeat;</span>
<span class="line" id="L7025">        _ = <span class="tok-kw">try</span> loop_scope.addNode(repeat_tag, node);</span>
<span class="line" id="L7026"></span>
<span class="line" id="L7027">        <span class="tok-kw">try</span> loop_scope.setBlockBody(loop_block);</span>
<span class="line" id="L7028">    }</span>
<span class="line" id="L7029"></span>
<span class="line" id="L7030">    <span class="tok-kw">const</span> result = <span class="tok-kw">if</span> (need_result_rvalue)</span>
<span class="line" id="L7031">        <span class="tok-kw">try</span> rvalue(parent_gz, ri, loop_block.toRef(), node)</span>
<span class="line" id="L7032">    <span class="tok-kw">else</span></span>
<span class="line" id="L7033">        loop_block.toRef();</span>
<span class="line" id="L7034"></span>
<span class="line" id="L7035">    <span class="tok-kw">if</span> (is_statement) {</span>
<span class="line" id="L7036">        _ = <span class="tok-kw">try</span> parent_gz.addUnNode(.ensure_result_used, result, node);</span>
<span class="line" id="L7037">    }</span>
<span class="line" id="L7038">    <span class="tok-kw">return</span> result;</span>
<span class="line" id="L7039">}</span>
<span class="line" id="L7040"></span>
<span class="line" id="L7041"><span class="tok-kw">fn</span> <span class="tok-fn">switchExprErrUnion</span>(</span>
<span class="line" id="L7042">    parent_gz: *GenZir,</span>
<span class="line" id="L7043">    scope: *Scope,</span>
<span class="line" id="L7044">    ri: ResultInfo,</span>
<span class="line" id="L7045">    catch_or_if_node: Ast.Node.Index,</span>
<span class="line" id="L7046">    node_ty: <span class="tok-kw">enum</span> { @&quot;catch&quot;, @&quot;if&quot; },</span>
<span class="line" id="L7047">) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L7048">    <span class="tok-kw">const</span> astgen = parent_gz.astgen;</span>
<span class="line" id="L7049">    <span class="tok-kw">const</span> gpa = astgen.gpa;</span>
<span class="line" id="L7050">    <span class="tok-kw">const</span> tree = astgen.tree;</span>
<span class="line" id="L7051">    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);</span>
<span class="line" id="L7052">    <span class="tok-kw">const</span> node_tags = tree.nodes.items(.tag);</span>
<span class="line" id="L7053">    <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);</span>
<span class="line" id="L7054">    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);</span>
<span class="line" id="L7055"></span>
<span class="line" id="L7056">    <span class="tok-kw">const</span> if_full = <span class="tok-kw">switch</span> (node_ty) {</span>
<span class="line" id="L7057">        .@&quot;catch&quot; =&gt; <span class="tok-null">undefined</span>,</span>
<span class="line" id="L7058">        .@&quot;if&quot; =&gt; tree.fullIf(catch_or_if_node).?,</span>
<span class="line" id="L7059">    };</span>
<span class="line" id="L7060"></span>
<span class="line" id="L7061">    <span class="tok-kw">const</span> switch_node, <span class="tok-kw">const</span> operand_node, <span class="tok-kw">const</span> error_payload = <span class="tok-kw">switch</span> (node_ty) {</span>
<span class="line" id="L7062">        .@&quot;catch&quot; =&gt; .{</span>
<span class="line" id="L7063">            node_datas[catch_or_if_node].rhs,</span>
<span class="line" id="L7064">            node_datas[catch_or_if_node].lhs,</span>
<span class="line" id="L7065">            main_tokens[catch_or_if_node] + <span class="tok-number">2</span>,</span>
<span class="line" id="L7066">        },</span>
<span class="line" id="L7067">        .@&quot;if&quot; =&gt; .{</span>
<span class="line" id="L7068">            if_full.ast.else_expr,</span>
<span class="line" id="L7069">            if_full.ast.cond_expr,</span>
<span class="line" id="L7070">            if_full.error_token.?,</span>
<span class="line" id="L7071">        },</span>
<span class="line" id="L7072">    };</span>
<span class="line" id="L7073">    assert(node_tags[switch_node] == .@&quot;switch&quot; <span class="tok-kw">or</span> node_tags[switch_node] == .switch_comma);</span>
<span class="line" id="L7074"></span>
<span class="line" id="L7075">    <span class="tok-kw">const</span> do_err_trace = astgen.fn_block != <span class="tok-null">null</span>;</span>
<span class="line" id="L7076"></span>
<span class="line" id="L7077">    <span class="tok-kw">const</span> extra = tree.extraData(node_datas[switch_node].rhs, Ast.Node.SubRange);</span>
<span class="line" id="L7078">    <span class="tok-kw">const</span> case_nodes = tree.extra_data[extra.start..extra.end];</span>
<span class="line" id="L7079"></span>
<span class="line" id="L7080">    <span class="tok-kw">const</span> need_rl = astgen.nodes_need_rl.contains(catch_or_if_node);</span>
<span class="line" id="L7081">    <span class="tok-kw">const</span> block_ri: ResultInfo = <span class="tok-kw">if</span> (need_rl) ri <span class="tok-kw">else</span> .{</span>
<span class="line" id="L7082">        .rl = <span class="tok-kw">switch</span> (ri.rl) {</span>
<span class="line" id="L7083">            .ptr =&gt; .{ .ty = (<span class="tok-kw">try</span> ri.rl.resultType(parent_gz, catch_or_if_node)).? },</span>
<span class="line" id="L7084">            .inferred_ptr =&gt; .none,</span>
<span class="line" id="L7085">            <span class="tok-kw">else</span> =&gt; ri.rl,</span>
<span class="line" id="L7086">        },</span>
<span class="line" id="L7087">        .ctx = ri.ctx,</span>
<span class="line" id="L7088">    };</span>
<span class="line" id="L7089"></span>
<span class="line" id="L7090">    <span class="tok-kw">const</span> payload_is_ref = node_ty == .@&quot;if&quot; <span class="tok-kw">and</span></span>
<span class="line" id="L7091">        if_full.payload_token != <span class="tok-null">null</span> <span class="tok-kw">and</span> token_tags[if_full.payload_token.?] == .asterisk;</span>
<span class="line" id="L7092"></span>
<span class="line" id="L7093">    <span class="tok-comment">// We need to call `rvalue` to write through to the pointer only if we had a</span>
</span>
<span class="line" id="L7094">    <span class="tok-comment">// result pointer and aren't forwarding it.</span>
</span>
<span class="line" id="L7095">    <span class="tok-kw">const</span> LocTag = <span class="tok-builtin">@typeInfo</span>(ResultInfo.Loc).Union.tag_type.?;</span>
<span class="line" id="L7096">    <span class="tok-kw">const</span> need_result_rvalue = <span class="tok-builtin">@as</span>(LocTag, block_ri.rl) != <span class="tok-builtin">@as</span>(LocTag, ri.rl);</span>
<span class="line" id="L7097">    <span class="tok-kw">var</span> scalar_cases_len: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L7098">    <span class="tok-kw">var</span> multi_cases_len: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L7099">    <span class="tok-kw">var</span> inline_cases_len: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L7100">    <span class="tok-kw">var</span> has_else = <span class="tok-null">false</span>;</span>
<span class="line" id="L7101">    <span class="tok-kw">var</span> else_node: Ast.Node.Index = <span class="tok-number">0</span>;</span>
<span class="line" id="L7102">    <span class="tok-kw">var</span> else_src: ?Ast.TokenIndex = <span class="tok-null">null</span>;</span>
<span class="line" id="L7103">    <span class="tok-kw">for</span> (case_nodes) |case_node| {</span>
<span class="line" id="L7104">        <span class="tok-kw">const</span> case = tree.fullSwitchCase(case_node).?;</span>
<span class="line" id="L7105"></span>
<span class="line" id="L7106">        <span class="tok-kw">if</span> (case.ast.values.len == <span class="tok-number">0</span>) {</span>
<span class="line" id="L7107">            <span class="tok-kw">const</span> case_src = case.ast.arrow_token - <span class="tok-number">1</span>;</span>
<span class="line" id="L7108">            <span class="tok-kw">if</span> (else_src) |src| {</span>
<span class="line" id="L7109">                <span class="tok-kw">return</span> astgen.failTokNotes(</span>
<span class="line" id="L7110">                    case_src,</span>
<span class="line" id="L7111">                    <span class="tok-str">&quot;multiple else prongs in switch expression&quot;</span>,</span>
<span class="line" id="L7112">                    .{},</span>
<span class="line" id="L7113">                    &amp;[_]<span class="tok-type">u32</span>{</span>
<span class="line" id="L7114">                        <span class="tok-kw">try</span> astgen.errNoteTok(</span>
<span class="line" id="L7115">                            src,</span>
<span class="line" id="L7116">                            <span class="tok-str">&quot;previous else prong here&quot;</span>,</span>
<span class="line" id="L7117">                            .{},</span>
<span class="line" id="L7118">                        ),</span>
<span class="line" id="L7119">                    },</span>
<span class="line" id="L7120">                );</span>
<span class="line" id="L7121">            }</span>
<span class="line" id="L7122">            has_else = <span class="tok-null">true</span>;</span>
<span class="line" id="L7123">            else_node = case_node;</span>
<span class="line" id="L7124">            else_src = case_src;</span>
<span class="line" id="L7125">            <span class="tok-kw">continue</span>;</span>
<span class="line" id="L7126">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (case.ast.values.len == <span class="tok-number">1</span> <span class="tok-kw">and</span></span>
<span class="line" id="L7127">            node_tags[case.ast.values[<span class="tok-number">0</span>]] == .identifier <span class="tok-kw">and</span></span>
<span class="line" id="L7128">            mem.eql(<span class="tok-type">u8</span>, tree.tokenSlice(main_tokens[case.ast.values[<span class="tok-number">0</span>]]), <span class="tok-str">&quot;_&quot;</span>))</span>
<span class="line" id="L7129">        {</span>
<span class="line" id="L7130">            <span class="tok-kw">const</span> case_src = case.ast.arrow_token - <span class="tok-number">1</span>;</span>
<span class="line" id="L7131">            <span class="tok-kw">return</span> astgen.failTokNotes(</span>
<span class="line" id="L7132">                case_src,</span>
<span class="line" id="L7133">                <span class="tok-str">&quot;'_' prong is not allowed when switching on errors&quot;</span>,</span>
<span class="line" id="L7134">                .{},</span>
<span class="line" id="L7135">                &amp;[_]<span class="tok-type">u32</span>{</span>
<span class="line" id="L7136">                    <span class="tok-kw">try</span> astgen.errNoteTok(</span>
<span class="line" id="L7137">                        case_src,</span>
<span class="line" id="L7138">                        <span class="tok-str">&quot;consider using 'else'&quot;</span>,</span>
<span class="line" id="L7139">                        .{},</span>
<span class="line" id="L7140">                    ),</span>
<span class="line" id="L7141">                },</span>
<span class="line" id="L7142">            );</span>
<span class="line" id="L7143">        }</span>
<span class="line" id="L7144"></span>
<span class="line" id="L7145">        <span class="tok-kw">for</span> (case.ast.values) |val| {</span>
<span class="line" id="L7146">            <span class="tok-kw">if</span> (node_tags[val] == .string_literal)</span>
<span class="line" id="L7147">                <span class="tok-kw">return</span> astgen.failNode(val, <span class="tok-str">&quot;cannot switch on strings&quot;</span>, .{});</span>
<span class="line" id="L7148">        }</span>
<span class="line" id="L7149"></span>
<span class="line" id="L7150">        <span class="tok-kw">if</span> (case.ast.values.len == <span class="tok-number">1</span> <span class="tok-kw">and</span> node_tags[case.ast.values[<span class="tok-number">0</span>]] != .switch_range) {</span>
<span class="line" id="L7151">            scalar_cases_len += <span class="tok-number">1</span>;</span>
<span class="line" id="L7152">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L7153">            multi_cases_len += <span class="tok-number">1</span>;</span>
<span class="line" id="L7154">        }</span>
<span class="line" id="L7155">        <span class="tok-kw">if</span> (case.inline_token != <span class="tok-null">null</span>) {</span>
<span class="line" id="L7156">            inline_cases_len += <span class="tok-number">1</span>;</span>
<span class="line" id="L7157">        }</span>
<span class="line" id="L7158">    }</span>
<span class="line" id="L7159"></span>
<span class="line" id="L7160">    <span class="tok-kw">const</span> operand_ri: ResultInfo = .{</span>
<span class="line" id="L7161">        .rl = <span class="tok-kw">if</span> (payload_is_ref) .ref <span class="tok-kw">else</span> .none,</span>
<span class="line" id="L7162">        .ctx = .error_handling_expr,</span>
<span class="line" id="L7163">    };</span>
<span class="line" id="L7164"></span>
<span class="line" id="L7165">    astgen.advanceSourceCursorToNode(operand_node);</span>
<span class="line" id="L7166">    <span class="tok-kw">const</span> operand_lc = LineColumn{ astgen.source_line - parent_gz.decl_line, astgen.source_column };</span>
<span class="line" id="L7167"></span>
<span class="line" id="L7168">    <span class="tok-kw">const</span> raw_operand = <span class="tok-kw">try</span> reachableExpr(parent_gz, scope, operand_ri, operand_node, switch_node);</span>
<span class="line" id="L7169">    <span class="tok-kw">const</span> item_ri: ResultInfo = .{ .rl = .none };</span>
<span class="line" id="L7170"></span>
<span class="line" id="L7171">    <span class="tok-comment">// This contains the data that goes into the `extra` array for the SwitchBlockErrUnion, except</span>
</span>
<span class="line" id="L7172">    <span class="tok-comment">// the first cases_nodes.len slots are a table that indexes payloads later in the array,</span>
</span>
<span class="line" id="L7173">    <span class="tok-comment">// with the non-error and else case indices coming first, then scalar_cases_len indexes, then</span>
</span>
<span class="line" id="L7174">    <span class="tok-comment">// multi_cases_len indexes</span>
</span>
<span class="line" id="L7175">    <span class="tok-kw">const</span> payloads = &amp;astgen.scratch;</span>
<span class="line" id="L7176">    <span class="tok-kw">const</span> scratch_top = astgen.scratch.items.len;</span>
<span class="line" id="L7177">    <span class="tok-kw">const</span> case_table_start = scratch_top;</span>
<span class="line" id="L7178">    <span class="tok-kw">const</span> scalar_case_table = case_table_start + <span class="tok-number">1</span> + <span class="tok-builtin">@intFromBool</span>(has_else);</span>
<span class="line" id="L7179">    <span class="tok-kw">const</span> multi_case_table = scalar_case_table + scalar_cases_len;</span>
<span class="line" id="L7180">    <span class="tok-kw">const</span> case_table_end = multi_case_table + multi_cases_len;</span>
<span class="line" id="L7181"></span>
<span class="line" id="L7182">    <span class="tok-kw">try</span> astgen.scratch.resize(gpa, case_table_end);</span>
<span class="line" id="L7183">    <span class="tok-kw">defer</span> astgen.scratch.items.len = scratch_top;</span>
<span class="line" id="L7184"></span>
<span class="line" id="L7185">    <span class="tok-kw">var</span> block_scope = parent_gz.makeSubBlock(scope);</span>
<span class="line" id="L7186">    <span class="tok-comment">// block_scope not used for collecting instructions</span>
</span>
<span class="line" id="L7187">    block_scope.instructions_top = GenZir.unstacked_top;</span>
<span class="line" id="L7188">    block_scope.setBreakResultInfo(block_ri);</span>
<span class="line" id="L7189"></span>
<span class="line" id="L7190">    <span class="tok-comment">// Sema expects a dbg_stmt immediately before switch_block_err_union</span>
</span>
<span class="line" id="L7191">    <span class="tok-kw">try</span> emitDbgStmtForceCurrentIndex(parent_gz, operand_lc);</span>
<span class="line" id="L7192">    <span class="tok-comment">// This gets added to the parent block later, after the item expressions.</span>
</span>
<span class="line" id="L7193">    <span class="tok-kw">const</span> switch_block = <span class="tok-kw">try</span> parent_gz.makeBlockInst(.switch_block_err_union, switch_node);</span>
<span class="line" id="L7194"></span>
<span class="line" id="L7195">    <span class="tok-comment">// We re-use this same scope for all cases, including the special prong, if any.</span>
</span>
<span class="line" id="L7196">    <span class="tok-kw">var</span> case_scope = parent_gz.makeSubBlock(&amp;block_scope.base);</span>
<span class="line" id="L7197">    case_scope.instructions_top = GenZir.unstacked_top;</span>
<span class="line" id="L7198"></span>
<span class="line" id="L7199">    {</span>
<span class="line" id="L7200">        <span class="tok-kw">const</span> body_len_index: <span class="tok-type">u32</span> = <span class="tok-builtin">@intCast</span>(payloads.items.len);</span>
<span class="line" id="L7201">        payloads.items[case_table_start] = body_len_index;</span>
<span class="line" id="L7202">        <span class="tok-kw">try</span> payloads.resize(gpa, body_len_index + <span class="tok-number">1</span>); <span class="tok-comment">// body_len</span>
</span>
<span class="line" id="L7203"></span>
<span class="line" id="L7204">        case_scope.instructions_top = parent_gz.instructions.items.len;</span>
<span class="line" id="L7205">        <span class="tok-kw">defer</span> case_scope.unstack();</span>
<span class="line" id="L7206"></span>
<span class="line" id="L7207">        <span class="tok-kw">const</span> unwrap_payload_tag: Zir.Inst.Tag = <span class="tok-kw">if</span> (payload_is_ref)</span>
<span class="line" id="L7208">            .err_union_payload_unsafe_ptr</span>
<span class="line" id="L7209">        <span class="tok-kw">else</span></span>
<span class="line" id="L7210">            .err_union_payload_unsafe;</span>
<span class="line" id="L7211"></span>
<span class="line" id="L7212">        <span class="tok-kw">const</span> unwrapped_payload = <span class="tok-kw">try</span> case_scope.addUnNode(</span>
<span class="line" id="L7213">            unwrap_payload_tag,</span>
<span class="line" id="L7214">            raw_operand,</span>
<span class="line" id="L7215">            catch_or_if_node,</span>
<span class="line" id="L7216">        );</span>
<span class="line" id="L7217"></span>
<span class="line" id="L7218">        <span class="tok-kw">switch</span> (node_ty) {</span>
<span class="line" id="L7219">            .@&quot;catch&quot; =&gt; {</span>
<span class="line" id="L7220">                <span class="tok-kw">const</span> case_result = <span class="tok-kw">switch</span> (ri.rl) {</span>
<span class="line" id="L7221">                    .ref, .ref_coerced_ty =&gt; unwrapped_payload,</span>
<span class="line" id="L7222">                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">try</span> rvalue(</span>
<span class="line" id="L7223">                        &amp;case_scope,</span>
<span class="line" id="L7224">                        block_scope.break_result_info,</span>
<span class="line" id="L7225">                        unwrapped_payload,</span>
<span class="line" id="L7226">                        catch_or_if_node,</span>
<span class="line" id="L7227">                    ),</span>
<span class="line" id="L7228">                };</span>
<span class="line" id="L7229">                _ = <span class="tok-kw">try</span> case_scope.addBreakWithSrcNode(</span>
<span class="line" id="L7230">                    .@&quot;break&quot;,</span>
<span class="line" id="L7231">                    switch_block,</span>
<span class="line" id="L7232">                    case_result,</span>
<span class="line" id="L7233">                    catch_or_if_node,</span>
<span class="line" id="L7234">                );</span>
<span class="line" id="L7235">            },</span>
<span class="line" id="L7236">            .@&quot;if&quot; =&gt; {</span>
<span class="line" id="L7237">                <span class="tok-kw">var</span> payload_val_scope: Scope.LocalVal = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L7238"></span>
<span class="line" id="L7239">                <span class="tok-kw">const</span> then_node = if_full.ast.then_expr;</span>
<span class="line" id="L7240">                <span class="tok-kw">const</span> then_sub_scope = s: {</span>
<span class="line" id="L7241">                    assert(if_full.error_token != <span class="tok-null">null</span>);</span>
<span class="line" id="L7242">                    <span class="tok-kw">if</span> (if_full.payload_token) |payload_token| {</span>
<span class="line" id="L7243">                        <span class="tok-kw">const</span> token_name_index = payload_token + <span class="tok-builtin">@intFromBool</span>(payload_is_ref);</span>
<span class="line" id="L7244">                        <span class="tok-kw">const</span> ident_name = <span class="tok-kw">try</span> astgen.identAsString(token_name_index);</span>
<span class="line" id="L7245">                        <span class="tok-kw">const</span> token_name_str = tree.tokenSlice(token_name_index);</span>
<span class="line" id="L7246">                        <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, <span class="tok-str">&quot;_&quot;</span>, token_name_str))</span>
<span class="line" id="L7247">                            <span class="tok-kw">break</span> :s &amp;case_scope.base;</span>
<span class="line" id="L7248">                        <span class="tok-kw">try</span> astgen.detectLocalShadowing(</span>
<span class="line" id="L7249">                            &amp;case_scope.base,</span>
<span class="line" id="L7250">                            ident_name,</span>
<span class="line" id="L7251">                            token_name_index,</span>
<span class="line" id="L7252">                            token_name_str,</span>
<span class="line" id="L7253">                            .capture,</span>
<span class="line" id="L7254">                        );</span>
<span class="line" id="L7255">                        payload_val_scope = .{</span>
<span class="line" id="L7256">                            .parent = &amp;case_scope.base,</span>
<span class="line" id="L7257">                            .gen_zir = &amp;case_scope,</span>
<span class="line" id="L7258">                            .name = ident_name,</span>
<span class="line" id="L7259">                            .inst = unwrapped_payload,</span>
<span class="line" id="L7260">                            .token_src = token_name_index,</span>
<span class="line" id="L7261">                            .id_cat = .capture,</span>
<span class="line" id="L7262">                        };</span>
<span class="line" id="L7263">                        <span class="tok-kw">try</span> case_scope.addDbgVar(.dbg_var_val, ident_name, unwrapped_payload);</span>
<span class="line" id="L7264">                        <span class="tok-kw">break</span> :s &amp;payload_val_scope.base;</span>
<span class="line" id="L7265">                    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L7266">                        _ = <span class="tok-kw">try</span> case_scope.addUnNode(</span>
<span class="line" id="L7267">                            .ensure_err_union_payload_void,</span>
<span class="line" id="L7268">                            raw_operand,</span>
<span class="line" id="L7269">                            catch_or_if_node,</span>
<span class="line" id="L7270">                        );</span>
<span class="line" id="L7271">                        <span class="tok-kw">break</span> :s &amp;case_scope.base;</span>
<span class="line" id="L7272">                    }</span>
<span class="line" id="L7273">                };</span>
<span class="line" id="L7274">                <span class="tok-kw">const</span> then_result = <span class="tok-kw">try</span> expr(</span>
<span class="line" id="L7275">                    &amp;case_scope,</span>
<span class="line" id="L7276">                    then_sub_scope,</span>
<span class="line" id="L7277">                    block_scope.break_result_info,</span>
<span class="line" id="L7278">                    then_node,</span>
<span class="line" id="L7279">                );</span>
<span class="line" id="L7280">                <span class="tok-kw">try</span> checkUsed(parent_gz, &amp;case_scope.base, then_sub_scope);</span>
<span class="line" id="L7281">                <span class="tok-kw">if</span> (!case_scope.endsWithNoReturn()) {</span>
<span class="line" id="L7282">                    _ = <span class="tok-kw">try</span> case_scope.addBreakWithSrcNode(</span>
<span class="line" id="L7283">                        .@&quot;break&quot;,</span>
<span class="line" id="L7284">                        switch_block,</span>
<span class="line" id="L7285">                        then_result,</span>
<span class="line" id="L7286">                        then_node,</span>
<span class="line" id="L7287">                    );</span>
<span class="line" id="L7288">                }</span>
<span class="line" id="L7289">            },</span>
<span class="line" id="L7290">        }</span>
<span class="line" id="L7291"></span>
<span class="line" id="L7292">        <span class="tok-kw">const</span> case_slice = case_scope.instructionsSlice();</span>
<span class="line" id="L7293">        <span class="tok-comment">// Since we use the switch_block_err_union instruction itself to refer</span>
</span>
<span class="line" id="L7294">        <span class="tok-comment">// to the capture, which will not be added to the child block, we need</span>
</span>
<span class="line" id="L7295">        <span class="tok-comment">// to handle ref_table manually.</span>
</span>
<span class="line" id="L7296">        <span class="tok-kw">const</span> refs_len = refs: {</span>
<span class="line" id="L7297">            <span class="tok-kw">var</span> n: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L7298">            <span class="tok-kw">var</span> check_inst = switch_block;</span>
<span class="line" id="L7299">            <span class="tok-kw">while</span> (astgen.ref_table.get(check_inst)) |ref_inst| {</span>
<span class="line" id="L7300">                n += <span class="tok-number">1</span>;</span>
<span class="line" id="L7301">                check_inst = ref_inst;</span>
<span class="line" id="L7302">            }</span>
<span class="line" id="L7303">            <span class="tok-kw">break</span> :refs n;</span>
<span class="line" id="L7304">        };</span>
<span class="line" id="L7305">        <span class="tok-kw">const</span> body_len = refs_len + astgen.countBodyLenAfterFixups(case_slice);</span>
<span class="line" id="L7306">        <span class="tok-kw">try</span> payloads.ensureUnusedCapacity(gpa, body_len);</span>
<span class="line" id="L7307">        <span class="tok-kw">const</span> capture: Zir.Inst.SwitchBlock.ProngInfo.Capture = <span class="tok-kw">switch</span> (node_ty) {</span>
<span class="line" id="L7308">            .@&quot;catch&quot; =&gt; .none,</span>
<span class="line" id="L7309">            .@&quot;if&quot; =&gt; <span class="tok-kw">if</span> (if_full.payload_token == <span class="tok-null">null</span>)</span>
<span class="line" id="L7310">                .none</span>
<span class="line" id="L7311">            <span class="tok-kw">else</span> <span class="tok-kw">if</span> (payload_is_ref)</span>
<span class="line" id="L7312">                .by_ref</span>
<span class="line" id="L7313">            <span class="tok-kw">else</span></span>
<span class="line" id="L7314">                .by_val,</span>
<span class="line" id="L7315">        };</span>
<span class="line" id="L7316">        payloads.items[body_len_index] = <span class="tok-builtin">@bitCast</span>(Zir.Inst.SwitchBlock.ProngInfo{</span>
<span class="line" id="L7317">            .body_len = <span class="tok-builtin">@intCast</span>(body_len),</span>
<span class="line" id="L7318">            .capture = capture,</span>
<span class="line" id="L7319">            .is_inline = <span class="tok-null">false</span>,</span>
<span class="line" id="L7320">            .has_tag_capture = <span class="tok-null">false</span>,</span>
<span class="line" id="L7321">        });</span>
<span class="line" id="L7322">        <span class="tok-kw">if</span> (astgen.ref_table.fetchRemove(switch_block)) |kv| {</span>
<span class="line" id="L7323">            appendPossiblyRefdBodyInst(astgen, payloads, kv.value);</span>
<span class="line" id="L7324">        }</span>
<span class="line" id="L7325">        appendBodyWithFixupsArrayList(astgen, payloads, case_slice);</span>
<span class="line" id="L7326">    }</span>
<span class="line" id="L7327"></span>
<span class="line" id="L7328">    <span class="tok-kw">const</span> err_name = blk: {</span>
<span class="line" id="L7329">        <span class="tok-kw">const</span> err_str = tree.tokenSlice(error_payload);</span>
<span class="line" id="L7330">        <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, err_str, <span class="tok-str">&quot;_&quot;</span>)) {</span>
<span class="line" id="L7331">            <span class="tok-kw">return</span> astgen.failTok(error_payload, <span class="tok-str">&quot;discard of error capture; omit it instead&quot;</span>, .{});</span>
<span class="line" id="L7332">        }</span>
<span class="line" id="L7333">        <span class="tok-kw">const</span> err_name = <span class="tok-kw">try</span> astgen.identAsString(error_payload);</span>
<span class="line" id="L7334">        <span class="tok-kw">try</span> astgen.detectLocalShadowing(scope, err_name, error_payload, err_str, .capture);</span>
<span class="line" id="L7335"></span>
<span class="line" id="L7336">        <span class="tok-kw">break</span> :blk err_name;</span>
<span class="line" id="L7337">    };</span>
<span class="line" id="L7338"></span>
<span class="line" id="L7339">    <span class="tok-comment">// allocate a shared dummy instruction for the error capture</span>
</span>
<span class="line" id="L7340">    <span class="tok-kw">const</span> err_inst = err_inst: {</span>
<span class="line" id="L7341">        <span class="tok-kw">const</span> inst: Zir.Inst.Index = <span class="tok-builtin">@enumFromInt</span>(astgen.instructions.len);</span>
<span class="line" id="L7342">        <span class="tok-kw">try</span> astgen.instructions.append(astgen.gpa, .{</span>
<span class="line" id="L7343">            .tag = .extended,</span>
<span class="line" id="L7344">            .data = .{ .extended = .{</span>
<span class="line" id="L7345">                .opcode = .value_placeholder,</span>
<span class="line" id="L7346">                .small = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L7347">                .operand = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L7348">            } },</span>
<span class="line" id="L7349">        });</span>
<span class="line" id="L7350">        <span class="tok-kw">break</span> :err_inst inst;</span>
<span class="line" id="L7351">    };</span>
<span class="line" id="L7352"></span>
<span class="line" id="L7353">    <span class="tok-comment">// In this pass we generate all the item and prong expressions for error cases.</span>
</span>
<span class="line" id="L7354">    <span class="tok-kw">var</span> multi_case_index: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L7355">    <span class="tok-kw">var</span> scalar_case_index: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L7356">    <span class="tok-kw">var</span> any_uses_err_capture = <span class="tok-null">false</span>;</span>
<span class="line" id="L7357">    <span class="tok-kw">for</span> (case_nodes) |case_node| {</span>
<span class="line" id="L7358">        <span class="tok-kw">const</span> case = tree.fullSwitchCase(case_node).?;</span>
<span class="line" id="L7359"></span>
<span class="line" id="L7360">        <span class="tok-kw">const</span> is_multi_case = case.ast.values.len &gt; <span class="tok-number">1</span> <span class="tok-kw">or</span></span>
<span class="line" id="L7361">            (case.ast.values.len == <span class="tok-number">1</span> <span class="tok-kw">and</span> node_tags[case.ast.values[<span class="tok-number">0</span>]] == .switch_range);</span>
<span class="line" id="L7362"></span>
<span class="line" id="L7363">        <span class="tok-kw">var</span> dbg_var_name: Zir.NullTerminatedString = .empty;</span>
<span class="line" id="L7364">        <span class="tok-kw">var</span> dbg_var_inst: Zir.Inst.Ref = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L7365">        <span class="tok-kw">var</span> err_scope: Scope.LocalVal = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L7366">        <span class="tok-kw">var</span> capture_scope: Scope.LocalVal = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L7367"></span>
<span class="line" id="L7368">        <span class="tok-kw">const</span> sub_scope = blk: {</span>
<span class="line" id="L7369">            err_scope = .{</span>
<span class="line" id="L7370">                .parent = &amp;case_scope.base,</span>
<span class="line" id="L7371">                .gen_zir = &amp;case_scope,</span>
<span class="line" id="L7372">                .name = err_name,</span>
<span class="line" id="L7373">                .inst = err_inst.toRef(),</span>
<span class="line" id="L7374">                .token_src = error_payload,</span>
<span class="line" id="L7375">                .id_cat = .capture,</span>
<span class="line" id="L7376">            };</span>
<span class="line" id="L7377"></span>
<span class="line" id="L7378">            <span class="tok-kw">const</span> capture_token = case.payload_token <span class="tok-kw">orelse</span> <span class="tok-kw">break</span> :blk &amp;err_scope.base;</span>
<span class="line" id="L7379">            <span class="tok-kw">if</span> (token_tags[capture_token] != .identifier) {</span>
<span class="line" id="L7380">                <span class="tok-kw">return</span> astgen.failTok(capture_token + <span class="tok-number">1</span>, <span class="tok-str">&quot;error set cannot be captured by reference&quot;</span>, .{});</span>
<span class="line" id="L7381">            }</span>
<span class="line" id="L7382"></span>
<span class="line" id="L7383">            <span class="tok-kw">const</span> capture_slice = tree.tokenSlice(capture_token);</span>
<span class="line" id="L7384">            <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, capture_slice, <span class="tok-str">&quot;_&quot;</span>)) {</span>
<span class="line" id="L7385">                <span class="tok-kw">return</span> astgen.failTok(capture_token, <span class="tok-str">&quot;discard of error capture; omit it instead&quot;</span>, .{});</span>
<span class="line" id="L7386">            }</span>
<span class="line" id="L7387">            <span class="tok-kw">const</span> tag_name = <span class="tok-kw">try</span> astgen.identAsString(capture_token);</span>
<span class="line" id="L7388">            <span class="tok-kw">try</span> astgen.detectLocalShadowing(&amp;case_scope.base, tag_name, capture_token, capture_slice, .capture);</span>
<span class="line" id="L7389"></span>
<span class="line" id="L7390">            capture_scope = .{</span>
<span class="line" id="L7391">                .parent = &amp;case_scope.base,</span>
<span class="line" id="L7392">                .gen_zir = &amp;case_scope,</span>
<span class="line" id="L7393">                .name = tag_name,</span>
<span class="line" id="L7394">                .inst = switch_block.toRef(),</span>
<span class="line" id="L7395">                .token_src = capture_token,</span>
<span class="line" id="L7396">                .id_cat = .capture,</span>
<span class="line" id="L7397">            };</span>
<span class="line" id="L7398">            dbg_var_name = tag_name;</span>
<span class="line" id="L7399">            dbg_var_inst = switch_block.toRef();</span>
<span class="line" id="L7400"></span>
<span class="line" id="L7401">            err_scope.parent = &amp;capture_scope.base;</span>
<span class="line" id="L7402"></span>
<span class="line" id="L7403">            <span class="tok-kw">break</span> :blk &amp;err_scope.base;</span>
<span class="line" id="L7404">        };</span>
<span class="line" id="L7405"></span>
<span class="line" id="L7406">        <span class="tok-kw">const</span> header_index: <span class="tok-type">u32</span> = <span class="tok-builtin">@intCast</span>(payloads.items.len);</span>
<span class="line" id="L7407">        <span class="tok-kw">const</span> body_len_index = <span class="tok-kw">if</span> (is_multi_case) blk: {</span>
<span class="line" id="L7408">            payloads.items[multi_case_table + multi_case_index] = header_index;</span>
<span class="line" id="L7409">            multi_case_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L7410">            <span class="tok-kw">try</span> payloads.resize(gpa, header_index + <span class="tok-number">3</span>); <span class="tok-comment">// items_len, ranges_len, body_len</span>
</span>
<span class="line" id="L7411"></span>
<span class="line" id="L7412">            <span class="tok-comment">// items</span>
</span>
<span class="line" id="L7413">            <span class="tok-kw">var</span> items_len: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L7414">            <span class="tok-kw">for</span> (case.ast.values) |item_node| {</span>
<span class="line" id="L7415">                <span class="tok-kw">if</span> (node_tags[item_node] == .switch_range) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L7416">                items_len += <span class="tok-number">1</span>;</span>
<span class="line" id="L7417"></span>
<span class="line" id="L7418">                <span class="tok-kw">const</span> item_inst = <span class="tok-kw">try</span> comptimeExpr(parent_gz, scope, item_ri, item_node);</span>
<span class="line" id="L7419">                <span class="tok-kw">try</span> payloads.append(gpa, <span class="tok-builtin">@intFromEnum</span>(item_inst));</span>
<span class="line" id="L7420">            }</span>
<span class="line" id="L7421"></span>
<span class="line" id="L7422">            <span class="tok-comment">// ranges</span>
</span>
<span class="line" id="L7423">            <span class="tok-kw">var</span> ranges_len: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L7424">            <span class="tok-kw">for</span> (case.ast.values) |range| {</span>
<span class="line" id="L7425">                <span class="tok-kw">if</span> (node_tags[range] != .switch_range) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L7426">                ranges_len += <span class="tok-number">1</span>;</span>
<span class="line" id="L7427"></span>
<span class="line" id="L7428">                <span class="tok-kw">const</span> first = <span class="tok-kw">try</span> comptimeExpr(parent_gz, scope, item_ri, node_datas[range].lhs);</span>
<span class="line" id="L7429">                <span class="tok-kw">const</span> last = <span class="tok-kw">try</span> comptimeExpr(parent_gz, scope, item_ri, node_datas[range].rhs);</span>
<span class="line" id="L7430">                <span class="tok-kw">try</span> payloads.appendSlice(gpa, &amp;[_]<span class="tok-type">u32</span>{</span>
<span class="line" id="L7431">                    <span class="tok-builtin">@intFromEnum</span>(first), <span class="tok-builtin">@intFromEnum</span>(last),</span>
<span class="line" id="L7432">                });</span>
<span class="line" id="L7433">            }</span>
<span class="line" id="L7434"></span>
<span class="line" id="L7435">            payloads.items[header_index] = items_len;</span>
<span class="line" id="L7436">            payloads.items[header_index + <span class="tok-number">1</span>] = ranges_len;</span>
<span class="line" id="L7437">            <span class="tok-kw">break</span> :blk header_index + <span class="tok-number">2</span>;</span>
<span class="line" id="L7438">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (case_node == else_node) blk: {</span>
<span class="line" id="L7439">            payloads.items[case_table_start + <span class="tok-number">1</span>] = header_index;</span>
<span class="line" id="L7440">            <span class="tok-kw">try</span> payloads.resize(gpa, header_index + <span class="tok-number">1</span>); <span class="tok-comment">// body_len</span>
</span>
<span class="line" id="L7441">            <span class="tok-kw">break</span> :blk header_index;</span>
<span class="line" id="L7442">        } <span class="tok-kw">else</span> blk: {</span>
<span class="line" id="L7443">            payloads.items[scalar_case_table + scalar_case_index] = header_index;</span>
<span class="line" id="L7444">            scalar_case_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L7445">            <span class="tok-kw">try</span> payloads.resize(gpa, header_index + <span class="tok-number">2</span>); <span class="tok-comment">// item, body_len</span>
</span>
<span class="line" id="L7446">            <span class="tok-kw">const</span> item_node = case.ast.values[<span class="tok-number">0</span>];</span>
<span class="line" id="L7447">            <span class="tok-kw">const</span> item_inst = <span class="tok-kw">try</span> comptimeExpr(parent_gz, scope, item_ri, item_node);</span>
<span class="line" id="L7448">            payloads.items[header_index] = <span class="tok-builtin">@intFromEnum</span>(item_inst);</span>
<span class="line" id="L7449">            <span class="tok-kw">break</span> :blk header_index + <span class="tok-number">1</span>;</span>
<span class="line" id="L7450">        };</span>
<span class="line" id="L7451"></span>
<span class="line" id="L7452">        {</span>
<span class="line" id="L7453">            <span class="tok-comment">// temporarily stack case_scope on parent_gz</span>
</span>
<span class="line" id="L7454">            case_scope.instructions_top = parent_gz.instructions.items.len;</span>
<span class="line" id="L7455">            <span class="tok-kw">defer</span> case_scope.unstack();</span>
<span class="line" id="L7456"></span>
<span class="line" id="L7457">            <span class="tok-kw">if</span> (do_err_trace <span class="tok-kw">and</span> nodeMayAppendToErrorTrace(tree, operand_node))</span>
<span class="line" id="L7458">                _ = <span class="tok-kw">try</span> case_scope.addSaveErrRetIndex(.always);</span>
<span class="line" id="L7459"></span>
<span class="line" id="L7460">            <span class="tok-kw">if</span> (dbg_var_name != .empty) {</span>
<span class="line" id="L7461">                <span class="tok-kw">try</span> case_scope.addDbgVar(.dbg_var_val, dbg_var_name, dbg_var_inst);</span>
<span class="line" id="L7462">            }</span>
<span class="line" id="L7463"></span>
<span class="line" id="L7464">            <span class="tok-kw">const</span> target_expr_node = case.ast.target_expr;</span>
<span class="line" id="L7465">            <span class="tok-kw">const</span> case_result = <span class="tok-kw">try</span> fullBodyExpr(&amp;case_scope, sub_scope, block_scope.break_result_info, target_expr_node);</span>
<span class="line" id="L7466">            <span class="tok-comment">// check capture_scope, not err_scope to avoid false positive unused error capture</span>
</span>
<span class="line" id="L7467">            <span class="tok-kw">try</span> checkUsed(parent_gz, &amp;case_scope.base, err_scope.parent);</span>
<span class="line" id="L7468">            <span class="tok-kw">const</span> uses_err = err_scope.used != <span class="tok-number">0</span> <span class="tok-kw">or</span> err_scope.discarded != <span class="tok-number">0</span>;</span>
<span class="line" id="L7469">            <span class="tok-kw">if</span> (uses_err) {</span>
<span class="line" id="L7470">                <span class="tok-kw">try</span> case_scope.addDbgVar(.dbg_var_val, err_name, err_inst.toRef());</span>
<span class="line" id="L7471">                any_uses_err_capture = <span class="tok-null">true</span>;</span>
<span class="line" id="L7472">            }</span>
<span class="line" id="L7473"></span>
<span class="line" id="L7474">            <span class="tok-kw">if</span> (!parent_gz.refIsNoReturn(case_result)) {</span>
<span class="line" id="L7475">                <span class="tok-kw">if</span> (do_err_trace)</span>
<span class="line" id="L7476">                    <span class="tok-kw">try</span> restoreErrRetIndex(</span>
<span class="line" id="L7477">                        &amp;case_scope,</span>
<span class="line" id="L7478">                        .{ .block = switch_block },</span>
<span class="line" id="L7479">                        block_scope.break_result_info,</span>
<span class="line" id="L7480">                        target_expr_node,</span>
<span class="line" id="L7481">                        case_result,</span>
<span class="line" id="L7482">                    );</span>
<span class="line" id="L7483"></span>
<span class="line" id="L7484">                _ = <span class="tok-kw">try</span> case_scope.addBreakWithSrcNode(.@&quot;break&quot;, switch_block, case_result, target_expr_node);</span>
<span class="line" id="L7485">            }</span>
<span class="line" id="L7486"></span>
<span class="line" id="L7487">            <span class="tok-kw">const</span> case_slice = case_scope.instructionsSlice();</span>
<span class="line" id="L7488">            <span class="tok-comment">// Since we use the switch_block_err_union instruction itself to refer</span>
</span>
<span class="line" id="L7489">            <span class="tok-comment">// to the capture, which will not be added to the child block, we need</span>
</span>
<span class="line" id="L7490">            <span class="tok-comment">// to handle ref_table manually.</span>
</span>
<span class="line" id="L7491">            <span class="tok-kw">const</span> refs_len = refs: {</span>
<span class="line" id="L7492">                <span class="tok-kw">var</span> n: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L7493">                <span class="tok-kw">var</span> check_inst = switch_block;</span>
<span class="line" id="L7494">                <span class="tok-kw">while</span> (astgen.ref_table.get(check_inst)) |ref_inst| {</span>
<span class="line" id="L7495">                    n += <span class="tok-number">1</span>;</span>
<span class="line" id="L7496">                    check_inst = ref_inst;</span>
<span class="line" id="L7497">                }</span>
<span class="line" id="L7498">                <span class="tok-kw">if</span> (uses_err) {</span>
<span class="line" id="L7499">                    check_inst = err_inst;</span>
<span class="line" id="L7500">                    <span class="tok-kw">while</span> (astgen.ref_table.get(check_inst)) |ref_inst| {</span>
<span class="line" id="L7501">                        n += <span class="tok-number">1</span>;</span>
<span class="line" id="L7502">                        check_inst = ref_inst;</span>
<span class="line" id="L7503">                    }</span>
<span class="line" id="L7504">                }</span>
<span class="line" id="L7505">                <span class="tok-kw">break</span> :refs n;</span>
<span class="line" id="L7506">            };</span>
<span class="line" id="L7507">            <span class="tok-kw">const</span> body_len = refs_len + astgen.countBodyLenAfterFixups(case_slice);</span>
<span class="line" id="L7508">            <span class="tok-kw">try</span> payloads.ensureUnusedCapacity(gpa, body_len);</span>
<span class="line" id="L7509">            payloads.items[body_len_index] = <span class="tok-builtin">@bitCast</span>(Zir.Inst.SwitchBlock.ProngInfo{</span>
<span class="line" id="L7510">                .body_len = <span class="tok-builtin">@intCast</span>(body_len),</span>
<span class="line" id="L7511">                .capture = <span class="tok-kw">if</span> (case.payload_token != <span class="tok-null">null</span>) .by_val <span class="tok-kw">else</span> .none,</span>
<span class="line" id="L7512">                .is_inline = case.inline_token != <span class="tok-null">null</span>,</span>
<span class="line" id="L7513">                .has_tag_capture = <span class="tok-null">false</span>,</span>
<span class="line" id="L7514">            });</span>
<span class="line" id="L7515">            <span class="tok-kw">if</span> (astgen.ref_table.fetchRemove(switch_block)) |kv| {</span>
<span class="line" id="L7516">                appendPossiblyRefdBodyInst(astgen, payloads, kv.value);</span>
<span class="line" id="L7517">            }</span>
<span class="line" id="L7518">            <span class="tok-kw">if</span> (uses_err) {</span>
<span class="line" id="L7519">                <span class="tok-kw">if</span> (astgen.ref_table.fetchRemove(err_inst)) |kv| {</span>
<span class="line" id="L7520">                    appendPossiblyRefdBodyInst(astgen, payloads, kv.value);</span>
<span class="line" id="L7521">                }</span>
<span class="line" id="L7522">            }</span>
<span class="line" id="L7523">            appendBodyWithFixupsArrayList(astgen, payloads, case_slice);</span>
<span class="line" id="L7524">        }</span>
<span class="line" id="L7525">    }</span>
<span class="line" id="L7526">    <span class="tok-comment">// Now that the item expressions are generated we can add this.</span>
</span>
<span class="line" id="L7527">    <span class="tok-kw">try</span> parent_gz.instructions.append(gpa, switch_block);</span>
<span class="line" id="L7528"></span>
<span class="line" id="L7529">    <span class="tok-kw">try</span> astgen.extra.ensureUnusedCapacity(gpa, <span class="tok-builtin">@typeInfo</span>(Zir.Inst.SwitchBlockErrUnion).Struct.fields.len +</span>
<span class="line" id="L7530">        <span class="tok-builtin">@intFromBool</span>(multi_cases_len != <span class="tok-number">0</span>) +</span>
<span class="line" id="L7531">        payloads.items.len - case_table_end +</span>
<span class="line" id="L7532">        (case_table_end - case_table_start) * <span class="tok-builtin">@typeInfo</span>(Zir.Inst.As).Struct.fields.len);</span>
<span class="line" id="L7533"></span>
<span class="line" id="L7534">    <span class="tok-kw">const</span> payload_index = astgen.addExtraAssumeCapacity(Zir.Inst.SwitchBlockErrUnion{</span>
<span class="line" id="L7535">        .operand = raw_operand,</span>
<span class="line" id="L7536">        .bits = Zir.Inst.SwitchBlockErrUnion.Bits{</span>
<span class="line" id="L7537">            .has_multi_cases = multi_cases_len != <span class="tok-number">0</span>,</span>
<span class="line" id="L7538">            .has_else = has_else,</span>
<span class="line" id="L7539">            .scalar_cases_len = <span class="tok-builtin">@intCast</span>(scalar_cases_len),</span>
<span class="line" id="L7540">            .any_uses_err_capture = any_uses_err_capture,</span>
<span class="line" id="L7541">            .payload_is_ref = payload_is_ref,</span>
<span class="line" id="L7542">        },</span>
<span class="line" id="L7543">        .main_src_node_offset = parent_gz.nodeIndexToRelative(catch_or_if_node),</span>
<span class="line" id="L7544">    });</span>
<span class="line" id="L7545"></span>
<span class="line" id="L7546">    <span class="tok-kw">if</span> (multi_cases_len != <span class="tok-number">0</span>) {</span>
<span class="line" id="L7547">        astgen.extra.appendAssumeCapacity(multi_cases_len);</span>
<span class="line" id="L7548">    }</span>
<span class="line" id="L7549"></span>
<span class="line" id="L7550">    <span class="tok-kw">if</span> (any_uses_err_capture) {</span>
<span class="line" id="L7551">        astgen.extra.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(err_inst));</span>
<span class="line" id="L7552">    }</span>
<span class="line" id="L7553"></span>
<span class="line" id="L7554">    <span class="tok-kw">const</span> zir_datas = astgen.instructions.items(.data);</span>
<span class="line" id="L7555">    zir_datas[<span class="tok-builtin">@intFromEnum</span>(switch_block)].pl_node.payload_index = payload_index;</span>
<span class="line" id="L7556"></span>
<span class="line" id="L7557">    <span class="tok-kw">for</span> (payloads.items[case_table_start..case_table_end], <span class="tok-number">0</span>..) |start_index, i| {</span>
<span class="line" id="L7558">        <span class="tok-kw">var</span> body_len_index = start_index;</span>
<span class="line" id="L7559">        <span class="tok-kw">var</span> end_index = start_index;</span>
<span class="line" id="L7560">        <span class="tok-kw">const</span> table_index = case_table_start + i;</span>
<span class="line" id="L7561">        <span class="tok-kw">if</span> (table_index &lt; scalar_case_table) {</span>
<span class="line" id="L7562">            end_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L7563">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (table_index &lt; multi_case_table) {</span>
<span class="line" id="L7564">            body_len_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L7565">            end_index += <span class="tok-number">2</span>;</span>
<span class="line" id="L7566">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L7567">            body_len_index += <span class="tok-number">2</span>;</span>
<span class="line" id="L7568">            <span class="tok-kw">const</span> items_len = payloads.items[start_index];</span>
<span class="line" id="L7569">            <span class="tok-kw">const</span> ranges_len = payloads.items[start_index + <span class="tok-number">1</span>];</span>
<span class="line" id="L7570">            end_index += <span class="tok-number">3</span> + items_len + <span class="tok-number">2</span> * ranges_len;</span>
<span class="line" id="L7571">        }</span>
<span class="line" id="L7572">        <span class="tok-kw">const</span> prong_info: Zir.Inst.SwitchBlock.ProngInfo = <span class="tok-builtin">@bitCast</span>(payloads.items[body_len_index]);</span>
<span class="line" id="L7573">        end_index += prong_info.body_len;</span>
<span class="line" id="L7574">        astgen.extra.appendSliceAssumeCapacity(payloads.items[start_index..end_index]);</span>
<span class="line" id="L7575">    }</span>
<span class="line" id="L7576"></span>
<span class="line" id="L7577">    <span class="tok-kw">if</span> (need_result_rvalue) {</span>
<span class="line" id="L7578">        <span class="tok-kw">return</span> rvalue(parent_gz, ri, switch_block.toRef(), switch_node);</span>
<span class="line" id="L7579">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L7580">        <span class="tok-kw">return</span> switch_block.toRef();</span>
<span class="line" id="L7581">    }</span>
<span class="line" id="L7582">}</span>
<span class="line" id="L7583"></span>
<span class="line" id="L7584"><span class="tok-kw">fn</span> <span class="tok-fn">switchExpr</span>(</span>
<span class="line" id="L7585">    parent_gz: *GenZir,</span>
<span class="line" id="L7586">    scope: *Scope,</span>
<span class="line" id="L7587">    ri: ResultInfo,</span>
<span class="line" id="L7588">    switch_node: Ast.Node.Index,</span>
<span class="line" id="L7589">) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L7590">    <span class="tok-kw">const</span> astgen = parent_gz.astgen;</span>
<span class="line" id="L7591">    <span class="tok-kw">const</span> gpa = astgen.gpa;</span>
<span class="line" id="L7592">    <span class="tok-kw">const</span> tree = astgen.tree;</span>
<span class="line" id="L7593">    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);</span>
<span class="line" id="L7594">    <span class="tok-kw">const</span> node_tags = tree.nodes.items(.tag);</span>
<span class="line" id="L7595">    <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);</span>
<span class="line" id="L7596">    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);</span>
<span class="line" id="L7597">    <span class="tok-kw">const</span> operand_node = node_datas[switch_node].lhs;</span>
<span class="line" id="L7598">    <span class="tok-kw">const</span> extra = tree.extraData(node_datas[switch_node].rhs, Ast.Node.SubRange);</span>
<span class="line" id="L7599">    <span class="tok-kw">const</span> case_nodes = tree.extra_data[extra.start..extra.end];</span>
<span class="line" id="L7600"></span>
<span class="line" id="L7601">    <span class="tok-kw">const</span> need_rl = astgen.nodes_need_rl.contains(switch_node);</span>
<span class="line" id="L7602">    <span class="tok-kw">const</span> block_ri: ResultInfo = <span class="tok-kw">if</span> (need_rl) ri <span class="tok-kw">else</span> .{</span>
<span class="line" id="L7603">        .rl = <span class="tok-kw">switch</span> (ri.rl) {</span>
<span class="line" id="L7604">            .ptr =&gt; .{ .ty = (<span class="tok-kw">try</span> ri.rl.resultType(parent_gz, switch_node)).? },</span>
<span class="line" id="L7605">            .inferred_ptr =&gt; .none,</span>
<span class="line" id="L7606">            <span class="tok-kw">else</span> =&gt; ri.rl,</span>
<span class="line" id="L7607">        },</span>
<span class="line" id="L7608">        .ctx = ri.ctx,</span>
<span class="line" id="L7609">    };</span>
<span class="line" id="L7610">    <span class="tok-comment">// We need to call `rvalue` to write through to the pointer only if we had a</span>
</span>
<span class="line" id="L7611">    <span class="tok-comment">// result pointer and aren't forwarding it.</span>
</span>
<span class="line" id="L7612">    <span class="tok-kw">const</span> LocTag = <span class="tok-builtin">@typeInfo</span>(ResultInfo.Loc).Union.tag_type.?;</span>
<span class="line" id="L7613">    <span class="tok-kw">const</span> need_result_rvalue = <span class="tok-builtin">@as</span>(LocTag, block_ri.rl) != <span class="tok-builtin">@as</span>(LocTag, ri.rl);</span>
<span class="line" id="L7614"></span>
<span class="line" id="L7615">    <span class="tok-comment">// We perform two passes over the AST. This first pass is to collect information</span>
</span>
<span class="line" id="L7616">    <span class="tok-comment">// for the following variables, make note of the special prong AST node index,</span>
</span>
<span class="line" id="L7617">    <span class="tok-comment">// and bail out with a compile error if there are multiple special prongs present.</span>
</span>
<span class="line" id="L7618">    <span class="tok-kw">var</span> any_payload_is_ref = <span class="tok-null">false</span>;</span>
<span class="line" id="L7619">    <span class="tok-kw">var</span> any_has_tag_capture = <span class="tok-null">false</span>;</span>
<span class="line" id="L7620">    <span class="tok-kw">var</span> scalar_cases_len: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L7621">    <span class="tok-kw">var</span> multi_cases_len: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L7622">    <span class="tok-kw">var</span> inline_cases_len: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L7623">    <span class="tok-kw">var</span> special_prong: Zir.SpecialProng = .none;</span>
<span class="line" id="L7624">    <span class="tok-kw">var</span> special_node: Ast.Node.Index = <span class="tok-number">0</span>;</span>
<span class="line" id="L7625">    <span class="tok-kw">var</span> else_src: ?Ast.TokenIndex = <span class="tok-null">null</span>;</span>
<span class="line" id="L7626">    <span class="tok-kw">var</span> underscore_src: ?Ast.TokenIndex = <span class="tok-null">null</span>;</span>
<span class="line" id="L7627">    <span class="tok-kw">for</span> (case_nodes) |case_node| {</span>
<span class="line" id="L7628">        <span class="tok-kw">const</span> case = tree.fullSwitchCase(case_node).?;</span>
<span class="line" id="L7629">        <span class="tok-kw">if</span> (case.payload_token) |payload_token| {</span>
<span class="line" id="L7630">            <span class="tok-kw">const</span> ident = <span class="tok-kw">if</span> (token_tags[payload_token] == .asterisk) blk: {</span>
<span class="line" id="L7631">                any_payload_is_ref = <span class="tok-null">true</span>;</span>
<span class="line" id="L7632">                <span class="tok-kw">break</span> :blk payload_token + <span class="tok-number">1</span>;</span>
<span class="line" id="L7633">            } <span class="tok-kw">else</span> payload_token;</span>
<span class="line" id="L7634">            <span class="tok-kw">if</span> (token_tags[ident + <span class="tok-number">1</span>] == .comma) {</span>
<span class="line" id="L7635">                any_has_tag_capture = <span class="tok-null">true</span>;</span>
<span class="line" id="L7636">            }</span>
<span class="line" id="L7637">        }</span>
<span class="line" id="L7638">        <span class="tok-comment">// Check for else/`_` prong.</span>
</span>
<span class="line" id="L7639">        <span class="tok-kw">if</span> (case.ast.values.len == <span class="tok-number">0</span>) {</span>
<span class="line" id="L7640">            <span class="tok-kw">const</span> case_src = case.ast.arrow_token - <span class="tok-number">1</span>;</span>
<span class="line" id="L7641">            <span class="tok-kw">if</span> (else_src) |src| {</span>
<span class="line" id="L7642">                <span class="tok-kw">return</span> astgen.failTokNotes(</span>
<span class="line" id="L7643">                    case_src,</span>
<span class="line" id="L7644">                    <span class="tok-str">&quot;multiple else prongs in switch expression&quot;</span>,</span>
<span class="line" id="L7645">                    .{},</span>
<span class="line" id="L7646">                    &amp;[_]<span class="tok-type">u32</span>{</span>
<span class="line" id="L7647">                        <span class="tok-kw">try</span> astgen.errNoteTok(</span>
<span class="line" id="L7648">                            src,</span>
<span class="line" id="L7649">                            <span class="tok-str">&quot;previous else prong here&quot;</span>,</span>
<span class="line" id="L7650">                            .{},</span>
<span class="line" id="L7651">                        ),</span>
<span class="line" id="L7652">                    },</span>
<span class="line" id="L7653">                );</span>
<span class="line" id="L7654">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (underscore_src) |some_underscore| {</span>
<span class="line" id="L7655">                <span class="tok-kw">return</span> astgen.failNodeNotes(</span>
<span class="line" id="L7656">                    switch_node,</span>
<span class="line" id="L7657">                    <span class="tok-str">&quot;else and '_' prong in switch expression&quot;</span>,</span>
<span class="line" id="L7658">                    .{},</span>
<span class="line" id="L7659">                    &amp;[_]<span class="tok-type">u32</span>{</span>
<span class="line" id="L7660">                        <span class="tok-kw">try</span> astgen.errNoteTok(</span>
<span class="line" id="L7661">                            case_src,</span>
<span class="line" id="L7662">                            <span class="tok-str">&quot;else prong here&quot;</span>,</span>
<span class="line" id="L7663">                            .{},</span>
<span class="line" id="L7664">                        ),</span>
<span class="line" id="L7665">                        <span class="tok-kw">try</span> astgen.errNoteTok(</span>
<span class="line" id="L7666">                            some_underscore,</span>
<span class="line" id="L7667">                            <span class="tok-str">&quot;'_' prong here&quot;</span>,</span>
<span class="line" id="L7668">                            .{},</span>
<span class="line" id="L7669">                        ),</span>
<span class="line" id="L7670">                    },</span>
<span class="line" id="L7671">                );</span>
<span class="line" id="L7672">            }</span>
<span class="line" id="L7673">            special_node = case_node;</span>
<span class="line" id="L7674">            special_prong = .@&quot;else&quot;;</span>
<span class="line" id="L7675">            else_src = case_src;</span>
<span class="line" id="L7676">            <span class="tok-kw">continue</span>;</span>
<span class="line" id="L7677">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (case.ast.values.len == <span class="tok-number">1</span> <span class="tok-kw">and</span></span>
<span class="line" id="L7678">            node_tags[case.ast.values[<span class="tok-number">0</span>]] == .identifier <span class="tok-kw">and</span></span>
<span class="line" id="L7679">            mem.eql(<span class="tok-type">u8</span>, tree.tokenSlice(main_tokens[case.ast.values[<span class="tok-number">0</span>]]), <span class="tok-str">&quot;_&quot;</span>))</span>
<span class="line" id="L7680">        {</span>
<span class="line" id="L7681">            <span class="tok-kw">const</span> case_src = case.ast.arrow_token - <span class="tok-number">1</span>;</span>
<span class="line" id="L7682">            <span class="tok-kw">if</span> (underscore_src) |src| {</span>
<span class="line" id="L7683">                <span class="tok-kw">return</span> astgen.failTokNotes(</span>
<span class="line" id="L7684">                    case_src,</span>
<span class="line" id="L7685">                    <span class="tok-str">&quot;multiple '_' prongs in switch expression&quot;</span>,</span>
<span class="line" id="L7686">                    .{},</span>
<span class="line" id="L7687">                    &amp;[_]<span class="tok-type">u32</span>{</span>
<span class="line" id="L7688">                        <span class="tok-kw">try</span> astgen.errNoteTok(</span>
<span class="line" id="L7689">                            src,</span>
<span class="line" id="L7690">                            <span class="tok-str">&quot;previous '_' prong here&quot;</span>,</span>
<span class="line" id="L7691">                            .{},</span>
<span class="line" id="L7692">                        ),</span>
<span class="line" id="L7693">                    },</span>
<span class="line" id="L7694">                );</span>
<span class="line" id="L7695">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (else_src) |some_else| {</span>
<span class="line" id="L7696">                <span class="tok-kw">return</span> astgen.failNodeNotes(</span>
<span class="line" id="L7697">                    switch_node,</span>
<span class="line" id="L7698">                    <span class="tok-str">&quot;else and '_' prong in switch expression&quot;</span>,</span>
<span class="line" id="L7699">                    .{},</span>
<span class="line" id="L7700">                    &amp;[_]<span class="tok-type">u32</span>{</span>
<span class="line" id="L7701">                        <span class="tok-kw">try</span> astgen.errNoteTok(</span>
<span class="line" id="L7702">                            some_else,</span>
<span class="line" id="L7703">                            <span class="tok-str">&quot;else prong here&quot;</span>,</span>
<span class="line" id="L7704">                            .{},</span>
<span class="line" id="L7705">                        ),</span>
<span class="line" id="L7706">                        <span class="tok-kw">try</span> astgen.errNoteTok(</span>
<span class="line" id="L7707">                            case_src,</span>
<span class="line" id="L7708">                            <span class="tok-str">&quot;'_' prong here&quot;</span>,</span>
<span class="line" id="L7709">                            .{},</span>
<span class="line" id="L7710">                        ),</span>
<span class="line" id="L7711">                    },</span>
<span class="line" id="L7712">                );</span>
<span class="line" id="L7713">            }</span>
<span class="line" id="L7714">            <span class="tok-kw">if</span> (case.inline_token != <span class="tok-null">null</span>) {</span>
<span class="line" id="L7715">                <span class="tok-kw">return</span> astgen.failTok(case_src, <span class="tok-str">&quot;cannot inline '_' prong&quot;</span>, .{});</span>
<span class="line" id="L7716">            }</span>
<span class="line" id="L7717">            special_node = case_node;</span>
<span class="line" id="L7718">            special_prong = .under;</span>
<span class="line" id="L7719">            underscore_src = case_src;</span>
<span class="line" id="L7720">            <span class="tok-kw">continue</span>;</span>
<span class="line" id="L7721">        }</span>
<span class="line" id="L7722"></span>
<span class="line" id="L7723">        <span class="tok-kw">for</span> (case.ast.values) |val| {</span>
<span class="line" id="L7724">            <span class="tok-kw">if</span> (node_tags[val] == .string_literal)</span>
<span class="line" id="L7725">                <span class="tok-kw">return</span> astgen.failNode(val, <span class="tok-str">&quot;cannot switch on strings&quot;</span>, .{});</span>
<span class="line" id="L7726">        }</span>
<span class="line" id="L7727"></span>
<span class="line" id="L7728">        <span class="tok-kw">if</span> (case.ast.values.len == <span class="tok-number">1</span> <span class="tok-kw">and</span> node_tags[case.ast.values[<span class="tok-number">0</span>]] != .switch_range) {</span>
<span class="line" id="L7729">            scalar_cases_len += <span class="tok-number">1</span>;</span>
<span class="line" id="L7730">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L7731">            multi_cases_len += <span class="tok-number">1</span>;</span>
<span class="line" id="L7732">        }</span>
<span class="line" id="L7733">        <span class="tok-kw">if</span> (case.inline_token != <span class="tok-null">null</span>) {</span>
<span class="line" id="L7734">            inline_cases_len += <span class="tok-number">1</span>;</span>
<span class="line" id="L7735">        }</span>
<span class="line" id="L7736">    }</span>
<span class="line" id="L7737"></span>
<span class="line" id="L7738">    <span class="tok-kw">const</span> operand_ri: ResultInfo = .{ .rl = <span class="tok-kw">if</span> (any_payload_is_ref) .ref <span class="tok-kw">else</span> .none };</span>
<span class="line" id="L7739"></span>
<span class="line" id="L7740">    astgen.advanceSourceCursorToNode(operand_node);</span>
<span class="line" id="L7741">    <span class="tok-kw">const</span> operand_lc = LineColumn{ astgen.source_line - parent_gz.decl_line, astgen.source_column };</span>
<span class="line" id="L7742"></span>
<span class="line" id="L7743">    <span class="tok-kw">const</span> raw_operand = <span class="tok-kw">try</span> expr(parent_gz, scope, operand_ri, operand_node);</span>
<span class="line" id="L7744">    <span class="tok-kw">const</span> item_ri: ResultInfo = .{ .rl = .none };</span>
<span class="line" id="L7745"></span>
<span class="line" id="L7746">    <span class="tok-comment">// This contains the data that goes into the `extra` array for the SwitchBlock/SwitchBlockMulti,</span>
</span>
<span class="line" id="L7747">    <span class="tok-comment">// except the first cases_nodes.len slots are a table that indexes payloads later in the array, with</span>
</span>
<span class="line" id="L7748">    <span class="tok-comment">// the special case index coming first, then scalar_case_len indexes, then multi_cases_len indexes</span>
</span>
<span class="line" id="L7749">    <span class="tok-kw">const</span> payloads = &amp;astgen.scratch;</span>
<span class="line" id="L7750">    <span class="tok-kw">const</span> scratch_top = astgen.scratch.items.len;</span>
<span class="line" id="L7751">    <span class="tok-kw">const</span> case_table_start = scratch_top;</span>
<span class="line" id="L7752">    <span class="tok-kw">const</span> scalar_case_table = case_table_start + <span class="tok-builtin">@intFromBool</span>(special_prong != .none);</span>
<span class="line" id="L7753">    <span class="tok-kw">const</span> multi_case_table = scalar_case_table + scalar_cases_len;</span>
<span class="line" id="L7754">    <span class="tok-kw">const</span> case_table_end = multi_case_table + multi_cases_len;</span>
<span class="line" id="L7755">    <span class="tok-kw">try</span> astgen.scratch.resize(gpa, case_table_end);</span>
<span class="line" id="L7756">    <span class="tok-kw">defer</span> astgen.scratch.items.len = scratch_top;</span>
<span class="line" id="L7757"></span>
<span class="line" id="L7758">    <span class="tok-kw">var</span> block_scope = parent_gz.makeSubBlock(scope);</span>
<span class="line" id="L7759">    <span class="tok-comment">// block_scope not used for collecting instructions</span>
</span>
<span class="line" id="L7760">    block_scope.instructions_top = GenZir.unstacked_top;</span>
<span class="line" id="L7761">    block_scope.setBreakResultInfo(block_ri);</span>
<span class="line" id="L7762"></span>
<span class="line" id="L7763">    <span class="tok-comment">// Sema expects a dbg_stmt immediately before switch_block(_ref)</span>
</span>
<span class="line" id="L7764">    <span class="tok-kw">try</span> emitDbgStmtForceCurrentIndex(parent_gz, operand_lc);</span>
<span class="line" id="L7765">    <span class="tok-comment">// This gets added to the parent block later, after the item expressions.</span>
</span>
<span class="line" id="L7766">    <span class="tok-kw">const</span> switch_tag: Zir.Inst.Tag = <span class="tok-kw">if</span> (any_payload_is_ref) .switch_block_ref <span class="tok-kw">else</span> .switch_block;</span>
<span class="line" id="L7767">    <span class="tok-kw">const</span> switch_block = <span class="tok-kw">try</span> parent_gz.makeBlockInst(switch_tag, switch_node);</span>
<span class="line" id="L7768"></span>
<span class="line" id="L7769">    <span class="tok-comment">// We re-use this same scope for all cases, including the special prong, if any.</span>
</span>
<span class="line" id="L7770">    <span class="tok-kw">var</span> case_scope = parent_gz.makeSubBlock(&amp;block_scope.base);</span>
<span class="line" id="L7771">    case_scope.instructions_top = GenZir.unstacked_top;</span>
<span class="line" id="L7772"></span>
<span class="line" id="L7773">    <span class="tok-comment">// If any prong has an inline tag capture, allocate a shared dummy instruction for it</span>
</span>
<span class="line" id="L7774">    <span class="tok-kw">const</span> tag_inst = <span class="tok-kw">if</span> (any_has_tag_capture) tag_inst: {</span>
<span class="line" id="L7775">        <span class="tok-kw">const</span> inst: Zir.Inst.Index = <span class="tok-builtin">@enumFromInt</span>(astgen.instructions.len);</span>
<span class="line" id="L7776">        <span class="tok-kw">try</span> astgen.instructions.append(astgen.gpa, .{</span>
<span class="line" id="L7777">            .tag = .extended,</span>
<span class="line" id="L7778">            .data = .{ .extended = .{</span>
<span class="line" id="L7779">                .opcode = .value_placeholder,</span>
<span class="line" id="L7780">                .small = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L7781">                .operand = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L7782">            } },</span>
<span class="line" id="L7783">        });</span>
<span class="line" id="L7784">        <span class="tok-kw">break</span> :tag_inst inst;</span>
<span class="line" id="L7785">    } <span class="tok-kw">else</span> <span class="tok-null">undefined</span>;</span>
<span class="line" id="L7786"></span>
<span class="line" id="L7787">    <span class="tok-comment">// In this pass we generate all the item and prong expressions.</span>
</span>
<span class="line" id="L7788">    <span class="tok-kw">var</span> multi_case_index: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L7789">    <span class="tok-kw">var</span> scalar_case_index: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L7790">    <span class="tok-kw">for</span> (case_nodes) |case_node| {</span>
<span class="line" id="L7791">        <span class="tok-kw">const</span> case = tree.fullSwitchCase(case_node).?;</span>
<span class="line" id="L7792"></span>
<span class="line" id="L7793">        <span class="tok-kw">const</span> is_multi_case = case.ast.values.len &gt; <span class="tok-number">1</span> <span class="tok-kw">or</span></span>
<span class="line" id="L7794">            (case.ast.values.len == <span class="tok-number">1</span> <span class="tok-kw">and</span> node_tags[case.ast.values[<span class="tok-number">0</span>]] == .switch_range);</span>
<span class="line" id="L7795"></span>
<span class="line" id="L7796">        <span class="tok-kw">var</span> dbg_var_name: Zir.NullTerminatedString = .empty;</span>
<span class="line" id="L7797">        <span class="tok-kw">var</span> dbg_var_inst: Zir.Inst.Ref = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L7798">        <span class="tok-kw">var</span> dbg_var_tag_name: Zir.NullTerminatedString = .empty;</span>
<span class="line" id="L7799">        <span class="tok-kw">var</span> dbg_var_tag_inst: Zir.Inst.Ref = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L7800">        <span class="tok-kw">var</span> has_tag_capture = <span class="tok-null">false</span>;</span>
<span class="line" id="L7801">        <span class="tok-kw">var</span> capture_val_scope: Scope.LocalVal = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L7802">        <span class="tok-kw">var</span> tag_scope: Scope.LocalVal = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L7803"></span>
<span class="line" id="L7804">        <span class="tok-kw">var</span> capture: Zir.Inst.SwitchBlock.ProngInfo.Capture = .none;</span>
<span class="line" id="L7805"></span>
<span class="line" id="L7806">        <span class="tok-kw">const</span> sub_scope = blk: {</span>
<span class="line" id="L7807">            <span class="tok-kw">const</span> payload_token = case.payload_token <span class="tok-kw">orelse</span> <span class="tok-kw">break</span> :blk &amp;case_scope.base;</span>
<span class="line" id="L7808">            <span class="tok-kw">const</span> ident = <span class="tok-kw">if</span> (token_tags[payload_token] == .asterisk)</span>
<span class="line" id="L7809">                payload_token + <span class="tok-number">1</span></span>
<span class="line" id="L7810">            <span class="tok-kw">else</span></span>
<span class="line" id="L7811">                payload_token;</span>
<span class="line" id="L7812"></span>
<span class="line" id="L7813">            <span class="tok-kw">const</span> is_ptr = ident != payload_token;</span>
<span class="line" id="L7814">            capture = <span class="tok-kw">if</span> (is_ptr) .by_ref <span class="tok-kw">else</span> .by_val;</span>
<span class="line" id="L7815"></span>
<span class="line" id="L7816">            <span class="tok-kw">const</span> ident_slice = tree.tokenSlice(ident);</span>
<span class="line" id="L7817">            <span class="tok-kw">var</span> payload_sub_scope: *Scope = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L7818">            <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, ident_slice, <span class="tok-str">&quot;_&quot;</span>)) {</span>
<span class="line" id="L7819">                <span class="tok-kw">if</span> (is_ptr) {</span>
<span class="line" id="L7820">                    <span class="tok-kw">return</span> astgen.failTok(payload_token, <span class="tok-str">&quot;pointer modifier invalid on discard&quot;</span>, .{});</span>
<span class="line" id="L7821">                }</span>
<span class="line" id="L7822">                payload_sub_scope = &amp;case_scope.base;</span>
<span class="line" id="L7823">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L7824">                <span class="tok-kw">const</span> capture_name = <span class="tok-kw">try</span> astgen.identAsString(ident);</span>
<span class="line" id="L7825">                <span class="tok-kw">try</span> astgen.detectLocalShadowing(&amp;case_scope.base, capture_name, ident, ident_slice, .capture);</span>
<span class="line" id="L7826">                capture_val_scope = .{</span>
<span class="line" id="L7827">                    .parent = &amp;case_scope.base,</span>
<span class="line" id="L7828">                    .gen_zir = &amp;case_scope,</span>
<span class="line" id="L7829">                    .name = capture_name,</span>
<span class="line" id="L7830">                    .inst = switch_block.toRef(),</span>
<span class="line" id="L7831">                    .token_src = ident,</span>
<span class="line" id="L7832">                    .id_cat = .capture,</span>
<span class="line" id="L7833">                };</span>
<span class="line" id="L7834">                dbg_var_name = capture_name;</span>
<span class="line" id="L7835">                dbg_var_inst = switch_block.toRef();</span>
<span class="line" id="L7836">                payload_sub_scope = &amp;capture_val_scope.base;</span>
<span class="line" id="L7837">            }</span>
<span class="line" id="L7838"></span>
<span class="line" id="L7839">            <span class="tok-kw">const</span> tag_token = <span class="tok-kw">if</span> (token_tags[ident + <span class="tok-number">1</span>] == .comma)</span>
<span class="line" id="L7840">                ident + <span class="tok-number">2</span></span>
<span class="line" id="L7841">            <span class="tok-kw">else</span></span>
<span class="line" id="L7842">                <span class="tok-kw">break</span> :blk payload_sub_scope;</span>
<span class="line" id="L7843">            <span class="tok-kw">const</span> tag_slice = tree.tokenSlice(tag_token);</span>
<span class="line" id="L7844">            <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, tag_slice, <span class="tok-str">&quot;_&quot;</span>)) {</span>
<span class="line" id="L7845">                <span class="tok-kw">return</span> astgen.failTok(tag_token, <span class="tok-str">&quot;discard of tag capture; omit it instead&quot;</span>, .{});</span>
<span class="line" id="L7846">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (case.inline_token == <span class="tok-null">null</span>) {</span>
<span class="line" id="L7847">                <span class="tok-kw">return</span> astgen.failTok(tag_token, <span class="tok-str">&quot;tag capture on non-inline prong&quot;</span>, .{});</span>
<span class="line" id="L7848">            }</span>
<span class="line" id="L7849">            <span class="tok-kw">const</span> tag_name = <span class="tok-kw">try</span> astgen.identAsString(tag_token);</span>
<span class="line" id="L7850">            <span class="tok-kw">try</span> astgen.detectLocalShadowing(payload_sub_scope, tag_name, tag_token, tag_slice, .@&quot;switch tag capture&quot;);</span>
<span class="line" id="L7851"></span>
<span class="line" id="L7852">            assert(any_has_tag_capture);</span>
<span class="line" id="L7853">            has_tag_capture = <span class="tok-null">true</span>;</span>
<span class="line" id="L7854"></span>
<span class="line" id="L7855">            tag_scope = .{</span>
<span class="line" id="L7856">                .parent = payload_sub_scope,</span>
<span class="line" id="L7857">                .gen_zir = &amp;case_scope,</span>
<span class="line" id="L7858">                .name = tag_name,</span>
<span class="line" id="L7859">                .inst = tag_inst.toRef(),</span>
<span class="line" id="L7860">                .token_src = tag_token,</span>
<span class="line" id="L7861">                .id_cat = .@&quot;switch tag capture&quot;,</span>
<span class="line" id="L7862">            };</span>
<span class="line" id="L7863">            dbg_var_tag_name = tag_name;</span>
<span class="line" id="L7864">            dbg_var_tag_inst = tag_inst.toRef();</span>
<span class="line" id="L7865">            <span class="tok-kw">break</span> :blk &amp;tag_scope.base;</span>
<span class="line" id="L7866">        };</span>
<span class="line" id="L7867"></span>
<span class="line" id="L7868">        <span class="tok-kw">const</span> header_index: <span class="tok-type">u32</span> = <span class="tok-builtin">@intCast</span>(payloads.items.len);</span>
<span class="line" id="L7869">        <span class="tok-kw">const</span> body_len_index = <span class="tok-kw">if</span> (is_multi_case) blk: {</span>
<span class="line" id="L7870">            payloads.items[multi_case_table + multi_case_index] = header_index;</span>
<span class="line" id="L7871">            multi_case_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L7872">            <span class="tok-kw">try</span> payloads.resize(gpa, header_index + <span class="tok-number">3</span>); <span class="tok-comment">// items_len, ranges_len, body_len</span>
</span>
<span class="line" id="L7873"></span>
<span class="line" id="L7874">            <span class="tok-comment">// items</span>
</span>
<span class="line" id="L7875">            <span class="tok-kw">var</span> items_len: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L7876">            <span class="tok-kw">for</span> (case.ast.values) |item_node| {</span>
<span class="line" id="L7877">                <span class="tok-kw">if</span> (node_tags[item_node] == .switch_range) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L7878">                items_len += <span class="tok-number">1</span>;</span>
<span class="line" id="L7879"></span>
<span class="line" id="L7880">                <span class="tok-kw">const</span> item_inst = <span class="tok-kw">try</span> comptimeExpr(parent_gz, scope, item_ri, item_node);</span>
<span class="line" id="L7881">                <span class="tok-kw">try</span> payloads.append(gpa, <span class="tok-builtin">@intFromEnum</span>(item_inst));</span>
<span class="line" id="L7882">            }</span>
<span class="line" id="L7883"></span>
<span class="line" id="L7884">            <span class="tok-comment">// ranges</span>
</span>
<span class="line" id="L7885">            <span class="tok-kw">var</span> ranges_len: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L7886">            <span class="tok-kw">for</span> (case.ast.values) |range| {</span>
<span class="line" id="L7887">                <span class="tok-kw">if</span> (node_tags[range] != .switch_range) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L7888">                ranges_len += <span class="tok-number">1</span>;</span>
<span class="line" id="L7889"></span>
<span class="line" id="L7890">                <span class="tok-kw">const</span> first = <span class="tok-kw">try</span> comptimeExpr(parent_gz, scope, item_ri, node_datas[range].lhs);</span>
<span class="line" id="L7891">                <span class="tok-kw">const</span> last = <span class="tok-kw">try</span> comptimeExpr(parent_gz, scope, item_ri, node_datas[range].rhs);</span>
<span class="line" id="L7892">                <span class="tok-kw">try</span> payloads.appendSlice(gpa, &amp;[_]<span class="tok-type">u32</span>{</span>
<span class="line" id="L7893">                    <span class="tok-builtin">@intFromEnum</span>(first), <span class="tok-builtin">@intFromEnum</span>(last),</span>
<span class="line" id="L7894">                });</span>
<span class="line" id="L7895">            }</span>
<span class="line" id="L7896"></span>
<span class="line" id="L7897">            payloads.items[header_index] = items_len;</span>
<span class="line" id="L7898">            payloads.items[header_index + <span class="tok-number">1</span>] = ranges_len;</span>
<span class="line" id="L7899">            <span class="tok-kw">break</span> :blk header_index + <span class="tok-number">2</span>;</span>
<span class="line" id="L7900">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (case_node == special_node) blk: {</span>
<span class="line" id="L7901">            payloads.items[case_table_start] = header_index;</span>
<span class="line" id="L7902">            <span class="tok-kw">try</span> payloads.resize(gpa, header_index + <span class="tok-number">1</span>); <span class="tok-comment">// body_len</span>
</span>
<span class="line" id="L7903">            <span class="tok-kw">break</span> :blk header_index;</span>
<span class="line" id="L7904">        } <span class="tok-kw">else</span> blk: {</span>
<span class="line" id="L7905">            payloads.items[scalar_case_table + scalar_case_index] = header_index;</span>
<span class="line" id="L7906">            scalar_case_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L7907">            <span class="tok-kw">try</span> payloads.resize(gpa, header_index + <span class="tok-number">2</span>); <span class="tok-comment">// item, body_len</span>
</span>
<span class="line" id="L7908">            <span class="tok-kw">const</span> item_node = case.ast.values[<span class="tok-number">0</span>];</span>
<span class="line" id="L7909">            <span class="tok-kw">const</span> item_inst = <span class="tok-kw">try</span> comptimeExpr(parent_gz, scope, item_ri, item_node);</span>
<span class="line" id="L7910">            payloads.items[header_index] = <span class="tok-builtin">@intFromEnum</span>(item_inst);</span>
<span class="line" id="L7911">            <span class="tok-kw">break</span> :blk header_index + <span class="tok-number">1</span>;</span>
<span class="line" id="L7912">        };</span>
<span class="line" id="L7913"></span>
<span class="line" id="L7914">        {</span>
<span class="line" id="L7915">            <span class="tok-comment">// temporarily stack case_scope on parent_gz</span>
</span>
<span class="line" id="L7916">            case_scope.instructions_top = parent_gz.instructions.items.len;</span>
<span class="line" id="L7917">            <span class="tok-kw">defer</span> case_scope.unstack();</span>
<span class="line" id="L7918"></span>
<span class="line" id="L7919">            <span class="tok-kw">if</span> (dbg_var_name != .empty) {</span>
<span class="line" id="L7920">                <span class="tok-kw">try</span> case_scope.addDbgVar(.dbg_var_val, dbg_var_name, dbg_var_inst);</span>
<span class="line" id="L7921">            }</span>
<span class="line" id="L7922">            <span class="tok-kw">if</span> (dbg_var_tag_name != .empty) {</span>
<span class="line" id="L7923">                <span class="tok-kw">try</span> case_scope.addDbgVar(.dbg_var_val, dbg_var_tag_name, dbg_var_tag_inst);</span>
<span class="line" id="L7924">            }</span>
<span class="line" id="L7925">            <span class="tok-kw">const</span> target_expr_node = case.ast.target_expr;</span>
<span class="line" id="L7926">            <span class="tok-kw">const</span> case_result = <span class="tok-kw">try</span> fullBodyExpr(&amp;case_scope, sub_scope, block_scope.break_result_info, target_expr_node);</span>
<span class="line" id="L7927">            <span class="tok-kw">try</span> checkUsed(parent_gz, &amp;case_scope.base, sub_scope);</span>
<span class="line" id="L7928">            <span class="tok-kw">if</span> (!parent_gz.refIsNoReturn(case_result)) {</span>
<span class="line" id="L7929">                _ = <span class="tok-kw">try</span> case_scope.addBreakWithSrcNode(.@&quot;break&quot;, switch_block, case_result, target_expr_node);</span>
<span class="line" id="L7930">            }</span>
<span class="line" id="L7931"></span>
<span class="line" id="L7932">            <span class="tok-kw">const</span> case_slice = case_scope.instructionsSlice();</span>
<span class="line" id="L7933">            <span class="tok-comment">// Since we use the switch_block instruction itself to refer to the</span>
</span>
<span class="line" id="L7934">            <span class="tok-comment">// capture, which will not be added to the child block, we need to</span>
</span>
<span class="line" id="L7935">            <span class="tok-comment">// handle ref_table manually, and the same for the inline tag</span>
</span>
<span class="line" id="L7936">            <span class="tok-comment">// capture instruction.</span>
</span>
<span class="line" id="L7937">            <span class="tok-kw">const</span> refs_len = refs: {</span>
<span class="line" id="L7938">                <span class="tok-kw">var</span> n: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L7939">                <span class="tok-kw">var</span> check_inst = switch_block;</span>
<span class="line" id="L7940">                <span class="tok-kw">while</span> (astgen.ref_table.get(check_inst)) |ref_inst| {</span>
<span class="line" id="L7941">                    n += <span class="tok-number">1</span>;</span>
<span class="line" id="L7942">                    check_inst = ref_inst;</span>
<span class="line" id="L7943">                }</span>
<span class="line" id="L7944">                <span class="tok-kw">if</span> (has_tag_capture) {</span>
<span class="line" id="L7945">                    check_inst = tag_inst;</span>
<span class="line" id="L7946">                    <span class="tok-kw">while</span> (astgen.ref_table.get(check_inst)) |ref_inst| {</span>
<span class="line" id="L7947">                        n += <span class="tok-number">1</span>;</span>
<span class="line" id="L7948">                        check_inst = ref_inst;</span>
<span class="line" id="L7949">                    }</span>
<span class="line" id="L7950">                }</span>
<span class="line" id="L7951">                <span class="tok-kw">break</span> :refs n;</span>
<span class="line" id="L7952">            };</span>
<span class="line" id="L7953">            <span class="tok-kw">const</span> body_len = refs_len + astgen.countBodyLenAfterFixups(case_slice);</span>
<span class="line" id="L7954">            <span class="tok-kw">try</span> payloads.ensureUnusedCapacity(gpa, body_len);</span>
<span class="line" id="L7955">            payloads.items[body_len_index] = <span class="tok-builtin">@bitCast</span>(Zir.Inst.SwitchBlock.ProngInfo{</span>
<span class="line" id="L7956">                .body_len = <span class="tok-builtin">@intCast</span>(body_len),</span>
<span class="line" id="L7957">                .capture = capture,</span>
<span class="line" id="L7958">                .is_inline = case.inline_token != <span class="tok-null">null</span>,</span>
<span class="line" id="L7959">                .has_tag_capture = has_tag_capture,</span>
<span class="line" id="L7960">            });</span>
<span class="line" id="L7961">            <span class="tok-kw">if</span> (astgen.ref_table.fetchRemove(switch_block)) |kv| {</span>
<span class="line" id="L7962">                appendPossiblyRefdBodyInst(astgen, payloads, kv.value);</span>
<span class="line" id="L7963">            }</span>
<span class="line" id="L7964">            <span class="tok-kw">if</span> (has_tag_capture) {</span>
<span class="line" id="L7965">                <span class="tok-kw">if</span> (astgen.ref_table.fetchRemove(tag_inst)) |kv| {</span>
<span class="line" id="L7966">                    appendPossiblyRefdBodyInst(astgen, payloads, kv.value);</span>
<span class="line" id="L7967">                }</span>
<span class="line" id="L7968">            }</span>
<span class="line" id="L7969">            appendBodyWithFixupsArrayList(astgen, payloads, case_slice);</span>
<span class="line" id="L7970">        }</span>
<span class="line" id="L7971">    }</span>
<span class="line" id="L7972">    <span class="tok-comment">// Now that the item expressions are generated we can add this.</span>
</span>
<span class="line" id="L7973">    <span class="tok-kw">try</span> parent_gz.instructions.append(gpa, switch_block);</span>
<span class="line" id="L7974"></span>
<span class="line" id="L7975">    <span class="tok-kw">try</span> astgen.extra.ensureUnusedCapacity(gpa, <span class="tok-builtin">@typeInfo</span>(Zir.Inst.SwitchBlock).Struct.fields.len +</span>
<span class="line" id="L7976">        <span class="tok-builtin">@intFromBool</span>(multi_cases_len != <span class="tok-number">0</span>) +</span>
<span class="line" id="L7977">        <span class="tok-builtin">@intFromBool</span>(any_has_tag_capture) +</span>
<span class="line" id="L7978">        payloads.items.len - case_table_end +</span>
<span class="line" id="L7979">        (case_table_end - case_table_start) * <span class="tok-builtin">@typeInfo</span>(Zir.Inst.As).Struct.fields.len);</span>
<span class="line" id="L7980"></span>
<span class="line" id="L7981">    <span class="tok-kw">const</span> payload_index = astgen.addExtraAssumeCapacity(Zir.Inst.SwitchBlock{</span>
<span class="line" id="L7982">        .operand = raw_operand,</span>
<span class="line" id="L7983">        .bits = Zir.Inst.SwitchBlock.Bits{</span>
<span class="line" id="L7984">            .has_multi_cases = multi_cases_len != <span class="tok-number">0</span>,</span>
<span class="line" id="L7985">            .has_else = special_prong == .@&quot;else&quot;,</span>
<span class="line" id="L7986">            .has_under = special_prong == .under,</span>
<span class="line" id="L7987">            .any_has_tag_capture = any_has_tag_capture,</span>
<span class="line" id="L7988">            .scalar_cases_len = <span class="tok-builtin">@intCast</span>(scalar_cases_len),</span>
<span class="line" id="L7989">        },</span>
<span class="line" id="L7990">    });</span>
<span class="line" id="L7991"></span>
<span class="line" id="L7992">    <span class="tok-kw">if</span> (multi_cases_len != <span class="tok-number">0</span>) {</span>
<span class="line" id="L7993">        astgen.extra.appendAssumeCapacity(multi_cases_len);</span>
<span class="line" id="L7994">    }</span>
<span class="line" id="L7995"></span>
<span class="line" id="L7996">    <span class="tok-kw">if</span> (any_has_tag_capture) {</span>
<span class="line" id="L7997">        astgen.extra.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(tag_inst));</span>
<span class="line" id="L7998">    }</span>
<span class="line" id="L7999"></span>
<span class="line" id="L8000">    <span class="tok-kw">const</span> zir_datas = astgen.instructions.items(.data);</span>
<span class="line" id="L8001">    zir_datas[<span class="tok-builtin">@intFromEnum</span>(switch_block)].pl_node.payload_index = payload_index;</span>
<span class="line" id="L8002"></span>
<span class="line" id="L8003">    <span class="tok-kw">for</span> (payloads.items[case_table_start..case_table_end], <span class="tok-number">0</span>..) |start_index, i| {</span>
<span class="line" id="L8004">        <span class="tok-kw">var</span> body_len_index = start_index;</span>
<span class="line" id="L8005">        <span class="tok-kw">var</span> end_index = start_index;</span>
<span class="line" id="L8006">        <span class="tok-kw">const</span> table_index = case_table_start + i;</span>
<span class="line" id="L8007">        <span class="tok-kw">if</span> (table_index &lt; scalar_case_table) {</span>
<span class="line" id="L8008">            end_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L8009">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (table_index &lt; multi_case_table) {</span>
<span class="line" id="L8010">            body_len_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L8011">            end_index += <span class="tok-number">2</span>;</span>
<span class="line" id="L8012">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L8013">            body_len_index += <span class="tok-number">2</span>;</span>
<span class="line" id="L8014">            <span class="tok-kw">const</span> items_len = payloads.items[start_index];</span>
<span class="line" id="L8015">            <span class="tok-kw">const</span> ranges_len = payloads.items[start_index + <span class="tok-number">1</span>];</span>
<span class="line" id="L8016">            end_index += <span class="tok-number">3</span> + items_len + <span class="tok-number">2</span> * ranges_len;</span>
<span class="line" id="L8017">        }</span>
<span class="line" id="L8018">        <span class="tok-kw">const</span> prong_info: Zir.Inst.SwitchBlock.ProngInfo = <span class="tok-builtin">@bitCast</span>(payloads.items[body_len_index]);</span>
<span class="line" id="L8019">        end_index += prong_info.body_len;</span>
<span class="line" id="L8020">        astgen.extra.appendSliceAssumeCapacity(payloads.items[start_index..end_index]);</span>
<span class="line" id="L8021">    }</span>
<span class="line" id="L8022"></span>
<span class="line" id="L8023">    <span class="tok-kw">if</span> (need_result_rvalue) {</span>
<span class="line" id="L8024">        <span class="tok-kw">return</span> rvalue(parent_gz, ri, switch_block.toRef(), switch_node);</span>
<span class="line" id="L8025">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L8026">        <span class="tok-kw">return</span> switch_block.toRef();</span>
<span class="line" id="L8027">    }</span>
<span class="line" id="L8028">}</span>
<span class="line" id="L8029"></span>
<span class="line" id="L8030"><span class="tok-kw">fn</span> <span class="tok-fn">ret</span>(gz: *GenZir, scope: *Scope, node: Ast.Node.Index) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L8031">    <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L8032">    <span class="tok-kw">const</span> tree = astgen.tree;</span>
<span class="line" id="L8033">    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);</span>
<span class="line" id="L8034">    <span class="tok-kw">const</span> node_tags = tree.nodes.items(.tag);</span>
<span class="line" id="L8035"></span>
<span class="line" id="L8036">    <span class="tok-kw">if</span> (astgen.fn_block == <span class="tok-null">null</span>) {</span>
<span class="line" id="L8037">        <span class="tok-kw">return</span> astgen.failNode(node, <span class="tok-str">&quot;'return' outside function scope&quot;</span>, .{});</span>
<span class="line" id="L8038">    }</span>
<span class="line" id="L8039"></span>
<span class="line" id="L8040">    <span class="tok-kw">if</span> (gz.any_defer_node != <span class="tok-number">0</span>) {</span>
<span class="line" id="L8041">        <span class="tok-kw">return</span> astgen.failNodeNotes(node, <span class="tok-str">&quot;cannot return from defer expression&quot;</span>, .{}, &amp;.{</span>
<span class="line" id="L8042">            <span class="tok-kw">try</span> astgen.errNoteNode(</span>
<span class="line" id="L8043">                gz.any_defer_node,</span>
<span class="line" id="L8044">                <span class="tok-str">&quot;defer expression here&quot;</span>,</span>
<span class="line" id="L8045">                .{},</span>
<span class="line" id="L8046">            ),</span>
<span class="line" id="L8047">        });</span>
<span class="line" id="L8048">    }</span>
<span class="line" id="L8049"></span>
<span class="line" id="L8050">    <span class="tok-comment">// Ensure debug line/column information is emitted for this return expression.</span>
</span>
<span class="line" id="L8051">    <span class="tok-comment">// Then we will save the line/column so that we can emit another one that goes</span>
</span>
<span class="line" id="L8052">    <span class="tok-comment">// &quot;backwards&quot; because we want to evaluate the operand, but then put the debug</span>
</span>
<span class="line" id="L8053">    <span class="tok-comment">// info back at the return keyword for error return tracing.</span>
</span>
<span class="line" id="L8054">    <span class="tok-kw">if</span> (!gz.is_comptime) {</span>
<span class="line" id="L8055">        <span class="tok-kw">try</span> emitDbgNode(gz, node);</span>
<span class="line" id="L8056">    }</span>
<span class="line" id="L8057">    <span class="tok-kw">const</span> ret_lc = LineColumn{ astgen.source_line - gz.decl_line, astgen.source_column };</span>
<span class="line" id="L8058"></span>
<span class="line" id="L8059">    <span class="tok-kw">const</span> defer_outer = &amp;astgen.fn_block.?.base;</span>
<span class="line" id="L8060"></span>
<span class="line" id="L8061">    <span class="tok-kw">const</span> operand_node = node_datas[node].lhs;</span>
<span class="line" id="L8062">    <span class="tok-kw">if</span> (operand_node == <span class="tok-number">0</span>) {</span>
<span class="line" id="L8063">        <span class="tok-comment">// Returning a void value; skip error defers.</span>
</span>
<span class="line" id="L8064">        <span class="tok-kw">try</span> genDefers(gz, defer_outer, scope, .normal_only);</span>
<span class="line" id="L8065"></span>
<span class="line" id="L8066">        <span class="tok-comment">// As our last action before the return, &quot;pop&quot; the error trace if needed</span>
</span>
<span class="line" id="L8067">        _ = <span class="tok-kw">try</span> gz.addRestoreErrRetIndex(.ret, .always, node);</span>
<span class="line" id="L8068"></span>
<span class="line" id="L8069">        _ = <span class="tok-kw">try</span> gz.addUnNode(.ret_node, .void_value, node);</span>
<span class="line" id="L8070">        <span class="tok-kw">return</span> Zir.Inst.Ref.unreachable_value;</span>
<span class="line" id="L8071">    }</span>
<span class="line" id="L8072"></span>
<span class="line" id="L8073">    <span class="tok-kw">if</span> (node_tags[operand_node] == .error_value) {</span>
<span class="line" id="L8074">        <span class="tok-comment">// Hot path for `return error.Foo`. This bypasses result location logic as well as logic</span>
</span>
<span class="line" id="L8075">        <span class="tok-comment">// for detecting whether to add something to the function's inferred error set.</span>
</span>
<span class="line" id="L8076">        <span class="tok-kw">const</span> ident_token = node_datas[operand_node].rhs;</span>
<span class="line" id="L8077">        <span class="tok-kw">const</span> err_name_str_index = <span class="tok-kw">try</span> astgen.identAsString(ident_token);</span>
<span class="line" id="L8078">        <span class="tok-kw">const</span> defer_counts = countDefers(defer_outer, scope);</span>
<span class="line" id="L8079">        <span class="tok-kw">if</span> (!defer_counts.need_err_code) {</span>
<span class="line" id="L8080">            <span class="tok-kw">try</span> genDefers(gz, defer_outer, scope, .both_sans_err);</span>
<span class="line" id="L8081">            <span class="tok-kw">try</span> emitDbgStmt(gz, ret_lc);</span>
<span class="line" id="L8082">            _ = <span class="tok-kw">try</span> gz.addStrTok(.ret_err_value, err_name_str_index, ident_token);</span>
<span class="line" id="L8083">            <span class="tok-kw">return</span> Zir.Inst.Ref.unreachable_value;</span>
<span class="line" id="L8084">        }</span>
<span class="line" id="L8085">        <span class="tok-kw">const</span> err_code = <span class="tok-kw">try</span> gz.addStrTok(.ret_err_value_code, err_name_str_index, ident_token);</span>
<span class="line" id="L8086">        <span class="tok-kw">try</span> genDefers(gz, defer_outer, scope, .{ .both = err_code });</span>
<span class="line" id="L8087">        <span class="tok-kw">try</span> emitDbgStmt(gz, ret_lc);</span>
<span class="line" id="L8088">        _ = <span class="tok-kw">try</span> gz.addUnNode(.ret_node, err_code, node);</span>
<span class="line" id="L8089">        <span class="tok-kw">return</span> Zir.Inst.Ref.unreachable_value;</span>
<span class="line" id="L8090">    }</span>
<span class="line" id="L8091"></span>
<span class="line" id="L8092">    <span class="tok-kw">const</span> ri: ResultInfo = <span class="tok-kw">if</span> (astgen.nodes_need_rl.contains(node)) .{</span>
<span class="line" id="L8093">        .rl = .{ .ptr = .{ .inst = <span class="tok-kw">try</span> gz.addNode(.ret_ptr, node) } },</span>
<span class="line" id="L8094">        .ctx = .@&quot;return&quot;,</span>
<span class="line" id="L8095">    } <span class="tok-kw">else</span> .{</span>
<span class="line" id="L8096">        .rl = .{ .coerced_ty = astgen.fn_ret_ty },</span>
<span class="line" id="L8097">        .ctx = .@&quot;return&quot;,</span>
<span class="line" id="L8098">    };</span>
<span class="line" id="L8099">    <span class="tok-kw">const</span> prev_anon_name_strategy = gz.anon_name_strategy;</span>
<span class="line" id="L8100">    gz.anon_name_strategy = .func;</span>
<span class="line" id="L8101">    <span class="tok-kw">const</span> operand = <span class="tok-kw">try</span> reachableExpr(gz, scope, ri, operand_node, node);</span>
<span class="line" id="L8102">    gz.anon_name_strategy = prev_anon_name_strategy;</span>
<span class="line" id="L8103"></span>
<span class="line" id="L8104">    <span class="tok-kw">switch</span> (nodeMayEvalToError(tree, operand_node)) {</span>
<span class="line" id="L8105">        .never =&gt; {</span>
<span class="line" id="L8106">            <span class="tok-comment">// Returning a value that cannot be an error; skip error defers.</span>
</span>
<span class="line" id="L8107">            <span class="tok-kw">try</span> genDefers(gz, defer_outer, scope, .normal_only);</span>
<span class="line" id="L8108"></span>
<span class="line" id="L8109">            <span class="tok-comment">// As our last action before the return, &quot;pop&quot; the error trace if needed</span>
</span>
<span class="line" id="L8110">            _ = <span class="tok-kw">try</span> gz.addRestoreErrRetIndex(.ret, .always, node);</span>
<span class="line" id="L8111"></span>
<span class="line" id="L8112">            <span class="tok-kw">try</span> emitDbgStmt(gz, ret_lc);</span>
<span class="line" id="L8113">            <span class="tok-kw">try</span> gz.addRet(ri, operand, node);</span>
<span class="line" id="L8114">            <span class="tok-kw">return</span> Zir.Inst.Ref.unreachable_value;</span>
<span class="line" id="L8115">        },</span>
<span class="line" id="L8116">        .always =&gt; {</span>
<span class="line" id="L8117">            <span class="tok-comment">// Value is always an error. Emit both error defers and regular defers.</span>
</span>
<span class="line" id="L8118">            <span class="tok-kw">const</span> err_code = <span class="tok-kw">if</span> (ri.rl == .ptr) <span class="tok-kw">try</span> gz.addUnNode(.load, ri.rl.ptr.inst, node) <span class="tok-kw">else</span> operand;</span>
<span class="line" id="L8119">            <span class="tok-kw">try</span> genDefers(gz, defer_outer, scope, .{ .both = err_code });</span>
<span class="line" id="L8120">            <span class="tok-kw">try</span> emitDbgStmt(gz, ret_lc);</span>
<span class="line" id="L8121">            <span class="tok-kw">try</span> gz.addRet(ri, operand, node);</span>
<span class="line" id="L8122">            <span class="tok-kw">return</span> Zir.Inst.Ref.unreachable_value;</span>
<span class="line" id="L8123">        },</span>
<span class="line" id="L8124">        .maybe =&gt; {</span>
<span class="line" id="L8125">            <span class="tok-kw">const</span> defer_counts = countDefers(defer_outer, scope);</span>
<span class="line" id="L8126">            <span class="tok-kw">if</span> (!defer_counts.have_err) {</span>
<span class="line" id="L8127">                <span class="tok-comment">// Only regular defers; no branch needed.</span>
</span>
<span class="line" id="L8128">                <span class="tok-kw">try</span> genDefers(gz, defer_outer, scope, .normal_only);</span>
<span class="line" id="L8129">                <span class="tok-kw">try</span> emitDbgStmt(gz, ret_lc);</span>
<span class="line" id="L8130"></span>
<span class="line" id="L8131">                <span class="tok-comment">// As our last action before the return, &quot;pop&quot; the error trace if needed</span>
</span>
<span class="line" id="L8132">                <span class="tok-kw">const</span> result = <span class="tok-kw">if</span> (ri.rl == .ptr) <span class="tok-kw">try</span> gz.addUnNode(.load, ri.rl.ptr.inst, node) <span class="tok-kw">else</span> operand;</span>
<span class="line" id="L8133">                _ = <span class="tok-kw">try</span> gz.addRestoreErrRetIndex(.ret, .{ .if_non_error = result }, node);</span>
<span class="line" id="L8134"></span>
<span class="line" id="L8135">                <span class="tok-kw">try</span> gz.addRet(ri, operand, node);</span>
<span class="line" id="L8136">                <span class="tok-kw">return</span> Zir.Inst.Ref.unreachable_value;</span>
<span class="line" id="L8137">            }</span>
<span class="line" id="L8138"></span>
<span class="line" id="L8139">            <span class="tok-comment">// Emit conditional branch for generating errdefers.</span>
</span>
<span class="line" id="L8140">            <span class="tok-kw">const</span> result = <span class="tok-kw">if</span> (ri.rl == .ptr) <span class="tok-kw">try</span> gz.addUnNode(.load, ri.rl.ptr.inst, node) <span class="tok-kw">else</span> operand;</span>
<span class="line" id="L8141">            <span class="tok-kw">const</span> is_non_err = <span class="tok-kw">try</span> gz.addUnNode(.ret_is_non_err, result, node);</span>
<span class="line" id="L8142">            <span class="tok-kw">const</span> condbr = <span class="tok-kw">try</span> gz.addCondBr(.condbr, node);</span>
<span class="line" id="L8143"></span>
<span class="line" id="L8144">            <span class="tok-kw">var</span> then_scope = gz.makeSubBlock(scope);</span>
<span class="line" id="L8145">            <span class="tok-kw">defer</span> then_scope.unstack();</span>
<span class="line" id="L8146"></span>
<span class="line" id="L8147">            <span class="tok-kw">try</span> genDefers(&amp;then_scope, defer_outer, scope, .normal_only);</span>
<span class="line" id="L8148"></span>
<span class="line" id="L8149">            <span class="tok-comment">// As our last action before the return, &quot;pop&quot; the error trace if needed</span>
</span>
<span class="line" id="L8150">            _ = <span class="tok-kw">try</span> then_scope.addRestoreErrRetIndex(.ret, .always, node);</span>
<span class="line" id="L8151"></span>
<span class="line" id="L8152">            <span class="tok-kw">try</span> emitDbgStmt(&amp;then_scope, ret_lc);</span>
<span class="line" id="L8153">            <span class="tok-kw">try</span> then_scope.addRet(ri, operand, node);</span>
<span class="line" id="L8154"></span>
<span class="line" id="L8155">            <span class="tok-kw">var</span> else_scope = gz.makeSubBlock(scope);</span>
<span class="line" id="L8156">            <span class="tok-kw">defer</span> else_scope.unstack();</span>
<span class="line" id="L8157"></span>
<span class="line" id="L8158">            <span class="tok-kw">const</span> which_ones: DefersToEmit = <span class="tok-kw">if</span> (!defer_counts.need_err_code) .both_sans_err <span class="tok-kw">else</span> .{</span>
<span class="line" id="L8159">                .both = <span class="tok-kw">try</span> else_scope.addUnNode(.err_union_code, result, node),</span>
<span class="line" id="L8160">            };</span>
<span class="line" id="L8161">            <span class="tok-kw">try</span> genDefers(&amp;else_scope, defer_outer, scope, which_ones);</span>
<span class="line" id="L8162">            <span class="tok-kw">try</span> emitDbgStmt(&amp;else_scope, ret_lc);</span>
<span class="line" id="L8163">            <span class="tok-kw">try</span> else_scope.addRet(ri, operand, node);</span>
<span class="line" id="L8164"></span>
<span class="line" id="L8165">            <span class="tok-kw">try</span> setCondBrPayload(condbr, is_non_err, &amp;then_scope, &amp;else_scope);</span>
<span class="line" id="L8166"></span>
<span class="line" id="L8167">            <span class="tok-kw">return</span> Zir.Inst.Ref.unreachable_value;</span>
<span class="line" id="L8168">        },</span>
<span class="line" id="L8169">    }</span>
<span class="line" id="L8170">}</span>
<span class="line" id="L8171"></span>
<span class="line" id="L8172"><span class="tok-comment">/// Parses the string `buf` as a base 10 integer of type `u16`.</span></span>
<span class="line" id="L8173"><span class="tok-comment">///</span></span>
<span class="line" id="L8174"><span class="tok-comment">/// Unlike std.fmt.parseInt, does not allow the '_' character in `buf`.</span></span>
<span class="line" id="L8175"><span class="tok-kw">fn</span> <span class="tok-fn">parseBitCount</span>(buf: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) std.fmt.ParseIntError!<span class="tok-type">u16</span> {</span>
<span class="line" id="L8176">    <span class="tok-kw">if</span> (buf.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCharacter;</span>
<span class="line" id="L8177"></span>
<span class="line" id="L8178">    <span class="tok-kw">var</span> x: <span class="tok-type">u16</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L8179"></span>
<span class="line" id="L8180">    <span class="tok-kw">for</span> (buf) |c| {</span>
<span class="line" id="L8181">        <span class="tok-kw">const</span> digit = <span class="tok-kw">switch</span> (c) {</span>
<span class="line" id="L8182">            <span class="tok-str">'0'</span>...<span class="tok-str">'9'</span> =&gt; c - <span class="tok-str">'0'</span>,</span>
<span class="line" id="L8183">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCharacter,</span>
<span class="line" id="L8184">        };</span>
<span class="line" id="L8185"></span>
<span class="line" id="L8186">        <span class="tok-kw">if</span> (x != <span class="tok-number">0</span>) x = <span class="tok-kw">try</span> std.math.mul(<span class="tok-type">u16</span>, x, <span class="tok-number">10</span>);</span>
<span class="line" id="L8187">        x = <span class="tok-kw">try</span> std.math.add(<span class="tok-type">u16</span>, x, digit);</span>
<span class="line" id="L8188">    }</span>
<span class="line" id="L8189"></span>
<span class="line" id="L8190">    <span class="tok-kw">return</span> x;</span>
<span class="line" id="L8191">}</span>
<span class="line" id="L8192"></span>
<span class="line" id="L8193"><span class="tok-kw">fn</span> <span class="tok-fn">identifier</span>(</span>
<span class="line" id="L8194">    gz: *GenZir,</span>
<span class="line" id="L8195">    scope: *Scope,</span>
<span class="line" id="L8196">    ri: ResultInfo,</span>
<span class="line" id="L8197">    ident: Ast.Node.Index,</span>
<span class="line" id="L8198">) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L8199">    <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L8200">    <span class="tok-kw">const</span> tree = astgen.tree;</span>
<span class="line" id="L8201">    <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);</span>
<span class="line" id="L8202"></span>
<span class="line" id="L8203">    <span class="tok-kw">const</span> ident_token = main_tokens[ident];</span>
<span class="line" id="L8204">    <span class="tok-kw">const</span> ident_name_raw = tree.tokenSlice(ident_token);</span>
<span class="line" id="L8205">    <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, ident_name_raw, <span class="tok-str">&quot;_&quot;</span>)) {</span>
<span class="line" id="L8206">        <span class="tok-kw">return</span> astgen.failNode(ident, <span class="tok-str">&quot;'_' used as an identifier without @\&quot;_\&quot; syntax&quot;</span>, .{});</span>
<span class="line" id="L8207">    }</span>
<span class="line" id="L8208"></span>
<span class="line" id="L8209">    <span class="tok-comment">// if not @&quot;&quot; syntax, just use raw token slice</span>
</span>
<span class="line" id="L8210">    <span class="tok-kw">if</span> (ident_name_raw[<span class="tok-number">0</span>] != <span class="tok-str">'@'</span>) {</span>
<span class="line" id="L8211">        <span class="tok-kw">if</span> (primitive_instrs.get(ident_name_raw)) |zir_const_ref| {</span>
<span class="line" id="L8212">            <span class="tok-kw">return</span> rvalue(gz, ri, zir_const_ref, ident);</span>
<span class="line" id="L8213">        }</span>
<span class="line" id="L8214"></span>
<span class="line" id="L8215">        <span class="tok-kw">if</span> (ident_name_raw.len &gt;= <span class="tok-number">2</span>) integer: {</span>
<span class="line" id="L8216">            <span class="tok-kw">const</span> first_c = ident_name_raw[<span class="tok-number">0</span>];</span>
<span class="line" id="L8217">            <span class="tok-kw">if</span> (first_c == <span class="tok-str">'i'</span> <span class="tok-kw">or</span> first_c == <span class="tok-str">'u'</span>) {</span>
<span class="line" id="L8218">                <span class="tok-kw">const</span> signedness: std.builtin.Signedness = <span class="tok-kw">switch</span> (first_c == <span class="tok-str">'i'</span>) {</span>
<span class="line" id="L8219">                    <span class="tok-null">true</span> =&gt; .signed,</span>
<span class="line" id="L8220">                    <span class="tok-null">false</span> =&gt; .unsigned,</span>
<span class="line" id="L8221">                };</span>
<span class="line" id="L8222">                <span class="tok-kw">if</span> (ident_name_raw.len &gt;= <span class="tok-number">3</span> <span class="tok-kw">and</span> ident_name_raw[<span class="tok-number">1</span>] == <span class="tok-str">'0'</span>) {</span>
<span class="line" id="L8223">                    <span class="tok-kw">return</span> astgen.failNode(</span>
<span class="line" id="L8224">                        ident,</span>
<span class="line" id="L8225">                        <span class="tok-str">&quot;primitive integer type '{s}' has leading zero&quot;</span>,</span>
<span class="line" id="L8226">                        .{ident_name_raw},</span>
<span class="line" id="L8227">                    );</span>
<span class="line" id="L8228">                }</span>
<span class="line" id="L8229">                <span class="tok-kw">const</span> bit_count = parseBitCount(ident_name_raw[<span class="tok-number">1</span>..]) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L8230">                    <span class="tok-kw">error</span>.Overflow =&gt; <span class="tok-kw">return</span> astgen.failNode(</span>
<span class="line" id="L8231">                        ident,</span>
<span class="line" id="L8232">                        <span class="tok-str">&quot;primitive integer type '{s}' exceeds maximum bit width of 65535&quot;</span>,</span>
<span class="line" id="L8233">                        .{ident_name_raw},</span>
<span class="line" id="L8234">                    ),</span>
<span class="line" id="L8235">                    <span class="tok-kw">error</span>.InvalidCharacter =&gt; <span class="tok-kw">break</span> :integer,</span>
<span class="line" id="L8236">                };</span>
<span class="line" id="L8237">                <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.add(.{</span>
<span class="line" id="L8238">                    .tag = .int_type,</span>
<span class="line" id="L8239">                    .data = .{ .int_type = .{</span>
<span class="line" id="L8240">                        .src_node = gz.nodeIndexToRelative(ident),</span>
<span class="line" id="L8241">                        .signedness = signedness,</span>
<span class="line" id="L8242">                        .bit_count = bit_count,</span>
<span class="line" id="L8243">                    } },</span>
<span class="line" id="L8244">                });</span>
<span class="line" id="L8245">                <span class="tok-kw">return</span> rvalue(gz, ri, result, ident);</span>
<span class="line" id="L8246">            }</span>
<span class="line" id="L8247">        }</span>
<span class="line" id="L8248">    }</span>
<span class="line" id="L8249"></span>
<span class="line" id="L8250">    <span class="tok-comment">// Local variables, including function parameters.</span>
</span>
<span class="line" id="L8251">    <span class="tok-kw">return</span> localVarRef(gz, scope, ri, ident, ident_token);</span>
<span class="line" id="L8252">}</span>
<span class="line" id="L8253"></span>
<span class="line" id="L8254"><span class="tok-kw">fn</span> <span class="tok-fn">localVarRef</span>(</span>
<span class="line" id="L8255">    gz: *GenZir,</span>
<span class="line" id="L8256">    scope: *Scope,</span>
<span class="line" id="L8257">    ri: ResultInfo,</span>
<span class="line" id="L8258">    ident: Ast.Node.Index,</span>
<span class="line" id="L8259">    ident_token: Ast.TokenIndex,</span>
<span class="line" id="L8260">) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L8261">    <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L8262">    <span class="tok-kw">const</span> name_str_index = <span class="tok-kw">try</span> astgen.identAsString(ident_token);</span>
<span class="line" id="L8263">    <span class="tok-kw">var</span> s = scope;</span>
<span class="line" id="L8264">    <span class="tok-kw">var</span> found_already: ?Ast.Node.Index = <span class="tok-null">null</span>; <span class="tok-comment">// we have found a decl with the same name already</span>
</span>
<span class="line" id="L8265">    <span class="tok-kw">var</span> found_needs_tunnel: <span class="tok-type">bool</span> = <span class="tok-null">undefined</span>; <span class="tok-comment">// defined when `found_already != null`</span>
</span>
<span class="line" id="L8266">    <span class="tok-kw">var</span> found_namespaces_out: <span class="tok-type">u32</span> = <span class="tok-null">undefined</span>; <span class="tok-comment">// defined when `found_already != null`</span>
</span>
<span class="line" id="L8267"></span>
<span class="line" id="L8268">    <span class="tok-comment">// The number of namespaces above `gz` we currently are</span>
</span>
<span class="line" id="L8269">    <span class="tok-kw">var</span> num_namespaces_out: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L8270">    <span class="tok-comment">// defined by `num_namespaces_out != 0`</span>
</span>
<span class="line" id="L8271">    <span class="tok-kw">var</span> capturing_namespace: *Scope.Namespace = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L8272"></span>
<span class="line" id="L8273">    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) <span class="tok-kw">switch</span> (s.tag) {</span>
<span class="line" id="L8274">        .local_val =&gt; {</span>
<span class="line" id="L8275">            <span class="tok-kw">const</span> local_val = s.cast(Scope.LocalVal).?;</span>
<span class="line" id="L8276"></span>
<span class="line" id="L8277">            <span class="tok-kw">if</span> (local_val.name == name_str_index) {</span>
<span class="line" id="L8278">                <span class="tok-comment">// Locals cannot shadow anything, so we do not need to look for ambiguous</span>
</span>
<span class="line" id="L8279">                <span class="tok-comment">// references in this case.</span>
</span>
<span class="line" id="L8280">                <span class="tok-kw">if</span> (ri.rl == .discard <span class="tok-kw">and</span> ri.ctx == .assignment) {</span>
<span class="line" id="L8281">                    local_val.discarded = ident_token;</span>
<span class="line" id="L8282">                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L8283">                    local_val.used = ident_token;</span>
<span class="line" id="L8284">                }</span>
<span class="line" id="L8285"></span>
<span class="line" id="L8286">                <span class="tok-kw">const</span> value_inst = <span class="tok-kw">if</span> (num_namespaces_out != <span class="tok-number">0</span>) <span class="tok-kw">try</span> tunnelThroughClosure(</span>
<span class="line" id="L8287">                    gz,</span>
<span class="line" id="L8288">                    ident,</span>
<span class="line" id="L8289">                    num_namespaces_out,</span>
<span class="line" id="L8290">                    .{ .ref = local_val.inst },</span>
<span class="line" id="L8291">                    .{ .token = local_val.token_src },</span>
<span class="line" id="L8292">                ) <span class="tok-kw">else</span> local_val.inst;</span>
<span class="line" id="L8293"></span>
<span class="line" id="L8294">                <span class="tok-kw">return</span> rvalueNoCoercePreRef(gz, ri, value_inst, ident);</span>
<span class="line" id="L8295">            }</span>
<span class="line" id="L8296">            s = local_val.parent;</span>
<span class="line" id="L8297">        },</span>
<span class="line" id="L8298">        .local_ptr =&gt; {</span>
<span class="line" id="L8299">            <span class="tok-kw">const</span> local_ptr = s.cast(Scope.LocalPtr).?;</span>
<span class="line" id="L8300">            <span class="tok-kw">if</span> (local_ptr.name == name_str_index) {</span>
<span class="line" id="L8301">                <span class="tok-kw">if</span> (ri.rl == .discard <span class="tok-kw">and</span> ri.ctx == .assignment) {</span>
<span class="line" id="L8302">                    local_ptr.discarded = ident_token;</span>
<span class="line" id="L8303">                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L8304">                    local_ptr.used = ident_token;</span>
<span class="line" id="L8305">                }</span>
<span class="line" id="L8306"></span>
<span class="line" id="L8307">                <span class="tok-comment">// Can't close over a runtime variable</span>
</span>
<span class="line" id="L8308">                <span class="tok-kw">if</span> (num_namespaces_out != <span class="tok-number">0</span> <span class="tok-kw">and</span> !local_ptr.maybe_comptime <span class="tok-kw">and</span> !gz.is_typeof) {</span>
<span class="line" id="L8309">                    <span class="tok-kw">const</span> ident_name = <span class="tok-kw">try</span> astgen.identifierTokenString(ident_token);</span>
<span class="line" id="L8310">                    <span class="tok-kw">return</span> astgen.failNodeNotes(ident, <span class="tok-str">&quot;mutable '{s}' not accessible from here&quot;</span>, .{ident_name}, &amp;.{</span>
<span class="line" id="L8311">                        <span class="tok-kw">try</span> astgen.errNoteTok(local_ptr.token_src, <span class="tok-str">&quot;declared mutable here&quot;</span>, .{}),</span>
<span class="line" id="L8312">                        <span class="tok-kw">try</span> astgen.errNoteNode(capturing_namespace.node, <span class="tok-str">&quot;crosses namespace boundary here&quot;</span>, .{}),</span>
<span class="line" id="L8313">                    });</span>
<span class="line" id="L8314">                }</span>
<span class="line" id="L8315"></span>
<span class="line" id="L8316">                <span class="tok-kw">const</span> ptr_inst = <span class="tok-kw">if</span> (num_namespaces_out != <span class="tok-number">0</span>) <span class="tok-kw">try</span> tunnelThroughClosure(</span>
<span class="line" id="L8317">                    gz,</span>
<span class="line" id="L8318">                    ident,</span>
<span class="line" id="L8319">                    num_namespaces_out,</span>
<span class="line" id="L8320">                    .{ .ref = local_ptr.ptr },</span>
<span class="line" id="L8321">                    .{ .token = local_ptr.token_src },</span>
<span class="line" id="L8322">                ) <span class="tok-kw">else</span> local_ptr.ptr;</span>
<span class="line" id="L8323"></span>
<span class="line" id="L8324">                <span class="tok-kw">switch</span> (ri.rl) {</span>
<span class="line" id="L8325">                    .ref, .ref_coerced_ty =&gt; {</span>
<span class="line" id="L8326">                        local_ptr.used_as_lvalue = <span class="tok-null">true</span>;</span>
<span class="line" id="L8327">                        <span class="tok-kw">return</span> ptr_inst;</span>
<span class="line" id="L8328">                    },</span>
<span class="line" id="L8329">                    <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L8330">                        <span class="tok-kw">const</span> loaded = <span class="tok-kw">try</span> gz.addUnNode(.load, ptr_inst, ident);</span>
<span class="line" id="L8331">                        <span class="tok-kw">return</span> rvalueNoCoercePreRef(gz, ri, loaded, ident);</span>
<span class="line" id="L8332">                    },</span>
<span class="line" id="L8333">                }</span>
<span class="line" id="L8334">            }</span>
<span class="line" id="L8335">            s = local_ptr.parent;</span>
<span class="line" id="L8336">        },</span>
<span class="line" id="L8337">        .gen_zir =&gt; s = s.cast(GenZir).?.parent,</span>
<span class="line" id="L8338">        .defer_normal, .defer_error =&gt; s = s.cast(Scope.Defer).?.parent,</span>
<span class="line" id="L8339">        .namespace =&gt; {</span>
<span class="line" id="L8340">            <span class="tok-kw">const</span> ns = s.cast(Scope.Namespace).?;</span>
<span class="line" id="L8341">            <span class="tok-kw">if</span> (ns.decls.get(name_str_index)) |i| {</span>
<span class="line" id="L8342">                <span class="tok-kw">if</span> (found_already) |f| {</span>
<span class="line" id="L8343">                    <span class="tok-kw">return</span> astgen.failNodeNotes(ident, <span class="tok-str">&quot;ambiguous reference&quot;</span>, .{}, &amp;.{</span>
<span class="line" id="L8344">                        <span class="tok-kw">try</span> astgen.errNoteNode(f, <span class="tok-str">&quot;declared here&quot;</span>, .{}),</span>
<span class="line" id="L8345">                        <span class="tok-kw">try</span> astgen.errNoteNode(i, <span class="tok-str">&quot;also declared here&quot;</span>, .{}),</span>
<span class="line" id="L8346">                    });</span>
<span class="line" id="L8347">                }</span>
<span class="line" id="L8348">                <span class="tok-comment">// We found a match but must continue looking for ambiguous references to decls.</span>
</span>
<span class="line" id="L8349">                found_already = i;</span>
<span class="line" id="L8350">                found_needs_tunnel = ns.maybe_generic;</span>
<span class="line" id="L8351">                found_namespaces_out = num_namespaces_out;</span>
<span class="line" id="L8352">            }</span>
<span class="line" id="L8353">            num_namespaces_out += <span class="tok-number">1</span>;</span>
<span class="line" id="L8354">            capturing_namespace = ns;</span>
<span class="line" id="L8355">            s = ns.parent;</span>
<span class="line" id="L8356">        },</span>
<span class="line" id="L8357">        .top =&gt; <span class="tok-kw">break</span>,</span>
<span class="line" id="L8358">    };</span>
<span class="line" id="L8359">    <span class="tok-kw">if</span> (found_already == <span class="tok-null">null</span>) {</span>
<span class="line" id="L8360">        <span class="tok-kw">const</span> ident_name = <span class="tok-kw">try</span> astgen.identifierTokenString(ident_token);</span>
<span class="line" id="L8361">        <span class="tok-kw">return</span> astgen.failNode(ident, <span class="tok-str">&quot;use of undeclared identifier '{s}'&quot;</span>, .{ident_name});</span>
<span class="line" id="L8362">    }</span>
<span class="line" id="L8363"></span>
<span class="line" id="L8364">    <span class="tok-comment">// Decl references happen by name rather than ZIR index so that when unrelated</span>
</span>
<span class="line" id="L8365">    <span class="tok-comment">// decls are modified, ZIR code containing references to them can be unmodified.</span>
</span>
<span class="line" id="L8366"></span>
<span class="line" id="L8367">    <span class="tok-kw">if</span> (found_namespaces_out &gt; <span class="tok-number">0</span> <span class="tok-kw">and</span> found_needs_tunnel) {</span>
<span class="line" id="L8368">        <span class="tok-kw">switch</span> (ri.rl) {</span>
<span class="line" id="L8369">            .ref, .ref_coerced_ty =&gt; <span class="tok-kw">return</span> tunnelThroughClosure(</span>
<span class="line" id="L8370">                gz,</span>
<span class="line" id="L8371">                ident,</span>
<span class="line" id="L8372">                found_namespaces_out,</span>
<span class="line" id="L8373">                .{ .decl_ref = name_str_index },</span>
<span class="line" id="L8374">                .{ .node = found_already.? },</span>
<span class="line" id="L8375">            ),</span>
<span class="line" id="L8376">            <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L8377">                <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> tunnelThroughClosure(</span>
<span class="line" id="L8378">                    gz,</span>
<span class="line" id="L8379">                    ident,</span>
<span class="line" id="L8380">                    found_namespaces_out,</span>
<span class="line" id="L8381">                    .{ .decl_val = name_str_index },</span>
<span class="line" id="L8382">                    .{ .node = found_already.? },</span>
<span class="line" id="L8383">                );</span>
<span class="line" id="L8384">                <span class="tok-kw">return</span> rvalueNoCoercePreRef(gz, ri, result, ident);</span>
<span class="line" id="L8385">            },</span>
<span class="line" id="L8386">        }</span>
<span class="line" id="L8387">    }</span>
<span class="line" id="L8388"></span>
<span class="line" id="L8389">    <span class="tok-kw">switch</span> (ri.rl) {</span>
<span class="line" id="L8390">        .ref, .ref_coerced_ty =&gt; <span class="tok-kw">return</span> gz.addStrTok(.decl_ref, name_str_index, ident_token),</span>
<span class="line" id="L8391">        <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L8392">            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addStrTok(.decl_val, name_str_index, ident_token);</span>
<span class="line" id="L8393">            <span class="tok-kw">return</span> rvalueNoCoercePreRef(gz, ri, result, ident);</span>
<span class="line" id="L8394">        },</span>
<span class="line" id="L8395">    }</span>
<span class="line" id="L8396">}</span>
<span class="line" id="L8397"></span>
<span class="line" id="L8398"><span class="tok-comment">/// Access a ZIR instruction through closure. May tunnel through arbitrarily</span></span>
<span class="line" id="L8399"><span class="tok-comment">/// many namespaces, adding closure captures as required.</span></span>
<span class="line" id="L8400"><span class="tok-comment">/// Returns the index of the `closure_get` instruction added to `gz`.</span></span>
<span class="line" id="L8401"><span class="tok-kw">fn</span> <span class="tok-fn">tunnelThroughClosure</span>(</span>
<span class="line" id="L8402">    gz: *GenZir,</span>
<span class="line" id="L8403">    <span class="tok-comment">/// The node which references the value to be captured.</span></span>
<span class="line" id="L8404">    inner_ref_node: Ast.Node.Index,</span>
<span class="line" id="L8405">    <span class="tok-comment">/// The number of namespaces being tunnelled through. At least 1.</span></span>
<span class="line" id="L8406">    num_tunnels: <span class="tok-type">u32</span>,</span>
<span class="line" id="L8407">    <span class="tok-comment">/// The value being captured.</span></span>
<span class="line" id="L8408">    value: <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {</span>
<span class="line" id="L8409">        ref: Zir.Inst.Ref,</span>
<span class="line" id="L8410">        decl_val: Zir.NullTerminatedString,</span>
<span class="line" id="L8411">        decl_ref: Zir.NullTerminatedString,</span>
<span class="line" id="L8412">    },</span>
<span class="line" id="L8413">    <span class="tok-comment">/// The location of the value's declaration.</span></span>
<span class="line" id="L8414">    decl_src: <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {</span>
<span class="line" id="L8415">        token: Ast.TokenIndex,</span>
<span class="line" id="L8416">        node: Ast.Node.Index,</span>
<span class="line" id="L8417">    },</span>
<span class="line" id="L8418">) !Zir.Inst.Ref {</span>
<span class="line" id="L8419">    <span class="tok-kw">switch</span> (value) {</span>
<span class="line" id="L8420">        .ref =&gt; |v| <span class="tok-kw">if</span> (v.toIndex() == <span class="tok-null">null</span>) <span class="tok-kw">return</span> v, <span class="tok-comment">// trivia value; do not need tunnel</span>
</span>
<span class="line" id="L8421">        .decl_val, .decl_ref =&gt; {},</span>
<span class="line" id="L8422">    }</span>
<span class="line" id="L8423"></span>
<span class="line" id="L8424">    <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L8425">    <span class="tok-kw">const</span> gpa = astgen.gpa;</span>
<span class="line" id="L8426"></span>
<span class="line" id="L8427">    <span class="tok-comment">// Otherwise we need a tunnel. First, figure out the path of namespaces we</span>
</span>
<span class="line" id="L8428">    <span class="tok-comment">// are tunneling through. This is usually only going to be one or two, so</span>
</span>
<span class="line" id="L8429">    <span class="tok-comment">// use an SFBA to optimize for the common case.</span>
</span>
<span class="line" id="L8430">    <span class="tok-kw">var</span> sfba = std.heap.stackFallback(<span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>) * <span class="tok-number">2</span>, astgen.arena);</span>
<span class="line" id="L8431">    <span class="tok-kw">var</span> intermediate_tunnels = <span class="tok-kw">try</span> sfba.get().alloc(*Scope.Namespace, num_tunnels - <span class="tok-number">1</span>);</span>
<span class="line" id="L8432"></span>
<span class="line" id="L8433">    <span class="tok-kw">const</span> root_ns = ns: {</span>
<span class="line" id="L8434">        <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = num_tunnels - <span class="tok-number">1</span>;</span>
<span class="line" id="L8435">        <span class="tok-kw">var</span> scope: *Scope = gz.parent;</span>
<span class="line" id="L8436">        <span class="tok-kw">while</span> (i &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L8437">            <span class="tok-kw">if</span> (scope.cast(Scope.Namespace)) |mid_ns| {</span>
<span class="line" id="L8438">                i -= <span class="tok-number">1</span>;</span>
<span class="line" id="L8439">                intermediate_tunnels[i] = mid_ns;</span>
<span class="line" id="L8440">            }</span>
<span class="line" id="L8441">            scope = scope.parent().?;</span>
<span class="line" id="L8442">        }</span>
<span class="line" id="L8443">        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L8444">            <span class="tok-kw">if</span> (scope.cast(Scope.Namespace)) |ns| <span class="tok-kw">break</span> :ns ns;</span>
<span class="line" id="L8445">            scope = scope.parent().?;</span>
<span class="line" id="L8446">        }</span>
<span class="line" id="L8447">    };</span>
<span class="line" id="L8448"></span>
<span class="line" id="L8449">    <span class="tok-comment">// Now that we know the scopes we're tunneling through, begin adding</span>
</span>
<span class="line" id="L8450">    <span class="tok-comment">// captures as required, starting with the outermost namespace.</span>
</span>
<span class="line" id="L8451">    <span class="tok-kw">const</span> root_capture = Zir.Inst.Capture.wrap(<span class="tok-kw">switch</span> (value) {</span>
<span class="line" id="L8452">        .ref =&gt; |v| .{ .instruction = v.toIndex().? },</span>
<span class="line" id="L8453">        .decl_val =&gt; |str| .{ .decl_val = str },</span>
<span class="line" id="L8454">        .decl_ref =&gt; |str| .{ .decl_ref = str },</span>
<span class="line" id="L8455">    });</span>
<span class="line" id="L8456">    <span class="tok-kw">var</span> cur_capture_index = std.math.cast(</span>
<span class="line" id="L8457">        <span class="tok-type">u16</span>,</span>
<span class="line" id="L8458">        (<span class="tok-kw">try</span> root_ns.captures.getOrPut(gpa, root_capture)).index,</span>
<span class="line" id="L8459">    ) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> astgen.failNodeNotes(root_ns.node, <span class="tok-str">&quot;this compiler implementation only supports up to 65536 captures per namespace&quot;</span>, .{}, &amp;.{</span>
<span class="line" id="L8460">        <span class="tok-kw">switch</span> (decl_src) {</span>
<span class="line" id="L8461">            .token =&gt; |t| <span class="tok-kw">try</span> astgen.errNoteTok(t, <span class="tok-str">&quot;captured value here&quot;</span>, .{}),</span>
<span class="line" id="L8462">            .node =&gt; |n| <span class="tok-kw">try</span> astgen.errNoteNode(n, <span class="tok-str">&quot;captured value here&quot;</span>, .{}),</span>
<span class="line" id="L8463">        },</span>
<span class="line" id="L8464">        <span class="tok-kw">try</span> astgen.errNoteNode(inner_ref_node, <span class="tok-str">&quot;value used here&quot;</span>, .{}),</span>
<span class="line" id="L8465">    });</span>
<span class="line" id="L8466"></span>
<span class="line" id="L8467">    <span class="tok-kw">for</span> (intermediate_tunnels) |tunnel_ns| {</span>
<span class="line" id="L8468">        cur_capture_index = std.math.cast(</span>
<span class="line" id="L8469">            <span class="tok-type">u16</span>,</span>
<span class="line" id="L8470">            (<span class="tok-kw">try</span> tunnel_ns.captures.getOrPut(gpa, Zir.Inst.Capture.wrap(.{ .nested = cur_capture_index }))).index,</span>
<span class="line" id="L8471">        ) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> astgen.failNodeNotes(tunnel_ns.node, <span class="tok-str">&quot;this compiler implementation only supports up to 65536 captures per namespace&quot;</span>, .{}, &amp;.{</span>
<span class="line" id="L8472">            <span class="tok-kw">switch</span> (decl_src) {</span>
<span class="line" id="L8473">                .token =&gt; |t| <span class="tok-kw">try</span> astgen.errNoteTok(t, <span class="tok-str">&quot;captured value here&quot;</span>, .{}),</span>
<span class="line" id="L8474">                .node =&gt; |n| <span class="tok-kw">try</span> astgen.errNoteNode(n, <span class="tok-str">&quot;captured value here&quot;</span>, .{}),</span>
<span class="line" id="L8475">            },</span>
<span class="line" id="L8476">            <span class="tok-kw">try</span> astgen.errNoteNode(inner_ref_node, <span class="tok-str">&quot;value used here&quot;</span>, .{}),</span>
<span class="line" id="L8477">        });</span>
<span class="line" id="L8478">    }</span>
<span class="line" id="L8479"></span>
<span class="line" id="L8480">    <span class="tok-comment">// Add an instruction to get the value from the closure.</span>
</span>
<span class="line" id="L8481">    <span class="tok-kw">return</span> gz.addExtendedNodeSmall(.closure_get, inner_ref_node, cur_capture_index);</span>
<span class="line" id="L8482">}</span>
<span class="line" id="L8483"></span>
<span class="line" id="L8484"><span class="tok-kw">fn</span> <span class="tok-fn">stringLiteral</span>(</span>
<span class="line" id="L8485">    gz: *GenZir,</span>
<span class="line" id="L8486">    ri: ResultInfo,</span>
<span class="line" id="L8487">    node: Ast.Node.Index,</span>
<span class="line" id="L8488">) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L8489">    <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L8490">    <span class="tok-kw">const</span> tree = astgen.tree;</span>
<span class="line" id="L8491">    <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);</span>
<span class="line" id="L8492">    <span class="tok-kw">const</span> str_lit_token = main_tokens[node];</span>
<span class="line" id="L8493">    <span class="tok-kw">const</span> str = <span class="tok-kw">try</span> astgen.strLitAsString(str_lit_token);</span>
<span class="line" id="L8494">    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.add(.{</span>
<span class="line" id="L8495">        .tag = .str,</span>
<span class="line" id="L8496">        .data = .{ .str = .{</span>
<span class="line" id="L8497">            .start = str.index,</span>
<span class="line" id="L8498">            .len = str.len,</span>
<span class="line" id="L8499">        } },</span>
<span class="line" id="L8500">    });</span>
<span class="line" id="L8501">    <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L8502">}</span>
<span class="line" id="L8503"></span>
<span class="line" id="L8504"><span class="tok-kw">fn</span> <span class="tok-fn">multilineStringLiteral</span>(</span>
<span class="line" id="L8505">    gz: *GenZir,</span>
<span class="line" id="L8506">    ri: ResultInfo,</span>
<span class="line" id="L8507">    node: Ast.Node.Index,</span>
<span class="line" id="L8508">) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L8509">    <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L8510">    <span class="tok-kw">const</span> str = <span class="tok-kw">try</span> astgen.strLitNodeAsString(node);</span>
<span class="line" id="L8511">    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.add(.{</span>
<span class="line" id="L8512">        .tag = .str,</span>
<span class="line" id="L8513">        .data = .{ .str = .{</span>
<span class="line" id="L8514">            .start = str.index,</span>
<span class="line" id="L8515">            .len = str.len,</span>
<span class="line" id="L8516">        } },</span>
<span class="line" id="L8517">    });</span>
<span class="line" id="L8518">    <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L8519">}</span>
<span class="line" id="L8520"></span>
<span class="line" id="L8521"><span class="tok-kw">fn</span> <span class="tok-fn">charLiteral</span>(gz: *GenZir, ri: ResultInfo, node: Ast.Node.Index) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L8522">    <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L8523">    <span class="tok-kw">const</span> tree = astgen.tree;</span>
<span class="line" id="L8524">    <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);</span>
<span class="line" id="L8525">    <span class="tok-kw">const</span> main_token = main_tokens[node];</span>
<span class="line" id="L8526">    <span class="tok-kw">const</span> slice = tree.tokenSlice(main_token);</span>
<span class="line" id="L8527"></span>
<span class="line" id="L8528">    <span class="tok-kw">switch</span> (std.zig.parseCharLiteral(slice)) {</span>
<span class="line" id="L8529">        .success =&gt; |codepoint| {</span>
<span class="line" id="L8530">            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addInt(codepoint);</span>
<span class="line" id="L8531">            <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L8532">        },</span>
<span class="line" id="L8533">        .failure =&gt; |err| <span class="tok-kw">return</span> astgen.failWithStrLitError(err, main_token, slice, <span class="tok-number">0</span>),</span>
<span class="line" id="L8534">    }</span>
<span class="line" id="L8535">}</span>
<span class="line" id="L8536"></span>
<span class="line" id="L8537"><span class="tok-kw">const</span> Sign = <span class="tok-kw">enum</span> { negative, positive };</span>
<span class="line" id="L8538"></span>
<span class="line" id="L8539"><span class="tok-kw">fn</span> <span class="tok-fn">numberLiteral</span>(gz: *GenZir, ri: ResultInfo, node: Ast.Node.Index, source_node: Ast.Node.Index, sign: Sign) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L8540">    <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L8541">    <span class="tok-kw">const</span> tree = astgen.tree;</span>
<span class="line" id="L8542">    <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);</span>
<span class="line" id="L8543">    <span class="tok-kw">const</span> num_token = main_tokens[node];</span>
<span class="line" id="L8544">    <span class="tok-kw">const</span> bytes = tree.tokenSlice(num_token);</span>
<span class="line" id="L8545"></span>
<span class="line" id="L8546">    <span class="tok-kw">const</span> result: Zir.Inst.Ref = <span class="tok-kw">switch</span> (std.zig.parseNumberLiteral(bytes)) {</span>
<span class="line" id="L8547">        .int =&gt; |num| <span class="tok-kw">switch</span> (num) {</span>
<span class="line" id="L8548">            <span class="tok-number">0</span> =&gt; <span class="tok-kw">if</span> (sign == .positive) .zero <span class="tok-kw">else</span> <span class="tok-kw">return</span> astgen.failTokNotes(</span>
<span class="line" id="L8549">                num_token,</span>
<span class="line" id="L8550">                <span class="tok-str">&quot;integer literal '-0' is ambiguous&quot;</span>,</span>
<span class="line" id="L8551">                .{},</span>
<span class="line" id="L8552">                &amp;.{</span>
<span class="line" id="L8553">                    <span class="tok-kw">try</span> astgen.errNoteTok(num_token, <span class="tok-str">&quot;use '0' for an integer zero&quot;</span>, .{}),</span>
<span class="line" id="L8554">                    <span class="tok-kw">try</span> astgen.errNoteTok(num_token, <span class="tok-str">&quot;use '-0.0' for a floating-point signed zero&quot;</span>, .{}),</span>
<span class="line" id="L8555">                },</span>
<span class="line" id="L8556">            ),</span>
<span class="line" id="L8557">            <span class="tok-number">1</span> =&gt; {</span>
<span class="line" id="L8558">                <span class="tok-comment">// Handle the negation here!</span>
</span>
<span class="line" id="L8559">                <span class="tok-kw">const</span> result: Zir.Inst.Ref = <span class="tok-kw">switch</span> (sign) {</span>
<span class="line" id="L8560">                    .positive =&gt; .one,</span>
<span class="line" id="L8561">                    .negative =&gt; .negative_one,</span>
<span class="line" id="L8562">                };</span>
<span class="line" id="L8563">                <span class="tok-kw">return</span> rvalue(gz, ri, result, source_node);</span>
<span class="line" id="L8564">            },</span>
<span class="line" id="L8565">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">try</span> gz.addInt(num),</span>
<span class="line" id="L8566">        },</span>
<span class="line" id="L8567">        .big_int =&gt; |base| big: {</span>
<span class="line" id="L8568">            <span class="tok-kw">const</span> gpa = astgen.gpa;</span>
<span class="line" id="L8569">            <span class="tok-kw">var</span> big_int = <span class="tok-kw">try</span> std.math.big.int.Managed.init(gpa);</span>
<span class="line" id="L8570">            <span class="tok-kw">defer</span> big_int.deinit();</span>
<span class="line" id="L8571">            <span class="tok-kw">const</span> prefix_offset: <span class="tok-type">usize</span> = <span class="tok-kw">if</span> (base == .decimal) <span class="tok-number">0</span> <span class="tok-kw">else</span> <span class="tok-number">2</span>;</span>
<span class="line" id="L8572">            big_int.setString(<span class="tok-builtin">@intFromEnum</span>(base), bytes[prefix_offset..]) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L8573">                <span class="tok-kw">error</span>.InvalidCharacter =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// caught in `parseNumberLiteral`</span>
</span>
<span class="line" id="L8574">                <span class="tok-kw">error</span>.InvalidBase =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// we only pass 16, 8, 2, see above</span>
</span>
<span class="line" id="L8575">                <span class="tok-kw">error</span>.OutOfMemory =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory,</span>
<span class="line" id="L8576">            };</span>
<span class="line" id="L8577"></span>
<span class="line" id="L8578">            <span class="tok-kw">const</span> limbs = big_int.limbs[<span class="tok-number">0</span>..big_int.len()];</span>
<span class="line" id="L8579">            assert(big_int.isPositive());</span>
<span class="line" id="L8580">            <span class="tok-kw">break</span> :big <span class="tok-kw">try</span> gz.addIntBig(limbs);</span>
<span class="line" id="L8581">        },</span>
<span class="line" id="L8582">        .float =&gt; {</span>
<span class="line" id="L8583">            <span class="tok-kw">const</span> unsigned_float_number = std.fmt.parseFloat(<span class="tok-type">f128</span>, bytes) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L8584">                <span class="tok-kw">error</span>.InvalidCharacter =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// validated by tokenizer</span>
</span>
<span class="line" id="L8585">            };</span>
<span class="line" id="L8586">            <span class="tok-kw">const</span> float_number = <span class="tok-kw">switch</span> (sign) {</span>
<span class="line" id="L8587">                .negative =&gt; -unsigned_float_number,</span>
<span class="line" id="L8588">                .positive =&gt; unsigned_float_number,</span>
<span class="line" id="L8589">            };</span>
<span class="line" id="L8590">            <span class="tok-comment">// If the value fits into a f64 without losing any precision, store it that way.</span>
</span>
<span class="line" id="L8591">            <span class="tok-builtin">@setFloatMode</span>(.Strict);</span>
<span class="line" id="L8592">            <span class="tok-kw">const</span> smaller_float: <span class="tok-type">f64</span> = <span class="tok-builtin">@floatCast</span>(float_number);</span>
<span class="line" id="L8593">            <span class="tok-kw">const</span> bigger_again: <span class="tok-type">f128</span> = smaller_float;</span>
<span class="line" id="L8594">            <span class="tok-kw">if</span> (bigger_again == float_number) {</span>
<span class="line" id="L8595">                <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addFloat(smaller_float);</span>
<span class="line" id="L8596">                <span class="tok-kw">return</span> rvalue(gz, ri, result, source_node);</span>
<span class="line" id="L8597">            }</span>
<span class="line" id="L8598">            <span class="tok-comment">// We need to use 128 bits. Break the float into 4 u32 values so we can</span>
</span>
<span class="line" id="L8599">            <span class="tok-comment">// put it into the `extra` array.</span>
</span>
<span class="line" id="L8600">            <span class="tok-kw">const</span> int_bits: <span class="tok-type">u128</span> = <span class="tok-builtin">@bitCast</span>(float_number);</span>
<span class="line" id="L8601">            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addPlNode(.float128, node, Zir.Inst.Float128{</span>
<span class="line" id="L8602">                .piece0 = <span class="tok-builtin">@truncate</span>(int_bits),</span>
<span class="line" id="L8603">                .piece1 = <span class="tok-builtin">@truncate</span>(int_bits &gt;&gt; <span class="tok-number">32</span>),</span>
<span class="line" id="L8604">                .piece2 = <span class="tok-builtin">@truncate</span>(int_bits &gt;&gt; <span class="tok-number">64</span>),</span>
<span class="line" id="L8605">                .piece3 = <span class="tok-builtin">@truncate</span>(int_bits &gt;&gt; <span class="tok-number">96</span>),</span>
<span class="line" id="L8606">            });</span>
<span class="line" id="L8607">            <span class="tok-kw">return</span> rvalue(gz, ri, result, source_node);</span>
<span class="line" id="L8608">        },</span>
<span class="line" id="L8609">        .failure =&gt; |err| <span class="tok-kw">return</span> astgen.failWithNumberError(err, num_token, bytes),</span>
<span class="line" id="L8610">    };</span>
<span class="line" id="L8611"></span>
<span class="line" id="L8612">    <span class="tok-kw">if</span> (sign == .positive) {</span>
<span class="line" id="L8613">        <span class="tok-kw">return</span> rvalue(gz, ri, result, source_node);</span>
<span class="line" id="L8614">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L8615">        <span class="tok-kw">const</span> negated = <span class="tok-kw">try</span> gz.addUnNode(.negate, result, source_node);</span>
<span class="line" id="L8616">        <span class="tok-kw">return</span> rvalue(gz, ri, negated, source_node);</span>
<span class="line" id="L8617">    }</span>
<span class="line" id="L8618">}</span>
<span class="line" id="L8619"></span>
<span class="line" id="L8620"><span class="tok-kw">fn</span> <span class="tok-fn">failWithNumberError</span>(astgen: *AstGen, err: std.zig.number_literal.Error, token: Ast.TokenIndex, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) InnerError {</span>
<span class="line" id="L8621">    <span class="tok-kw">const</span> is_float = std.mem.indexOfScalar(<span class="tok-type">u8</span>, bytes, <span class="tok-str">'.'</span>) != <span class="tok-null">null</span>;</span>
<span class="line" id="L8622">    <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L8623">        .leading_zero =&gt; <span class="tok-kw">if</span> (is_float) {</span>
<span class="line" id="L8624">            <span class="tok-kw">return</span> astgen.failTok(token, <span class="tok-str">&quot;number '{s}' has leading zero&quot;</span>, .{bytes});</span>
<span class="line" id="L8625">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L8626">            <span class="tok-kw">return</span> astgen.failTokNotes(token, <span class="tok-str">&quot;number '{s}' has leading zero&quot;</span>, .{bytes}, &amp;.{</span>
<span class="line" id="L8627">                <span class="tok-kw">try</span> astgen.errNoteTok(token, <span class="tok-str">&quot;use '0o' prefix for octal literals&quot;</span>, .{}),</span>
<span class="line" id="L8628">            });</span>
<span class="line" id="L8629">        },</span>
<span class="line" id="L8630">        .digit_after_base =&gt; <span class="tok-kw">return</span> astgen.failTok(token, <span class="tok-str">&quot;expected a digit after base prefix&quot;</span>, .{}),</span>
<span class="line" id="L8631">        .upper_case_base =&gt; |i| <span class="tok-kw">return</span> astgen.failOff(token, <span class="tok-builtin">@intCast</span>(i), <span class="tok-str">&quot;base prefix must be lowercase&quot;</span>, .{}),</span>
<span class="line" id="L8632">        .invalid_float_base =&gt; |i| <span class="tok-kw">return</span> astgen.failOff(token, <span class="tok-builtin">@intCast</span>(i), <span class="tok-str">&quot;invalid base for float literal&quot;</span>, .{}),</span>
<span class="line" id="L8633">        .repeated_underscore =&gt; |i| <span class="tok-kw">return</span> astgen.failOff(token, <span class="tok-builtin">@intCast</span>(i), <span class="tok-str">&quot;repeated digit separator&quot;</span>, .{}),</span>
<span class="line" id="L8634">        .invalid_underscore_after_special =&gt; |i| <span class="tok-kw">return</span> astgen.failOff(token, <span class="tok-builtin">@intCast</span>(i), <span class="tok-str">&quot;expected digit before digit separator&quot;</span>, .{}),</span>
<span class="line" id="L8635">        .invalid_digit =&gt; |info| <span class="tok-kw">return</span> astgen.failOff(token, <span class="tok-builtin">@intCast</span>(info.i), <span class="tok-str">&quot;invalid digit '{c}' for {s} base&quot;</span>, .{ bytes[info.i], <span class="tok-builtin">@tagName</span>(info.base) }),</span>
<span class="line" id="L8636">        .invalid_digit_exponent =&gt; |i| <span class="tok-kw">return</span> astgen.failOff(token, <span class="tok-builtin">@intCast</span>(i), <span class="tok-str">&quot;invalid digit '{c}' in exponent&quot;</span>, .{bytes[i]}),</span>
<span class="line" id="L8637">        .duplicate_exponent =&gt; |i| <span class="tok-kw">return</span> astgen.failOff(token, <span class="tok-builtin">@intCast</span>(i), <span class="tok-str">&quot;duplicate exponent&quot;</span>, .{}),</span>
<span class="line" id="L8638">        .exponent_after_underscore =&gt; |i| <span class="tok-kw">return</span> astgen.failOff(token, <span class="tok-builtin">@intCast</span>(i), <span class="tok-str">&quot;expected digit before exponent&quot;</span>, .{}),</span>
<span class="line" id="L8639">        .special_after_underscore =&gt; |i| <span class="tok-kw">return</span> astgen.failOff(token, <span class="tok-builtin">@intCast</span>(i), <span class="tok-str">&quot;expected digit before '{c}'&quot;</span>, .{bytes[i]}),</span>
<span class="line" id="L8640">        .trailing_special =&gt; |i| <span class="tok-kw">return</span> astgen.failOff(token, <span class="tok-builtin">@intCast</span>(i), <span class="tok-str">&quot;expected digit after '{c}'&quot;</span>, .{bytes[i - <span class="tok-number">1</span>]}),</span>
<span class="line" id="L8641">        .trailing_underscore =&gt; |i| <span class="tok-kw">return</span> astgen.failOff(token, <span class="tok-builtin">@intCast</span>(i), <span class="tok-str">&quot;trailing digit separator&quot;</span>, .{}),</span>
<span class="line" id="L8642">        .duplicate_period =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Validated by tokenizer</span>
</span>
<span class="line" id="L8643">        .invalid_character =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Validated by tokenizer</span>
</span>
<span class="line" id="L8644">        .invalid_exponent_sign =&gt; |i| {</span>
<span class="line" id="L8645">            assert(bytes.len &gt;= <span class="tok-number">2</span> <span class="tok-kw">and</span> bytes[<span class="tok-number">0</span>] == <span class="tok-str">'0'</span> <span class="tok-kw">and</span> bytes[<span class="tok-number">1</span>] == <span class="tok-str">'x'</span>); <span class="tok-comment">// Validated by tokenizer</span>
</span>
<span class="line" id="L8646">            <span class="tok-kw">return</span> astgen.failOff(token, <span class="tok-builtin">@intCast</span>(i), <span class="tok-str">&quot;sign '{c}' cannot follow digit '{c}' in hex base&quot;</span>, .{ bytes[i], bytes[i - <span class="tok-number">1</span>] });</span>
<span class="line" id="L8647">        },</span>
<span class="line" id="L8648">    }</span>
<span class="line" id="L8649">}</span>
<span class="line" id="L8650"></span>
<span class="line" id="L8651"><span class="tok-kw">fn</span> <span class="tok-fn">asmExpr</span>(</span>
<span class="line" id="L8652">    gz: *GenZir,</span>
<span class="line" id="L8653">    scope: *Scope,</span>
<span class="line" id="L8654">    ri: ResultInfo,</span>
<span class="line" id="L8655">    node: Ast.Node.Index,</span>
<span class="line" id="L8656">    full: Ast.full.Asm,</span>
<span class="line" id="L8657">) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L8658">    <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L8659">    <span class="tok-kw">const</span> tree = astgen.tree;</span>
<span class="line" id="L8660">    <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);</span>
<span class="line" id="L8661">    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);</span>
<span class="line" id="L8662">    <span class="tok-kw">const</span> node_tags = tree.nodes.items(.tag);</span>
<span class="line" id="L8663">    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);</span>
<span class="line" id="L8664"></span>
<span class="line" id="L8665">    <span class="tok-kw">const</span> TagAndTmpl = <span class="tok-kw">struct</span> { tag: Zir.Inst.Extended, tmpl: Zir.NullTerminatedString };</span>
<span class="line" id="L8666">    <span class="tok-kw">const</span> tag_and_tmpl: TagAndTmpl = <span class="tok-kw">switch</span> (node_tags[full.ast.template]) {</span>
<span class="line" id="L8667">        .string_literal =&gt; .{</span>
<span class="line" id="L8668">            .tag = .@&quot;asm&quot;,</span>
<span class="line" id="L8669">            .tmpl = (<span class="tok-kw">try</span> astgen.strLitAsString(main_tokens[full.ast.template])).index,</span>
<span class="line" id="L8670">        },</span>
<span class="line" id="L8671">        .multiline_string_literal =&gt; .{</span>
<span class="line" id="L8672">            .tag = .@&quot;asm&quot;,</span>
<span class="line" id="L8673">            .tmpl = (<span class="tok-kw">try</span> astgen.strLitNodeAsString(full.ast.template)).index,</span>
<span class="line" id="L8674">        },</span>
<span class="line" id="L8675">        <span class="tok-kw">else</span> =&gt; .{</span>
<span class="line" id="L8676">            .tag = .asm_expr,</span>
<span class="line" id="L8677">            .tmpl = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@intFromEnum</span>(<span class="tok-kw">try</span> comptimeExpr(gz, scope, .{ .rl = .none }, full.ast.template))),</span>
<span class="line" id="L8678">        },</span>
<span class="line" id="L8679">    };</span>
<span class="line" id="L8680"></span>
<span class="line" id="L8681">    <span class="tok-comment">// See https://github.com/ziglang/zig/issues/215 and related issues discussing</span>
</span>
<span class="line" id="L8682">    <span class="tok-comment">// possible inline assembly improvements. Until then here is status quo AstGen</span>
</span>
<span class="line" id="L8683">    <span class="tok-comment">// for assembly syntax. It's used by std lib crypto aesni.zig.</span>
</span>
<span class="line" id="L8684">    <span class="tok-kw">const</span> is_container_asm = astgen.fn_block == <span class="tok-null">null</span>;</span>
<span class="line" id="L8685">    <span class="tok-kw">if</span> (is_container_asm) {</span>
<span class="line" id="L8686">        <span class="tok-kw">if</span> (full.volatile_token) |t|</span>
<span class="line" id="L8687">            <span class="tok-kw">return</span> astgen.failTok(t, <span class="tok-str">&quot;volatile is meaningless on global assembly&quot;</span>, .{});</span>
<span class="line" id="L8688">        <span class="tok-kw">if</span> (full.outputs.len != <span class="tok-number">0</span> <span class="tok-kw">or</span> full.inputs.len != <span class="tok-number">0</span> <span class="tok-kw">or</span> full.first_clobber != <span class="tok-null">null</span>)</span>
<span class="line" id="L8689">            <span class="tok-kw">return</span> astgen.failNode(node, <span class="tok-str">&quot;global assembly cannot have inputs, outputs, or clobbers&quot;</span>, .{});</span>
<span class="line" id="L8690">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L8691">        <span class="tok-kw">if</span> (full.outputs.len == <span class="tok-number">0</span> <span class="tok-kw">and</span> full.volatile_token == <span class="tok-null">null</span>) {</span>
<span class="line" id="L8692">            <span class="tok-kw">return</span> astgen.failNode(node, <span class="tok-str">&quot;assembly expression with no output must be marked volatile&quot;</span>, .{});</span>
<span class="line" id="L8693">        }</span>
<span class="line" id="L8694">    }</span>
<span class="line" id="L8695">    <span class="tok-kw">if</span> (full.outputs.len &gt; <span class="tok-number">32</span>) {</span>
<span class="line" id="L8696">        <span class="tok-kw">return</span> astgen.failNode(full.outputs[<span class="tok-number">32</span>], <span class="tok-str">&quot;too many asm outputs&quot;</span>, .{});</span>
<span class="line" id="L8697">    }</span>
<span class="line" id="L8698">    <span class="tok-kw">var</span> outputs_buffer: [<span class="tok-number">32</span>]Zir.Inst.Asm.Output = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L8699">    <span class="tok-kw">const</span> outputs = outputs_buffer[<span class="tok-number">0</span>..full.outputs.len];</span>
<span class="line" id="L8700"></span>
<span class="line" id="L8701">    <span class="tok-kw">var</span> output_type_bits: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L8702"></span>
<span class="line" id="L8703">    <span class="tok-kw">for</span> (full.outputs, <span class="tok-number">0</span>..) |output_node, i| {</span>
<span class="line" id="L8704">        <span class="tok-kw">const</span> symbolic_name = main_tokens[output_node];</span>
<span class="line" id="L8705">        <span class="tok-kw">const</span> name = <span class="tok-kw">try</span> astgen.identAsString(symbolic_name);</span>
<span class="line" id="L8706">        <span class="tok-kw">const</span> constraint_token = symbolic_name + <span class="tok-number">2</span>;</span>
<span class="line" id="L8707">        <span class="tok-kw">const</span> constraint = (<span class="tok-kw">try</span> astgen.strLitAsString(constraint_token)).index;</span>
<span class="line" id="L8708">        <span class="tok-kw">const</span> has_arrow = token_tags[symbolic_name + <span class="tok-number">4</span>] == .arrow;</span>
<span class="line" id="L8709">        <span class="tok-kw">if</span> (has_arrow) {</span>
<span class="line" id="L8710">            <span class="tok-kw">if</span> (output_type_bits != <span class="tok-number">0</span>) {</span>
<span class="line" id="L8711">                <span class="tok-kw">return</span> astgen.failNode(output_node, <span class="tok-str">&quot;inline assembly allows up to one output value&quot;</span>, .{});</span>
<span class="line" id="L8712">            }</span>
<span class="line" id="L8713">            output_type_bits |= <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>) &lt;&lt; <span class="tok-builtin">@intCast</span>(i);</span>
<span class="line" id="L8714">            <span class="tok-kw">const</span> out_type_node = node_datas[output_node].lhs;</span>
<span class="line" id="L8715">            <span class="tok-kw">const</span> out_type_inst = <span class="tok-kw">try</span> typeExpr(gz, scope, out_type_node);</span>
<span class="line" id="L8716">            outputs[i] = .{</span>
<span class="line" id="L8717">                .name = name,</span>
<span class="line" id="L8718">                .constraint = constraint,</span>
<span class="line" id="L8719">                .operand = out_type_inst,</span>
<span class="line" id="L8720">            };</span>
<span class="line" id="L8721">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L8722">            <span class="tok-kw">const</span> ident_token = symbolic_name + <span class="tok-number">4</span>;</span>
<span class="line" id="L8723">            <span class="tok-comment">// TODO have a look at #215 and related issues and decide how to</span>
</span>
<span class="line" id="L8724">            <span class="tok-comment">// handle outputs. Do we want this to be identifiers?</span>
</span>
<span class="line" id="L8725">            <span class="tok-comment">// Or maybe we want to force this to be expressions with a pointer type.</span>
</span>
<span class="line" id="L8726">            outputs[i] = .{</span>
<span class="line" id="L8727">                .name = name,</span>
<span class="line" id="L8728">                .constraint = constraint,</span>
<span class="line" id="L8729">                .operand = <span class="tok-kw">try</span> localVarRef(gz, scope, .{ .rl = .ref }, node, ident_token),</span>
<span class="line" id="L8730">            };</span>
<span class="line" id="L8731">        }</span>
<span class="line" id="L8732">    }</span>
<span class="line" id="L8733"></span>
<span class="line" id="L8734">    <span class="tok-kw">if</span> (full.inputs.len &gt; <span class="tok-number">32</span>) {</span>
<span class="line" id="L8735">        <span class="tok-kw">return</span> astgen.failNode(full.inputs[<span class="tok-number">32</span>], <span class="tok-str">&quot;too many asm inputs&quot;</span>, .{});</span>
<span class="line" id="L8736">    }</span>
<span class="line" id="L8737">    <span class="tok-kw">var</span> inputs_buffer: [<span class="tok-number">32</span>]Zir.Inst.Asm.Input = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L8738">    <span class="tok-kw">const</span> inputs = inputs_buffer[<span class="tok-number">0</span>..full.inputs.len];</span>
<span class="line" id="L8739"></span>
<span class="line" id="L8740">    <span class="tok-kw">for</span> (full.inputs, <span class="tok-number">0</span>..) |input_node, i| {</span>
<span class="line" id="L8741">        <span class="tok-kw">const</span> symbolic_name = main_tokens[input_node];</span>
<span class="line" id="L8742">        <span class="tok-kw">const</span> name = <span class="tok-kw">try</span> astgen.identAsString(symbolic_name);</span>
<span class="line" id="L8743">        <span class="tok-kw">const</span> constraint_token = symbolic_name + <span class="tok-number">2</span>;</span>
<span class="line" id="L8744">        <span class="tok-kw">const</span> constraint = (<span class="tok-kw">try</span> astgen.strLitAsString(constraint_token)).index;</span>
<span class="line" id="L8745">        <span class="tok-kw">const</span> operand = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .none }, node_datas[input_node].lhs);</span>
<span class="line" id="L8746">        inputs[i] = .{</span>
<span class="line" id="L8747">            .name = name,</span>
<span class="line" id="L8748">            .constraint = constraint,</span>
<span class="line" id="L8749">            .operand = operand,</span>
<span class="line" id="L8750">        };</span>
<span class="line" id="L8751">    }</span>
<span class="line" id="L8752"></span>
<span class="line" id="L8753">    <span class="tok-kw">var</span> clobbers_buffer: [<span class="tok-number">32</span>]<span class="tok-type">u32</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L8754">    <span class="tok-kw">var</span> clobber_i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L8755">    <span class="tok-kw">if</span> (full.first_clobber) |first_clobber| clobbers: {</span>
<span class="line" id="L8756">        <span class="tok-comment">// asm (&quot;foo&quot; ::: &quot;a&quot;, &quot;b&quot;)</span>
</span>
<span class="line" id="L8757">        <span class="tok-comment">// asm (&quot;foo&quot; ::: &quot;a&quot;, &quot;b&quot;,)</span>
</span>
<span class="line" id="L8758">        <span class="tok-kw">var</span> tok_i = first_clobber;</span>
<span class="line" id="L8759">        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) : (tok_i += <span class="tok-number">1</span>) {</span>
<span class="line" id="L8760">            <span class="tok-kw">if</span> (clobber_i &gt;= clobbers_buffer.len) {</span>
<span class="line" id="L8761">                <span class="tok-kw">return</span> astgen.failTok(tok_i, <span class="tok-str">&quot;too many asm clobbers&quot;</span>, .{});</span>
<span class="line" id="L8762">            }</span>
<span class="line" id="L8763">            clobbers_buffer[clobber_i] = <span class="tok-builtin">@intFromEnum</span>((<span class="tok-kw">try</span> astgen.strLitAsString(tok_i)).index);</span>
<span class="line" id="L8764">            clobber_i += <span class="tok-number">1</span>;</span>
<span class="line" id="L8765">            tok_i += <span class="tok-number">1</span>;</span>
<span class="line" id="L8766">            <span class="tok-kw">switch</span> (token_tags[tok_i]) {</span>
<span class="line" id="L8767">                .r_paren =&gt; <span class="tok-kw">break</span> :clobbers,</span>
<span class="line" id="L8768">                .comma =&gt; {</span>
<span class="line" id="L8769">                    <span class="tok-kw">if</span> (token_tags[tok_i + <span class="tok-number">1</span>] == .r_paren) {</span>
<span class="line" id="L8770">                        <span class="tok-kw">break</span> :clobbers;</span>
<span class="line" id="L8771">                    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L8772">                        <span class="tok-kw">continue</span>;</span>
<span class="line" id="L8773">                    }</span>
<span class="line" id="L8774">                },</span>
<span class="line" id="L8775">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L8776">            }</span>
<span class="line" id="L8777">        }</span>
<span class="line" id="L8778">    }</span>
<span class="line" id="L8779"></span>
<span class="line" id="L8780">    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addAsm(.{</span>
<span class="line" id="L8781">        .tag = tag_and_tmpl.tag,</span>
<span class="line" id="L8782">        .node = node,</span>
<span class="line" id="L8783">        .asm_source = tag_and_tmpl.tmpl,</span>
<span class="line" id="L8784">        .is_volatile = full.volatile_token != <span class="tok-null">null</span>,</span>
<span class="line" id="L8785">        .output_type_bits = output_type_bits,</span>
<span class="line" id="L8786">        .outputs = outputs,</span>
<span class="line" id="L8787">        .inputs = inputs,</span>
<span class="line" id="L8788">        .clobbers = clobbers_buffer[<span class="tok-number">0</span>..clobber_i],</span>
<span class="line" id="L8789">    });</span>
<span class="line" id="L8790">    <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L8791">}</span>
<span class="line" id="L8792"></span>
<span class="line" id="L8793"><span class="tok-kw">fn</span> <span class="tok-fn">as</span>(</span>
<span class="line" id="L8794">    gz: *GenZir,</span>
<span class="line" id="L8795">    scope: *Scope,</span>
<span class="line" id="L8796">    ri: ResultInfo,</span>
<span class="line" id="L8797">    node: Ast.Node.Index,</span>
<span class="line" id="L8798">    lhs: Ast.Node.Index,</span>
<span class="line" id="L8799">    rhs: Ast.Node.Index,</span>
<span class="line" id="L8800">) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L8801">    <span class="tok-kw">const</span> dest_type = <span class="tok-kw">try</span> typeExpr(gz, scope, lhs);</span>
<span class="line" id="L8802">    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> reachableExpr(gz, scope, .{ .rl = .{ .ty = dest_type } }, rhs, node);</span>
<span class="line" id="L8803">    <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L8804">}</span>
<span class="line" id="L8805"></span>
<span class="line" id="L8806"><span class="tok-kw">fn</span> <span class="tok-fn">unionInit</span>(</span>
<span class="line" id="L8807">    gz: *GenZir,</span>
<span class="line" id="L8808">    scope: *Scope,</span>
<span class="line" id="L8809">    ri: ResultInfo,</span>
<span class="line" id="L8810">    node: Ast.Node.Index,</span>
<span class="line" id="L8811">    params: []<span class="tok-kw">const</span> Ast.Node.Index,</span>
<span class="line" id="L8812">) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L8813">    <span class="tok-kw">const</span> union_type = <span class="tok-kw">try</span> typeExpr(gz, scope, params[<span class="tok-number">0</span>]);</span>
<span class="line" id="L8814">    <span class="tok-kw">const</span> field_name = <span class="tok-kw">try</span> comptimeExpr(gz, scope, .{ .rl = .{ .coerced_ty = .slice_const_u8_type } }, params[<span class="tok-number">1</span>]);</span>
<span class="line" id="L8815">    <span class="tok-kw">const</span> field_type = <span class="tok-kw">try</span> gz.addPlNode(.field_type_ref, node, Zir.Inst.FieldTypeRef{</span>
<span class="line" id="L8816">        .container_type = union_type,</span>
<span class="line" id="L8817">        .field_name = field_name,</span>
<span class="line" id="L8818">    });</span>
<span class="line" id="L8819">    <span class="tok-kw">const</span> init = <span class="tok-kw">try</span> reachableExpr(gz, scope, .{ .rl = .{ .ty = field_type } }, params[<span class="tok-number">2</span>], node);</span>
<span class="line" id="L8820">    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addPlNode(.union_init, node, Zir.Inst.UnionInit{</span>
<span class="line" id="L8821">        .union_type = union_type,</span>
<span class="line" id="L8822">        .init = init,</span>
<span class="line" id="L8823">        .field_name = field_name,</span>
<span class="line" id="L8824">    });</span>
<span class="line" id="L8825">    <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L8826">}</span>
<span class="line" id="L8827"></span>
<span class="line" id="L8828"><span class="tok-kw">fn</span> <span class="tok-fn">bitCast</span>(</span>
<span class="line" id="L8829">    gz: *GenZir,</span>
<span class="line" id="L8830">    scope: *Scope,</span>
<span class="line" id="L8831">    ri: ResultInfo,</span>
<span class="line" id="L8832">    node: Ast.Node.Index,</span>
<span class="line" id="L8833">    operand_node: Ast.Node.Index,</span>
<span class="line" id="L8834">) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L8835">    <span class="tok-kw">const</span> dest_type = <span class="tok-kw">try</span> ri.rl.resultTypeForCast(gz, node, <span class="tok-str">&quot;@bitCast&quot;</span>);</span>
<span class="line" id="L8836">    <span class="tok-kw">const</span> operand = <span class="tok-kw">try</span> reachableExpr(gz, scope, .{ .rl = .none }, operand_node, node);</span>
<span class="line" id="L8837">    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addPlNode(.bitcast, node, Zir.Inst.Bin{</span>
<span class="line" id="L8838">        .lhs = dest_type,</span>
<span class="line" id="L8839">        .rhs = operand,</span>
<span class="line" id="L8840">    });</span>
<span class="line" id="L8841">    <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L8842">}</span>
<span class="line" id="L8843"></span>
<span class="line" id="L8844"><span class="tok-comment">/// Handle one or more nested pointer cast builtins:</span></span>
<span class="line" id="L8845"><span class="tok-comment">/// * @ptrCast</span></span>
<span class="line" id="L8846"><span class="tok-comment">/// * @alignCast</span></span>
<span class="line" id="L8847"><span class="tok-comment">/// * @addrSpaceCast</span></span>
<span class="line" id="L8848"><span class="tok-comment">/// * @constCast</span></span>
<span class="line" id="L8849"><span class="tok-comment">/// * @volatileCast</span></span>
<span class="line" id="L8850"><span class="tok-comment">/// Any sequence of such builtins is treated as a single operation. This allowed</span></span>
<span class="line" id="L8851"><span class="tok-comment">/// for sequences like `@ptrCast(@alignCast(ptr))` to work correctly despite the</span></span>
<span class="line" id="L8852"><span class="tok-comment">/// intermediate result type being unknown.</span></span>
<span class="line" id="L8853"><span class="tok-kw">fn</span> <span class="tok-fn">ptrCast</span>(</span>
<span class="line" id="L8854">    gz: *GenZir,</span>
<span class="line" id="L8855">    scope: *Scope,</span>
<span class="line" id="L8856">    ri: ResultInfo,</span>
<span class="line" id="L8857">    root_node: Ast.Node.Index,</span>
<span class="line" id="L8858">) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L8859">    <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L8860">    <span class="tok-kw">const</span> tree = astgen.tree;</span>
<span class="line" id="L8861">    <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);</span>
<span class="line" id="L8862">    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);</span>
<span class="line" id="L8863">    <span class="tok-kw">const</span> node_tags = tree.nodes.items(.tag);</span>
<span class="line" id="L8864"></span>
<span class="line" id="L8865">    <span class="tok-kw">var</span> flags: Zir.Inst.FullPtrCastFlags = .{};</span>
<span class="line" id="L8866"></span>
<span class="line" id="L8867">    <span class="tok-comment">// Note that all pointer cast builtins have one parameter, so we only need</span>
</span>
<span class="line" id="L8868">    <span class="tok-comment">// to handle `builtin_call_two`.</span>
</span>
<span class="line" id="L8869">    <span class="tok-kw">var</span> node = root_node;</span>
<span class="line" id="L8870">    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L8871">        <span class="tok-kw">switch</span> (node_tags[node]) {</span>
<span class="line" id="L8872">            .builtin_call_two, .builtin_call_two_comma =&gt; {},</span>
<span class="line" id="L8873">            .grouped_expression =&gt; {</span>
<span class="line" id="L8874">                <span class="tok-comment">// Handle the chaining even with redundant parentheses</span>
</span>
<span class="line" id="L8875">                node = node_datas[node].lhs;</span>
<span class="line" id="L8876">                <span class="tok-kw">continue</span>;</span>
<span class="line" id="L8877">            },</span>
<span class="line" id="L8878">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">break</span>,</span>
<span class="line" id="L8879">        }</span>
<span class="line" id="L8880"></span>
<span class="line" id="L8881">        <span class="tok-kw">if</span> (node_datas[node].lhs == <span class="tok-number">0</span>) <span class="tok-kw">break</span>; <span class="tok-comment">// 0 args</span>
</span>
<span class="line" id="L8882">        <span class="tok-kw">if</span> (node_datas[node].rhs != <span class="tok-number">0</span>) <span class="tok-kw">break</span>; <span class="tok-comment">// 2 args</span>
</span>
<span class="line" id="L8883"></span>
<span class="line" id="L8884">        <span class="tok-kw">const</span> builtin_token = main_tokens[node];</span>
<span class="line" id="L8885">        <span class="tok-kw">const</span> builtin_name = tree.tokenSlice(builtin_token);</span>
<span class="line" id="L8886">        <span class="tok-kw">const</span> info = BuiltinFn.list.get(builtin_name) <span class="tok-kw">orelse</span> <span class="tok-kw">break</span>;</span>
<span class="line" id="L8887">        <span class="tok-kw">if</span> (info.param_count != <span class="tok-number">1</span>) <span class="tok-kw">break</span>;</span>
<span class="line" id="L8888"></span>
<span class="line" id="L8889">        <span class="tok-kw">switch</span> (info.tag) {</span>
<span class="line" id="L8890">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">break</span>,</span>
<span class="line" id="L8891">            <span class="tok-kw">inline</span> .ptr_cast,</span>
<span class="line" id="L8892">            .align_cast,</span>
<span class="line" id="L8893">            .addrspace_cast,</span>
<span class="line" id="L8894">            .const_cast,</span>
<span class="line" id="L8895">            .volatile_cast,</span>
<span class="line" id="L8896">            =&gt; |tag| {</span>
<span class="line" id="L8897">                <span class="tok-kw">if</span> (<span class="tok-builtin">@field</span>(flags, <span class="tok-builtin">@tagName</span>(tag))) {</span>
<span class="line" id="L8898">                    <span class="tok-kw">return</span> astgen.failNode(node, <span class="tok-str">&quot;redundant {s}&quot;</span>, .{builtin_name});</span>
<span class="line" id="L8899">                }</span>
<span class="line" id="L8900">                <span class="tok-builtin">@field</span>(flags, <span class="tok-builtin">@tagName</span>(tag)) = <span class="tok-null">true</span>;</span>
<span class="line" id="L8901">            },</span>
<span class="line" id="L8902">        }</span>
<span class="line" id="L8903"></span>
<span class="line" id="L8904">        node = node_datas[node].lhs;</span>
<span class="line" id="L8905">    }</span>
<span class="line" id="L8906"></span>
<span class="line" id="L8907">    <span class="tok-kw">const</span> flags_i: <span class="tok-type">u5</span> = <span class="tok-builtin">@bitCast</span>(flags);</span>
<span class="line" id="L8908">    assert(flags_i != <span class="tok-number">0</span>);</span>
<span class="line" id="L8909"></span>
<span class="line" id="L8910">    <span class="tok-kw">const</span> ptr_only: Zir.Inst.FullPtrCastFlags = .{ .ptr_cast = <span class="tok-null">true</span> };</span>
<span class="line" id="L8911">    <span class="tok-kw">if</span> (flags_i == <span class="tok-builtin">@as</span>(<span class="tok-type">u5</span>, <span class="tok-builtin">@bitCast</span>(ptr_only))) {</span>
<span class="line" id="L8912">        <span class="tok-comment">// Special case: simpler representation</span>
</span>
<span class="line" id="L8913">        <span class="tok-kw">return</span> typeCast(gz, scope, ri, root_node, node, .ptr_cast, <span class="tok-str">&quot;@ptrCast&quot;</span>);</span>
<span class="line" id="L8914">    }</span>
<span class="line" id="L8915"></span>
<span class="line" id="L8916">    <span class="tok-kw">const</span> no_result_ty_flags: Zir.Inst.FullPtrCastFlags = .{</span>
<span class="line" id="L8917">        .const_cast = <span class="tok-null">true</span>,</span>
<span class="line" id="L8918">        .volatile_cast = <span class="tok-null">true</span>,</span>
<span class="line" id="L8919">    };</span>
<span class="line" id="L8920">    <span class="tok-kw">if</span> ((flags_i &amp; ~<span class="tok-builtin">@as</span>(<span class="tok-type">u5</span>, <span class="tok-builtin">@bitCast</span>(no_result_ty_flags))) == <span class="tok-number">0</span>) {</span>
<span class="line" id="L8921">        <span class="tok-comment">// Result type not needed</span>
</span>
<span class="line" id="L8922">        <span class="tok-kw">const</span> cursor = maybeAdvanceSourceCursorToMainToken(gz, root_node);</span>
<span class="line" id="L8923">        <span class="tok-kw">const</span> operand = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .none }, node);</span>
<span class="line" id="L8924">        <span class="tok-kw">try</span> emitDbgStmt(gz, cursor);</span>
<span class="line" id="L8925">        <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addExtendedPayloadSmall(.ptr_cast_no_dest, flags_i, Zir.Inst.UnNode{</span>
<span class="line" id="L8926">            .node = gz.nodeIndexToRelative(root_node),</span>
<span class="line" id="L8927">            .operand = operand,</span>
<span class="line" id="L8928">        });</span>
<span class="line" id="L8929">        <span class="tok-kw">return</span> rvalue(gz, ri, result, root_node);</span>
<span class="line" id="L8930">    }</span>
<span class="line" id="L8931"></span>
<span class="line" id="L8932">    <span class="tok-comment">// Full cast including result type</span>
</span>
<span class="line" id="L8933"></span>
<span class="line" id="L8934">    <span class="tok-kw">const</span> cursor = maybeAdvanceSourceCursorToMainToken(gz, root_node);</span>
<span class="line" id="L8935">    <span class="tok-kw">const</span> result_type = <span class="tok-kw">try</span> ri.rl.resultTypeForCast(gz, root_node, flags.needResultTypeBuiltinName());</span>
<span class="line" id="L8936">    <span class="tok-kw">const</span> operand = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .none }, node);</span>
<span class="line" id="L8937">    <span class="tok-kw">try</span> emitDbgStmt(gz, cursor);</span>
<span class="line" id="L8938">    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addExtendedPayloadSmall(.ptr_cast_full, flags_i, Zir.Inst.BinNode{</span>
<span class="line" id="L8939">        .node = gz.nodeIndexToRelative(root_node),</span>
<span class="line" id="L8940">        .lhs = result_type,</span>
<span class="line" id="L8941">        .rhs = operand,</span>
<span class="line" id="L8942">    });</span>
<span class="line" id="L8943">    <span class="tok-kw">return</span> rvalue(gz, ri, result, root_node);</span>
<span class="line" id="L8944">}</span>
<span class="line" id="L8945"></span>
<span class="line" id="L8946"><span class="tok-kw">fn</span> <span class="tok-fn">typeOf</span>(</span>
<span class="line" id="L8947">    gz: *GenZir,</span>
<span class="line" id="L8948">    scope: *Scope,</span>
<span class="line" id="L8949">    ri: ResultInfo,</span>
<span class="line" id="L8950">    node: Ast.Node.Index,</span>
<span class="line" id="L8951">    args: []<span class="tok-kw">const</span> Ast.Node.Index,</span>
<span class="line" id="L8952">) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L8953">    <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L8954">    <span class="tok-kw">if</span> (args.len &lt; <span class="tok-number">1</span>) {</span>
<span class="line" id="L8955">        <span class="tok-kw">return</span> astgen.failNode(node, <span class="tok-str">&quot;expected at least 1 argument, found 0&quot;</span>, .{});</span>
<span class="line" id="L8956">    }</span>
<span class="line" id="L8957">    <span class="tok-kw">const</span> gpa = astgen.gpa;</span>
<span class="line" id="L8958">    <span class="tok-kw">if</span> (args.len == <span class="tok-number">1</span>) {</span>
<span class="line" id="L8959">        <span class="tok-kw">const</span> typeof_inst = <span class="tok-kw">try</span> gz.makeBlockInst(.typeof_builtin, node);</span>
<span class="line" id="L8960"></span>
<span class="line" id="L8961">        <span class="tok-kw">var</span> typeof_scope = gz.makeSubBlock(scope);</span>
<span class="line" id="L8962">        typeof_scope.is_comptime = <span class="tok-null">false</span>;</span>
<span class="line" id="L8963">        typeof_scope.is_typeof = <span class="tok-null">true</span>;</span>
<span class="line" id="L8964">        typeof_scope.c_import = <span class="tok-null">false</span>;</span>
<span class="line" id="L8965">        <span class="tok-kw">defer</span> typeof_scope.unstack();</span>
<span class="line" id="L8966"></span>
<span class="line" id="L8967">        <span class="tok-kw">const</span> ty_expr = <span class="tok-kw">try</span> reachableExpr(&amp;typeof_scope, &amp;typeof_scope.base, .{ .rl = .none }, args[<span class="tok-number">0</span>], node);</span>
<span class="line" id="L8968">        <span class="tok-kw">if</span> (!gz.refIsNoReturn(ty_expr)) {</span>
<span class="line" id="L8969">            _ = <span class="tok-kw">try</span> typeof_scope.addBreak(.break_inline, typeof_inst, ty_expr);</span>
<span class="line" id="L8970">        }</span>
<span class="line" id="L8971">        <span class="tok-kw">try</span> typeof_scope.setBlockBody(typeof_inst);</span>
<span class="line" id="L8972"></span>
<span class="line" id="L8973">        <span class="tok-comment">// typeof_scope unstacked now, can add new instructions to gz</span>
</span>
<span class="line" id="L8974">        <span class="tok-kw">try</span> gz.instructions.append(gpa, typeof_inst);</span>
<span class="line" id="L8975">        <span class="tok-kw">return</span> rvalue(gz, ri, typeof_inst.toRef(), node);</span>
<span class="line" id="L8976">    }</span>
<span class="line" id="L8977">    <span class="tok-kw">const</span> payload_size: <span class="tok-type">u32</span> = std.meta.fields(Zir.Inst.TypeOfPeer).len;</span>
<span class="line" id="L8978">    <span class="tok-kw">const</span> payload_index = <span class="tok-kw">try</span> reserveExtra(astgen, payload_size + args.len);</span>
<span class="line" id="L8979">    <span class="tok-kw">const</span> args_index = payload_index + payload_size;</span>
<span class="line" id="L8980"></span>
<span class="line" id="L8981">    <span class="tok-kw">const</span> typeof_inst = <span class="tok-kw">try</span> gz.addExtendedMultiOpPayloadIndex(.typeof_peer, payload_index, args.len);</span>
<span class="line" id="L8982"></span>
<span class="line" id="L8983">    <span class="tok-kw">var</span> typeof_scope = gz.makeSubBlock(scope);</span>
<span class="line" id="L8984">    typeof_scope.is_comptime = <span class="tok-null">false</span>;</span>
<span class="line" id="L8985"></span>
<span class="line" id="L8986">    <span class="tok-kw">for</span> (args, <span class="tok-number">0</span>..) |arg, i| {</span>
<span class="line" id="L8987">        <span class="tok-kw">const</span> param_ref = <span class="tok-kw">try</span> reachableExpr(&amp;typeof_scope, &amp;typeof_scope.base, .{ .rl = .none }, arg, node);</span>
<span class="line" id="L8988">        astgen.extra.items[args_index + i] = <span class="tok-builtin">@intFromEnum</span>(param_ref);</span>
<span class="line" id="L8989">    }</span>
<span class="line" id="L8990">    _ = <span class="tok-kw">try</span> typeof_scope.addBreak(.break_inline, typeof_inst.toIndex().?, .void_value);</span>
<span class="line" id="L8991"></span>
<span class="line" id="L8992">    <span class="tok-kw">const</span> body = typeof_scope.instructionsSlice();</span>
<span class="line" id="L8993">    <span class="tok-kw">const</span> body_len = astgen.countBodyLenAfterFixups(body);</span>
<span class="line" id="L8994">    astgen.setExtra(payload_index, Zir.Inst.TypeOfPeer{</span>
<span class="line" id="L8995">        .body_len = <span class="tok-builtin">@intCast</span>(body_len),</span>
<span class="line" id="L8996">        .body_index = <span class="tok-builtin">@intCast</span>(astgen.extra.items.len),</span>
<span class="line" id="L8997">        .src_node = gz.nodeIndexToRelative(node),</span>
<span class="line" id="L8998">    });</span>
<span class="line" id="L8999">    <span class="tok-kw">try</span> astgen.extra.ensureUnusedCapacity(gpa, body_len);</span>
<span class="line" id="L9000">    astgen.appendBodyWithFixups(body);</span>
<span class="line" id="L9001">    typeof_scope.unstack();</span>
<span class="line" id="L9002"></span>
<span class="line" id="L9003">    <span class="tok-kw">return</span> rvalue(gz, ri, typeof_inst, node);</span>
<span class="line" id="L9004">}</span>
<span class="line" id="L9005"></span>
<span class="line" id="L9006"><span class="tok-kw">fn</span> <span class="tok-fn">minMax</span>(</span>
<span class="line" id="L9007">    gz: *GenZir,</span>
<span class="line" id="L9008">    scope: *Scope,</span>
<span class="line" id="L9009">    ri: ResultInfo,</span>
<span class="line" id="L9010">    node: Ast.Node.Index,</span>
<span class="line" id="L9011">    args: []<span class="tok-kw">const</span> Ast.Node.Index,</span>
<span class="line" id="L9012">    <span class="tok-kw">comptime</span> op: <span class="tok-kw">enum</span> { min, max },</span>
<span class="line" id="L9013">) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L9014">    <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L9015">    <span class="tok-kw">if</span> (args.len &lt; <span class="tok-number">2</span>) {</span>
<span class="line" id="L9016">        <span class="tok-kw">return</span> astgen.failNode(node, <span class="tok-str">&quot;expected at least 2 arguments, found 0&quot;</span>, .{});</span>
<span class="line" id="L9017">    }</span>
<span class="line" id="L9018">    <span class="tok-kw">if</span> (args.len == <span class="tok-number">2</span>) {</span>
<span class="line" id="L9019">        <span class="tok-kw">const</span> tag: Zir.Inst.Tag = <span class="tok-kw">switch</span> (op) {</span>
<span class="line" id="L9020">            .min =&gt; .min,</span>
<span class="line" id="L9021">            .max =&gt; .max,</span>
<span class="line" id="L9022">        };</span>
<span class="line" id="L9023">        <span class="tok-kw">const</span> a = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .none }, args[<span class="tok-number">0</span>]);</span>
<span class="line" id="L9024">        <span class="tok-kw">const</span> b = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .none }, args[<span class="tok-number">1</span>]);</span>
<span class="line" id="L9025">        <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addPlNode(tag, node, Zir.Inst.Bin{</span>
<span class="line" id="L9026">            .lhs = a,</span>
<span class="line" id="L9027">            .rhs = b,</span>
<span class="line" id="L9028">        });</span>
<span class="line" id="L9029">        <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L9030">    }</span>
<span class="line" id="L9031">    <span class="tok-kw">const</span> payload_index = <span class="tok-kw">try</span> addExtra(astgen, Zir.Inst.NodeMultiOp{</span>
<span class="line" id="L9032">        .src_node = gz.nodeIndexToRelative(node),</span>
<span class="line" id="L9033">    });</span>
<span class="line" id="L9034">    <span class="tok-kw">var</span> extra_index = <span class="tok-kw">try</span> reserveExtra(gz.astgen, args.len);</span>
<span class="line" id="L9035">    <span class="tok-kw">for</span> (args) |arg| {</span>
<span class="line" id="L9036">        <span class="tok-kw">const</span> arg_ref = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .none }, arg);</span>
<span class="line" id="L9037">        astgen.extra.items[extra_index] = <span class="tok-builtin">@intFromEnum</span>(arg_ref);</span>
<span class="line" id="L9038">        extra_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L9039">    }</span>
<span class="line" id="L9040">    <span class="tok-kw">const</span> tag: Zir.Inst.Extended = <span class="tok-kw">switch</span> (op) {</span>
<span class="line" id="L9041">        .min =&gt; .min_multi,</span>
<span class="line" id="L9042">        .max =&gt; .max_multi,</span>
<span class="line" id="L9043">    };</span>
<span class="line" id="L9044">    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addExtendedMultiOpPayloadIndex(tag, payload_index, args.len);</span>
<span class="line" id="L9045">    <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L9046">}</span>
<span class="line" id="L9047"></span>
<span class="line" id="L9048"><span class="tok-kw">fn</span> <span class="tok-fn">builtinCall</span>(</span>
<span class="line" id="L9049">    gz: *GenZir,</span>
<span class="line" id="L9050">    scope: *Scope,</span>
<span class="line" id="L9051">    ri: ResultInfo,</span>
<span class="line" id="L9052">    node: Ast.Node.Index,</span>
<span class="line" id="L9053">    params: []<span class="tok-kw">const</span> Ast.Node.Index,</span>
<span class="line" id="L9054">) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L9055">    <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L9056">    <span class="tok-kw">const</span> tree = astgen.tree;</span>
<span class="line" id="L9057">    <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);</span>
<span class="line" id="L9058"></span>
<span class="line" id="L9059">    <span class="tok-kw">const</span> builtin_token = main_tokens[node];</span>
<span class="line" id="L9060">    <span class="tok-kw">const</span> builtin_name = tree.tokenSlice(builtin_token);</span>
<span class="line" id="L9061"></span>
<span class="line" id="L9062">    <span class="tok-comment">// We handle the different builtins manually because they have different semantics depending</span>
</span>
<span class="line" id="L9063">    <span class="tok-comment">// on the function. For example, `@as` and others participate in result location semantics,</span>
</span>
<span class="line" id="L9064">    <span class="tok-comment">// and `@cImport` creates a special scope that collects a .c source code text buffer.</span>
</span>
<span class="line" id="L9065">    <span class="tok-comment">// Also, some builtins have a variable number of parameters.</span>
</span>
<span class="line" id="L9066"></span>
<span class="line" id="L9067">    <span class="tok-kw">const</span> info = BuiltinFn.list.get(builtin_name) <span class="tok-kw">orelse</span> {</span>
<span class="line" id="L9068">        <span class="tok-kw">return</span> astgen.failNode(node, <span class="tok-str">&quot;invalid builtin function: '{s}'&quot;</span>, .{</span>
<span class="line" id="L9069">            builtin_name,</span>
<span class="line" id="L9070">        });</span>
<span class="line" id="L9071">    };</span>
<span class="line" id="L9072">    <span class="tok-kw">if</span> (info.param_count) |expected| {</span>
<span class="line" id="L9073">        <span class="tok-kw">if</span> (expected != params.len) {</span>
<span class="line" id="L9074">            <span class="tok-kw">const</span> s = <span class="tok-kw">if</span> (expected == <span class="tok-number">1</span>) <span class="tok-str">&quot;&quot;</span> <span class="tok-kw">else</span> <span class="tok-str">&quot;s&quot;</span>;</span>
<span class="line" id="L9075">            <span class="tok-kw">return</span> astgen.failNode(node, <span class="tok-str">&quot;expected {d} argument{s}, found {d}&quot;</span>, .{</span>
<span class="line" id="L9076">                expected, s, params.len,</span>
<span class="line" id="L9077">            });</span>
<span class="line" id="L9078">        }</span>
<span class="line" id="L9079">    }</span>
<span class="line" id="L9080"></span>
<span class="line" id="L9081">    <span class="tok-comment">// Check function scope-only builtins</span>
</span>
<span class="line" id="L9082"></span>
<span class="line" id="L9083">    <span class="tok-kw">if</span> (astgen.fn_block == <span class="tok-null">null</span> <span class="tok-kw">and</span> info.illegal_outside_function)</span>
<span class="line" id="L9084">        <span class="tok-kw">return</span> astgen.failNode(node, <span class="tok-str">&quot;'{s}' outside function scope&quot;</span>, .{builtin_name});</span>
<span class="line" id="L9085"></span>
<span class="line" id="L9086">    <span class="tok-kw">switch</span> (info.tag) {</span>
<span class="line" id="L9087">        .import =&gt; {</span>
<span class="line" id="L9088">            <span class="tok-kw">const</span> node_tags = tree.nodes.items(.tag);</span>
<span class="line" id="L9089">            <span class="tok-kw">const</span> operand_node = params[<span class="tok-number">0</span>];</span>
<span class="line" id="L9090"></span>
<span class="line" id="L9091">            <span class="tok-kw">if</span> (node_tags[operand_node] != .string_literal) {</span>
<span class="line" id="L9092">                <span class="tok-comment">// Spec reference: https://github.com/ziglang/zig/issues/2206</span>
</span>
<span class="line" id="L9093">                <span class="tok-kw">return</span> astgen.failNode(operand_node, <span class="tok-str">&quot;@import operand must be a string literal&quot;</span>, .{});</span>
<span class="line" id="L9094">            }</span>
<span class="line" id="L9095">            <span class="tok-kw">const</span> str_lit_token = main_tokens[operand_node];</span>
<span class="line" id="L9096">            <span class="tok-kw">const</span> str = <span class="tok-kw">try</span> astgen.strLitAsString(str_lit_token);</span>
<span class="line" id="L9097">            <span class="tok-kw">const</span> str_slice = astgen.string_bytes.items[<span class="tok-builtin">@intFromEnum</span>(str.index)..][<span class="tok-number">0</span>..str.len];</span>
<span class="line" id="L9098">            <span class="tok-kw">if</span> (mem.indexOfScalar(<span class="tok-type">u8</span>, str_slice, <span class="tok-number">0</span>) != <span class="tok-null">null</span>) {</span>
<span class="line" id="L9099">                <span class="tok-kw">return</span> astgen.failTok(str_lit_token, <span class="tok-str">&quot;import path cannot contain null bytes&quot;</span>, .{});</span>
<span class="line" id="L9100">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (str.len == <span class="tok-number">0</span>) {</span>
<span class="line" id="L9101">                <span class="tok-kw">return</span> astgen.failTok(str_lit_token, <span class="tok-str">&quot;import path cannot be empty&quot;</span>, .{});</span>
<span class="line" id="L9102">            }</span>
<span class="line" id="L9103">            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addStrTok(.import, str.index, str_lit_token);</span>
<span class="line" id="L9104">            <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> astgen.imports.getOrPut(astgen.gpa, str.index);</span>
<span class="line" id="L9105">            <span class="tok-kw">if</span> (!gop.found_existing) {</span>
<span class="line" id="L9106">                gop.value_ptr.* = str_lit_token;</span>
<span class="line" id="L9107">            }</span>
<span class="line" id="L9108">            <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L9109">        },</span>
<span class="line" id="L9110">        .compile_log =&gt; {</span>
<span class="line" id="L9111">            <span class="tok-kw">const</span> payload_index = <span class="tok-kw">try</span> addExtra(gz.astgen, Zir.Inst.NodeMultiOp{</span>
<span class="line" id="L9112">                .src_node = gz.nodeIndexToRelative(node),</span>
<span class="line" id="L9113">            });</span>
<span class="line" id="L9114">            <span class="tok-kw">var</span> extra_index = <span class="tok-kw">try</span> reserveExtra(gz.astgen, params.len);</span>
<span class="line" id="L9115">            <span class="tok-kw">for</span> (params) |param| {</span>
<span class="line" id="L9116">                <span class="tok-kw">const</span> param_ref = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .none }, param);</span>
<span class="line" id="L9117">                astgen.extra.items[extra_index] = <span class="tok-builtin">@intFromEnum</span>(param_ref);</span>
<span class="line" id="L9118">                extra_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L9119">            }</span>
<span class="line" id="L9120">            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addExtendedMultiOpPayloadIndex(.compile_log, payload_index, params.len);</span>
<span class="line" id="L9121">            <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L9122">        },</span>
<span class="line" id="L9123">        .field =&gt; {</span>
<span class="line" id="L9124">            <span class="tok-kw">if</span> (ri.rl == .ref <span class="tok-kw">or</span> ri.rl == .ref_coerced_ty) {</span>
<span class="line" id="L9125">                <span class="tok-kw">return</span> gz.addPlNode(.field_ptr_named, node, Zir.Inst.FieldNamed{</span>
<span class="line" id="L9126">                    .lhs = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .ref }, params[<span class="tok-number">0</span>]),</span>
<span class="line" id="L9127">                    .field_name = <span class="tok-kw">try</span> comptimeExpr(gz, scope, .{ .rl = .{ .coerced_ty = .slice_const_u8_type } }, params[<span class="tok-number">1</span>]),</span>
<span class="line" id="L9128">                });</span>
<span class="line" id="L9129">            }</span>
<span class="line" id="L9130">            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addPlNode(.field_val_named, node, Zir.Inst.FieldNamed{</span>
<span class="line" id="L9131">                .lhs = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .none }, params[<span class="tok-number">0</span>]),</span>
<span class="line" id="L9132">                .field_name = <span class="tok-kw">try</span> comptimeExpr(gz, scope, .{ .rl = .{ .coerced_ty = .slice_const_u8_type } }, params[<span class="tok-number">1</span>]),</span>
<span class="line" id="L9133">            });</span>
<span class="line" id="L9134">            <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L9135">        },</span>
<span class="line" id="L9136"></span>
<span class="line" id="L9137">        <span class="tok-comment">// zig fmt: off</span>
</span>
<span class="line" id="L9138">        .as         =&gt; <span class="tok-kw">return</span> as(       gz, scope, ri, node, params[<span class="tok-number">0</span>], params[<span class="tok-number">1</span>]),</span>
<span class="line" id="L9139">        .bit_cast   =&gt; <span class="tok-kw">return</span> bitCast(  gz, scope, ri, node, params[<span class="tok-number">0</span>]),</span>
<span class="line" id="L9140">        .TypeOf     =&gt; <span class="tok-kw">return</span> typeOf(   gz, scope, ri, node, params),</span>
<span class="line" id="L9141">        .union_init =&gt; <span class="tok-kw">return</span> unionInit(gz, scope, ri, node, params),</span>
<span class="line" id="L9142">        .c_import   =&gt; <span class="tok-kw">return</span> cImport(  gz, scope,     node, params[<span class="tok-number">0</span>]),</span>
<span class="line" id="L9143">        .min        =&gt; <span class="tok-kw">return</span> minMax(   gz, scope, ri, node, params, .min),</span>
<span class="line" id="L9144">        .max        =&gt; <span class="tok-kw">return</span> minMax(   gz, scope, ri, node, params, .max),</span>
<span class="line" id="L9145">        <span class="tok-comment">// zig fmt: on</span>
</span>
<span class="line" id="L9146"></span>
<span class="line" id="L9147">        .@&quot;export&quot; =&gt; {</span>
<span class="line" id="L9148">            <span class="tok-kw">const</span> node_tags = tree.nodes.items(.tag);</span>
<span class="line" id="L9149">            <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);</span>
<span class="line" id="L9150">            <span class="tok-comment">// This function causes a Decl to be exported. The first parameter is not an expression,</span>
</span>
<span class="line" id="L9151">            <span class="tok-comment">// but an identifier of the Decl to be exported.</span>
</span>
<span class="line" id="L9152">            <span class="tok-kw">var</span> namespace: Zir.Inst.Ref = .none;</span>
<span class="line" id="L9153">            <span class="tok-kw">var</span> decl_name: Zir.NullTerminatedString = .empty;</span>
<span class="line" id="L9154">            <span class="tok-kw">switch</span> (node_tags[params[<span class="tok-number">0</span>]]) {</span>
<span class="line" id="L9155">                .identifier =&gt; {</span>
<span class="line" id="L9156">                    <span class="tok-kw">const</span> ident_token = main_tokens[params[<span class="tok-number">0</span>]];</span>
<span class="line" id="L9157">                    <span class="tok-kw">if</span> (isPrimitive(tree.tokenSlice(ident_token))) {</span>
<span class="line" id="L9158">                        <span class="tok-kw">return</span> astgen.failTok(ident_token, <span class="tok-str">&quot;unable to export primitive value&quot;</span>, .{});</span>
<span class="line" id="L9159">                    }</span>
<span class="line" id="L9160">                    decl_name = <span class="tok-kw">try</span> astgen.identAsString(ident_token);</span>
<span class="line" id="L9161"></span>
<span class="line" id="L9162">                    <span class="tok-kw">var</span> s = scope;</span>
<span class="line" id="L9163">                    <span class="tok-kw">var</span> found_already: ?Ast.Node.Index = <span class="tok-null">null</span>; <span class="tok-comment">// we have found a decl with the same name already</span>
</span>
<span class="line" id="L9164">                    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) <span class="tok-kw">switch</span> (s.tag) {</span>
<span class="line" id="L9165">                        .local_val =&gt; {</span>
<span class="line" id="L9166">                            <span class="tok-kw">const</span> local_val = s.cast(Scope.LocalVal).?;</span>
<span class="line" id="L9167">                            <span class="tok-kw">if</span> (local_val.name == decl_name) {</span>
<span class="line" id="L9168">                                local_val.used = ident_token;</span>
<span class="line" id="L9169">                                _ = <span class="tok-kw">try</span> gz.addPlNode(.export_value, node, Zir.Inst.ExportValue{</span>
<span class="line" id="L9170">                                    .operand = local_val.inst,</span>
<span class="line" id="L9171">                                    .options = <span class="tok-kw">try</span> comptimeExpr(gz, scope, .{ .rl = .{ .coerced_ty = .export_options_type } }, params[<span class="tok-number">1</span>]),</span>
<span class="line" id="L9172">                                });</span>
<span class="line" id="L9173">                                <span class="tok-kw">return</span> rvalue(gz, ri, .void_value, node);</span>
<span class="line" id="L9174">                            }</span>
<span class="line" id="L9175">                            s = local_val.parent;</span>
<span class="line" id="L9176">                        },</span>
<span class="line" id="L9177">                        .local_ptr =&gt; {</span>
<span class="line" id="L9178">                            <span class="tok-kw">const</span> local_ptr = s.cast(Scope.LocalPtr).?;</span>
<span class="line" id="L9179">                            <span class="tok-kw">if</span> (local_ptr.name == decl_name) {</span>
<span class="line" id="L9180">                                <span class="tok-kw">if</span> (!local_ptr.maybe_comptime)</span>
<span class="line" id="L9181">                                    <span class="tok-kw">return</span> astgen.failNode(params[<span class="tok-number">0</span>], <span class="tok-str">&quot;unable to export runtime-known value&quot;</span>, .{});</span>
<span class="line" id="L9182">                                local_ptr.used = ident_token;</span>
<span class="line" id="L9183">                                <span class="tok-kw">const</span> loaded = <span class="tok-kw">try</span> gz.addUnNode(.load, local_ptr.ptr, node);</span>
<span class="line" id="L9184">                                _ = <span class="tok-kw">try</span> gz.addPlNode(.export_value, node, Zir.Inst.ExportValue{</span>
<span class="line" id="L9185">                                    .operand = loaded,</span>
<span class="line" id="L9186">                                    .options = <span class="tok-kw">try</span> comptimeExpr(gz, scope, .{ .rl = .{ .coerced_ty = .export_options_type } }, params[<span class="tok-number">1</span>]),</span>
<span class="line" id="L9187">                                });</span>
<span class="line" id="L9188">                                <span class="tok-kw">return</span> rvalue(gz, ri, .void_value, node);</span>
<span class="line" id="L9189">                            }</span>
<span class="line" id="L9190">                            s = local_ptr.parent;</span>
<span class="line" id="L9191">                        },</span>
<span class="line" id="L9192">                        .gen_zir =&gt; s = s.cast(GenZir).?.parent,</span>
<span class="line" id="L9193">                        .defer_normal, .defer_error =&gt; s = s.cast(Scope.Defer).?.parent,</span>
<span class="line" id="L9194">                        .namespace =&gt; {</span>
<span class="line" id="L9195">                            <span class="tok-kw">const</span> ns = s.cast(Scope.Namespace).?;</span>
<span class="line" id="L9196">                            <span class="tok-kw">if</span> (ns.decls.get(decl_name)) |i| {</span>
<span class="line" id="L9197">                                <span class="tok-kw">if</span> (found_already) |f| {</span>
<span class="line" id="L9198">                                    <span class="tok-kw">return</span> astgen.failNodeNotes(node, <span class="tok-str">&quot;ambiguous reference&quot;</span>, .{}, &amp;.{</span>
<span class="line" id="L9199">                                        <span class="tok-kw">try</span> astgen.errNoteNode(f, <span class="tok-str">&quot;declared here&quot;</span>, .{}),</span>
<span class="line" id="L9200">                                        <span class="tok-kw">try</span> astgen.errNoteNode(i, <span class="tok-str">&quot;also declared here&quot;</span>, .{}),</span>
<span class="line" id="L9201">                                    });</span>
<span class="line" id="L9202">                                }</span>
<span class="line" id="L9203">                                <span class="tok-comment">// We found a match but must continue looking for ambiguous references to decls.</span>
</span>
<span class="line" id="L9204">                                found_already = i;</span>
<span class="line" id="L9205">                            }</span>
<span class="line" id="L9206">                            s = ns.parent;</span>
<span class="line" id="L9207">                        },</span>
<span class="line" id="L9208">                        .top =&gt; <span class="tok-kw">break</span>,</span>
<span class="line" id="L9209">                    };</span>
<span class="line" id="L9210">                    <span class="tok-kw">if</span> (found_already == <span class="tok-null">null</span>) {</span>
<span class="line" id="L9211">                        <span class="tok-kw">const</span> ident_name = <span class="tok-kw">try</span> astgen.identifierTokenString(ident_token);</span>
<span class="line" id="L9212">                        <span class="tok-kw">return</span> astgen.failNode(params[<span class="tok-number">0</span>], <span class="tok-str">&quot;use of undeclared identifier '{s}'&quot;</span>, .{ident_name});</span>
<span class="line" id="L9213">                    }</span>
<span class="line" id="L9214">                },</span>
<span class="line" id="L9215">                .field_access =&gt; {</span>
<span class="line" id="L9216">                    <span class="tok-kw">const</span> namespace_node = node_datas[params[<span class="tok-number">0</span>]].lhs;</span>
<span class="line" id="L9217">                    namespace = <span class="tok-kw">try</span> typeExpr(gz, scope, namespace_node);</span>
<span class="line" id="L9218">                    <span class="tok-kw">const</span> dot_token = main_tokens[params[<span class="tok-number">0</span>]];</span>
<span class="line" id="L9219">                    <span class="tok-kw">const</span> field_ident = dot_token + <span class="tok-number">1</span>;</span>
<span class="line" id="L9220">                    decl_name = <span class="tok-kw">try</span> astgen.identAsString(field_ident);</span>
<span class="line" id="L9221">                },</span>
<span class="line" id="L9222">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> astgen.failNode(params[<span class="tok-number">0</span>], <span class="tok-str">&quot;symbol to export must identify a declaration&quot;</span>, .{}),</span>
<span class="line" id="L9223">            }</span>
<span class="line" id="L9224">            <span class="tok-kw">const</span> options = <span class="tok-kw">try</span> comptimeExpr(gz, scope, .{ .rl = .{ .coerced_ty = .export_options_type } }, params[<span class="tok-number">1</span>]);</span>
<span class="line" id="L9225">            _ = <span class="tok-kw">try</span> gz.addPlNode(.@&quot;export&quot;, node, Zir.Inst.Export{</span>
<span class="line" id="L9226">                .namespace = namespace,</span>
<span class="line" id="L9227">                .decl_name = decl_name,</span>
<span class="line" id="L9228">                .options = options,</span>
<span class="line" id="L9229">            });</span>
<span class="line" id="L9230">            <span class="tok-kw">return</span> rvalue(gz, ri, .void_value, node);</span>
<span class="line" id="L9231">        },</span>
<span class="line" id="L9232">        .@&quot;extern&quot; =&gt; {</span>
<span class="line" id="L9233">            <span class="tok-kw">const</span> type_inst = <span class="tok-kw">try</span> typeExpr(gz, scope, params[<span class="tok-number">0</span>]);</span>
<span class="line" id="L9234">            <span class="tok-kw">const</span> options = <span class="tok-kw">try</span> comptimeExpr(gz, scope, .{ .rl = .{ .coerced_ty = .extern_options_type } }, params[<span class="tok-number">1</span>]);</span>
<span class="line" id="L9235">            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addExtendedPayload(.builtin_extern, Zir.Inst.BinNode{</span>
<span class="line" id="L9236">                .node = gz.nodeIndexToRelative(node),</span>
<span class="line" id="L9237">                .lhs = type_inst,</span>
<span class="line" id="L9238">                .rhs = options,</span>
<span class="line" id="L9239">            });</span>
<span class="line" id="L9240">            <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L9241">        },</span>
<span class="line" id="L9242">        .fence =&gt; {</span>
<span class="line" id="L9243">            <span class="tok-kw">const</span> order = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .{ .coerced_ty = .atomic_order_type } }, params[<span class="tok-number">0</span>]);</span>
<span class="line" id="L9244">            _ = <span class="tok-kw">try</span> gz.addExtendedPayload(.fence, Zir.Inst.UnNode{</span>
<span class="line" id="L9245">                .node = gz.nodeIndexToRelative(node),</span>
<span class="line" id="L9246">                .operand = order,</span>
<span class="line" id="L9247">            });</span>
<span class="line" id="L9248">            <span class="tok-kw">return</span> rvalue(gz, ri, .void_value, node);</span>
<span class="line" id="L9249">        },</span>
<span class="line" id="L9250">        .set_float_mode =&gt; {</span>
<span class="line" id="L9251">            <span class="tok-kw">const</span> order = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .{ .coerced_ty = .float_mode_type } }, params[<span class="tok-number">0</span>]);</span>
<span class="line" id="L9252">            _ = <span class="tok-kw">try</span> gz.addExtendedPayload(.set_float_mode, Zir.Inst.UnNode{</span>
<span class="line" id="L9253">                .node = gz.nodeIndexToRelative(node),</span>
<span class="line" id="L9254">                .operand = order,</span>
<span class="line" id="L9255">            });</span>
<span class="line" id="L9256">            <span class="tok-kw">return</span> rvalue(gz, ri, .void_value, node);</span>
<span class="line" id="L9257">        },</span>
<span class="line" id="L9258">        .set_align_stack =&gt; {</span>
<span class="line" id="L9259">            <span class="tok-kw">const</span> order = <span class="tok-kw">try</span> expr(gz, scope, coerced_align_ri, params[<span class="tok-number">0</span>]);</span>
<span class="line" id="L9260">            _ = <span class="tok-kw">try</span> gz.addExtendedPayload(.set_align_stack, Zir.Inst.UnNode{</span>
<span class="line" id="L9261">                .node = gz.nodeIndexToRelative(node),</span>
<span class="line" id="L9262">                .operand = order,</span>
<span class="line" id="L9263">            });</span>
<span class="line" id="L9264">            <span class="tok-kw">return</span> rvalue(gz, ri, .void_value, node);</span>
<span class="line" id="L9265">        },</span>
<span class="line" id="L9266">        .set_cold =&gt; {</span>
<span class="line" id="L9267">            <span class="tok-kw">const</span> order = <span class="tok-kw">try</span> expr(gz, scope, ri, params[<span class="tok-number">0</span>]);</span>
<span class="line" id="L9268">            _ = <span class="tok-kw">try</span> gz.addExtendedPayload(.set_cold, Zir.Inst.UnNode{</span>
<span class="line" id="L9269">                .node = gz.nodeIndexToRelative(node),</span>
<span class="line" id="L9270">                .operand = order,</span>
<span class="line" id="L9271">            });</span>
<span class="line" id="L9272">            <span class="tok-kw">return</span> rvalue(gz, ri, .void_value, node);</span>
<span class="line" id="L9273">        },</span>
<span class="line" id="L9274"></span>
<span class="line" id="L9275">        .src =&gt; {</span>
<span class="line" id="L9276">            <span class="tok-kw">const</span> token_starts = tree.tokens.items(.start);</span>
<span class="line" id="L9277">            <span class="tok-kw">const</span> node_start = token_starts[tree.firstToken(node)];</span>
<span class="line" id="L9278">            astgen.advanceSourceCursor(node_start);</span>
<span class="line" id="L9279">            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addExtendedPayload(.builtin_src, Zir.Inst.Src{</span>
<span class="line" id="L9280">                .node = gz.nodeIndexToRelative(node),</span>
<span class="line" id="L9281">                .line = astgen.source_line,</span>
<span class="line" id="L9282">                .column = astgen.source_column,</span>
<span class="line" id="L9283">            });</span>
<span class="line" id="L9284">            <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L9285">        },</span>
<span class="line" id="L9286"></span>
<span class="line" id="L9287">        <span class="tok-comment">// zig fmt: off</span>
</span>
<span class="line" id="L9288">        .This               =&gt; <span class="tok-kw">return</span> rvalue(gz, ri, <span class="tok-kw">try</span> gz.addNodeExtended(.this,               node), node),</span>
<span class="line" id="L9289">        .return_address     =&gt; <span class="tok-kw">return</span> rvalue(gz, ri, <span class="tok-kw">try</span> gz.addNodeExtended(.ret_addr,           node), node),</span>
<span class="line" id="L9290">        .error_return_trace =&gt; <span class="tok-kw">return</span> rvalue(gz, ri, <span class="tok-kw">try</span> gz.addNodeExtended(.error_return_trace, node), node),</span>
<span class="line" id="L9291">        .frame              =&gt; <span class="tok-kw">return</span> rvalue(gz, ri, <span class="tok-kw">try</span> gz.addNodeExtended(.frame,              node), node),</span>
<span class="line" id="L9292">        .frame_address      =&gt; <span class="tok-kw">return</span> rvalue(gz, ri, <span class="tok-kw">try</span> gz.addNodeExtended(.frame_address,      node), node),</span>
<span class="line" id="L9293">        .breakpoint         =&gt; <span class="tok-kw">return</span> rvalue(gz, ri, <span class="tok-kw">try</span> gz.addNodeExtended(.breakpoint,         node), node),</span>
<span class="line" id="L9294">        .in_comptime        =&gt; <span class="tok-kw">return</span> rvalue(gz, ri, <span class="tok-kw">try</span> gz.addNodeExtended(.in_comptime,        node), node),</span>
<span class="line" id="L9295"></span>
<span class="line" id="L9296">        .type_info   =&gt; <span class="tok-kw">return</span> simpleUnOpType(gz, scope, ri, node, params[<span class="tok-number">0</span>], .type_info),</span>
<span class="line" id="L9297">        .size_of     =&gt; <span class="tok-kw">return</span> simpleUnOpType(gz, scope, ri, node, params[<span class="tok-number">0</span>], .size_of),</span>
<span class="line" id="L9298">        .bit_size_of =&gt; <span class="tok-kw">return</span> simpleUnOpType(gz, scope, ri, node, params[<span class="tok-number">0</span>], .bit_size_of),</span>
<span class="line" id="L9299">        .align_of    =&gt; <span class="tok-kw">return</span> simpleUnOpType(gz, scope, ri, node, params[<span class="tok-number">0</span>], .align_of),</span>
<span class="line" id="L9300"></span>
<span class="line" id="L9301">        .int_from_ptr          =&gt; <span class="tok-kw">return</span> simpleUnOp(gz, scope, ri, node, .{ .rl = .none },                                     params[<span class="tok-number">0</span>], .int_from_ptr),</span>
<span class="line" id="L9302">        .compile_error         =&gt; <span class="tok-kw">return</span> simpleUnOp(gz, scope, ri, node, .{ .rl = .{ .coerced_ty = .slice_const_u8_type } },   params[<span class="tok-number">0</span>], .compile_error),</span>
<span class="line" id="L9303">        .set_eval_branch_quota =&gt; <span class="tok-kw">return</span> simpleUnOp(gz, scope, ri, node, .{ .rl = .{ .coerced_ty = .u32_type } },              params[<span class="tok-number">0</span>], .set_eval_branch_quota),</span>
<span class="line" id="L9304">        .int_from_enum         =&gt; <span class="tok-kw">return</span> simpleUnOp(gz, scope, ri, node, .{ .rl = .none },                                     params[<span class="tok-number">0</span>], .int_from_enum),</span>
<span class="line" id="L9305">        .int_from_bool         =&gt; <span class="tok-kw">return</span> simpleUnOp(gz, scope, ri, node, .{ .rl = .none },                                     params[<span class="tok-number">0</span>], .int_from_bool),</span>
<span class="line" id="L9306">        .embed_file            =&gt; <span class="tok-kw">return</span> simpleUnOp(gz, scope, ri, node, .{ .rl = .{ .coerced_ty = .slice_const_u8_type } },   params[<span class="tok-number">0</span>], .embed_file),</span>
<span class="line" id="L9307">        .error_name            =&gt; <span class="tok-kw">return</span> simpleUnOp(gz, scope, ri, node, .{ .rl = .{ .coerced_ty = .anyerror_type } },         params[<span class="tok-number">0</span>], .error_name),</span>
<span class="line" id="L9308">        .set_runtime_safety    =&gt; <span class="tok-kw">return</span> simpleUnOp(gz, scope, ri, node, coerced_bool_ri,                                      params[<span class="tok-number">0</span>], .set_runtime_safety),</span>
<span class="line" id="L9309">        .sqrt                  =&gt; <span class="tok-kw">return</span> simpleUnOp(gz, scope, ri, node, .{ .rl = .none },                                     params[<span class="tok-number">0</span>], .sqrt),</span>
<span class="line" id="L9310">        .sin                   =&gt; <span class="tok-kw">return</span> simpleUnOp(gz, scope, ri, node, .{ .rl = .none },                                     params[<span class="tok-number">0</span>], .sin),</span>
<span class="line" id="L9311">        .cos                   =&gt; <span class="tok-kw">return</span> simpleUnOp(gz, scope, ri, node, .{ .rl = .none },                                     params[<span class="tok-number">0</span>], .cos),</span>
<span class="line" id="L9312">        .tan                   =&gt; <span class="tok-kw">return</span> simpleUnOp(gz, scope, ri, node, .{ .rl = .none },                                     params[<span class="tok-number">0</span>], .tan),</span>
<span class="line" id="L9313">        .exp                   =&gt; <span class="tok-kw">return</span> simpleUnOp(gz, scope, ri, node, .{ .rl = .none },                                     params[<span class="tok-number">0</span>], .exp),</span>
<span class="line" id="L9314">        .exp2                  =&gt; <span class="tok-kw">return</span> simpleUnOp(gz, scope, ri, node, .{ .rl = .none },                                     params[<span class="tok-number">0</span>], .exp2),</span>
<span class="line" id="L9315">        .log                   =&gt; <span class="tok-kw">return</span> simpleUnOp(gz, scope, ri, node, .{ .rl = .none },                                     params[<span class="tok-number">0</span>], .log),</span>
<span class="line" id="L9316">        .log2                  =&gt; <span class="tok-kw">return</span> simpleUnOp(gz, scope, ri, node, .{ .rl = .none },                                     params[<span class="tok-number">0</span>], .log2),</span>
<span class="line" id="L9317">        .log10                 =&gt; <span class="tok-kw">return</span> simpleUnOp(gz, scope, ri, node, .{ .rl = .none },                                     params[<span class="tok-number">0</span>], .log10),</span>
<span class="line" id="L9318">        .abs                   =&gt; <span class="tok-kw">return</span> simpleUnOp(gz, scope, ri, node, .{ .rl = .none },                                     params[<span class="tok-number">0</span>], .abs),</span>
<span class="line" id="L9319">        .floor                 =&gt; <span class="tok-kw">return</span> simpleUnOp(gz, scope, ri, node, .{ .rl = .none },                                     params[<span class="tok-number">0</span>], .floor),</span>
<span class="line" id="L9320">        .ceil                  =&gt; <span class="tok-kw">return</span> simpleUnOp(gz, scope, ri, node, .{ .rl = .none },                                     params[<span class="tok-number">0</span>], .ceil),</span>
<span class="line" id="L9321">        .trunc                 =&gt; <span class="tok-kw">return</span> simpleUnOp(gz, scope, ri, node, .{ .rl = .none },                                     params[<span class="tok-number">0</span>], .trunc),</span>
<span class="line" id="L9322">        .round                 =&gt; <span class="tok-kw">return</span> simpleUnOp(gz, scope, ri, node, .{ .rl = .none },                                     params[<span class="tok-number">0</span>], .round),</span>
<span class="line" id="L9323">        .tag_name              =&gt; <span class="tok-kw">return</span> simpleUnOp(gz, scope, ri, node, .{ .rl = .none },                                     params[<span class="tok-number">0</span>], .tag_name),</span>
<span class="line" id="L9324">        .type_name             =&gt; <span class="tok-kw">return</span> simpleUnOp(gz, scope, ri, node, .{ .rl = .none },                                     params[<span class="tok-number">0</span>], .type_name),</span>
<span class="line" id="L9325">        .Frame                 =&gt; <span class="tok-kw">return</span> simpleUnOp(gz, scope, ri, node, .{ .rl = .none },                                     params[<span class="tok-number">0</span>], .frame_type),</span>
<span class="line" id="L9326">        .frame_size            =&gt; <span class="tok-kw">return</span> simpleUnOp(gz, scope, ri, node, .{ .rl = .none },                                     params[<span class="tok-number">0</span>], .frame_size),</span>
<span class="line" id="L9327"></span>
<span class="line" id="L9328">        .int_from_float =&gt; <span class="tok-kw">return</span> typeCast(gz, scope, ri, node, params[<span class="tok-number">0</span>], .int_from_float, builtin_name),</span>
<span class="line" id="L9329">        .float_from_int =&gt; <span class="tok-kw">return</span> typeCast(gz, scope, ri, node, params[<span class="tok-number">0</span>], .float_from_int, builtin_name),</span>
<span class="line" id="L9330">        .ptr_from_int   =&gt; <span class="tok-kw">return</span> typeCast(gz, scope, ri, node, params[<span class="tok-number">0</span>], .ptr_from_int, builtin_name),</span>
<span class="line" id="L9331">        .enum_from_int  =&gt; <span class="tok-kw">return</span> typeCast(gz, scope, ri, node, params[<span class="tok-number">0</span>], .enum_from_int, builtin_name),</span>
<span class="line" id="L9332">        .float_cast     =&gt; <span class="tok-kw">return</span> typeCast(gz, scope, ri, node, params[<span class="tok-number">0</span>], .float_cast, builtin_name),</span>
<span class="line" id="L9333">        .int_cast       =&gt; <span class="tok-kw">return</span> typeCast(gz, scope, ri, node, params[<span class="tok-number">0</span>], .int_cast, builtin_name),</span>
<span class="line" id="L9334">        .truncate       =&gt; <span class="tok-kw">return</span> typeCast(gz, scope, ri, node, params[<span class="tok-number">0</span>], .truncate, builtin_name),</span>
<span class="line" id="L9335">        <span class="tok-comment">// zig fmt: on</span>
</span>
<span class="line" id="L9336"></span>
<span class="line" id="L9337">        .Type =&gt; {</span>
<span class="line" id="L9338">            <span class="tok-kw">const</span> operand = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .{ .coerced_ty = .type_info_type } }, params[<span class="tok-number">0</span>]);</span>
<span class="line" id="L9339"></span>
<span class="line" id="L9340">            <span class="tok-kw">const</span> gpa = gz.astgen.gpa;</span>
<span class="line" id="L9341"></span>
<span class="line" id="L9342">            <span class="tok-kw">try</span> gz.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);</span>
<span class="line" id="L9343">            <span class="tok-kw">try</span> gz.astgen.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);</span>
<span class="line" id="L9344"></span>
<span class="line" id="L9345">            <span class="tok-kw">const</span> payload_index = <span class="tok-kw">try</span> gz.astgen.addExtra(Zir.Inst.UnNode{</span>
<span class="line" id="L9346">                .node = gz.nodeIndexToRelative(node),</span>
<span class="line" id="L9347">                .operand = operand,</span>
<span class="line" id="L9348">            });</span>
<span class="line" id="L9349">            <span class="tok-kw">const</span> new_index: Zir.Inst.Index = <span class="tok-builtin">@enumFromInt</span>(gz.astgen.instructions.len);</span>
<span class="line" id="L9350">            gz.astgen.instructions.appendAssumeCapacity(.{</span>
<span class="line" id="L9351">                .tag = .extended,</span>
<span class="line" id="L9352">                .data = .{ .extended = .{</span>
<span class="line" id="L9353">                    .opcode = .reify,</span>
<span class="line" id="L9354">                    .small = <span class="tok-builtin">@intFromEnum</span>(gz.anon_name_strategy),</span>
<span class="line" id="L9355">                    .operand = payload_index,</span>
<span class="line" id="L9356">                } },</span>
<span class="line" id="L9357">            });</span>
<span class="line" id="L9358">            gz.instructions.appendAssumeCapacity(new_index);</span>
<span class="line" id="L9359">            <span class="tok-kw">const</span> result = new_index.toRef();</span>
<span class="line" id="L9360">            <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L9361">        },</span>
<span class="line" id="L9362">        .panic =&gt; {</span>
<span class="line" id="L9363">            <span class="tok-kw">try</span> emitDbgNode(gz, node);</span>
<span class="line" id="L9364">            <span class="tok-kw">return</span> simpleUnOp(gz, scope, ri, node, .{ .rl = .{ .coerced_ty = .slice_const_u8_type } }, params[<span class="tok-number">0</span>], .panic);</span>
<span class="line" id="L9365">        },</span>
<span class="line" id="L9366">        .trap =&gt; {</span>
<span class="line" id="L9367">            <span class="tok-kw">try</span> emitDbgNode(gz, node);</span>
<span class="line" id="L9368">            _ = <span class="tok-kw">try</span> gz.addNode(.trap, node);</span>
<span class="line" id="L9369">            <span class="tok-kw">return</span> rvalue(gz, ri, .unreachable_value, node);</span>
<span class="line" id="L9370">        },</span>
<span class="line" id="L9371">        .int_from_error =&gt; {</span>
<span class="line" id="L9372">            <span class="tok-kw">const</span> operand = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .none }, params[<span class="tok-number">0</span>]);</span>
<span class="line" id="L9373">            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addExtendedPayload(.int_from_error, Zir.Inst.UnNode{</span>
<span class="line" id="L9374">                .node = gz.nodeIndexToRelative(node),</span>
<span class="line" id="L9375">                .operand = operand,</span>
<span class="line" id="L9376">            });</span>
<span class="line" id="L9377">            <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L9378">        },</span>
<span class="line" id="L9379">        .error_from_int =&gt; {</span>
<span class="line" id="L9380">            <span class="tok-kw">const</span> operand = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .none }, params[<span class="tok-number">0</span>]);</span>
<span class="line" id="L9381">            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addExtendedPayload(.error_from_int, Zir.Inst.UnNode{</span>
<span class="line" id="L9382">                .node = gz.nodeIndexToRelative(node),</span>
<span class="line" id="L9383">                .operand = operand,</span>
<span class="line" id="L9384">            });</span>
<span class="line" id="L9385">            <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L9386">        },</span>
<span class="line" id="L9387">        .error_cast =&gt; {</span>
<span class="line" id="L9388">            <span class="tok-kw">try</span> emitDbgNode(gz, node);</span>
<span class="line" id="L9389"></span>
<span class="line" id="L9390">            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addExtendedPayload(.error_cast, Zir.Inst.BinNode{</span>
<span class="line" id="L9391">                .lhs = <span class="tok-kw">try</span> ri.rl.resultTypeForCast(gz, node, <span class="tok-str">&quot;@errorCast&quot;</span>),</span>
<span class="line" id="L9392">                .rhs = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .none }, params[<span class="tok-number">0</span>]),</span>
<span class="line" id="L9393">                .node = gz.nodeIndexToRelative(node),</span>
<span class="line" id="L9394">            });</span>
<span class="line" id="L9395">            <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L9396">        },</span>
<span class="line" id="L9397">        .ptr_cast,</span>
<span class="line" id="L9398">        .align_cast,</span>
<span class="line" id="L9399">        .addrspace_cast,</span>
<span class="line" id="L9400">        .const_cast,</span>
<span class="line" id="L9401">        .volatile_cast,</span>
<span class="line" id="L9402">        =&gt; <span class="tok-kw">return</span> ptrCast(gz, scope, ri, node),</span>
<span class="line" id="L9403"></span>
<span class="line" id="L9404">        <span class="tok-comment">// zig fmt: off</span>
</span>
<span class="line" id="L9405">        .has_decl  =&gt; <span class="tok-kw">return</span> hasDeclOrField(gz, scope, ri, node, params[<span class="tok-number">0</span>], params[<span class="tok-number">1</span>], .has_decl),</span>
<span class="line" id="L9406">        .has_field =&gt; <span class="tok-kw">return</span> hasDeclOrField(gz, scope, ri, node, params[<span class="tok-number">0</span>], params[<span class="tok-number">1</span>], .has_field),</span>
<span class="line" id="L9407"></span>
<span class="line" id="L9408">        .clz         =&gt; <span class="tok-kw">return</span> bitBuiltin(gz, scope, ri, node, params[<span class="tok-number">0</span>], .clz),</span>
<span class="line" id="L9409">        .ctz         =&gt; <span class="tok-kw">return</span> bitBuiltin(gz, scope, ri, node, params[<span class="tok-number">0</span>], .ctz),</span>
<span class="line" id="L9410">        .pop_count   =&gt; <span class="tok-kw">return</span> bitBuiltin(gz, scope, ri, node, params[<span class="tok-number">0</span>], .pop_count),</span>
<span class="line" id="L9411">        .byte_swap   =&gt; <span class="tok-kw">return</span> bitBuiltin(gz, scope, ri, node, params[<span class="tok-number">0</span>], .byte_swap),</span>
<span class="line" id="L9412">        .bit_reverse =&gt; <span class="tok-kw">return</span> bitBuiltin(gz, scope, ri, node, params[<span class="tok-number">0</span>], .bit_reverse),</span>
<span class="line" id="L9413"></span>
<span class="line" id="L9414">        .div_exact =&gt; <span class="tok-kw">return</span> divBuiltin(gz, scope, ri, node, params[<span class="tok-number">0</span>], params[<span class="tok-number">1</span>], .div_exact),</span>
<span class="line" id="L9415">        .div_floor =&gt; <span class="tok-kw">return</span> divBuiltin(gz, scope, ri, node, params[<span class="tok-number">0</span>], params[<span class="tok-number">1</span>], .div_floor),</span>
<span class="line" id="L9416">        .div_trunc =&gt; <span class="tok-kw">return</span> divBuiltin(gz, scope, ri, node, params[<span class="tok-number">0</span>], params[<span class="tok-number">1</span>], .div_trunc),</span>
<span class="line" id="L9417">        .mod       =&gt; <span class="tok-kw">return</span> divBuiltin(gz, scope, ri, node, params[<span class="tok-number">0</span>], params[<span class="tok-number">1</span>], .mod),</span>
<span class="line" id="L9418">        .rem       =&gt; <span class="tok-kw">return</span> divBuiltin(gz, scope, ri, node, params[<span class="tok-number">0</span>], params[<span class="tok-number">1</span>], .rem),</span>
<span class="line" id="L9419"></span>
<span class="line" id="L9420">        .shl_exact =&gt; <span class="tok-kw">return</span> shiftOp(gz, scope, ri, node, params[<span class="tok-number">0</span>], params[<span class="tok-number">1</span>], .shl_exact),</span>
<span class="line" id="L9421">        .shr_exact =&gt; <span class="tok-kw">return</span> shiftOp(gz, scope, ri, node, params[<span class="tok-number">0</span>], params[<span class="tok-number">1</span>], .shr_exact),</span>
<span class="line" id="L9422"></span>
<span class="line" id="L9423">        .bit_offset_of =&gt; <span class="tok-kw">return</span> offsetOf(gz, scope, ri, node, params[<span class="tok-number">0</span>], params[<span class="tok-number">1</span>], .bit_offset_of),</span>
<span class="line" id="L9424">        .offset_of     =&gt; <span class="tok-kw">return</span> offsetOf(gz, scope, ri, node, params[<span class="tok-number">0</span>], params[<span class="tok-number">1</span>], .offset_of),</span>
<span class="line" id="L9425"></span>
<span class="line" id="L9426">        .c_undef   =&gt; <span class="tok-kw">return</span> simpleCBuiltin(gz, scope, ri, node, params[<span class="tok-number">0</span>], .c_undef),</span>
<span class="line" id="L9427">        .c_include =&gt; <span class="tok-kw">return</span> simpleCBuiltin(gz, scope, ri, node, params[<span class="tok-number">0</span>], .c_include),</span>
<span class="line" id="L9428"></span>
<span class="line" id="L9429">        .cmpxchg_strong =&gt; <span class="tok-kw">return</span> cmpxchg(gz, scope, ri, node, params, <span class="tok-number">1</span>),</span>
<span class="line" id="L9430">        .cmpxchg_weak   =&gt; <span class="tok-kw">return</span> cmpxchg(gz, scope, ri, node, params, <span class="tok-number">0</span>),</span>
<span class="line" id="L9431">        <span class="tok-comment">// zig fmt: on</span>
</span>
<span class="line" id="L9432"></span>
<span class="line" id="L9433">        .wasm_memory_size =&gt; {</span>
<span class="line" id="L9434">            <span class="tok-kw">const</span> operand = <span class="tok-kw">try</span> comptimeExpr(gz, scope, .{ .rl = .{ .coerced_ty = .u32_type } }, params[<span class="tok-number">0</span>]);</span>
<span class="line" id="L9435">            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addExtendedPayload(.wasm_memory_size, Zir.Inst.UnNode{</span>
<span class="line" id="L9436">                .node = gz.nodeIndexToRelative(node),</span>
<span class="line" id="L9437">                .operand = operand,</span>
<span class="line" id="L9438">            });</span>
<span class="line" id="L9439">            <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L9440">        },</span>
<span class="line" id="L9441">        .wasm_memory_grow =&gt; {</span>
<span class="line" id="L9442">            <span class="tok-kw">const</span> index_arg = <span class="tok-kw">try</span> comptimeExpr(gz, scope, .{ .rl = .{ .coerced_ty = .u32_type } }, params[<span class="tok-number">0</span>]);</span>
<span class="line" id="L9443">            <span class="tok-kw">const</span> delta_arg = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .{ .coerced_ty = .u32_type } }, params[<span class="tok-number">1</span>]);</span>
<span class="line" id="L9444">            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addExtendedPayload(.wasm_memory_grow, Zir.Inst.BinNode{</span>
<span class="line" id="L9445">                .node = gz.nodeIndexToRelative(node),</span>
<span class="line" id="L9446">                .lhs = index_arg,</span>
<span class="line" id="L9447">                .rhs = delta_arg,</span>
<span class="line" id="L9448">            });</span>
<span class="line" id="L9449">            <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L9450">        },</span>
<span class="line" id="L9451">        .c_define =&gt; {</span>
<span class="line" id="L9452">            <span class="tok-kw">if</span> (!gz.c_import) <span class="tok-kw">return</span> gz.astgen.failNode(node, <span class="tok-str">&quot;C define valid only inside C import block&quot;</span>, .{});</span>
<span class="line" id="L9453">            <span class="tok-kw">const</span> name = <span class="tok-kw">try</span> comptimeExpr(gz, scope, .{ .rl = .{ .coerced_ty = .slice_const_u8_type } }, params[<span class="tok-number">0</span>]);</span>
<span class="line" id="L9454">            <span class="tok-kw">const</span> value = <span class="tok-kw">try</span> comptimeExpr(gz, scope, .{ .rl = .none }, params[<span class="tok-number">1</span>]);</span>
<span class="line" id="L9455">            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addExtendedPayload(.c_define, Zir.Inst.BinNode{</span>
<span class="line" id="L9456">                .node = gz.nodeIndexToRelative(node),</span>
<span class="line" id="L9457">                .lhs = name,</span>
<span class="line" id="L9458">                .rhs = value,</span>
<span class="line" id="L9459">            });</span>
<span class="line" id="L9460">            <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L9461">        },</span>
<span class="line" id="L9462"></span>
<span class="line" id="L9463">        .splat =&gt; {</span>
<span class="line" id="L9464">            <span class="tok-kw">const</span> result_type = <span class="tok-kw">try</span> ri.rl.resultTypeForCast(gz, node, <span class="tok-str">&quot;@splat&quot;</span>);</span>
<span class="line" id="L9465">            <span class="tok-kw">const</span> elem_type = <span class="tok-kw">try</span> gz.addUnNode(.vector_elem_type, result_type, node);</span>
<span class="line" id="L9466">            <span class="tok-kw">const</span> scalar = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .{ .ty = elem_type } }, params[<span class="tok-number">0</span>]);</span>
<span class="line" id="L9467">            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addPlNode(.splat, node, Zir.Inst.Bin{</span>
<span class="line" id="L9468">                .lhs = result_type,</span>
<span class="line" id="L9469">                .rhs = scalar,</span>
<span class="line" id="L9470">            });</span>
<span class="line" id="L9471">            <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L9472">        },</span>
<span class="line" id="L9473">        .reduce =&gt; {</span>
<span class="line" id="L9474">            <span class="tok-kw">const</span> op = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .{ .coerced_ty = .reduce_op_type } }, params[<span class="tok-number">0</span>]);</span>
<span class="line" id="L9475">            <span class="tok-kw">const</span> scalar = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .none }, params[<span class="tok-number">1</span>]);</span>
<span class="line" id="L9476">            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addPlNode(.reduce, node, Zir.Inst.Bin{</span>
<span class="line" id="L9477">                .lhs = op,</span>
<span class="line" id="L9478">                .rhs = scalar,</span>
<span class="line" id="L9479">            });</span>
<span class="line" id="L9480">            <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L9481">        },</span>
<span class="line" id="L9482"></span>
<span class="line" id="L9483">        .add_with_overflow =&gt; <span class="tok-kw">return</span> overflowArithmetic(gz, scope, ri, node, params, .add_with_overflow),</span>
<span class="line" id="L9484">        .sub_with_overflow =&gt; <span class="tok-kw">return</span> overflowArithmetic(gz, scope, ri, node, params, .sub_with_overflow),</span>
<span class="line" id="L9485">        .mul_with_overflow =&gt; <span class="tok-kw">return</span> overflowArithmetic(gz, scope, ri, node, params, .mul_with_overflow),</span>
<span class="line" id="L9486">        .shl_with_overflow =&gt; <span class="tok-kw">return</span> overflowArithmetic(gz, scope, ri, node, params, .shl_with_overflow),</span>
<span class="line" id="L9487"></span>
<span class="line" id="L9488">        .atomic_load =&gt; {</span>
<span class="line" id="L9489">            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addPlNode(.atomic_load, node, Zir.Inst.AtomicLoad{</span>
<span class="line" id="L9490">                <span class="tok-comment">// zig fmt: off</span>
</span>
<span class="line" id="L9491">                .elem_type = <span class="tok-kw">try</span> typeExpr(gz, scope,                                                   params[<span class="tok-number">0</span>]),</span>
<span class="line" id="L9492">                .ptr       = <span class="tok-kw">try</span> expr    (gz, scope, .{ .rl = .none },                                 params[<span class="tok-number">1</span>]),</span>
<span class="line" id="L9493">                .ordering  = <span class="tok-kw">try</span> expr    (gz, scope, .{ .rl = .{ .coerced_ty = .atomic_order_type } }, params[<span class="tok-number">2</span>]),</span>
<span class="line" id="L9494">                <span class="tok-comment">// zig fmt: on</span>
</span>
<span class="line" id="L9495">            });</span>
<span class="line" id="L9496">            <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L9497">        },</span>
<span class="line" id="L9498">        .atomic_rmw =&gt; {</span>
<span class="line" id="L9499">            <span class="tok-kw">const</span> int_type = <span class="tok-kw">try</span> typeExpr(gz, scope, params[<span class="tok-number">0</span>]);</span>
<span class="line" id="L9500">            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addPlNode(.atomic_rmw, node, Zir.Inst.AtomicRmw{</span>
<span class="line" id="L9501">                <span class="tok-comment">// zig fmt: off</span>
</span>
<span class="line" id="L9502">                .ptr       = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .none },                                  params[<span class="tok-number">1</span>]),</span>
<span class="line" id="L9503">                .operation = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .{ .coerced_ty = .atomic_rmw_op_type } }, params[<span class="tok-number">2</span>]),</span>
<span class="line" id="L9504">                .operand   = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .{ .ty = int_type } },                    params[<span class="tok-number">3</span>]),</span>
<span class="line" id="L9505">                .ordering  = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .{ .coerced_ty = .atomic_order_type } },  params[<span class="tok-number">4</span>]),</span>
<span class="line" id="L9506">                <span class="tok-comment">// zig fmt: on</span>
</span>
<span class="line" id="L9507">            });</span>
<span class="line" id="L9508">            <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L9509">        },</span>
<span class="line" id="L9510">        .atomic_store =&gt; {</span>
<span class="line" id="L9511">            <span class="tok-kw">const</span> int_type = <span class="tok-kw">try</span> typeExpr(gz, scope, params[<span class="tok-number">0</span>]);</span>
<span class="line" id="L9512">            _ = <span class="tok-kw">try</span> gz.addPlNode(.atomic_store, node, Zir.Inst.AtomicStore{</span>
<span class="line" id="L9513">                <span class="tok-comment">// zig fmt: off</span>
</span>
<span class="line" id="L9514">                .ptr      = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .none },                                 params[<span class="tok-number">1</span>]),</span>
<span class="line" id="L9515">                .operand  = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .{ .ty = int_type } },                   params[<span class="tok-number">2</span>]),</span>
<span class="line" id="L9516">                .ordering = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .{ .coerced_ty = .atomic_order_type } }, params[<span class="tok-number">3</span>]),</span>
<span class="line" id="L9517">                <span class="tok-comment">// zig fmt: on</span>
</span>
<span class="line" id="L9518">            });</span>
<span class="line" id="L9519">            <span class="tok-kw">return</span> rvalue(gz, ri, .void_value, node);</span>
<span class="line" id="L9520">        },</span>
<span class="line" id="L9521">        .mul_add =&gt; {</span>
<span class="line" id="L9522">            <span class="tok-kw">const</span> float_type = <span class="tok-kw">try</span> typeExpr(gz, scope, params[<span class="tok-number">0</span>]);</span>
<span class="line" id="L9523">            <span class="tok-kw">const</span> mulend1 = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .{ .coerced_ty = float_type } }, params[<span class="tok-number">1</span>]);</span>
<span class="line" id="L9524">            <span class="tok-kw">const</span> mulend2 = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .{ .coerced_ty = float_type } }, params[<span class="tok-number">2</span>]);</span>
<span class="line" id="L9525">            <span class="tok-kw">const</span> addend = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .{ .ty = float_type } }, params[<span class="tok-number">3</span>]);</span>
<span class="line" id="L9526">            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addPlNode(.mul_add, node, Zir.Inst.MulAdd{</span>
<span class="line" id="L9527">                .mulend1 = mulend1,</span>
<span class="line" id="L9528">                .mulend2 = mulend2,</span>
<span class="line" id="L9529">                .addend = addend,</span>
<span class="line" id="L9530">            });</span>
<span class="line" id="L9531">            <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L9532">        },</span>
<span class="line" id="L9533">        .call =&gt; {</span>
<span class="line" id="L9534">            <span class="tok-kw">const</span> modifier = <span class="tok-kw">try</span> comptimeExpr(gz, scope, .{ .rl = .{ .coerced_ty = .call_modifier_type } }, params[<span class="tok-number">0</span>]);</span>
<span class="line" id="L9535">            <span class="tok-kw">const</span> callee = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .none }, params[<span class="tok-number">1</span>]);</span>
<span class="line" id="L9536">            <span class="tok-kw">const</span> args = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .none }, params[<span class="tok-number">2</span>]);</span>
<span class="line" id="L9537">            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addPlNode(.builtin_call, node, Zir.Inst.BuiltinCall{</span>
<span class="line" id="L9538">                .modifier = modifier,</span>
<span class="line" id="L9539">                .callee = callee,</span>
<span class="line" id="L9540">                .args = args,</span>
<span class="line" id="L9541">                .flags = .{</span>
<span class="line" id="L9542">                    .is_nosuspend = gz.nosuspend_node != <span class="tok-number">0</span>,</span>
<span class="line" id="L9543">                    .ensure_result_used = <span class="tok-null">false</span>,</span>
<span class="line" id="L9544">                },</span>
<span class="line" id="L9545">            });</span>
<span class="line" id="L9546">            <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L9547">        },</span>
<span class="line" id="L9548">        .field_parent_ptr =&gt; {</span>
<span class="line" id="L9549">            <span class="tok-kw">const</span> parent_type = <span class="tok-kw">try</span> typeExpr(gz, scope, params[<span class="tok-number">0</span>]);</span>
<span class="line" id="L9550">            <span class="tok-kw">const</span> field_name = <span class="tok-kw">try</span> comptimeExpr(gz, scope, .{ .rl = .{ .coerced_ty = .slice_const_u8_type } }, params[<span class="tok-number">1</span>]);</span>
<span class="line" id="L9551">            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addPlNode(.field_parent_ptr, node, Zir.Inst.FieldParentPtr{</span>
<span class="line" id="L9552">                .parent_type = parent_type,</span>
<span class="line" id="L9553">                .field_name = field_name,</span>
<span class="line" id="L9554">                .field_ptr = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .none }, params[<span class="tok-number">2</span>]),</span>
<span class="line" id="L9555">            });</span>
<span class="line" id="L9556">            <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L9557">        },</span>
<span class="line" id="L9558">        .memcpy =&gt; {</span>
<span class="line" id="L9559">            _ = <span class="tok-kw">try</span> gz.addPlNode(.memcpy, node, Zir.Inst.Bin{</span>
<span class="line" id="L9560">                .lhs = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .none }, params[<span class="tok-number">0</span>]),</span>
<span class="line" id="L9561">                .rhs = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .none }, params[<span class="tok-number">1</span>]),</span>
<span class="line" id="L9562">            });</span>
<span class="line" id="L9563">            <span class="tok-kw">return</span> rvalue(gz, ri, .void_value, node);</span>
<span class="line" id="L9564">        },</span>
<span class="line" id="L9565">        .memset =&gt; {</span>
<span class="line" id="L9566">            <span class="tok-kw">const</span> lhs = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .none }, params[<span class="tok-number">0</span>]);</span>
<span class="line" id="L9567">            <span class="tok-kw">const</span> lhs_ty = <span class="tok-kw">try</span> gz.addUnNode(.typeof, lhs, params[<span class="tok-number">0</span>]);</span>
<span class="line" id="L9568">            <span class="tok-kw">const</span> elem_ty = <span class="tok-kw">try</span> gz.addUnNode(.indexable_ptr_elem_type, lhs_ty, params[<span class="tok-number">0</span>]);</span>
<span class="line" id="L9569">            _ = <span class="tok-kw">try</span> gz.addPlNode(.memset, node, Zir.Inst.Bin{</span>
<span class="line" id="L9570">                .lhs = lhs,</span>
<span class="line" id="L9571">                .rhs = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .{ .coerced_ty = elem_ty } }, params[<span class="tok-number">1</span>]),</span>
<span class="line" id="L9572">            });</span>
<span class="line" id="L9573">            <span class="tok-kw">return</span> rvalue(gz, ri, .void_value, node);</span>
<span class="line" id="L9574">        },</span>
<span class="line" id="L9575">        .shuffle =&gt; {</span>
<span class="line" id="L9576">            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addPlNode(.shuffle, node, Zir.Inst.Shuffle{</span>
<span class="line" id="L9577">                .elem_type = <span class="tok-kw">try</span> typeExpr(gz, scope, params[<span class="tok-number">0</span>]),</span>
<span class="line" id="L9578">                .a = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .none }, params[<span class="tok-number">1</span>]),</span>
<span class="line" id="L9579">                .b = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .none }, params[<span class="tok-number">2</span>]),</span>
<span class="line" id="L9580">                .mask = <span class="tok-kw">try</span> comptimeExpr(gz, scope, .{ .rl = .none }, params[<span class="tok-number">3</span>]),</span>
<span class="line" id="L9581">            });</span>
<span class="line" id="L9582">            <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L9583">        },</span>
<span class="line" id="L9584">        .select =&gt; {</span>
<span class="line" id="L9585">            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addExtendedPayload(.select, Zir.Inst.Select{</span>
<span class="line" id="L9586">                .node = gz.nodeIndexToRelative(node),</span>
<span class="line" id="L9587">                .elem_type = <span class="tok-kw">try</span> typeExpr(gz, scope, params[<span class="tok-number">0</span>]),</span>
<span class="line" id="L9588">                .pred = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .none }, params[<span class="tok-number">1</span>]),</span>
<span class="line" id="L9589">                .a = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .none }, params[<span class="tok-number">2</span>]),</span>
<span class="line" id="L9590">                .b = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .none }, params[<span class="tok-number">3</span>]),</span>
<span class="line" id="L9591">            });</span>
<span class="line" id="L9592">            <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L9593">        },</span>
<span class="line" id="L9594">        .async_call =&gt; {</span>
<span class="line" id="L9595">            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addExtendedPayload(.builtin_async_call, Zir.Inst.AsyncCall{</span>
<span class="line" id="L9596">                .node = gz.nodeIndexToRelative(node),</span>
<span class="line" id="L9597">                .frame_buffer = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .none }, params[<span class="tok-number">0</span>]),</span>
<span class="line" id="L9598">                .result_ptr = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .none }, params[<span class="tok-number">1</span>]),</span>
<span class="line" id="L9599">                .fn_ptr = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .none }, params[<span class="tok-number">2</span>]),</span>
<span class="line" id="L9600">                .args = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .none }, params[<span class="tok-number">3</span>]),</span>
<span class="line" id="L9601">            });</span>
<span class="line" id="L9602">            <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L9603">        },</span>
<span class="line" id="L9604">        .Vector =&gt; {</span>
<span class="line" id="L9605">            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addPlNode(.vector_type, node, Zir.Inst.Bin{</span>
<span class="line" id="L9606">                .lhs = <span class="tok-kw">try</span> comptimeExpr(gz, scope, .{ .rl = .{ .coerced_ty = .u32_type } }, params[<span class="tok-number">0</span>]),</span>
<span class="line" id="L9607">                .rhs = <span class="tok-kw">try</span> typeExpr(gz, scope, params[<span class="tok-number">1</span>]),</span>
<span class="line" id="L9608">            });</span>
<span class="line" id="L9609">            <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L9610">        },</span>
<span class="line" id="L9611">        .prefetch =&gt; {</span>
<span class="line" id="L9612">            <span class="tok-kw">const</span> ptr = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .none }, params[<span class="tok-number">0</span>]);</span>
<span class="line" id="L9613">            <span class="tok-kw">const</span> options = <span class="tok-kw">try</span> comptimeExpr(gz, scope, .{ .rl = .{ .coerced_ty = .prefetch_options_type } }, params[<span class="tok-number">1</span>]);</span>
<span class="line" id="L9614">            _ = <span class="tok-kw">try</span> gz.addExtendedPayload(.prefetch, Zir.Inst.BinNode{</span>
<span class="line" id="L9615">                .node = gz.nodeIndexToRelative(node),</span>
<span class="line" id="L9616">                .lhs = ptr,</span>
<span class="line" id="L9617">                .rhs = options,</span>
<span class="line" id="L9618">            });</span>
<span class="line" id="L9619">            <span class="tok-kw">return</span> rvalue(gz, ri, .void_value, node);</span>
<span class="line" id="L9620">        },</span>
<span class="line" id="L9621">        .c_va_arg =&gt; {</span>
<span class="line" id="L9622">            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addExtendedPayload(.c_va_arg, Zir.Inst.BinNode{</span>
<span class="line" id="L9623">                .node = gz.nodeIndexToRelative(node),</span>
<span class="line" id="L9624">                .lhs = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .none }, params[<span class="tok-number">0</span>]),</span>
<span class="line" id="L9625">                .rhs = <span class="tok-kw">try</span> typeExpr(gz, scope, params[<span class="tok-number">1</span>]),</span>
<span class="line" id="L9626">            });</span>
<span class="line" id="L9627">            <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L9628">        },</span>
<span class="line" id="L9629">        .c_va_copy =&gt; {</span>
<span class="line" id="L9630">            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addExtendedPayload(.c_va_copy, Zir.Inst.UnNode{</span>
<span class="line" id="L9631">                .node = gz.nodeIndexToRelative(node),</span>
<span class="line" id="L9632">                .operand = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .none }, params[<span class="tok-number">0</span>]),</span>
<span class="line" id="L9633">            });</span>
<span class="line" id="L9634">            <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L9635">        },</span>
<span class="line" id="L9636">        .c_va_end =&gt; {</span>
<span class="line" id="L9637">            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addExtendedPayload(.c_va_end, Zir.Inst.UnNode{</span>
<span class="line" id="L9638">                .node = gz.nodeIndexToRelative(node),</span>
<span class="line" id="L9639">                .operand = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .none }, params[<span class="tok-number">0</span>]),</span>
<span class="line" id="L9640">            });</span>
<span class="line" id="L9641">            <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L9642">        },</span>
<span class="line" id="L9643">        .c_va_start =&gt; {</span>
<span class="line" id="L9644">            <span class="tok-kw">if</span> (!astgen.fn_var_args) {</span>
<span class="line" id="L9645">                <span class="tok-kw">return</span> astgen.failNode(node, <span class="tok-str">&quot;'@cVaStart' in a non-variadic function&quot;</span>, .{});</span>
<span class="line" id="L9646">            }</span>
<span class="line" id="L9647">            <span class="tok-kw">return</span> rvalue(gz, ri, <span class="tok-kw">try</span> gz.addNodeExtended(.c_va_start, node), node);</span>
<span class="line" id="L9648">        },</span>
<span class="line" id="L9649"></span>
<span class="line" id="L9650">        .work_item_id =&gt; {</span>
<span class="line" id="L9651">            <span class="tok-kw">const</span> operand = <span class="tok-kw">try</span> comptimeExpr(gz, scope, .{ .rl = .{ .coerced_ty = .u32_type } }, params[<span class="tok-number">0</span>]);</span>
<span class="line" id="L9652">            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addExtendedPayload(.work_item_id, Zir.Inst.UnNode{</span>
<span class="line" id="L9653">                .node = gz.nodeIndexToRelative(node),</span>
<span class="line" id="L9654">                .operand = operand,</span>
<span class="line" id="L9655">            });</span>
<span class="line" id="L9656">            <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L9657">        },</span>
<span class="line" id="L9658">        .work_group_size =&gt; {</span>
<span class="line" id="L9659">            <span class="tok-kw">const</span> operand = <span class="tok-kw">try</span> comptimeExpr(gz, scope, .{ .rl = .{ .coerced_ty = .u32_type } }, params[<span class="tok-number">0</span>]);</span>
<span class="line" id="L9660">            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addExtendedPayload(.work_group_size, Zir.Inst.UnNode{</span>
<span class="line" id="L9661">                .node = gz.nodeIndexToRelative(node),</span>
<span class="line" id="L9662">                .operand = operand,</span>
<span class="line" id="L9663">            });</span>
<span class="line" id="L9664">            <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L9665">        },</span>
<span class="line" id="L9666">        .work_group_id =&gt; {</span>
<span class="line" id="L9667">            <span class="tok-kw">const</span> operand = <span class="tok-kw">try</span> comptimeExpr(gz, scope, .{ .rl = .{ .coerced_ty = .u32_type } }, params[<span class="tok-number">0</span>]);</span>
<span class="line" id="L9668">            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addExtendedPayload(.work_group_id, Zir.Inst.UnNode{</span>
<span class="line" id="L9669">                .node = gz.nodeIndexToRelative(node),</span>
<span class="line" id="L9670">                .operand = operand,</span>
<span class="line" id="L9671">            });</span>
<span class="line" id="L9672">            <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L9673">        },</span>
<span class="line" id="L9674">    }</span>
<span class="line" id="L9675">}</span>
<span class="line" id="L9676"></span>
<span class="line" id="L9677"><span class="tok-kw">fn</span> <span class="tok-fn">hasDeclOrField</span>(</span>
<span class="line" id="L9678">    gz: *GenZir,</span>
<span class="line" id="L9679">    scope: *Scope,</span>
<span class="line" id="L9680">    ri: ResultInfo,</span>
<span class="line" id="L9681">    node: Ast.Node.Index,</span>
<span class="line" id="L9682">    lhs_node: Ast.Node.Index,</span>
<span class="line" id="L9683">    rhs_node: Ast.Node.Index,</span>
<span class="line" id="L9684">    tag: Zir.Inst.Tag,</span>
<span class="line" id="L9685">) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L9686">    <span class="tok-kw">const</span> container_type = <span class="tok-kw">try</span> typeExpr(gz, scope, lhs_node);</span>
<span class="line" id="L9687">    <span class="tok-kw">const</span> name = <span class="tok-kw">try</span> comptimeExpr(gz, scope, .{ .rl = .{ .coerced_ty = .slice_const_u8_type } }, rhs_node);</span>
<span class="line" id="L9688">    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addPlNode(tag, node, Zir.Inst.Bin{</span>
<span class="line" id="L9689">        .lhs = container_type,</span>
<span class="line" id="L9690">        .rhs = name,</span>
<span class="line" id="L9691">    });</span>
<span class="line" id="L9692">    <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L9693">}</span>
<span class="line" id="L9694"></span>
<span class="line" id="L9695"><span class="tok-kw">fn</span> <span class="tok-fn">typeCast</span>(</span>
<span class="line" id="L9696">    gz: *GenZir,</span>
<span class="line" id="L9697">    scope: *Scope,</span>
<span class="line" id="L9698">    ri: ResultInfo,</span>
<span class="line" id="L9699">    node: Ast.Node.Index,</span>
<span class="line" id="L9700">    operand_node: Ast.Node.Index,</span>
<span class="line" id="L9701">    tag: Zir.Inst.Tag,</span>
<span class="line" id="L9702">    builtin_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L9703">) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L9704">    <span class="tok-kw">const</span> cursor = maybeAdvanceSourceCursorToMainToken(gz, node);</span>
<span class="line" id="L9705">    <span class="tok-kw">const</span> result_type = <span class="tok-kw">try</span> ri.rl.resultTypeForCast(gz, node, builtin_name);</span>
<span class="line" id="L9706">    <span class="tok-kw">const</span> operand = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .none }, operand_node);</span>
<span class="line" id="L9707"></span>
<span class="line" id="L9708">    <span class="tok-kw">try</span> emitDbgStmt(gz, cursor);</span>
<span class="line" id="L9709">    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addPlNode(tag, node, Zir.Inst.Bin{</span>
<span class="line" id="L9710">        .lhs = result_type,</span>
<span class="line" id="L9711">        .rhs = operand,</span>
<span class="line" id="L9712">    });</span>
<span class="line" id="L9713">    <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L9714">}</span>
<span class="line" id="L9715"></span>
<span class="line" id="L9716"><span class="tok-kw">fn</span> <span class="tok-fn">simpleUnOpType</span>(</span>
<span class="line" id="L9717">    gz: *GenZir,</span>
<span class="line" id="L9718">    scope: *Scope,</span>
<span class="line" id="L9719">    ri: ResultInfo,</span>
<span class="line" id="L9720">    node: Ast.Node.Index,</span>
<span class="line" id="L9721">    operand_node: Ast.Node.Index,</span>
<span class="line" id="L9722">    tag: Zir.Inst.Tag,</span>
<span class="line" id="L9723">) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L9724">    <span class="tok-kw">const</span> operand = <span class="tok-kw">try</span> typeExpr(gz, scope, operand_node);</span>
<span class="line" id="L9725">    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addUnNode(tag, operand, node);</span>
<span class="line" id="L9726">    <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L9727">}</span>
<span class="line" id="L9728"></span>
<span class="line" id="L9729"><span class="tok-kw">fn</span> <span class="tok-fn">simpleUnOp</span>(</span>
<span class="line" id="L9730">    gz: *GenZir,</span>
<span class="line" id="L9731">    scope: *Scope,</span>
<span class="line" id="L9732">    ri: ResultInfo,</span>
<span class="line" id="L9733">    node: Ast.Node.Index,</span>
<span class="line" id="L9734">    operand_ri: ResultInfo,</span>
<span class="line" id="L9735">    operand_node: Ast.Node.Index,</span>
<span class="line" id="L9736">    tag: Zir.Inst.Tag,</span>
<span class="line" id="L9737">) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L9738">    <span class="tok-kw">const</span> cursor = maybeAdvanceSourceCursorToMainToken(gz, node);</span>
<span class="line" id="L9739">    <span class="tok-kw">const</span> operand = <span class="tok-kw">if</span> (tag == .compile_error)</span>
<span class="line" id="L9740">        <span class="tok-kw">try</span> comptimeExpr(gz, scope, operand_ri, operand_node)</span>
<span class="line" id="L9741">    <span class="tok-kw">else</span></span>
<span class="line" id="L9742">        <span class="tok-kw">try</span> expr(gz, scope, operand_ri, operand_node);</span>
<span class="line" id="L9743">    <span class="tok-kw">switch</span> (tag) {</span>
<span class="line" id="L9744">        .tag_name, .error_name, .int_from_ptr =&gt; <span class="tok-kw">try</span> emitDbgStmt(gz, cursor),</span>
<span class="line" id="L9745">        <span class="tok-kw">else</span> =&gt; {},</span>
<span class="line" id="L9746">    }</span>
<span class="line" id="L9747">    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addUnNode(tag, operand, node);</span>
<span class="line" id="L9748">    <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L9749">}</span>
<span class="line" id="L9750"></span>
<span class="line" id="L9751"><span class="tok-kw">fn</span> <span class="tok-fn">negation</span>(</span>
<span class="line" id="L9752">    gz: *GenZir,</span>
<span class="line" id="L9753">    scope: *Scope,</span>
<span class="line" id="L9754">    ri: ResultInfo,</span>
<span class="line" id="L9755">    node: Ast.Node.Index,</span>
<span class="line" id="L9756">) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L9757">    <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L9758">    <span class="tok-kw">const</span> tree = astgen.tree;</span>
<span class="line" id="L9759">    <span class="tok-kw">const</span> node_tags = tree.nodes.items(.tag);</span>
<span class="line" id="L9760">    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);</span>
<span class="line" id="L9761"></span>
<span class="line" id="L9762">    <span class="tok-comment">// Check for float literal as the sub-expression because we want to preserve</span>
</span>
<span class="line" id="L9763">    <span class="tok-comment">// its negativity rather than having it go through comptime subtraction.</span>
</span>
<span class="line" id="L9764">    <span class="tok-kw">const</span> operand_node = node_datas[node].lhs;</span>
<span class="line" id="L9765">    <span class="tok-kw">if</span> (node_tags[operand_node] == .number_literal) {</span>
<span class="line" id="L9766">        <span class="tok-kw">return</span> numberLiteral(gz, ri, operand_node, node, .negative);</span>
<span class="line" id="L9767">    }</span>
<span class="line" id="L9768"></span>
<span class="line" id="L9769">    <span class="tok-kw">const</span> operand = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .none }, operand_node);</span>
<span class="line" id="L9770">    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addUnNode(.negate, operand, node);</span>
<span class="line" id="L9771">    <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L9772">}</span>
<span class="line" id="L9773"></span>
<span class="line" id="L9774"><span class="tok-kw">fn</span> <span class="tok-fn">cmpxchg</span>(</span>
<span class="line" id="L9775">    gz: *GenZir,</span>
<span class="line" id="L9776">    scope: *Scope,</span>
<span class="line" id="L9777">    ri: ResultInfo,</span>
<span class="line" id="L9778">    node: Ast.Node.Index,</span>
<span class="line" id="L9779">    params: []<span class="tok-kw">const</span> Ast.Node.Index,</span>
<span class="line" id="L9780">    small: <span class="tok-type">u16</span>,</span>
<span class="line" id="L9781">) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L9782">    <span class="tok-kw">const</span> int_type = <span class="tok-kw">try</span> typeExpr(gz, scope, params[<span class="tok-number">0</span>]);</span>
<span class="line" id="L9783">    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addExtendedPayloadSmall(.cmpxchg, small, Zir.Inst.Cmpxchg{</span>
<span class="line" id="L9784">        <span class="tok-comment">// zig fmt: off</span>
</span>
<span class="line" id="L9785">        .node           = gz.nodeIndexToRelative(node),</span>
<span class="line" id="L9786">        .ptr            = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .none },                                 params[<span class="tok-number">1</span>]),</span>
<span class="line" id="L9787">        .expected_value = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .{ .ty = int_type } },                   params[<span class="tok-number">2</span>]),</span>
<span class="line" id="L9788">        .new_value      = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .{ .coerced_ty = int_type } },           params[<span class="tok-number">3</span>]),</span>
<span class="line" id="L9789">        .success_order  = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .{ .coerced_ty = .atomic_order_type } }, params[<span class="tok-number">4</span>]),</span>
<span class="line" id="L9790">        .failure_order  = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .{ .coerced_ty = .atomic_order_type } }, params[<span class="tok-number">5</span>]),</span>
<span class="line" id="L9791">        <span class="tok-comment">// zig fmt: on</span>
</span>
<span class="line" id="L9792">    });</span>
<span class="line" id="L9793">    <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L9794">}</span>
<span class="line" id="L9795"></span>
<span class="line" id="L9796"><span class="tok-kw">fn</span> <span class="tok-fn">bitBuiltin</span>(</span>
<span class="line" id="L9797">    gz: *GenZir,</span>
<span class="line" id="L9798">    scope: *Scope,</span>
<span class="line" id="L9799">    ri: ResultInfo,</span>
<span class="line" id="L9800">    node: Ast.Node.Index,</span>
<span class="line" id="L9801">    operand_node: Ast.Node.Index,</span>
<span class="line" id="L9802">    tag: Zir.Inst.Tag,</span>
<span class="line" id="L9803">) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L9804">    <span class="tok-kw">const</span> operand = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .none }, operand_node);</span>
<span class="line" id="L9805">    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addUnNode(tag, operand, node);</span>
<span class="line" id="L9806">    <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L9807">}</span>
<span class="line" id="L9808"></span>
<span class="line" id="L9809"><span class="tok-kw">fn</span> <span class="tok-fn">divBuiltin</span>(</span>
<span class="line" id="L9810">    gz: *GenZir,</span>
<span class="line" id="L9811">    scope: *Scope,</span>
<span class="line" id="L9812">    ri: ResultInfo,</span>
<span class="line" id="L9813">    node: Ast.Node.Index,</span>
<span class="line" id="L9814">    lhs_node: Ast.Node.Index,</span>
<span class="line" id="L9815">    rhs_node: Ast.Node.Index,</span>
<span class="line" id="L9816">    tag: Zir.Inst.Tag,</span>
<span class="line" id="L9817">) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L9818">    <span class="tok-kw">const</span> cursor = maybeAdvanceSourceCursorToMainToken(gz, node);</span>
<span class="line" id="L9819">    <span class="tok-kw">const</span> lhs = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .none }, lhs_node);</span>
<span class="line" id="L9820">    <span class="tok-kw">const</span> rhs = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .none }, rhs_node);</span>
<span class="line" id="L9821"></span>
<span class="line" id="L9822">    <span class="tok-kw">try</span> emitDbgStmt(gz, cursor);</span>
<span class="line" id="L9823">    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addPlNode(tag, node, Zir.Inst.Bin{ .lhs = lhs, .rhs = rhs });</span>
<span class="line" id="L9824">    <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L9825">}</span>
<span class="line" id="L9826"></span>
<span class="line" id="L9827"><span class="tok-kw">fn</span> <span class="tok-fn">simpleCBuiltin</span>(</span>
<span class="line" id="L9828">    gz: *GenZir,</span>
<span class="line" id="L9829">    scope: *Scope,</span>
<span class="line" id="L9830">    ri: ResultInfo,</span>
<span class="line" id="L9831">    node: Ast.Node.Index,</span>
<span class="line" id="L9832">    operand_node: Ast.Node.Index,</span>
<span class="line" id="L9833">    tag: Zir.Inst.Extended,</span>
<span class="line" id="L9834">) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L9835">    <span class="tok-kw">const</span> name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-kw">if</span> (tag == .c_undef) <span class="tok-str">&quot;C undef&quot;</span> <span class="tok-kw">else</span> <span class="tok-str">&quot;C include&quot;</span>;</span>
<span class="line" id="L9836">    <span class="tok-kw">if</span> (!gz.c_import) <span class="tok-kw">return</span> gz.astgen.failNode(node, <span class="tok-str">&quot;{s} valid only inside C import block&quot;</span>, .{name});</span>
<span class="line" id="L9837">    <span class="tok-kw">const</span> operand = <span class="tok-kw">try</span> comptimeExpr(gz, scope, .{ .rl = .{ .coerced_ty = .slice_const_u8_type } }, operand_node);</span>
<span class="line" id="L9838">    _ = <span class="tok-kw">try</span> gz.addExtendedPayload(tag, Zir.Inst.UnNode{</span>
<span class="line" id="L9839">        .node = gz.nodeIndexToRelative(node),</span>
<span class="line" id="L9840">        .operand = operand,</span>
<span class="line" id="L9841">    });</span>
<span class="line" id="L9842">    <span class="tok-kw">return</span> rvalue(gz, ri, .void_value, node);</span>
<span class="line" id="L9843">}</span>
<span class="line" id="L9844"></span>
<span class="line" id="L9845"><span class="tok-kw">fn</span> <span class="tok-fn">offsetOf</span>(</span>
<span class="line" id="L9846">    gz: *GenZir,</span>
<span class="line" id="L9847">    scope: *Scope,</span>
<span class="line" id="L9848">    ri: ResultInfo,</span>
<span class="line" id="L9849">    node: Ast.Node.Index,</span>
<span class="line" id="L9850">    lhs_node: Ast.Node.Index,</span>
<span class="line" id="L9851">    rhs_node: Ast.Node.Index,</span>
<span class="line" id="L9852">    tag: Zir.Inst.Tag,</span>
<span class="line" id="L9853">) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L9854">    <span class="tok-kw">const</span> type_inst = <span class="tok-kw">try</span> typeExpr(gz, scope, lhs_node);</span>
<span class="line" id="L9855">    <span class="tok-kw">const</span> field_name = <span class="tok-kw">try</span> comptimeExpr(gz, scope, .{ .rl = .{ .coerced_ty = .slice_const_u8_type } }, rhs_node);</span>
<span class="line" id="L9856">    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addPlNode(tag, node, Zir.Inst.Bin{</span>
<span class="line" id="L9857">        .lhs = type_inst,</span>
<span class="line" id="L9858">        .rhs = field_name,</span>
<span class="line" id="L9859">    });</span>
<span class="line" id="L9860">    <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L9861">}</span>
<span class="line" id="L9862"></span>
<span class="line" id="L9863"><span class="tok-kw">fn</span> <span class="tok-fn">shiftOp</span>(</span>
<span class="line" id="L9864">    gz: *GenZir,</span>
<span class="line" id="L9865">    scope: *Scope,</span>
<span class="line" id="L9866">    ri: ResultInfo,</span>
<span class="line" id="L9867">    node: Ast.Node.Index,</span>
<span class="line" id="L9868">    lhs_node: Ast.Node.Index,</span>
<span class="line" id="L9869">    rhs_node: Ast.Node.Index,</span>
<span class="line" id="L9870">    tag: Zir.Inst.Tag,</span>
<span class="line" id="L9871">) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L9872">    <span class="tok-kw">const</span> lhs = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .none }, lhs_node);</span>
<span class="line" id="L9873"></span>
<span class="line" id="L9874">    <span class="tok-kw">const</span> cursor = <span class="tok-kw">switch</span> (gz.astgen.tree.nodes.items(.tag)[node]) {</span>
<span class="line" id="L9875">        .shl, .shr =&gt; maybeAdvanceSourceCursorToMainToken(gz, node),</span>
<span class="line" id="L9876">        <span class="tok-kw">else</span> =&gt; <span class="tok-null">undefined</span>,</span>
<span class="line" id="L9877">    };</span>
<span class="line" id="L9878"></span>
<span class="line" id="L9879">    <span class="tok-kw">const</span> log2_int_type = <span class="tok-kw">try</span> gz.addUnNode(.typeof_log2_int_type, lhs, lhs_node);</span>
<span class="line" id="L9880">    <span class="tok-kw">const</span> rhs = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .{ .ty = log2_int_type }, .ctx = .shift_op }, rhs_node);</span>
<span class="line" id="L9881"></span>
<span class="line" id="L9882">    <span class="tok-kw">switch</span> (gz.astgen.tree.nodes.items(.tag)[node]) {</span>
<span class="line" id="L9883">        .shl, .shr =&gt; <span class="tok-kw">try</span> emitDbgStmt(gz, cursor),</span>
<span class="line" id="L9884">        <span class="tok-kw">else</span> =&gt; <span class="tok-null">undefined</span>,</span>
<span class="line" id="L9885">    }</span>
<span class="line" id="L9886"></span>
<span class="line" id="L9887">    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addPlNode(tag, node, Zir.Inst.Bin{</span>
<span class="line" id="L9888">        .lhs = lhs,</span>
<span class="line" id="L9889">        .rhs = rhs,</span>
<span class="line" id="L9890">    });</span>
<span class="line" id="L9891">    <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L9892">}</span>
<span class="line" id="L9893"></span>
<span class="line" id="L9894"><span class="tok-kw">fn</span> <span class="tok-fn">cImport</span>(</span>
<span class="line" id="L9895">    gz: *GenZir,</span>
<span class="line" id="L9896">    scope: *Scope,</span>
<span class="line" id="L9897">    node: Ast.Node.Index,</span>
<span class="line" id="L9898">    body_node: Ast.Node.Index,</span>
<span class="line" id="L9899">) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L9900">    <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L9901">    <span class="tok-kw">const</span> gpa = astgen.gpa;</span>
<span class="line" id="L9902"></span>
<span class="line" id="L9903">    <span class="tok-kw">if</span> (gz.c_import) <span class="tok-kw">return</span> gz.astgen.failNode(node, <span class="tok-str">&quot;cannot nest @cImport&quot;</span>, .{});</span>
<span class="line" id="L9904"></span>
<span class="line" id="L9905">    <span class="tok-kw">var</span> block_scope = gz.makeSubBlock(scope);</span>
<span class="line" id="L9906">    block_scope.is_comptime = <span class="tok-null">true</span>;</span>
<span class="line" id="L9907">    block_scope.c_import = <span class="tok-null">true</span>;</span>
<span class="line" id="L9908">    <span class="tok-kw">defer</span> block_scope.unstack();</span>
<span class="line" id="L9909"></span>
<span class="line" id="L9910">    <span class="tok-kw">const</span> block_inst = <span class="tok-kw">try</span> gz.makeBlockInst(.c_import, node);</span>
<span class="line" id="L9911">    <span class="tok-kw">const</span> block_result = <span class="tok-kw">try</span> fullBodyExpr(&amp;block_scope, &amp;block_scope.base, .{ .rl = .none }, body_node);</span>
<span class="line" id="L9912">    _ = <span class="tok-kw">try</span> gz.addUnNode(.ensure_result_used, block_result, node);</span>
<span class="line" id="L9913">    <span class="tok-kw">if</span> (!gz.refIsNoReturn(block_result)) {</span>
<span class="line" id="L9914">        _ = <span class="tok-kw">try</span> block_scope.addBreak(.break_inline, block_inst, .void_value);</span>
<span class="line" id="L9915">    }</span>
<span class="line" id="L9916">    <span class="tok-kw">try</span> block_scope.setBlockBody(block_inst);</span>
<span class="line" id="L9917">    <span class="tok-comment">// block_scope unstacked now, can add new instructions to gz</span>
</span>
<span class="line" id="L9918">    <span class="tok-kw">try</span> gz.instructions.append(gpa, block_inst);</span>
<span class="line" id="L9919"></span>
<span class="line" id="L9920">    <span class="tok-kw">return</span> block_inst.toRef();</span>
<span class="line" id="L9921">}</span>
<span class="line" id="L9922"></span>
<span class="line" id="L9923"><span class="tok-kw">fn</span> <span class="tok-fn">overflowArithmetic</span>(</span>
<span class="line" id="L9924">    gz: *GenZir,</span>
<span class="line" id="L9925">    scope: *Scope,</span>
<span class="line" id="L9926">    ri: ResultInfo,</span>
<span class="line" id="L9927">    node: Ast.Node.Index,</span>
<span class="line" id="L9928">    params: []<span class="tok-kw">const</span> Ast.Node.Index,</span>
<span class="line" id="L9929">    tag: Zir.Inst.Extended,</span>
<span class="line" id="L9930">) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L9931">    <span class="tok-kw">const</span> lhs = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .none }, params[<span class="tok-number">0</span>]);</span>
<span class="line" id="L9932">    <span class="tok-kw">const</span> rhs = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .none }, params[<span class="tok-number">1</span>]);</span>
<span class="line" id="L9933">    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> gz.addExtendedPayload(tag, Zir.Inst.BinNode{</span>
<span class="line" id="L9934">        .node = gz.nodeIndexToRelative(node),</span>
<span class="line" id="L9935">        .lhs = lhs,</span>
<span class="line" id="L9936">        .rhs = rhs,</span>
<span class="line" id="L9937">    });</span>
<span class="line" id="L9938">    <span class="tok-kw">return</span> rvalue(gz, ri, result, node);</span>
<span class="line" id="L9939">}</span>
<span class="line" id="L9940"></span>
<span class="line" id="L9941"><span class="tok-kw">fn</span> <span class="tok-fn">callExpr</span>(</span>
<span class="line" id="L9942">    gz: *GenZir,</span>
<span class="line" id="L9943">    scope: *Scope,</span>
<span class="line" id="L9944">    ri: ResultInfo,</span>
<span class="line" id="L9945">    node: Ast.Node.Index,</span>
<span class="line" id="L9946">    call: Ast.full.Call,</span>
<span class="line" id="L9947">) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L9948">    <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L9949"></span>
<span class="line" id="L9950">    <span class="tok-kw">const</span> callee = <span class="tok-kw">try</span> calleeExpr(gz, scope, call.ast.fn_expr);</span>
<span class="line" id="L9951">    <span class="tok-kw">const</span> modifier: std.builtin.CallModifier = blk: {</span>
<span class="line" id="L9952">        <span class="tok-kw">if</span> (gz.is_comptime) {</span>
<span class="line" id="L9953">            <span class="tok-kw">break</span> :blk .compile_time;</span>
<span class="line" id="L9954">        }</span>
<span class="line" id="L9955">        <span class="tok-kw">if</span> (call.async_token != <span class="tok-null">null</span>) {</span>
<span class="line" id="L9956">            <span class="tok-kw">break</span> :blk .async_kw;</span>
<span class="line" id="L9957">        }</span>
<span class="line" id="L9958">        <span class="tok-kw">if</span> (gz.nosuspend_node != <span class="tok-number">0</span>) {</span>
<span class="line" id="L9959">            <span class="tok-kw">break</span> :blk .no_async;</span>
<span class="line" id="L9960">        }</span>
<span class="line" id="L9961">        <span class="tok-kw">break</span> :blk .auto;</span>
<span class="line" id="L9962">    };</span>
<span class="line" id="L9963"></span>
<span class="line" id="L9964">    {</span>
<span class="line" id="L9965">        astgen.advanceSourceCursor(astgen.tree.tokens.items(.start)[call.ast.lparen]);</span>
<span class="line" id="L9966">        <span class="tok-kw">const</span> line = astgen.source_line - gz.decl_line;</span>
<span class="line" id="L9967">        <span class="tok-kw">const</span> column = astgen.source_column;</span>
<span class="line" id="L9968">        <span class="tok-comment">// Sema expects a dbg_stmt immediately before call,</span>
</span>
<span class="line" id="L9969">        <span class="tok-kw">try</span> emitDbgStmtForceCurrentIndex(gz, .{ line, column });</span>
<span class="line" id="L9970">    }</span>
<span class="line" id="L9971"></span>
<span class="line" id="L9972">    <span class="tok-kw">switch</span> (callee) {</span>
<span class="line" id="L9973">        .direct =&gt; |obj| assert(obj != .none),</span>
<span class="line" id="L9974">        .field =&gt; |field| assert(field.obj_ptr != .none),</span>
<span class="line" id="L9975">    }</span>
<span class="line" id="L9976">    assert(node != <span class="tok-number">0</span>);</span>
<span class="line" id="L9977"></span>
<span class="line" id="L9978">    <span class="tok-kw">const</span> call_index: Zir.Inst.Index = <span class="tok-builtin">@enumFromInt</span>(astgen.instructions.len);</span>
<span class="line" id="L9979">    <span class="tok-kw">const</span> call_inst = call_index.toRef();</span>
<span class="line" id="L9980">    <span class="tok-kw">try</span> gz.astgen.instructions.append(astgen.gpa, <span class="tok-null">undefined</span>);</span>
<span class="line" id="L9981">    <span class="tok-kw">try</span> gz.instructions.append(astgen.gpa, call_index);</span>
<span class="line" id="L9982"></span>
<span class="line" id="L9983">    <span class="tok-kw">const</span> scratch_top = astgen.scratch.items.len;</span>
<span class="line" id="L9984">    <span class="tok-kw">defer</span> astgen.scratch.items.len = scratch_top;</span>
<span class="line" id="L9985"></span>
<span class="line" id="L9986">    <span class="tok-kw">var</span> scratch_index = scratch_top;</span>
<span class="line" id="L9987">    <span class="tok-kw">try</span> astgen.scratch.resize(astgen.gpa, scratch_top + call.ast.params.len);</span>
<span class="line" id="L9988"></span>
<span class="line" id="L9989">    <span class="tok-kw">for</span> (call.ast.params) |param_node| {</span>
<span class="line" id="L9990">        <span class="tok-kw">var</span> arg_block = gz.makeSubBlock(scope);</span>
<span class="line" id="L9991">        <span class="tok-kw">defer</span> arg_block.unstack();</span>
<span class="line" id="L9992"></span>
<span class="line" id="L9993">        <span class="tok-comment">// `call_inst` is reused to provide the param type.</span>
</span>
<span class="line" id="L9994">        <span class="tok-kw">const</span> arg_ref = <span class="tok-kw">try</span> fullBodyExpr(&amp;arg_block, &amp;arg_block.base, .{ .rl = .{ .coerced_ty = call_inst }, .ctx = .fn_arg }, param_node);</span>
<span class="line" id="L9995">        _ = <span class="tok-kw">try</span> arg_block.addBreakWithSrcNode(.break_inline, call_index, arg_ref, param_node);</span>
<span class="line" id="L9996"></span>
<span class="line" id="L9997">        <span class="tok-kw">const</span> body = arg_block.instructionsSlice();</span>
<span class="line" id="L9998">        <span class="tok-kw">try</span> astgen.scratch.ensureUnusedCapacity(astgen.gpa, countBodyLenAfterFixups(astgen, body));</span>
<span class="line" id="L9999">        appendBodyWithFixupsArrayList(astgen, &amp;astgen.scratch, body);</span>
<span class="line" id="L10000"></span>
<span class="line" id="L10001">        astgen.scratch.items[scratch_index] = <span class="tok-builtin">@intCast</span>(astgen.scratch.items.len - scratch_top);</span>
<span class="line" id="L10002">        scratch_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L10003">    }</span>
<span class="line" id="L10004"></span>
<span class="line" id="L10005">    <span class="tok-comment">// If our result location is a try/catch/error-union-if/return, a function argument,</span>
</span>
<span class="line" id="L10006">    <span class="tok-comment">// or an initializer for a `const` variable, the error trace propagates.</span>
</span>
<span class="line" id="L10007">    <span class="tok-comment">// Otherwise, it should always be popped (handled in Sema).</span>
</span>
<span class="line" id="L10008">    <span class="tok-kw">const</span> propagate_error_trace = <span class="tok-kw">switch</span> (ri.ctx) {</span>
<span class="line" id="L10009">        .error_handling_expr, .@&quot;return&quot;, .fn_arg, .const_init =&gt; <span class="tok-null">true</span>,</span>
<span class="line" id="L10010">        <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,</span>
<span class="line" id="L10011">    };</span>
<span class="line" id="L10012"></span>
<span class="line" id="L10013">    <span class="tok-kw">switch</span> (callee) {</span>
<span class="line" id="L10014">        .direct =&gt; |callee_obj| {</span>
<span class="line" id="L10015">            <span class="tok-kw">const</span> payload_index = <span class="tok-kw">try</span> addExtra(astgen, Zir.Inst.Call{</span>
<span class="line" id="L10016">                .callee = callee_obj,</span>
<span class="line" id="L10017">                .flags = .{</span>
<span class="line" id="L10018">                    .pop_error_return_trace = !propagate_error_trace,</span>
<span class="line" id="L10019">                    .packed_modifier = <span class="tok-builtin">@intCast</span>(<span class="tok-builtin">@intFromEnum</span>(modifier)),</span>
<span class="line" id="L10020">                    .args_len = <span class="tok-builtin">@intCast</span>(call.ast.params.len),</span>
<span class="line" id="L10021">                },</span>
<span class="line" id="L10022">            });</span>
<span class="line" id="L10023">            <span class="tok-kw">if</span> (call.ast.params.len != <span class="tok-number">0</span>) {</span>
<span class="line" id="L10024">                <span class="tok-kw">try</span> astgen.extra.appendSlice(astgen.gpa, astgen.scratch.items[scratch_top..]);</span>
<span class="line" id="L10025">            }</span>
<span class="line" id="L10026">            gz.astgen.instructions.set(<span class="tok-builtin">@intFromEnum</span>(call_index), .{</span>
<span class="line" id="L10027">                .tag = .call,</span>
<span class="line" id="L10028">                .data = .{ .pl_node = .{</span>
<span class="line" id="L10029">                    .src_node = gz.nodeIndexToRelative(node),</span>
<span class="line" id="L10030">                    .payload_index = payload_index,</span>
<span class="line" id="L10031">                } },</span>
<span class="line" id="L10032">            });</span>
<span class="line" id="L10033">        },</span>
<span class="line" id="L10034">        .field =&gt; |callee_field| {</span>
<span class="line" id="L10035">            <span class="tok-kw">const</span> payload_index = <span class="tok-kw">try</span> addExtra(astgen, Zir.Inst.FieldCall{</span>
<span class="line" id="L10036">                .obj_ptr = callee_field.obj_ptr,</span>
<span class="line" id="L10037">                .field_name_start = callee_field.field_name_start,</span>
<span class="line" id="L10038">                .flags = .{</span>
<span class="line" id="L10039">                    .pop_error_return_trace = !propagate_error_trace,</span>
<span class="line" id="L10040">                    .packed_modifier = <span class="tok-builtin">@intCast</span>(<span class="tok-builtin">@intFromEnum</span>(modifier)),</span>
<span class="line" id="L10041">                    .args_len = <span class="tok-builtin">@intCast</span>(call.ast.params.len),</span>
<span class="line" id="L10042">                },</span>
<span class="line" id="L10043">            });</span>
<span class="line" id="L10044">            <span class="tok-kw">if</span> (call.ast.params.len != <span class="tok-number">0</span>) {</span>
<span class="line" id="L10045">                <span class="tok-kw">try</span> astgen.extra.appendSlice(astgen.gpa, astgen.scratch.items[scratch_top..]);</span>
<span class="line" id="L10046">            }</span>
<span class="line" id="L10047">            gz.astgen.instructions.set(<span class="tok-builtin">@intFromEnum</span>(call_index), .{</span>
<span class="line" id="L10048">                .tag = .field_call,</span>
<span class="line" id="L10049">                .data = .{ .pl_node = .{</span>
<span class="line" id="L10050">                    .src_node = gz.nodeIndexToRelative(node),</span>
<span class="line" id="L10051">                    .payload_index = payload_index,</span>
<span class="line" id="L10052">                } },</span>
<span class="line" id="L10053">            });</span>
<span class="line" id="L10054">        },</span>
<span class="line" id="L10055">    }</span>
<span class="line" id="L10056">    <span class="tok-kw">return</span> rvalue(gz, ri, call_inst, node); <span class="tok-comment">// TODO function call with result location</span>
</span>
<span class="line" id="L10057">}</span>
<span class="line" id="L10058"></span>
<span class="line" id="L10059"><span class="tok-kw">const</span> Callee = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {</span>
<span class="line" id="L10060">    field: <span class="tok-kw">struct</span> {</span>
<span class="line" id="L10061">        <span class="tok-comment">/// A *pointer* to the object the field is fetched on, so that we can</span></span>
<span class="line" id="L10062">        <span class="tok-comment">/// promote the lvalue to an address if the first parameter requires it.</span></span>
<span class="line" id="L10063">        obj_ptr: Zir.Inst.Ref,</span>
<span class="line" id="L10064">        <span class="tok-comment">/// Offset into `string_bytes`.</span></span>
<span class="line" id="L10065">        field_name_start: Zir.NullTerminatedString,</span>
<span class="line" id="L10066">    },</span>
<span class="line" id="L10067">    direct: Zir.Inst.Ref,</span>
<span class="line" id="L10068">};</span>
<span class="line" id="L10069"></span>
<span class="line" id="L10070"><span class="tok-comment">/// calleeExpr generates the function part of a call expression (f in f(x)), but</span></span>
<span class="line" id="L10071"><span class="tok-comment">/// *not* the callee argument to the @call() builtin. Its purpose is to</span></span>
<span class="line" id="L10072"><span class="tok-comment">/// distinguish between standard calls and method call syntax `a.b()`. Thus, if</span></span>
<span class="line" id="L10073"><span class="tok-comment">/// the lhs is a field access, we return using the `field` union field;</span></span>
<span class="line" id="L10074"><span class="tok-comment">/// otherwise, we use the `direct` union field.</span></span>
<span class="line" id="L10075"><span class="tok-kw">fn</span> <span class="tok-fn">calleeExpr</span>(</span>
<span class="line" id="L10076">    gz: *GenZir,</span>
<span class="line" id="L10077">    scope: *Scope,</span>
<span class="line" id="L10078">    node: Ast.Node.Index,</span>
<span class="line" id="L10079">) InnerError!Callee {</span>
<span class="line" id="L10080">    <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L10081">    <span class="tok-kw">const</span> tree = astgen.tree;</span>
<span class="line" id="L10082"></span>
<span class="line" id="L10083">    <span class="tok-kw">const</span> tag = tree.nodes.items(.tag)[node];</span>
<span class="line" id="L10084">    <span class="tok-kw">switch</span> (tag) {</span>
<span class="line" id="L10085">        .field_access =&gt; {</span>
<span class="line" id="L10086">            <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);</span>
<span class="line" id="L10087">            <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);</span>
<span class="line" id="L10088">            <span class="tok-kw">const</span> object_node = node_datas[node].lhs;</span>
<span class="line" id="L10089">            <span class="tok-kw">const</span> dot_token = main_tokens[node];</span>
<span class="line" id="L10090">            <span class="tok-kw">const</span> field_ident = dot_token + <span class="tok-number">1</span>;</span>
<span class="line" id="L10091">            <span class="tok-kw">const</span> str_index = <span class="tok-kw">try</span> astgen.identAsString(field_ident);</span>
<span class="line" id="L10092">            <span class="tok-comment">// Capture the object by reference so we can promote it to an</span>
</span>
<span class="line" id="L10093">            <span class="tok-comment">// address in Sema if needed.</span>
</span>
<span class="line" id="L10094">            <span class="tok-kw">const</span> lhs = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .ref }, object_node);</span>
<span class="line" id="L10095"></span>
<span class="line" id="L10096">            <span class="tok-kw">const</span> cursor = maybeAdvanceSourceCursorToMainToken(gz, node);</span>
<span class="line" id="L10097">            <span class="tok-kw">try</span> emitDbgStmt(gz, cursor);</span>
<span class="line" id="L10098"></span>
<span class="line" id="L10099">            <span class="tok-kw">return</span> .{ .field = .{</span>
<span class="line" id="L10100">                .obj_ptr = lhs,</span>
<span class="line" id="L10101">                .field_name_start = str_index,</span>
<span class="line" id="L10102">            } };</span>
<span class="line" id="L10103">        },</span>
<span class="line" id="L10104">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> .{ .direct = <span class="tok-kw">try</span> expr(gz, scope, .{ .rl = .none }, node) },</span>
<span class="line" id="L10105">    }</span>
<span class="line" id="L10106">}</span>
<span class="line" id="L10107"></span>
<span class="line" id="L10108"><span class="tok-kw">const</span> primitive_instrs = std.ComptimeStringMap(Zir.Inst.Ref, .{</span>
<span class="line" id="L10109">    .{ <span class="tok-str">&quot;anyerror&quot;</span>, .anyerror_type },</span>
<span class="line" id="L10110">    .{ <span class="tok-str">&quot;anyframe&quot;</span>, .anyframe_type },</span>
<span class="line" id="L10111">    .{ <span class="tok-str">&quot;anyopaque&quot;</span>, .anyopaque_type },</span>
<span class="line" id="L10112">    .{ <span class="tok-str">&quot;bool&quot;</span>, .bool_type },</span>
<span class="line" id="L10113">    .{ <span class="tok-str">&quot;c_int&quot;</span>, .c_int_type },</span>
<span class="line" id="L10114">    .{ <span class="tok-str">&quot;c_long&quot;</span>, .c_long_type },</span>
<span class="line" id="L10115">    .{ <span class="tok-str">&quot;c_longdouble&quot;</span>, .c_longdouble_type },</span>
<span class="line" id="L10116">    .{ <span class="tok-str">&quot;c_longlong&quot;</span>, .c_longlong_type },</span>
<span class="line" id="L10117">    .{ <span class="tok-str">&quot;c_char&quot;</span>, .c_char_type },</span>
<span class="line" id="L10118">    .{ <span class="tok-str">&quot;c_short&quot;</span>, .c_short_type },</span>
<span class="line" id="L10119">    .{ <span class="tok-str">&quot;c_uint&quot;</span>, .c_uint_type },</span>
<span class="line" id="L10120">    .{ <span class="tok-str">&quot;c_ulong&quot;</span>, .c_ulong_type },</span>
<span class="line" id="L10121">    .{ <span class="tok-str">&quot;c_ulonglong&quot;</span>, .c_ulonglong_type },</span>
<span class="line" id="L10122">    .{ <span class="tok-str">&quot;c_ushort&quot;</span>, .c_ushort_type },</span>
<span class="line" id="L10123">    .{ <span class="tok-str">&quot;comptime_float&quot;</span>, .comptime_float_type },</span>
<span class="line" id="L10124">    .{ <span class="tok-str">&quot;comptime_int&quot;</span>, .comptime_int_type },</span>
<span class="line" id="L10125">    .{ <span class="tok-str">&quot;f128&quot;</span>, .f128_type },</span>
<span class="line" id="L10126">    .{ <span class="tok-str">&quot;f16&quot;</span>, .f16_type },</span>
<span class="line" id="L10127">    .{ <span class="tok-str">&quot;f32&quot;</span>, .f32_type },</span>
<span class="line" id="L10128">    .{ <span class="tok-str">&quot;f64&quot;</span>, .f64_type },</span>
<span class="line" id="L10129">    .{ <span class="tok-str">&quot;f80&quot;</span>, .f80_type },</span>
<span class="line" id="L10130">    .{ <span class="tok-str">&quot;false&quot;</span>, .bool_false },</span>
<span class="line" id="L10131">    .{ <span class="tok-str">&quot;i16&quot;</span>, .i16_type },</span>
<span class="line" id="L10132">    .{ <span class="tok-str">&quot;i32&quot;</span>, .i32_type },</span>
<span class="line" id="L10133">    .{ <span class="tok-str">&quot;i64&quot;</span>, .i64_type },</span>
<span class="line" id="L10134">    .{ <span class="tok-str">&quot;i128&quot;</span>, .i128_type },</span>
<span class="line" id="L10135">    .{ <span class="tok-str">&quot;i8&quot;</span>, .i8_type },</span>
<span class="line" id="L10136">    .{ <span class="tok-str">&quot;isize&quot;</span>, .isize_type },</span>
<span class="line" id="L10137">    .{ <span class="tok-str">&quot;noreturn&quot;</span>, .noreturn_type },</span>
<span class="line" id="L10138">    .{ <span class="tok-str">&quot;null&quot;</span>, .null_value },</span>
<span class="line" id="L10139">    .{ <span class="tok-str">&quot;true&quot;</span>, .bool_true },</span>
<span class="line" id="L10140">    .{ <span class="tok-str">&quot;type&quot;</span>, .type_type },</span>
<span class="line" id="L10141">    .{ <span class="tok-str">&quot;u16&quot;</span>, .u16_type },</span>
<span class="line" id="L10142">    .{ <span class="tok-str">&quot;u29&quot;</span>, .u29_type },</span>
<span class="line" id="L10143">    .{ <span class="tok-str">&quot;u32&quot;</span>, .u32_type },</span>
<span class="line" id="L10144">    .{ <span class="tok-str">&quot;u64&quot;</span>, .u64_type },</span>
<span class="line" id="L10145">    .{ <span class="tok-str">&quot;u128&quot;</span>, .u128_type },</span>
<span class="line" id="L10146">    .{ <span class="tok-str">&quot;u1&quot;</span>, .u1_type },</span>
<span class="line" id="L10147">    .{ <span class="tok-str">&quot;u8&quot;</span>, .u8_type },</span>
<span class="line" id="L10148">    .{ <span class="tok-str">&quot;undefined&quot;</span>, .undef },</span>
<span class="line" id="L10149">    .{ <span class="tok-str">&quot;usize&quot;</span>, .usize_type },</span>
<span class="line" id="L10150">    .{ <span class="tok-str">&quot;void&quot;</span>, .void_type },</span>
<span class="line" id="L10151">});</span>
<span class="line" id="L10152"></span>
<span class="line" id="L10153"><span class="tok-kw">comptime</span> {</span>
<span class="line" id="L10154">    <span class="tok-comment">// These checks ensure that std.zig.primitives stays in sync with the primitive-&gt;Zir map.</span>
</span>
<span class="line" id="L10155">    <span class="tok-kw">const</span> primitives = std.zig.primitives;</span>
<span class="line" id="L10156">    <span class="tok-kw">for</span> (primitive_instrs.kvs) |kv| {</span>
<span class="line" id="L10157">        <span class="tok-kw">if</span> (!primitives.isPrimitive(kv.key)) {</span>
<span class="line" id="L10158">            <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;std.zig.isPrimitive() is not aware of Zir instr '&quot;</span> ++ <span class="tok-builtin">@tagName</span>(kv.value) ++ <span class="tok-str">&quot;'&quot;</span>);</span>
<span class="line" id="L10159">        }</span>
<span class="line" id="L10160">    }</span>
<span class="line" id="L10161">    <span class="tok-kw">for</span> (primitives.names.kvs) |kv| {</span>
<span class="line" id="L10162">        <span class="tok-kw">if</span> (primitive_instrs.get(kv.key) == <span class="tok-null">null</span>) {</span>
<span class="line" id="L10163">            <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;std.zig.primitives entry '&quot;</span> ++ kv.key ++ <span class="tok-str">&quot;' does not have a corresponding Zir instr&quot;</span>);</span>
<span class="line" id="L10164">        }</span>
<span class="line" id="L10165">    }</span>
<span class="line" id="L10166">}</span>
<span class="line" id="L10167"></span>
<span class="line" id="L10168"><span class="tok-kw">fn</span> <span class="tok-fn">nodeIsTriviallyZero</span>(tree: *<span class="tok-kw">const</span> Ast, node: Ast.Node.Index) <span class="tok-type">bool</span> {</span>
<span class="line" id="L10169">    <span class="tok-kw">const</span> node_tags = tree.nodes.items(.tag);</span>
<span class="line" id="L10170">    <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);</span>
<span class="line" id="L10171"></span>
<span class="line" id="L10172">    <span class="tok-kw">switch</span> (node_tags[node]) {</span>
<span class="line" id="L10173">        .number_literal =&gt; {</span>
<span class="line" id="L10174">            <span class="tok-kw">const</span> ident = main_tokens[node];</span>
<span class="line" id="L10175">            <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (std.zig.parseNumberLiteral(tree.tokenSlice(ident))) {</span>
<span class="line" id="L10176">                .int =&gt; |number| <span class="tok-kw">switch</span> (number) {</span>
<span class="line" id="L10177">                    <span class="tok-number">0</span> =&gt; <span class="tok-null">true</span>,</span>
<span class="line" id="L10178">                    <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,</span>
<span class="line" id="L10179">                },</span>
<span class="line" id="L10180">                <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,</span>
<span class="line" id="L10181">            };</span>
<span class="line" id="L10182">        },</span>
<span class="line" id="L10183">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-null">false</span>,</span>
<span class="line" id="L10184">    }</span>
<span class="line" id="L10185">}</span>
<span class="line" id="L10186"></span>
<span class="line" id="L10187"><span class="tok-kw">fn</span> <span class="tok-fn">nodeMayAppendToErrorTrace</span>(tree: *<span class="tok-kw">const</span> Ast, start_node: Ast.Node.Index) <span class="tok-type">bool</span> {</span>
<span class="line" id="L10188">    <span class="tok-kw">const</span> node_tags = tree.nodes.items(.tag);</span>
<span class="line" id="L10189">    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);</span>
<span class="line" id="L10190"></span>
<span class="line" id="L10191">    <span class="tok-kw">var</span> node = start_node;</span>
<span class="line" id="L10192">    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L10193">        <span class="tok-kw">switch</span> (node_tags[node]) {</span>
<span class="line" id="L10194">            <span class="tok-comment">// These don't have the opportunity to call any runtime functions.</span>
</span>
<span class="line" id="L10195">            .error_value,</span>
<span class="line" id="L10196">            .identifier,</span>
<span class="line" id="L10197">            .@&quot;comptime&quot;,</span>
<span class="line" id="L10198">            =&gt; <span class="tok-kw">return</span> <span class="tok-null">false</span>,</span>
<span class="line" id="L10199"></span>
<span class="line" id="L10200">            <span class="tok-comment">// Forward the question to the LHS sub-expression.</span>
</span>
<span class="line" id="L10201">            .grouped_expression,</span>
<span class="line" id="L10202">            .@&quot;try&quot;,</span>
<span class="line" id="L10203">            .@&quot;nosuspend&quot;,</span>
<span class="line" id="L10204">            .unwrap_optional,</span>
<span class="line" id="L10205">            =&gt; node = node_datas[node].lhs,</span>
<span class="line" id="L10206"></span>
<span class="line" id="L10207">            <span class="tok-comment">// Anything that does not eval to an error is guaranteed to pop any</span>
</span>
<span class="line" id="L10208">            <span class="tok-comment">// additions to the error trace, so it effectively does not append.</span>
</span>
<span class="line" id="L10209">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> nodeMayEvalToError(tree, start_node) != .never,</span>
<span class="line" id="L10210">        }</span>
<span class="line" id="L10211">    }</span>
<span class="line" id="L10212">}</span>
<span class="line" id="L10213"></span>
<span class="line" id="L10214"><span class="tok-kw">fn</span> <span class="tok-fn">nodeMayEvalToError</span>(tree: *<span class="tok-kw">const</span> Ast, start_node: Ast.Node.Index) BuiltinFn.EvalToError {</span>
<span class="line" id="L10215">    <span class="tok-kw">const</span> node_tags = tree.nodes.items(.tag);</span>
<span class="line" id="L10216">    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);</span>
<span class="line" id="L10217">    <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);</span>
<span class="line" id="L10218">    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);</span>
<span class="line" id="L10219"></span>
<span class="line" id="L10220">    <span class="tok-kw">var</span> node = start_node;</span>
<span class="line" id="L10221">    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L10222">        <span class="tok-kw">switch</span> (node_tags[node]) {</span>
<span class="line" id="L10223">            .root,</span>
<span class="line" id="L10224">            .@&quot;usingnamespace&quot;,</span>
<span class="line" id="L10225">            .test_decl,</span>
<span class="line" id="L10226">            .switch_case,</span>
<span class="line" id="L10227">            .switch_case_inline,</span>
<span class="line" id="L10228">            .switch_case_one,</span>
<span class="line" id="L10229">            .switch_case_inline_one,</span>
<span class="line" id="L10230">            .container_field_init,</span>
<span class="line" id="L10231">            .container_field_align,</span>
<span class="line" id="L10232">            .container_field,</span>
<span class="line" id="L10233">            .asm_output,</span>
<span class="line" id="L10234">            .asm_input,</span>
<span class="line" id="L10235">            =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L10236"></span>
<span class="line" id="L10237">            .error_value =&gt; <span class="tok-kw">return</span> .always,</span>
<span class="line" id="L10238"></span>
<span class="line" id="L10239">            .@&quot;asm&quot;,</span>
<span class="line" id="L10240">            .asm_simple,</span>
<span class="line" id="L10241">            .identifier,</span>
<span class="line" id="L10242">            .field_access,</span>
<span class="line" id="L10243">            .deref,</span>
<span class="line" id="L10244">            .array_access,</span>
<span class="line" id="L10245">            .while_simple,</span>
<span class="line" id="L10246">            .while_cont,</span>
<span class="line" id="L10247">            .for_simple,</span>
<span class="line" id="L10248">            .if_simple,</span>
<span class="line" id="L10249">            .@&quot;while&quot;,</span>
<span class="line" id="L10250">            .@&quot;if&quot;,</span>
<span class="line" id="L10251">            .@&quot;for&quot;,</span>
<span class="line" id="L10252">            .@&quot;switch&quot;,</span>
<span class="line" id="L10253">            .switch_comma,</span>
<span class="line" id="L10254">            .call_one,</span>
<span class="line" id="L10255">            .call_one_comma,</span>
<span class="line" id="L10256">            .async_call_one,</span>
<span class="line" id="L10257">            .async_call_one_comma,</span>
<span class="line" id="L10258">            .call,</span>
<span class="line" id="L10259">            .call_comma,</span>
<span class="line" id="L10260">            .async_call,</span>
<span class="line" id="L10261">            .async_call_comma,</span>
<span class="line" id="L10262">            =&gt; <span class="tok-kw">return</span> .maybe,</span>
<span class="line" id="L10263"></span>
<span class="line" id="L10264">            .@&quot;return&quot;,</span>
<span class="line" id="L10265">            .@&quot;break&quot;,</span>
<span class="line" id="L10266">            .@&quot;continue&quot;,</span>
<span class="line" id="L10267">            .bit_not,</span>
<span class="line" id="L10268">            .bool_not,</span>
<span class="line" id="L10269">            .global_var_decl,</span>
<span class="line" id="L10270">            .local_var_decl,</span>
<span class="line" id="L10271">            .simple_var_decl,</span>
<span class="line" id="L10272">            .aligned_var_decl,</span>
<span class="line" id="L10273">            .@&quot;defer&quot;,</span>
<span class="line" id="L10274">            .@&quot;errdefer&quot;,</span>
<span class="line" id="L10275">            .address_of,</span>
<span class="line" id="L10276">            .optional_type,</span>
<span class="line" id="L10277">            .negation,</span>
<span class="line" id="L10278">            .negation_wrap,</span>
<span class="line" id="L10279">            .@&quot;resume&quot;,</span>
<span class="line" id="L10280">            .array_type,</span>
<span class="line" id="L10281">            .array_type_sentinel,</span>
<span class="line" id="L10282">            .ptr_type_aligned,</span>
<span class="line" id="L10283">            .ptr_type_sentinel,</span>
<span class="line" id="L10284">            .ptr_type,</span>
<span class="line" id="L10285">            .ptr_type_bit_range,</span>
<span class="line" id="L10286">            .@&quot;suspend&quot;,</span>
<span class="line" id="L10287">            .fn_proto_simple,</span>
<span class="line" id="L10288">            .fn_proto_multi,</span>
<span class="line" id="L10289">            .fn_proto_one,</span>
<span class="line" id="L10290">            .fn_proto,</span>
<span class="line" id="L10291">            .fn_decl,</span>
<span class="line" id="L10292">            .anyframe_type,</span>
<span class="line" id="L10293">            .anyframe_literal,</span>
<span class="line" id="L10294">            .number_literal,</span>
<span class="line" id="L10295">            .enum_literal,</span>
<span class="line" id="L10296">            .string_literal,</span>
<span class="line" id="L10297">            .multiline_string_literal,</span>
<span class="line" id="L10298">            .char_literal,</span>
<span class="line" id="L10299">            .unreachable_literal,</span>
<span class="line" id="L10300">            .error_set_decl,</span>
<span class="line" id="L10301">            .container_decl,</span>
<span class="line" id="L10302">            .container_decl_trailing,</span>
<span class="line" id="L10303">            .container_decl_two,</span>
<span class="line" id="L10304">            .container_decl_two_trailing,</span>
<span class="line" id="L10305">            .container_decl_arg,</span>
<span class="line" id="L10306">            .container_decl_arg_trailing,</span>
<span class="line" id="L10307">            .tagged_union,</span>
<span class="line" id="L10308">            .tagged_union_trailing,</span>
<span class="line" id="L10309">            .tagged_union_two,</span>
<span class="line" id="L10310">            .tagged_union_two_trailing,</span>
<span class="line" id="L10311">            .tagged_union_enum_tag,</span>
<span class="line" id="L10312">            .tagged_union_enum_tag_trailing,</span>
<span class="line" id="L10313">            .add,</span>
<span class="line" id="L10314">            .add_wrap,</span>
<span class="line" id="L10315">            .add_sat,</span>
<span class="line" id="L10316">            .array_cat,</span>
<span class="line" id="L10317">            .array_mult,</span>
<span class="line" id="L10318">            .assign,</span>
<span class="line" id="L10319">            .assign_destructure,</span>
<span class="line" id="L10320">            .assign_bit_and,</span>
<span class="line" id="L10321">            .assign_bit_or,</span>
<span class="line" id="L10322">            .assign_shl,</span>
<span class="line" id="L10323">            .assign_shl_sat,</span>
<span class="line" id="L10324">            .assign_shr,</span>
<span class="line" id="L10325">            .assign_bit_xor,</span>
<span class="line" id="L10326">            .assign_div,</span>
<span class="line" id="L10327">            .assign_sub,</span>
<span class="line" id="L10328">            .assign_sub_wrap,</span>
<span class="line" id="L10329">            .assign_sub_sat,</span>
<span class="line" id="L10330">            .assign_mod,</span>
<span class="line" id="L10331">            .assign_add,</span>
<span class="line" id="L10332">            .assign_add_wrap,</span>
<span class="line" id="L10333">            .assign_add_sat,</span>
<span class="line" id="L10334">            .assign_mul,</span>
<span class="line" id="L10335">            .assign_mul_wrap,</span>
<span class="line" id="L10336">            .assign_mul_sat,</span>
<span class="line" id="L10337">            .bang_equal,</span>
<span class="line" id="L10338">            .bit_and,</span>
<span class="line" id="L10339">            .bit_or,</span>
<span class="line" id="L10340">            .shl,</span>
<span class="line" id="L10341">            .shl_sat,</span>
<span class="line" id="L10342">            .shr,</span>
<span class="line" id="L10343">            .bit_xor,</span>
<span class="line" id="L10344">            .bool_and,</span>
<span class="line" id="L10345">            .bool_or,</span>
<span class="line" id="L10346">            .div,</span>
<span class="line" id="L10347">            .equal_equal,</span>
<span class="line" id="L10348">            .error_union,</span>
<span class="line" id="L10349">            .greater_or_equal,</span>
<span class="line" id="L10350">            .greater_than,</span>
<span class="line" id="L10351">            .less_or_equal,</span>
<span class="line" id="L10352">            .less_than,</span>
<span class="line" id="L10353">            .merge_error_sets,</span>
<span class="line" id="L10354">            .mod,</span>
<span class="line" id="L10355">            .mul,</span>
<span class="line" id="L10356">            .mul_wrap,</span>
<span class="line" id="L10357">            .mul_sat,</span>
<span class="line" id="L10358">            .switch_range,</span>
<span class="line" id="L10359">            .for_range,</span>
<span class="line" id="L10360">            .sub,</span>
<span class="line" id="L10361">            .sub_wrap,</span>
<span class="line" id="L10362">            .sub_sat,</span>
<span class="line" id="L10363">            .slice,</span>
<span class="line" id="L10364">            .slice_open,</span>
<span class="line" id="L10365">            .slice_sentinel,</span>
<span class="line" id="L10366">            .array_init_one,</span>
<span class="line" id="L10367">            .array_init_one_comma,</span>
<span class="line" id="L10368">            .array_init_dot_two,</span>
<span class="line" id="L10369">            .array_init_dot_two_comma,</span>
<span class="line" id="L10370">            .array_init_dot,</span>
<span class="line" id="L10371">            .array_init_dot_comma,</span>
<span class="line" id="L10372">            .array_init,</span>
<span class="line" id="L10373">            .array_init_comma,</span>
<span class="line" id="L10374">            .struct_init_one,</span>
<span class="line" id="L10375">            .struct_init_one_comma,</span>
<span class="line" id="L10376">            .struct_init_dot_two,</span>
<span class="line" id="L10377">            .struct_init_dot_two_comma,</span>
<span class="line" id="L10378">            .struct_init_dot,</span>
<span class="line" id="L10379">            .struct_init_dot_comma,</span>
<span class="line" id="L10380">            .struct_init,</span>
<span class="line" id="L10381">            .struct_init_comma,</span>
<span class="line" id="L10382">            =&gt; <span class="tok-kw">return</span> .never,</span>
<span class="line" id="L10383"></span>
<span class="line" id="L10384">            <span class="tok-comment">// Forward the question to the LHS sub-expression.</span>
</span>
<span class="line" id="L10385">            .grouped_expression,</span>
<span class="line" id="L10386">            .@&quot;try&quot;,</span>
<span class="line" id="L10387">            .@&quot;await&quot;,</span>
<span class="line" id="L10388">            .@&quot;comptime&quot;,</span>
<span class="line" id="L10389">            .@&quot;nosuspend&quot;,</span>
<span class="line" id="L10390">            .unwrap_optional,</span>
<span class="line" id="L10391">            =&gt; node = node_datas[node].lhs,</span>
<span class="line" id="L10392"></span>
<span class="line" id="L10393">            <span class="tok-comment">// LHS sub-expression may still be an error under the outer optional or error union</span>
</span>
<span class="line" id="L10394">            .@&quot;catch&quot;,</span>
<span class="line" id="L10395">            .@&quot;orelse&quot;,</span>
<span class="line" id="L10396">            =&gt; <span class="tok-kw">return</span> .maybe,</span>
<span class="line" id="L10397"></span>
<span class="line" id="L10398">            .block_two,</span>
<span class="line" id="L10399">            .block_two_semicolon,</span>
<span class="line" id="L10400">            .block,</span>
<span class="line" id="L10401">            .block_semicolon,</span>
<span class="line" id="L10402">            =&gt; {</span>
<span class="line" id="L10403">                <span class="tok-kw">const</span> lbrace = main_tokens[node];</span>
<span class="line" id="L10404">                <span class="tok-kw">if</span> (token_tags[lbrace - <span class="tok-number">1</span>] == .colon) {</span>
<span class="line" id="L10405">                    <span class="tok-comment">// Labeled blocks may need a memory location to forward</span>
</span>
<span class="line" id="L10406">                    <span class="tok-comment">// to their break statements.</span>
</span>
<span class="line" id="L10407">                    <span class="tok-kw">return</span> .maybe;</span>
<span class="line" id="L10408">                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L10409">                    <span class="tok-kw">return</span> .never;</span>
<span class="line" id="L10410">                }</span>
<span class="line" id="L10411">            },</span>
<span class="line" id="L10412"></span>
<span class="line" id="L10413">            .builtin_call,</span>
<span class="line" id="L10414">            .builtin_call_comma,</span>
<span class="line" id="L10415">            .builtin_call_two,</span>
<span class="line" id="L10416">            .builtin_call_two_comma,</span>
<span class="line" id="L10417">            =&gt; {</span>
<span class="line" id="L10418">                <span class="tok-kw">const</span> builtin_token = main_tokens[node];</span>
<span class="line" id="L10419">                <span class="tok-kw">const</span> builtin_name = tree.tokenSlice(builtin_token);</span>
<span class="line" id="L10420">                <span class="tok-comment">// If the builtin is an invalid name, we don't cause an error here; instead</span>
</span>
<span class="line" id="L10421">                <span class="tok-comment">// let it pass, and the error will be &quot;invalid builtin function&quot; later.</span>
</span>
<span class="line" id="L10422">                <span class="tok-kw">const</span> builtin_info = BuiltinFn.list.get(builtin_name) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> .maybe;</span>
<span class="line" id="L10423">                <span class="tok-kw">return</span> builtin_info.eval_to_error;</span>
<span class="line" id="L10424">            },</span>
<span class="line" id="L10425">        }</span>
<span class="line" id="L10426">    }</span>
<span class="line" id="L10427">}</span>
<span class="line" id="L10428"></span>
<span class="line" id="L10429"><span class="tok-comment">/// Returns `true` if it is known the type expression has more than one possible value;</span></span>
<span class="line" id="L10430"><span class="tok-comment">/// `false` otherwise.</span></span>
<span class="line" id="L10431"><span class="tok-kw">fn</span> <span class="tok-fn">nodeImpliesMoreThanOnePossibleValue</span>(tree: *<span class="tok-kw">const</span> Ast, start_node: Ast.Node.Index) <span class="tok-type">bool</span> {</span>
<span class="line" id="L10432">    <span class="tok-kw">const</span> node_tags = tree.nodes.items(.tag);</span>
<span class="line" id="L10433">    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);</span>
<span class="line" id="L10434"></span>
<span class="line" id="L10435">    <span class="tok-kw">var</span> node = start_node;</span>
<span class="line" id="L10436">    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L10437">        <span class="tok-kw">switch</span> (node_tags[node]) {</span>
<span class="line" id="L10438">            .root,</span>
<span class="line" id="L10439">            .@&quot;usingnamespace&quot;,</span>
<span class="line" id="L10440">            .test_decl,</span>
<span class="line" id="L10441">            .switch_case,</span>
<span class="line" id="L10442">            .switch_case_inline,</span>
<span class="line" id="L10443">            .switch_case_one,</span>
<span class="line" id="L10444">            .switch_case_inline_one,</span>
<span class="line" id="L10445">            .container_field_init,</span>
<span class="line" id="L10446">            .container_field_align,</span>
<span class="line" id="L10447">            .container_field,</span>
<span class="line" id="L10448">            .asm_output,</span>
<span class="line" id="L10449">            .asm_input,</span>
<span class="line" id="L10450">            .global_var_decl,</span>
<span class="line" id="L10451">            .local_var_decl,</span>
<span class="line" id="L10452">            .simple_var_decl,</span>
<span class="line" id="L10453">            .aligned_var_decl,</span>
<span class="line" id="L10454">            =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L10455"></span>
<span class="line" id="L10456">            .@&quot;return&quot;,</span>
<span class="line" id="L10457">            .@&quot;break&quot;,</span>
<span class="line" id="L10458">            .@&quot;continue&quot;,</span>
<span class="line" id="L10459">            .bit_not,</span>
<span class="line" id="L10460">            .bool_not,</span>
<span class="line" id="L10461">            .@&quot;defer&quot;,</span>
<span class="line" id="L10462">            .@&quot;errdefer&quot;,</span>
<span class="line" id="L10463">            .address_of,</span>
<span class="line" id="L10464">            .negation,</span>
<span class="line" id="L10465">            .negation_wrap,</span>
<span class="line" id="L10466">            .@&quot;resume&quot;,</span>
<span class="line" id="L10467">            .array_type,</span>
<span class="line" id="L10468">            .@&quot;suspend&quot;,</span>
<span class="line" id="L10469">            .fn_decl,</span>
<span class="line" id="L10470">            .anyframe_literal,</span>
<span class="line" id="L10471">            .number_literal,</span>
<span class="line" id="L10472">            .enum_literal,</span>
<span class="line" id="L10473">            .string_literal,</span>
<span class="line" id="L10474">            .multiline_string_literal,</span>
<span class="line" id="L10475">            .char_literal,</span>
<span class="line" id="L10476">            .unreachable_literal,</span>
<span class="line" id="L10477">            .error_set_decl,</span>
<span class="line" id="L10478">            .container_decl,</span>
<span class="line" id="L10479">            .container_decl_trailing,</span>
<span class="line" id="L10480">            .container_decl_two,</span>
<span class="line" id="L10481">            .container_decl_two_trailing,</span>
<span class="line" id="L10482">            .container_decl_arg,</span>
<span class="line" id="L10483">            .container_decl_arg_trailing,</span>
<span class="line" id="L10484">            .tagged_union,</span>
<span class="line" id="L10485">            .tagged_union_trailing,</span>
<span class="line" id="L10486">            .tagged_union_two,</span>
<span class="line" id="L10487">            .tagged_union_two_trailing,</span>
<span class="line" id="L10488">            .tagged_union_enum_tag,</span>
<span class="line" id="L10489">            .tagged_union_enum_tag_trailing,</span>
<span class="line" id="L10490">            .@&quot;asm&quot;,</span>
<span class="line" id="L10491">            .asm_simple,</span>
<span class="line" id="L10492">            .add,</span>
<span class="line" id="L10493">            .add_wrap,</span>
<span class="line" id="L10494">            .add_sat,</span>
<span class="line" id="L10495">            .array_cat,</span>
<span class="line" id="L10496">            .array_mult,</span>
<span class="line" id="L10497">            .assign,</span>
<span class="line" id="L10498">            .assign_destructure,</span>
<span class="line" id="L10499">            .assign_bit_and,</span>
<span class="line" id="L10500">            .assign_bit_or,</span>
<span class="line" id="L10501">            .assign_shl,</span>
<span class="line" id="L10502">            .assign_shl_sat,</span>
<span class="line" id="L10503">            .assign_shr,</span>
<span class="line" id="L10504">            .assign_bit_xor,</span>
<span class="line" id="L10505">            .assign_div,</span>
<span class="line" id="L10506">            .assign_sub,</span>
<span class="line" id="L10507">            .assign_sub_wrap,</span>
<span class="line" id="L10508">            .assign_sub_sat,</span>
<span class="line" id="L10509">            .assign_mod,</span>
<span class="line" id="L10510">            .assign_add,</span>
<span class="line" id="L10511">            .assign_add_wrap,</span>
<span class="line" id="L10512">            .assign_add_sat,</span>
<span class="line" id="L10513">            .assign_mul,</span>
<span class="line" id="L10514">            .assign_mul_wrap,</span>
<span class="line" id="L10515">            .assign_mul_sat,</span>
<span class="line" id="L10516">            .bang_equal,</span>
<span class="line" id="L10517">            .bit_and,</span>
<span class="line" id="L10518">            .bit_or,</span>
<span class="line" id="L10519">            .shl,</span>
<span class="line" id="L10520">            .shl_sat,</span>
<span class="line" id="L10521">            .shr,</span>
<span class="line" id="L10522">            .bit_xor,</span>
<span class="line" id="L10523">            .bool_and,</span>
<span class="line" id="L10524">            .bool_or,</span>
<span class="line" id="L10525">            .div,</span>
<span class="line" id="L10526">            .equal_equal,</span>
<span class="line" id="L10527">            .error_union,</span>
<span class="line" id="L10528">            .greater_or_equal,</span>
<span class="line" id="L10529">            .greater_than,</span>
<span class="line" id="L10530">            .less_or_equal,</span>
<span class="line" id="L10531">            .less_than,</span>
<span class="line" id="L10532">            .merge_error_sets,</span>
<span class="line" id="L10533">            .mod,</span>
<span class="line" id="L10534">            .mul,</span>
<span class="line" id="L10535">            .mul_wrap,</span>
<span class="line" id="L10536">            .mul_sat,</span>
<span class="line" id="L10537">            .switch_range,</span>
<span class="line" id="L10538">            .for_range,</span>
<span class="line" id="L10539">            .field_access,</span>
<span class="line" id="L10540">            .sub,</span>
<span class="line" id="L10541">            .sub_wrap,</span>
<span class="line" id="L10542">            .sub_sat,</span>
<span class="line" id="L10543">            .slice,</span>
<span class="line" id="L10544">            .slice_open,</span>
<span class="line" id="L10545">            .slice_sentinel,</span>
<span class="line" id="L10546">            .deref,</span>
<span class="line" id="L10547">            .array_access,</span>
<span class="line" id="L10548">            .error_value,</span>
<span class="line" id="L10549">            .while_simple,</span>
<span class="line" id="L10550">            .while_cont,</span>
<span class="line" id="L10551">            .for_simple,</span>
<span class="line" id="L10552">            .if_simple,</span>
<span class="line" id="L10553">            .@&quot;catch&quot;,</span>
<span class="line" id="L10554">            .@&quot;orelse&quot;,</span>
<span class="line" id="L10555">            .array_init_one,</span>
<span class="line" id="L10556">            .array_init_one_comma,</span>
<span class="line" id="L10557">            .array_init_dot_two,</span>
<span class="line" id="L10558">            .array_init_dot_two_comma,</span>
<span class="line" id="L10559">            .array_init_dot,</span>
<span class="line" id="L10560">            .array_init_dot_comma,</span>
<span class="line" id="L10561">            .array_init,</span>
<span class="line" id="L10562">            .array_init_comma,</span>
<span class="line" id="L10563">            .struct_init_one,</span>
<span class="line" id="L10564">            .struct_init_one_comma,</span>
<span class="line" id="L10565">            .struct_init_dot_two,</span>
<span class="line" id="L10566">            .struct_init_dot_two_comma,</span>
<span class="line" id="L10567">            .struct_init_dot,</span>
<span class="line" id="L10568">            .struct_init_dot_comma,</span>
<span class="line" id="L10569">            .struct_init,</span>
<span class="line" id="L10570">            .struct_init_comma,</span>
<span class="line" id="L10571">            .@&quot;while&quot;,</span>
<span class="line" id="L10572">            .@&quot;if&quot;,</span>
<span class="line" id="L10573">            .@&quot;for&quot;,</span>
<span class="line" id="L10574">            .@&quot;switch&quot;,</span>
<span class="line" id="L10575">            .switch_comma,</span>
<span class="line" id="L10576">            .call_one,</span>
<span class="line" id="L10577">            .call_one_comma,</span>
<span class="line" id="L10578">            .async_call_one,</span>
<span class="line" id="L10579">            .async_call_one_comma,</span>
<span class="line" id="L10580">            .call,</span>
<span class="line" id="L10581">            .call_comma,</span>
<span class="line" id="L10582">            .async_call,</span>
<span class="line" id="L10583">            .async_call_comma,</span>
<span class="line" id="L10584">            .block_two,</span>
<span class="line" id="L10585">            .block_two_semicolon,</span>
<span class="line" id="L10586">            .block,</span>
<span class="line" id="L10587">            .block_semicolon,</span>
<span class="line" id="L10588">            .builtin_call,</span>
<span class="line" id="L10589">            .builtin_call_comma,</span>
<span class="line" id="L10590">            .builtin_call_two,</span>
<span class="line" id="L10591">            .builtin_call_two_comma,</span>
<span class="line" id="L10592">            <span class="tok-comment">// these are function bodies, not pointers</span>
</span>
<span class="line" id="L10593">            .fn_proto_simple,</span>
<span class="line" id="L10594">            .fn_proto_multi,</span>
<span class="line" id="L10595">            .fn_proto_one,</span>
<span class="line" id="L10596">            .fn_proto,</span>
<span class="line" id="L10597">            =&gt; <span class="tok-kw">return</span> <span class="tok-null">false</span>,</span>
<span class="line" id="L10598"></span>
<span class="line" id="L10599">            <span class="tok-comment">// Forward the question to the LHS sub-expression.</span>
</span>
<span class="line" id="L10600">            .grouped_expression,</span>
<span class="line" id="L10601">            .@&quot;try&quot;,</span>
<span class="line" id="L10602">            .@&quot;await&quot;,</span>
<span class="line" id="L10603">            .@&quot;comptime&quot;,</span>
<span class="line" id="L10604">            .@&quot;nosuspend&quot;,</span>
<span class="line" id="L10605">            .unwrap_optional,</span>
<span class="line" id="L10606">            =&gt; node = node_datas[node].lhs,</span>
<span class="line" id="L10607"></span>
<span class="line" id="L10608">            .ptr_type_aligned,</span>
<span class="line" id="L10609">            .ptr_type_sentinel,</span>
<span class="line" id="L10610">            .ptr_type,</span>
<span class="line" id="L10611">            .ptr_type_bit_range,</span>
<span class="line" id="L10612">            .optional_type,</span>
<span class="line" id="L10613">            .anyframe_type,</span>
<span class="line" id="L10614">            .array_type_sentinel,</span>
<span class="line" id="L10615">            =&gt; <span class="tok-kw">return</span> <span class="tok-null">true</span>,</span>
<span class="line" id="L10616"></span>
<span class="line" id="L10617">            .identifier =&gt; {</span>
<span class="line" id="L10618">                <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);</span>
<span class="line" id="L10619">                <span class="tok-kw">const</span> ident_bytes = tree.tokenSlice(main_tokens[node]);</span>
<span class="line" id="L10620">                <span class="tok-kw">if</span> (primitive_instrs.get(ident_bytes)) |primitive| <span class="tok-kw">switch</span> (primitive) {</span>
<span class="line" id="L10621">                    .anyerror_type,</span>
<span class="line" id="L10622">                    .anyframe_type,</span>
<span class="line" id="L10623">                    .anyopaque_type,</span>
<span class="line" id="L10624">                    .bool_type,</span>
<span class="line" id="L10625">                    .c_int_type,</span>
<span class="line" id="L10626">                    .c_long_type,</span>
<span class="line" id="L10627">                    .c_longdouble_type,</span>
<span class="line" id="L10628">                    .c_longlong_type,</span>
<span class="line" id="L10629">                    .c_char_type,</span>
<span class="line" id="L10630">                    .c_short_type,</span>
<span class="line" id="L10631">                    .c_uint_type,</span>
<span class="line" id="L10632">                    .c_ulong_type,</span>
<span class="line" id="L10633">                    .c_ulonglong_type,</span>
<span class="line" id="L10634">                    .c_ushort_type,</span>
<span class="line" id="L10635">                    .comptime_float_type,</span>
<span class="line" id="L10636">                    .comptime_int_type,</span>
<span class="line" id="L10637">                    .f16_type,</span>
<span class="line" id="L10638">                    .f32_type,</span>
<span class="line" id="L10639">                    .f64_type,</span>
<span class="line" id="L10640">                    .f80_type,</span>
<span class="line" id="L10641">                    .f128_type,</span>
<span class="line" id="L10642">                    .i16_type,</span>
<span class="line" id="L10643">                    .i32_type,</span>
<span class="line" id="L10644">                    .i64_type,</span>
<span class="line" id="L10645">                    .i128_type,</span>
<span class="line" id="L10646">                    .i8_type,</span>
<span class="line" id="L10647">                    .isize_type,</span>
<span class="line" id="L10648">                    .type_type,</span>
<span class="line" id="L10649">                    .u16_type,</span>
<span class="line" id="L10650">                    .u29_type,</span>
<span class="line" id="L10651">                    .u32_type,</span>
<span class="line" id="L10652">                    .u64_type,</span>
<span class="line" id="L10653">                    .u128_type,</span>
<span class="line" id="L10654">                    .u1_type,</span>
<span class="line" id="L10655">                    .u8_type,</span>
<span class="line" id="L10656">                    .usize_type,</span>
<span class="line" id="L10657">                    =&gt; <span class="tok-kw">return</span> <span class="tok-null">true</span>,</span>
<span class="line" id="L10658"></span>
<span class="line" id="L10659">                    .void_type,</span>
<span class="line" id="L10660">                    .bool_false,</span>
<span class="line" id="L10661">                    .bool_true,</span>
<span class="line" id="L10662">                    .null_value,</span>
<span class="line" id="L10663">                    .undef,</span>
<span class="line" id="L10664">                    .noreturn_type,</span>
<span class="line" id="L10665">                    =&gt; <span class="tok-kw">return</span> <span class="tok-null">false</span>,</span>
<span class="line" id="L10666"></span>
<span class="line" id="L10667">                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// that's all the values from `primitives`.</span>
</span>
<span class="line" id="L10668">                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L10669">                    <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L10670">                }</span>
<span class="line" id="L10671">            },</span>
<span class="line" id="L10672">        }</span>
<span class="line" id="L10673">    }</span>
<span class="line" id="L10674">}</span>
<span class="line" id="L10675"></span>
<span class="line" id="L10676"><span class="tok-comment">/// Returns `true` if it is known the expression is a type that cannot be used at runtime;</span></span>
<span class="line" id="L10677"><span class="tok-comment">/// `false` otherwise.</span></span>
<span class="line" id="L10678"><span class="tok-kw">fn</span> <span class="tok-fn">nodeImpliesComptimeOnly</span>(tree: *<span class="tok-kw">const</span> Ast, start_node: Ast.Node.Index) <span class="tok-type">bool</span> {</span>
<span class="line" id="L10679">    <span class="tok-kw">const</span> node_tags = tree.nodes.items(.tag);</span>
<span class="line" id="L10680">    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);</span>
<span class="line" id="L10681"></span>
<span class="line" id="L10682">    <span class="tok-kw">var</span> node = start_node;</span>
<span class="line" id="L10683">    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L10684">        <span class="tok-kw">switch</span> (node_tags[node]) {</span>
<span class="line" id="L10685">            .root,</span>
<span class="line" id="L10686">            .@&quot;usingnamespace&quot;,</span>
<span class="line" id="L10687">            .test_decl,</span>
<span class="line" id="L10688">            .switch_case,</span>
<span class="line" id="L10689">            .switch_case_inline,</span>
<span class="line" id="L10690">            .switch_case_one,</span>
<span class="line" id="L10691">            .switch_case_inline_one,</span>
<span class="line" id="L10692">            .container_field_init,</span>
<span class="line" id="L10693">            .container_field_align,</span>
<span class="line" id="L10694">            .container_field,</span>
<span class="line" id="L10695">            .asm_output,</span>
<span class="line" id="L10696">            .asm_input,</span>
<span class="line" id="L10697">            .global_var_decl,</span>
<span class="line" id="L10698">            .local_var_decl,</span>
<span class="line" id="L10699">            .simple_var_decl,</span>
<span class="line" id="L10700">            .aligned_var_decl,</span>
<span class="line" id="L10701">            =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L10702"></span>
<span class="line" id="L10703">            .@&quot;return&quot;,</span>
<span class="line" id="L10704">            .@&quot;break&quot;,</span>
<span class="line" id="L10705">            .@&quot;continue&quot;,</span>
<span class="line" id="L10706">            .bit_not,</span>
<span class="line" id="L10707">            .bool_not,</span>
<span class="line" id="L10708">            .@&quot;defer&quot;,</span>
<span class="line" id="L10709">            .@&quot;errdefer&quot;,</span>
<span class="line" id="L10710">            .address_of,</span>
<span class="line" id="L10711">            .negation,</span>
<span class="line" id="L10712">            .negation_wrap,</span>
<span class="line" id="L10713">            .@&quot;resume&quot;,</span>
<span class="line" id="L10714">            .array_type,</span>
<span class="line" id="L10715">            .@&quot;suspend&quot;,</span>
<span class="line" id="L10716">            .fn_decl,</span>
<span class="line" id="L10717">            .anyframe_literal,</span>
<span class="line" id="L10718">            .number_literal,</span>
<span class="line" id="L10719">            .enum_literal,</span>
<span class="line" id="L10720">            .string_literal,</span>
<span class="line" id="L10721">            .multiline_string_literal,</span>
<span class="line" id="L10722">            .char_literal,</span>
<span class="line" id="L10723">            .unreachable_literal,</span>
<span class="line" id="L10724">            .error_set_decl,</span>
<span class="line" id="L10725">            .container_decl,</span>
<span class="line" id="L10726">            .container_decl_trailing,</span>
<span class="line" id="L10727">            .container_decl_two,</span>
<span class="line" id="L10728">            .container_decl_two_trailing,</span>
<span class="line" id="L10729">            .container_decl_arg,</span>
<span class="line" id="L10730">            .container_decl_arg_trailing,</span>
<span class="line" id="L10731">            .tagged_union,</span>
<span class="line" id="L10732">            .tagged_union_trailing,</span>
<span class="line" id="L10733">            .tagged_union_two,</span>
<span class="line" id="L10734">            .tagged_union_two_trailing,</span>
<span class="line" id="L10735">            .tagged_union_enum_tag,</span>
<span class="line" id="L10736">            .tagged_union_enum_tag_trailing,</span>
<span class="line" id="L10737">            .@&quot;asm&quot;,</span>
<span class="line" id="L10738">            .asm_simple,</span>
<span class="line" id="L10739">            .add,</span>
<span class="line" id="L10740">            .add_wrap,</span>
<span class="line" id="L10741">            .add_sat,</span>
<span class="line" id="L10742">            .array_cat,</span>
<span class="line" id="L10743">            .array_mult,</span>
<span class="line" id="L10744">            .assign,</span>
<span class="line" id="L10745">            .assign_destructure,</span>
<span class="line" id="L10746">            .assign_bit_and,</span>
<span class="line" id="L10747">            .assign_bit_or,</span>
<span class="line" id="L10748">            .assign_shl,</span>
<span class="line" id="L10749">            .assign_shl_sat,</span>
<span class="line" id="L10750">            .assign_shr,</span>
<span class="line" id="L10751">            .assign_bit_xor,</span>
<span class="line" id="L10752">            .assign_div,</span>
<span class="line" id="L10753">            .assign_sub,</span>
<span class="line" id="L10754">            .assign_sub_wrap,</span>
<span class="line" id="L10755">            .assign_sub_sat,</span>
<span class="line" id="L10756">            .assign_mod,</span>
<span class="line" id="L10757">            .assign_add,</span>
<span class="line" id="L10758">            .assign_add_wrap,</span>
<span class="line" id="L10759">            .assign_add_sat,</span>
<span class="line" id="L10760">            .assign_mul,</span>
<span class="line" id="L10761">            .assign_mul_wrap,</span>
<span class="line" id="L10762">            .assign_mul_sat,</span>
<span class="line" id="L10763">            .bang_equal,</span>
<span class="line" id="L10764">            .bit_and,</span>
<span class="line" id="L10765">            .bit_or,</span>
<span class="line" id="L10766">            .shl,</span>
<span class="line" id="L10767">            .shl_sat,</span>
<span class="line" id="L10768">            .shr,</span>
<span class="line" id="L10769">            .bit_xor,</span>
<span class="line" id="L10770">            .bool_and,</span>
<span class="line" id="L10771">            .bool_or,</span>
<span class="line" id="L10772">            .div,</span>
<span class="line" id="L10773">            .equal_equal,</span>
<span class="line" id="L10774">            .error_union,</span>
<span class="line" id="L10775">            .greater_or_equal,</span>
<span class="line" id="L10776">            .greater_than,</span>
<span class="line" id="L10777">            .less_or_equal,</span>
<span class="line" id="L10778">            .less_than,</span>
<span class="line" id="L10779">            .merge_error_sets,</span>
<span class="line" id="L10780">            .mod,</span>
<span class="line" id="L10781">            .mul,</span>
<span class="line" id="L10782">            .mul_wrap,</span>
<span class="line" id="L10783">            .mul_sat,</span>
<span class="line" id="L10784">            .switch_range,</span>
<span class="line" id="L10785">            .for_range,</span>
<span class="line" id="L10786">            .field_access,</span>
<span class="line" id="L10787">            .sub,</span>
<span class="line" id="L10788">            .sub_wrap,</span>
<span class="line" id="L10789">            .sub_sat,</span>
<span class="line" id="L10790">            .slice,</span>
<span class="line" id="L10791">            .slice_open,</span>
<span class="line" id="L10792">            .slice_sentinel,</span>
<span class="line" id="L10793">            .deref,</span>
<span class="line" id="L10794">            .array_access,</span>
<span class="line" id="L10795">            .error_value,</span>
<span class="line" id="L10796">            .while_simple,</span>
<span class="line" id="L10797">            .while_cont,</span>
<span class="line" id="L10798">            .for_simple,</span>
<span class="line" id="L10799">            .if_simple,</span>
<span class="line" id="L10800">            .@&quot;catch&quot;,</span>
<span class="line" id="L10801">            .@&quot;orelse&quot;,</span>
<span class="line" id="L10802">            .array_init_one,</span>
<span class="line" id="L10803">            .array_init_one_comma,</span>
<span class="line" id="L10804">            .array_init_dot_two,</span>
<span class="line" id="L10805">            .array_init_dot_two_comma,</span>
<span class="line" id="L10806">            .array_init_dot,</span>
<span class="line" id="L10807">            .array_init_dot_comma,</span>
<span class="line" id="L10808">            .array_init,</span>
<span class="line" id="L10809">            .array_init_comma,</span>
<span class="line" id="L10810">            .struct_init_one,</span>
<span class="line" id="L10811">            .struct_init_one_comma,</span>
<span class="line" id="L10812">            .struct_init_dot_two,</span>
<span class="line" id="L10813">            .struct_init_dot_two_comma,</span>
<span class="line" id="L10814">            .struct_init_dot,</span>
<span class="line" id="L10815">            .struct_init_dot_comma,</span>
<span class="line" id="L10816">            .struct_init,</span>
<span class="line" id="L10817">            .struct_init_comma,</span>
<span class="line" id="L10818">            .@&quot;while&quot;,</span>
<span class="line" id="L10819">            .@&quot;if&quot;,</span>
<span class="line" id="L10820">            .@&quot;for&quot;,</span>
<span class="line" id="L10821">            .@&quot;switch&quot;,</span>
<span class="line" id="L10822">            .switch_comma,</span>
<span class="line" id="L10823">            .call_one,</span>
<span class="line" id="L10824">            .call_one_comma,</span>
<span class="line" id="L10825">            .async_call_one,</span>
<span class="line" id="L10826">            .async_call_one_comma,</span>
<span class="line" id="L10827">            .call,</span>
<span class="line" id="L10828">            .call_comma,</span>
<span class="line" id="L10829">            .async_call,</span>
<span class="line" id="L10830">            .async_call_comma,</span>
<span class="line" id="L10831">            .block_two,</span>
<span class="line" id="L10832">            .block_two_semicolon,</span>
<span class="line" id="L10833">            .block,</span>
<span class="line" id="L10834">            .block_semicolon,</span>
<span class="line" id="L10835">            .builtin_call,</span>
<span class="line" id="L10836">            .builtin_call_comma,</span>
<span class="line" id="L10837">            .builtin_call_two,</span>
<span class="line" id="L10838">            .builtin_call_two_comma,</span>
<span class="line" id="L10839">            .ptr_type_aligned,</span>
<span class="line" id="L10840">            .ptr_type_sentinel,</span>
<span class="line" id="L10841">            .ptr_type,</span>
<span class="line" id="L10842">            .ptr_type_bit_range,</span>
<span class="line" id="L10843">            .optional_type,</span>
<span class="line" id="L10844">            .anyframe_type,</span>
<span class="line" id="L10845">            .array_type_sentinel,</span>
<span class="line" id="L10846">            =&gt; <span class="tok-kw">return</span> <span class="tok-null">false</span>,</span>
<span class="line" id="L10847"></span>
<span class="line" id="L10848">            <span class="tok-comment">// these are function bodies, not pointers</span>
</span>
<span class="line" id="L10849">            .fn_proto_simple,</span>
<span class="line" id="L10850">            .fn_proto_multi,</span>
<span class="line" id="L10851">            .fn_proto_one,</span>
<span class="line" id="L10852">            .fn_proto,</span>
<span class="line" id="L10853">            =&gt; <span class="tok-kw">return</span> <span class="tok-null">true</span>,</span>
<span class="line" id="L10854"></span>
<span class="line" id="L10855">            <span class="tok-comment">// Forward the question to the LHS sub-expression.</span>
</span>
<span class="line" id="L10856">            .grouped_expression,</span>
<span class="line" id="L10857">            .@&quot;try&quot;,</span>
<span class="line" id="L10858">            .@&quot;await&quot;,</span>
<span class="line" id="L10859">            .@&quot;comptime&quot;,</span>
<span class="line" id="L10860">            .@&quot;nosuspend&quot;,</span>
<span class="line" id="L10861">            .unwrap_optional,</span>
<span class="line" id="L10862">            =&gt; node = node_datas[node].lhs,</span>
<span class="line" id="L10863"></span>
<span class="line" id="L10864">            .identifier =&gt; {</span>
<span class="line" id="L10865">                <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);</span>
<span class="line" id="L10866">                <span class="tok-kw">const</span> ident_bytes = tree.tokenSlice(main_tokens[node]);</span>
<span class="line" id="L10867">                <span class="tok-kw">if</span> (primitive_instrs.get(ident_bytes)) |primitive| <span class="tok-kw">switch</span> (primitive) {</span>
<span class="line" id="L10868">                    .anyerror_type,</span>
<span class="line" id="L10869">                    .anyframe_type,</span>
<span class="line" id="L10870">                    .anyopaque_type,</span>
<span class="line" id="L10871">                    .bool_type,</span>
<span class="line" id="L10872">                    .c_int_type,</span>
<span class="line" id="L10873">                    .c_long_type,</span>
<span class="line" id="L10874">                    .c_longdouble_type,</span>
<span class="line" id="L10875">                    .c_longlong_type,</span>
<span class="line" id="L10876">                    .c_char_type,</span>
<span class="line" id="L10877">                    .c_short_type,</span>
<span class="line" id="L10878">                    .c_uint_type,</span>
<span class="line" id="L10879">                    .c_ulong_type,</span>
<span class="line" id="L10880">                    .c_ulonglong_type,</span>
<span class="line" id="L10881">                    .c_ushort_type,</span>
<span class="line" id="L10882">                    .f16_type,</span>
<span class="line" id="L10883">                    .f32_type,</span>
<span class="line" id="L10884">                    .f64_type,</span>
<span class="line" id="L10885">                    .f80_type,</span>
<span class="line" id="L10886">                    .f128_type,</span>
<span class="line" id="L10887">                    .i16_type,</span>
<span class="line" id="L10888">                    .i32_type,</span>
<span class="line" id="L10889">                    .i64_type,</span>
<span class="line" id="L10890">                    .i128_type,</span>
<span class="line" id="L10891">                    .i8_type,</span>
<span class="line" id="L10892">                    .isize_type,</span>
<span class="line" id="L10893">                    .u16_type,</span>
<span class="line" id="L10894">                    .u29_type,</span>
<span class="line" id="L10895">                    .u32_type,</span>
<span class="line" id="L10896">                    .u64_type,</span>
<span class="line" id="L10897">                    .u128_type,</span>
<span class="line" id="L10898">                    .u1_type,</span>
<span class="line" id="L10899">                    .u8_type,</span>
<span class="line" id="L10900">                    .usize_type,</span>
<span class="line" id="L10901">                    .void_type,</span>
<span class="line" id="L10902">                    .bool_false,</span>
<span class="line" id="L10903">                    .bool_true,</span>
<span class="line" id="L10904">                    .null_value,</span>
<span class="line" id="L10905">                    .undef,</span>
<span class="line" id="L10906">                    .noreturn_type,</span>
<span class="line" id="L10907">                    =&gt; <span class="tok-kw">return</span> <span class="tok-null">false</span>,</span>
<span class="line" id="L10908"></span>
<span class="line" id="L10909">                    .comptime_float_type,</span>
<span class="line" id="L10910">                    .comptime_int_type,</span>
<span class="line" id="L10911">                    .type_type,</span>
<span class="line" id="L10912">                    =&gt; <span class="tok-kw">return</span> <span class="tok-null">true</span>,</span>
<span class="line" id="L10913"></span>
<span class="line" id="L10914">                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// that's all the values from `primitives`.</span>
</span>
<span class="line" id="L10915">                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L10916">                    <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L10917">                }</span>
<span class="line" id="L10918">            },</span>
<span class="line" id="L10919">        }</span>
<span class="line" id="L10920">    }</span>
<span class="line" id="L10921">}</span>
<span class="line" id="L10922"></span>
<span class="line" id="L10923"><span class="tok-comment">/// Returns `true` if the node uses `gz.anon_name_strategy`.</span></span>
<span class="line" id="L10924"><span class="tok-kw">fn</span> <span class="tok-fn">nodeUsesAnonNameStrategy</span>(tree: *<span class="tok-kw">const</span> Ast, node: Ast.Node.Index) <span class="tok-type">bool</span> {</span>
<span class="line" id="L10925">    <span class="tok-kw">const</span> node_tags = tree.nodes.items(.tag);</span>
<span class="line" id="L10926">    <span class="tok-kw">switch</span> (node_tags[node]) {</span>
<span class="line" id="L10927">        .container_decl,</span>
<span class="line" id="L10928">        .container_decl_trailing,</span>
<span class="line" id="L10929">        .container_decl_two,</span>
<span class="line" id="L10930">        .container_decl_two_trailing,</span>
<span class="line" id="L10931">        .container_decl_arg,</span>
<span class="line" id="L10932">        .container_decl_arg_trailing,</span>
<span class="line" id="L10933">        .tagged_union,</span>
<span class="line" id="L10934">        .tagged_union_trailing,</span>
<span class="line" id="L10935">        .tagged_union_two,</span>
<span class="line" id="L10936">        .tagged_union_two_trailing,</span>
<span class="line" id="L10937">        .tagged_union_enum_tag,</span>
<span class="line" id="L10938">        .tagged_union_enum_tag_trailing,</span>
<span class="line" id="L10939">        =&gt; <span class="tok-kw">return</span> <span class="tok-null">true</span>,</span>
<span class="line" id="L10940">        .builtin_call_two, .builtin_call_two_comma, .builtin_call, .builtin_call_comma =&gt; {</span>
<span class="line" id="L10941">            <span class="tok-kw">const</span> builtin_token = tree.nodes.items(.main_token)[node];</span>
<span class="line" id="L10942">            <span class="tok-kw">const</span> builtin_name = tree.tokenSlice(builtin_token);</span>
<span class="line" id="L10943">            <span class="tok-kw">return</span> std.mem.eql(<span class="tok-type">u8</span>, builtin_name, <span class="tok-str">&quot;@Type&quot;</span>);</span>
<span class="line" id="L10944">        },</span>
<span class="line" id="L10945">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-null">false</span>,</span>
<span class="line" id="L10946">    }</span>
<span class="line" id="L10947">}</span>
<span class="line" id="L10948"></span>
<span class="line" id="L10949"><span class="tok-comment">/// Applies `rl` semantics to `result`. Expressions which do not do their own handling of</span></span>
<span class="line" id="L10950"><span class="tok-comment">/// result locations must call this function on their result.</span></span>
<span class="line" id="L10951"><span class="tok-comment">/// As an example, if `ri.rl` is `.ptr`, it will write the result to the pointer.</span></span>
<span class="line" id="L10952"><span class="tok-comment">/// If `ri.rl` is `.ty`, it will coerce the result to the type.</span></span>
<span class="line" id="L10953"><span class="tok-comment">/// Assumes nothing stacked on `gz`.</span></span>
<span class="line" id="L10954"><span class="tok-kw">fn</span> <span class="tok-fn">rvalue</span>(</span>
<span class="line" id="L10955">    gz: *GenZir,</span>
<span class="line" id="L10956">    ri: ResultInfo,</span>
<span class="line" id="L10957">    raw_result: Zir.Inst.Ref,</span>
<span class="line" id="L10958">    src_node: Ast.Node.Index,</span>
<span class="line" id="L10959">) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L10960">    <span class="tok-kw">return</span> rvalueInner(gz, ri, raw_result, src_node, <span class="tok-null">true</span>);</span>
<span class="line" id="L10961">}</span>
<span class="line" id="L10962"></span>
<span class="line" id="L10963"><span class="tok-comment">/// Like `rvalue`, but refuses to perform coercions before taking references for</span></span>
<span class="line" id="L10964"><span class="tok-comment">/// the `ref_coerced_ty` result type. This is used for local variables which do</span></span>
<span class="line" id="L10965"><span class="tok-comment">/// not have `alloc`s, because we want variables to have consistent addresses,</span></span>
<span class="line" id="L10966"><span class="tok-comment">/// i.e. we want them to act like lvalues.</span></span>
<span class="line" id="L10967"><span class="tok-kw">fn</span> <span class="tok-fn">rvalueNoCoercePreRef</span>(</span>
<span class="line" id="L10968">    gz: *GenZir,</span>
<span class="line" id="L10969">    ri: ResultInfo,</span>
<span class="line" id="L10970">    raw_result: Zir.Inst.Ref,</span>
<span class="line" id="L10971">    src_node: Ast.Node.Index,</span>
<span class="line" id="L10972">) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L10973">    <span class="tok-kw">return</span> rvalueInner(gz, ri, raw_result, src_node, <span class="tok-null">false</span>);</span>
<span class="line" id="L10974">}</span>
<span class="line" id="L10975"></span>
<span class="line" id="L10976"><span class="tok-kw">fn</span> <span class="tok-fn">rvalueInner</span>(</span>
<span class="line" id="L10977">    gz: *GenZir,</span>
<span class="line" id="L10978">    ri: ResultInfo,</span>
<span class="line" id="L10979">    raw_result: Zir.Inst.Ref,</span>
<span class="line" id="L10980">    src_node: Ast.Node.Index,</span>
<span class="line" id="L10981">    allow_coerce_pre_ref: <span class="tok-type">bool</span>,</span>
<span class="line" id="L10982">) InnerError!Zir.Inst.Ref {</span>
<span class="line" id="L10983">    <span class="tok-kw">const</span> result = r: {</span>
<span class="line" id="L10984">        <span class="tok-kw">if</span> (raw_result.toIndex()) |result_index| {</span>
<span class="line" id="L10985">            <span class="tok-kw">const</span> zir_tags = gz.astgen.instructions.items(.tag);</span>
<span class="line" id="L10986">            <span class="tok-kw">const</span> data = gz.astgen.instructions.items(.data)[<span class="tok-builtin">@intFromEnum</span>(result_index)];</span>
<span class="line" id="L10987">            <span class="tok-kw">if</span> (zir_tags[<span class="tok-builtin">@intFromEnum</span>(result_index)].isAlwaysVoid(data)) {</span>
<span class="line" id="L10988">                <span class="tok-kw">break</span> :r Zir.Inst.Ref.void_value;</span>
<span class="line" id="L10989">            }</span>
<span class="line" id="L10990">        }</span>
<span class="line" id="L10991">        <span class="tok-kw">break</span> :r raw_result;</span>
<span class="line" id="L10992">    };</span>
<span class="line" id="L10993">    <span class="tok-kw">if</span> (gz.endsWithNoReturn()) <span class="tok-kw">return</span> result;</span>
<span class="line" id="L10994">    <span class="tok-kw">switch</span> (ri.rl) {</span>
<span class="line" id="L10995">        .none, .coerced_ty =&gt; <span class="tok-kw">return</span> result,</span>
<span class="line" id="L10996">        .discard =&gt; {</span>
<span class="line" id="L10997">            <span class="tok-comment">// Emit a compile error for discarding error values.</span>
</span>
<span class="line" id="L10998">            _ = <span class="tok-kw">try</span> gz.addUnNode(.ensure_result_non_error, result, src_node);</span>
<span class="line" id="L10999">            <span class="tok-kw">return</span> .void_value;</span>
<span class="line" id="L11000">        },</span>
<span class="line" id="L11001">        .ref, .ref_coerced_ty =&gt; {</span>
<span class="line" id="L11002">            <span class="tok-kw">const</span> coerced_result = <span class="tok-kw">if</span> (allow_coerce_pre_ref <span class="tok-kw">and</span> ri.rl == .ref_coerced_ty) res: {</span>
<span class="line" id="L11003">                <span class="tok-kw">const</span> ptr_ty = ri.rl.ref_coerced_ty;</span>
<span class="line" id="L11004">                <span class="tok-kw">break</span> :res <span class="tok-kw">try</span> gz.addPlNode(.coerce_ptr_elem_ty, src_node, Zir.Inst.Bin{</span>
<span class="line" id="L11005">                    .lhs = ptr_ty,</span>
<span class="line" id="L11006">                    .rhs = result,</span>
<span class="line" id="L11007">                });</span>
<span class="line" id="L11008">            } <span class="tok-kw">else</span> result;</span>
<span class="line" id="L11009">            <span class="tok-comment">// We need a pointer but we have a value.</span>
</span>
<span class="line" id="L11010">            <span class="tok-comment">// Unfortunately it's not quite as simple as directly emitting a ref</span>
</span>
<span class="line" id="L11011">            <span class="tok-comment">// instruction here because we need subsequent address-of operator on</span>
</span>
<span class="line" id="L11012">            <span class="tok-comment">// const locals to return the same address.</span>
</span>
<span class="line" id="L11013">            <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L11014">            <span class="tok-kw">const</span> tree = astgen.tree;</span>
<span class="line" id="L11015">            <span class="tok-kw">const</span> src_token = tree.firstToken(src_node);</span>
<span class="line" id="L11016">            <span class="tok-kw">const</span> result_index = coerced_result.toIndex() <span class="tok-kw">orelse</span></span>
<span class="line" id="L11017">                <span class="tok-kw">return</span> gz.addUnTok(.ref, coerced_result, src_token);</span>
<span class="line" id="L11018">            <span class="tok-kw">const</span> zir_tags = gz.astgen.instructions.items(.tag);</span>
<span class="line" id="L11019">            <span class="tok-kw">if</span> (zir_tags[<span class="tok-builtin">@intFromEnum</span>(result_index)].isParam() <span class="tok-kw">or</span> astgen.isInferred(coerced_result))</span>
<span class="line" id="L11020">                <span class="tok-kw">return</span> gz.addUnTok(.ref, coerced_result, src_token);</span>
<span class="line" id="L11021">            <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> astgen.ref_table.getOrPut(astgen.gpa, result_index);</span>
<span class="line" id="L11022">            <span class="tok-kw">if</span> (!gop.found_existing) {</span>
<span class="line" id="L11023">                gop.value_ptr.* = <span class="tok-kw">try</span> gz.makeUnTok(.ref, coerced_result, src_token);</span>
<span class="line" id="L11024">            }</span>
<span class="line" id="L11025">            <span class="tok-kw">return</span> gop.value_ptr.*.toRef();</span>
<span class="line" id="L11026">        },</span>
<span class="line" id="L11027">        .ty =&gt; |ty_inst| {</span>
<span class="line" id="L11028">            <span class="tok-comment">// Quickly eliminate some common, unnecessary type coercion.</span>
</span>
<span class="line" id="L11029">            <span class="tok-kw">const</span> as_ty = <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.type_type)) &lt;&lt; <span class="tok-number">32</span>;</span>
<span class="line" id="L11030">            <span class="tok-kw">const</span> as_bool = <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.bool_type)) &lt;&lt; <span class="tok-number">32</span>;</span>
<span class="line" id="L11031">            <span class="tok-kw">const</span> as_void = <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.void_type)) &lt;&lt; <span class="tok-number">32</span>;</span>
<span class="line" id="L11032">            <span class="tok-kw">const</span> as_comptime_int = <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.comptime_int_type)) &lt;&lt; <span class="tok-number">32</span>;</span>
<span class="line" id="L11033">            <span class="tok-kw">const</span> as_usize = <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.usize_type)) &lt;&lt; <span class="tok-number">32</span>;</span>
<span class="line" id="L11034">            <span class="tok-kw">const</span> as_u8 = <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.u8_type)) &lt;&lt; <span class="tok-number">32</span>;</span>
<span class="line" id="L11035">            <span class="tok-kw">switch</span> ((<span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-builtin">@intFromEnum</span>(ty_inst)) &lt;&lt; <span class="tok-number">32</span>) | <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-builtin">@intFromEnum</span>(result))) {</span>
<span class="line" id="L11036">                as_ty | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.u1_type),</span>
<span class="line" id="L11037">                as_ty | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.u8_type),</span>
<span class="line" id="L11038">                as_ty | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.i8_type),</span>
<span class="line" id="L11039">                as_ty | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.u16_type),</span>
<span class="line" id="L11040">                as_ty | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.u29_type),</span>
<span class="line" id="L11041">                as_ty | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.i16_type),</span>
<span class="line" id="L11042">                as_ty | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.u32_type),</span>
<span class="line" id="L11043">                as_ty | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.i32_type),</span>
<span class="line" id="L11044">                as_ty | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.u64_type),</span>
<span class="line" id="L11045">                as_ty | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.i64_type),</span>
<span class="line" id="L11046">                as_ty | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.u128_type),</span>
<span class="line" id="L11047">                as_ty | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.i128_type),</span>
<span class="line" id="L11048">                as_ty | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.usize_type),</span>
<span class="line" id="L11049">                as_ty | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.isize_type),</span>
<span class="line" id="L11050">                as_ty | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.c_char_type),</span>
<span class="line" id="L11051">                as_ty | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.c_short_type),</span>
<span class="line" id="L11052">                as_ty | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.c_ushort_type),</span>
<span class="line" id="L11053">                as_ty | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.c_int_type),</span>
<span class="line" id="L11054">                as_ty | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.c_uint_type),</span>
<span class="line" id="L11055">                as_ty | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.c_long_type),</span>
<span class="line" id="L11056">                as_ty | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.c_ulong_type),</span>
<span class="line" id="L11057">                as_ty | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.c_longlong_type),</span>
<span class="line" id="L11058">                as_ty | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.c_ulonglong_type),</span>
<span class="line" id="L11059">                as_ty | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.c_longdouble_type),</span>
<span class="line" id="L11060">                as_ty | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.f16_type),</span>
<span class="line" id="L11061">                as_ty | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.f32_type),</span>
<span class="line" id="L11062">                as_ty | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.f64_type),</span>
<span class="line" id="L11063">                as_ty | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.f80_type),</span>
<span class="line" id="L11064">                as_ty | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.f128_type),</span>
<span class="line" id="L11065">                as_ty | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.anyopaque_type),</span>
<span class="line" id="L11066">                as_ty | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.bool_type),</span>
<span class="line" id="L11067">                as_ty | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.void_type),</span>
<span class="line" id="L11068">                as_ty | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.type_type),</span>
<span class="line" id="L11069">                as_ty | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.anyerror_type),</span>
<span class="line" id="L11070">                as_ty | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.comptime_int_type),</span>
<span class="line" id="L11071">                as_ty | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.comptime_float_type),</span>
<span class="line" id="L11072">                as_ty | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.noreturn_type),</span>
<span class="line" id="L11073">                as_ty | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.anyframe_type),</span>
<span class="line" id="L11074">                as_ty | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.null_type),</span>
<span class="line" id="L11075">                as_ty | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.undefined_type),</span>
<span class="line" id="L11076">                as_ty | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.enum_literal_type),</span>
<span class="line" id="L11077">                as_ty | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.atomic_order_type),</span>
<span class="line" id="L11078">                as_ty | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.atomic_rmw_op_type),</span>
<span class="line" id="L11079">                as_ty | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.calling_convention_type),</span>
<span class="line" id="L11080">                as_ty | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.address_space_type),</span>
<span class="line" id="L11081">                as_ty | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.float_mode_type),</span>
<span class="line" id="L11082">                as_ty | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.reduce_op_type),</span>
<span class="line" id="L11083">                as_ty | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.call_modifier_type),</span>
<span class="line" id="L11084">                as_ty | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.prefetch_options_type),</span>
<span class="line" id="L11085">                as_ty | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.export_options_type),</span>
<span class="line" id="L11086">                as_ty | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.extern_options_type),</span>
<span class="line" id="L11087">                as_ty | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.type_info_type),</span>
<span class="line" id="L11088">                as_ty | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.manyptr_u8_type),</span>
<span class="line" id="L11089">                as_ty | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.manyptr_const_u8_type),</span>
<span class="line" id="L11090">                as_ty | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.manyptr_const_u8_sentinel_0_type),</span>
<span class="line" id="L11091">                as_ty | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.single_const_pointer_to_comptime_int_type),</span>
<span class="line" id="L11092">                as_ty | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.slice_const_u8_type),</span>
<span class="line" id="L11093">                as_ty | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.slice_const_u8_sentinel_0_type),</span>
<span class="line" id="L11094">                as_ty | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.anyerror_void_error_union_type),</span>
<span class="line" id="L11095">                as_ty | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.generic_poison_type),</span>
<span class="line" id="L11096">                as_ty | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.empty_struct_type),</span>
<span class="line" id="L11097">                as_comptime_int | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.zero),</span>
<span class="line" id="L11098">                as_comptime_int | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.one),</span>
<span class="line" id="L11099">                as_comptime_int | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.negative_one),</span>
<span class="line" id="L11100">                as_usize | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.zero_usize),</span>
<span class="line" id="L11101">                as_usize | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.one_usize),</span>
<span class="line" id="L11102">                as_u8 | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.zero_u8),</span>
<span class="line" id="L11103">                as_u8 | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.one_u8),</span>
<span class="line" id="L11104">                as_u8 | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.four_u8),</span>
<span class="line" id="L11105">                as_bool | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.bool_true),</span>
<span class="line" id="L11106">                as_bool | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.bool_false),</span>
<span class="line" id="L11107">                as_void | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.void_value),</span>
<span class="line" id="L11108">                =&gt; <span class="tok-kw">return</span> result, <span class="tok-comment">// type of result is already correct</span>
</span>
<span class="line" id="L11109"></span>
<span class="line" id="L11110">                as_usize | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.zero) =&gt; <span class="tok-kw">return</span> .zero_usize,</span>
<span class="line" id="L11111">                as_u8 | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.zero) =&gt; <span class="tok-kw">return</span> .zero_u8,</span>
<span class="line" id="L11112">                as_usize | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.one) =&gt; <span class="tok-kw">return</span> .one_usize,</span>
<span class="line" id="L11113">                as_u8 | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.one) =&gt; <span class="tok-kw">return</span> .one_u8,</span>
<span class="line" id="L11114">                as_comptime_int | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.zero_usize) =&gt; <span class="tok-kw">return</span> .zero,</span>
<span class="line" id="L11115">                as_u8 | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.zero_usize) =&gt; <span class="tok-kw">return</span> .zero_u8,</span>
<span class="line" id="L11116">                as_comptime_int | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.one_usize) =&gt; <span class="tok-kw">return</span> .one,</span>
<span class="line" id="L11117">                as_u8 | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.one_usize) =&gt; <span class="tok-kw">return</span> .one_u8,</span>
<span class="line" id="L11118">                as_comptime_int | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.zero_u8) =&gt; <span class="tok-kw">return</span> .zero,</span>
<span class="line" id="L11119">                as_usize | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.zero_u8) =&gt; <span class="tok-kw">return</span> .zero_usize,</span>
<span class="line" id="L11120">                as_comptime_int | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.one_u8) =&gt; <span class="tok-kw">return</span> .one,</span>
<span class="line" id="L11121">                as_usize | <span class="tok-builtin">@intFromEnum</span>(Zir.Inst.Ref.one_u8) =&gt; <span class="tok-kw">return</span> .one_usize,</span>
<span class="line" id="L11122"></span>
<span class="line" id="L11123">                <span class="tok-comment">// Need an explicit type coercion instruction.</span>
</span>
<span class="line" id="L11124">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> gz.addPlNode(ri.zirTag(), src_node, Zir.Inst.As{</span>
<span class="line" id="L11125">                    .dest_type = ty_inst,</span>
<span class="line" id="L11126">                    .operand = result,</span>
<span class="line" id="L11127">                }),</span>
<span class="line" id="L11128">            }</span>
<span class="line" id="L11129">        },</span>
<span class="line" id="L11130">        .ptr =&gt; |ptr_res| {</span>
<span class="line" id="L11131">            _ = <span class="tok-kw">try</span> gz.addPlNode(.store_node, ptr_res.src_node <span class="tok-kw">orelse</span> src_node, Zir.Inst.Bin{</span>
<span class="line" id="L11132">                .lhs = ptr_res.inst,</span>
<span class="line" id="L11133">                .rhs = result,</span>
<span class="line" id="L11134">            });</span>
<span class="line" id="L11135">            <span class="tok-kw">return</span> .void_value;</span>
<span class="line" id="L11136">        },</span>
<span class="line" id="L11137">        .inferred_ptr =&gt; |alloc| {</span>
<span class="line" id="L11138">            _ = <span class="tok-kw">try</span> gz.addPlNode(.store_to_inferred_ptr, src_node, Zir.Inst.Bin{</span>
<span class="line" id="L11139">                .lhs = alloc,</span>
<span class="line" id="L11140">                .rhs = result,</span>
<span class="line" id="L11141">            });</span>
<span class="line" id="L11142">            <span class="tok-kw">return</span> .void_value;</span>
<span class="line" id="L11143">        },</span>
<span class="line" id="L11144">        .destructure =&gt; |destructure| {</span>
<span class="line" id="L11145">            <span class="tok-kw">const</span> components = destructure.components;</span>
<span class="line" id="L11146">            _ = <span class="tok-kw">try</span> gz.addPlNode(.validate_destructure, src_node, Zir.Inst.ValidateDestructure{</span>
<span class="line" id="L11147">                .operand = result,</span>
<span class="line" id="L11148">                .destructure_node = gz.nodeIndexToRelative(destructure.src_node),</span>
<span class="line" id="L11149">                .expect_len = <span class="tok-builtin">@intCast</span>(components.len),</span>
<span class="line" id="L11150">            });</span>
<span class="line" id="L11151">            <span class="tok-kw">for</span> (components, <span class="tok-number">0</span>..) |component, i| {</span>
<span class="line" id="L11152">                <span class="tok-kw">if</span> (component == .discard) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L11153">                <span class="tok-kw">const</span> elem_val = <span class="tok-kw">try</span> gz.add(.{</span>
<span class="line" id="L11154">                    .tag = .elem_val_imm,</span>
<span class="line" id="L11155">                    .data = .{ .elem_val_imm = .{</span>
<span class="line" id="L11156">                        .operand = result,</span>
<span class="line" id="L11157">                        .idx = <span class="tok-builtin">@intCast</span>(i),</span>
<span class="line" id="L11158">                    } },</span>
<span class="line" id="L11159">                });</span>
<span class="line" id="L11160">                <span class="tok-kw">switch</span> (component) {</span>
<span class="line" id="L11161">                    .typed_ptr =&gt; |ptr_res| {</span>
<span class="line" id="L11162">                        _ = <span class="tok-kw">try</span> gz.addPlNode(.store_node, ptr_res.src_node <span class="tok-kw">orelse</span> src_node, Zir.Inst.Bin{</span>
<span class="line" id="L11163">                            .lhs = ptr_res.inst,</span>
<span class="line" id="L11164">                            .rhs = elem_val,</span>
<span class="line" id="L11165">                        });</span>
<span class="line" id="L11166">                    },</span>
<span class="line" id="L11167">                    .inferred_ptr =&gt; |ptr_inst| {</span>
<span class="line" id="L11168">                        _ = <span class="tok-kw">try</span> gz.addPlNode(.store_to_inferred_ptr, src_node, Zir.Inst.Bin{</span>
<span class="line" id="L11169">                            .lhs = ptr_inst,</span>
<span class="line" id="L11170">                            .rhs = elem_val,</span>
<span class="line" id="L11171">                        });</span>
<span class="line" id="L11172">                    },</span>
<span class="line" id="L11173">                    .discard =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L11174">                }</span>
<span class="line" id="L11175">            }</span>
<span class="line" id="L11176">            <span class="tok-kw">return</span> .void_value;</span>
<span class="line" id="L11177">        },</span>
<span class="line" id="L11178">    }</span>
<span class="line" id="L11179">}</span>
<span class="line" id="L11180"></span>
<span class="line" id="L11181"><span class="tok-comment">/// Given an identifier token, obtain the string for it.</span></span>
<span class="line" id="L11182"><span class="tok-comment">/// If the token uses @&quot;&quot; syntax, parses as a string, reports errors if applicable,</span></span>
<span class="line" id="L11183"><span class="tok-comment">/// and allocates the result within `astgen.arena`.</span></span>
<span class="line" id="L11184"><span class="tok-comment">/// Otherwise, returns a reference to the source code bytes directly.</span></span>
<span class="line" id="L11185"><span class="tok-comment">/// See also `appendIdentStr` and `parseStrLit`.</span></span>
<span class="line" id="L11186"><span class="tok-kw">fn</span> <span class="tok-fn">identifierTokenString</span>(astgen: *AstGen, token: Ast.TokenIndex) InnerError![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L11187">    <span class="tok-kw">const</span> tree = astgen.tree;</span>
<span class="line" id="L11188">    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);</span>
<span class="line" id="L11189">    assert(token_tags[token] == .identifier);</span>
<span class="line" id="L11190">    <span class="tok-kw">const</span> ident_name = tree.tokenSlice(token);</span>
<span class="line" id="L11191">    <span class="tok-kw">if</span> (!mem.startsWith(<span class="tok-type">u8</span>, ident_name, <span class="tok-str">&quot;@&quot;</span>)) {</span>
<span class="line" id="L11192">        <span class="tok-kw">return</span> ident_name;</span>
<span class="line" id="L11193">    }</span>
<span class="line" id="L11194">    <span class="tok-kw">var</span> buf: ArrayListUnmanaged(<span class="tok-type">u8</span>) = .{};</span>
<span class="line" id="L11195">    <span class="tok-kw">defer</span> buf.deinit(astgen.gpa);</span>
<span class="line" id="L11196">    <span class="tok-kw">try</span> astgen.parseStrLit(token, &amp;buf, ident_name, <span class="tok-number">1</span>);</span>
<span class="line" id="L11197">    <span class="tok-kw">if</span> (mem.indexOfScalar(<span class="tok-type">u8</span>, buf.items, <span class="tok-number">0</span>) != <span class="tok-null">null</span>) {</span>
<span class="line" id="L11198">        <span class="tok-kw">return</span> astgen.failTok(token, <span class="tok-str">&quot;identifier cannot contain null bytes&quot;</span>, .{});</span>
<span class="line" id="L11199">    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (buf.items.len == <span class="tok-number">0</span>) {</span>
<span class="line" id="L11200">        <span class="tok-kw">return</span> astgen.failTok(token, <span class="tok-str">&quot;identifier cannot be empty&quot;</span>, .{});</span>
<span class="line" id="L11201">    }</span>
<span class="line" id="L11202">    <span class="tok-kw">const</span> duped = <span class="tok-kw">try</span> astgen.arena.dupe(<span class="tok-type">u8</span>, buf.items);</span>
<span class="line" id="L11203">    <span class="tok-kw">return</span> duped;</span>
<span class="line" id="L11204">}</span>
<span class="line" id="L11205"></span>
<span class="line" id="L11206"><span class="tok-comment">/// Given an identifier token, obtain the string for it (possibly parsing as a string</span></span>
<span class="line" id="L11207"><span class="tok-comment">/// literal if it is @&quot;&quot; syntax), and append the string to `buf`.</span></span>
<span class="line" id="L11208"><span class="tok-comment">/// See also `identifierTokenString` and `parseStrLit`.</span></span>
<span class="line" id="L11209"><span class="tok-kw">fn</span> <span class="tok-fn">appendIdentStr</span>(</span>
<span class="line" id="L11210">    astgen: *AstGen,</span>
<span class="line" id="L11211">    token: Ast.TokenIndex,</span>
<span class="line" id="L11212">    buf: *ArrayListUnmanaged(<span class="tok-type">u8</span>),</span>
<span class="line" id="L11213">) InnerError!<span class="tok-type">void</span> {</span>
<span class="line" id="L11214">    <span class="tok-kw">const</span> tree = astgen.tree;</span>
<span class="line" id="L11215">    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);</span>
<span class="line" id="L11216">    assert(token_tags[token] == .identifier);</span>
<span class="line" id="L11217">    <span class="tok-kw">const</span> ident_name = tree.tokenSlice(token);</span>
<span class="line" id="L11218">    <span class="tok-kw">if</span> (!mem.startsWith(<span class="tok-type">u8</span>, ident_name, <span class="tok-str">&quot;@&quot;</span>)) {</span>
<span class="line" id="L11219">        <span class="tok-kw">return</span> buf.appendSlice(astgen.gpa, ident_name);</span>
<span class="line" id="L11220">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L11221">        <span class="tok-kw">const</span> start = buf.items.len;</span>
<span class="line" id="L11222">        <span class="tok-kw">try</span> astgen.parseStrLit(token, buf, ident_name, <span class="tok-number">1</span>);</span>
<span class="line" id="L11223">        <span class="tok-kw">const</span> slice = buf.items[start..];</span>
<span class="line" id="L11224">        <span class="tok-kw">if</span> (mem.indexOfScalar(<span class="tok-type">u8</span>, slice, <span class="tok-number">0</span>) != <span class="tok-null">null</span>) {</span>
<span class="line" id="L11225">            <span class="tok-kw">return</span> astgen.failTok(token, <span class="tok-str">&quot;identifier cannot contain null bytes&quot;</span>, .{});</span>
<span class="line" id="L11226">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (slice.len == <span class="tok-number">0</span>) {</span>
<span class="line" id="L11227">            <span class="tok-kw">return</span> astgen.failTok(token, <span class="tok-str">&quot;identifier cannot be empty&quot;</span>, .{});</span>
<span class="line" id="L11228">        }</span>
<span class="line" id="L11229">    }</span>
<span class="line" id="L11230">}</span>
<span class="line" id="L11231"></span>
<span class="line" id="L11232"><span class="tok-comment">/// Appends the result to `buf`.</span></span>
<span class="line" id="L11233"><span class="tok-kw">fn</span> <span class="tok-fn">parseStrLit</span>(</span>
<span class="line" id="L11234">    astgen: *AstGen,</span>
<span class="line" id="L11235">    token: Ast.TokenIndex,</span>
<span class="line" id="L11236">    buf: *ArrayListUnmanaged(<span class="tok-type">u8</span>),</span>
<span class="line" id="L11237">    bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L11238">    offset: <span class="tok-type">u32</span>,</span>
<span class="line" id="L11239">) InnerError!<span class="tok-type">void</span> {</span>
<span class="line" id="L11240">    <span class="tok-kw">const</span> raw_string = bytes[offset..];</span>
<span class="line" id="L11241">    <span class="tok-kw">var</span> buf_managed = buf.toManaged(astgen.gpa);</span>
<span class="line" id="L11242">    <span class="tok-kw">const</span> result = std.zig.string_literal.parseWrite(buf_managed.writer(), raw_string);</span>
<span class="line" id="L11243">    buf.* = buf_managed.moveToUnmanaged();</span>
<span class="line" id="L11244">    <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> result) {</span>
<span class="line" id="L11245">        .success =&gt; <span class="tok-kw">return</span>,</span>
<span class="line" id="L11246">        .failure =&gt; |err| <span class="tok-kw">return</span> astgen.failWithStrLitError(err, token, bytes, offset),</span>
<span class="line" id="L11247">    }</span>
<span class="line" id="L11248">}</span>
<span class="line" id="L11249"></span>
<span class="line" id="L11250"><span class="tok-kw">fn</span> <span class="tok-fn">failWithStrLitError</span>(astgen: *AstGen, err: std.zig.string_literal.Error, token: Ast.TokenIndex, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, offset: <span class="tok-type">u32</span>) InnerError {</span>
<span class="line" id="L11251">    <span class="tok-kw">const</span> raw_string = bytes[offset..];</span>
<span class="line" id="L11252">    <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L11253">        .invalid_escape_character =&gt; |bad_index| {</span>
<span class="line" id="L11254">            <span class="tok-kw">return</span> astgen.failOff(</span>
<span class="line" id="L11255">                token,</span>
<span class="line" id="L11256">                offset + <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@intCast</span>(bad_index)),</span>
<span class="line" id="L11257">                <span class="tok-str">&quot;invalid escape character: '{c}'&quot;</span>,</span>
<span class="line" id="L11258">                .{raw_string[bad_index]},</span>
<span class="line" id="L11259">            );</span>
<span class="line" id="L11260">        },</span>
<span class="line" id="L11261">        .expected_hex_digit =&gt; |bad_index| {</span>
<span class="line" id="L11262">            <span class="tok-kw">return</span> astgen.failOff(</span>
<span class="line" id="L11263">                token,</span>
<span class="line" id="L11264">                offset + <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@intCast</span>(bad_index)),</span>
<span class="line" id="L11265">                <span class="tok-str">&quot;expected hex digit, found '{c}'&quot;</span>,</span>
<span class="line" id="L11266">                .{raw_string[bad_index]},</span>
<span class="line" id="L11267">            );</span>
<span class="line" id="L11268">        },</span>
<span class="line" id="L11269">        .empty_unicode_escape_sequence =&gt; |bad_index| {</span>
<span class="line" id="L11270">            <span class="tok-kw">return</span> astgen.failOff(</span>
<span class="line" id="L11271">                token,</span>
<span class="line" id="L11272">                offset + <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@intCast</span>(bad_index)),</span>
<span class="line" id="L11273">                <span class="tok-str">&quot;empty unicode escape sequence&quot;</span>,</span>
<span class="line" id="L11274">                .{},</span>
<span class="line" id="L11275">            );</span>
<span class="line" id="L11276">        },</span>
<span class="line" id="L11277">        .expected_hex_digit_or_rbrace =&gt; |bad_index| {</span>
<span class="line" id="L11278">            <span class="tok-kw">return</span> astgen.failOff(</span>
<span class="line" id="L11279">                token,</span>
<span class="line" id="L11280">                offset + <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@intCast</span>(bad_index)),</span>
<span class="line" id="L11281">                <span class="tok-str">&quot;expected hex digit or '}}', found '{c}'&quot;</span>,</span>
<span class="line" id="L11282">                .{raw_string[bad_index]},</span>
<span class="line" id="L11283">            );</span>
<span class="line" id="L11284">        },</span>
<span class="line" id="L11285">        .invalid_unicode_codepoint =&gt; |bad_index| {</span>
<span class="line" id="L11286">            <span class="tok-kw">return</span> astgen.failOff(</span>
<span class="line" id="L11287">                token,</span>
<span class="line" id="L11288">                offset + <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@intCast</span>(bad_index)),</span>
<span class="line" id="L11289">                <span class="tok-str">&quot;unicode escape does not correspond to a valid codepoint&quot;</span>,</span>
<span class="line" id="L11290">                .{},</span>
<span class="line" id="L11291">            );</span>
<span class="line" id="L11292">        },</span>
<span class="line" id="L11293">        .expected_lbrace =&gt; |bad_index| {</span>
<span class="line" id="L11294">            <span class="tok-kw">return</span> astgen.failOff(</span>
<span class="line" id="L11295">                token,</span>
<span class="line" id="L11296">                offset + <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@intCast</span>(bad_index)),</span>
<span class="line" id="L11297">                <span class="tok-str">&quot;expected '{{', found '{c}&quot;</span>,</span>
<span class="line" id="L11298">                .{raw_string[bad_index]},</span>
<span class="line" id="L11299">            );</span>
<span class="line" id="L11300">        },</span>
<span class="line" id="L11301">        .expected_rbrace =&gt; |bad_index| {</span>
<span class="line" id="L11302">            <span class="tok-kw">return</span> astgen.failOff(</span>
<span class="line" id="L11303">                token,</span>
<span class="line" id="L11304">                offset + <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@intCast</span>(bad_index)),</span>
<span class="line" id="L11305">                <span class="tok-str">&quot;expected '}}', found '{c}&quot;</span>,</span>
<span class="line" id="L11306">                .{raw_string[bad_index]},</span>
<span class="line" id="L11307">            );</span>
<span class="line" id="L11308">        },</span>
<span class="line" id="L11309">        .expected_single_quote =&gt; |bad_index| {</span>
<span class="line" id="L11310">            <span class="tok-kw">return</span> astgen.failOff(</span>
<span class="line" id="L11311">                token,</span>
<span class="line" id="L11312">                offset + <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@intCast</span>(bad_index)),</span>
<span class="line" id="L11313">                <span class="tok-str">&quot;expected single quote ('), found '{c}&quot;</span>,</span>
<span class="line" id="L11314">                .{raw_string[bad_index]},</span>
<span class="line" id="L11315">            );</span>
<span class="line" id="L11316">        },</span>
<span class="line" id="L11317">        .invalid_character =&gt; |bad_index| {</span>
<span class="line" id="L11318">            <span class="tok-kw">return</span> astgen.failOff(</span>
<span class="line" id="L11319">                token,</span>
<span class="line" id="L11320">                offset + <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@intCast</span>(bad_index)),</span>
<span class="line" id="L11321">                <span class="tok-str">&quot;invalid byte in string or character literal: '{c}'&quot;</span>,</span>
<span class="line" id="L11322">                .{raw_string[bad_index]},</span>
<span class="line" id="L11323">            );</span>
<span class="line" id="L11324">        },</span>
<span class="line" id="L11325">    }</span>
<span class="line" id="L11326">}</span>
<span class="line" id="L11327"></span>
<span class="line" id="L11328"><span class="tok-kw">fn</span> <span class="tok-fn">failNode</span>(</span>
<span class="line" id="L11329">    astgen: *AstGen,</span>
<span class="line" id="L11330">    node: Ast.Node.Index,</span>
<span class="line" id="L11331">    <span class="tok-kw">comptime</span> format: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L11332">    args: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L11333">) InnerError {</span>
<span class="line" id="L11334">    <span class="tok-kw">return</span> astgen.failNodeNotes(node, format, args, &amp;[<span class="tok-number">0</span>]<span class="tok-type">u32</span>{});</span>
<span class="line" id="L11335">}</span>
<span class="line" id="L11336"></span>
<span class="line" id="L11337"><span class="tok-kw">fn</span> <span class="tok-fn">appendErrorNode</span>(</span>
<span class="line" id="L11338">    astgen: *AstGen,</span>
<span class="line" id="L11339">    node: Ast.Node.Index,</span>
<span class="line" id="L11340">    <span class="tok-kw">comptime</span> format: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L11341">    args: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L11342">) Allocator.Error!<span class="tok-type">void</span> {</span>
<span class="line" id="L11343">    <span class="tok-kw">try</span> astgen.appendErrorNodeNotes(node, format, args, &amp;[<span class="tok-number">0</span>]<span class="tok-type">u32</span>{});</span>
<span class="line" id="L11344">}</span>
<span class="line" id="L11345"></span>
<span class="line" id="L11346"><span class="tok-kw">fn</span> <span class="tok-fn">appendErrorNodeNotes</span>(</span>
<span class="line" id="L11347">    astgen: *AstGen,</span>
<span class="line" id="L11348">    node: Ast.Node.Index,</span>
<span class="line" id="L11349">    <span class="tok-kw">comptime</span> format: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L11350">    args: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L11351">    notes: []<span class="tok-kw">const</span> <span class="tok-type">u32</span>,</span>
<span class="line" id="L11352">) Allocator.Error!<span class="tok-type">void</span> {</span>
<span class="line" id="L11353">    <span class="tok-builtin">@setCold</span>(<span class="tok-null">true</span>);</span>
<span class="line" id="L11354">    <span class="tok-kw">const</span> string_bytes = &amp;astgen.string_bytes;</span>
<span class="line" id="L11355">    <span class="tok-kw">const</span> msg: Zir.NullTerminatedString = <span class="tok-builtin">@enumFromInt</span>(string_bytes.items.len);</span>
<span class="line" id="L11356">    <span class="tok-kw">try</span> string_bytes.writer(astgen.gpa).print(format ++ <span class="tok-str">&quot;\x00&quot;</span>, args);</span>
<span class="line" id="L11357">    <span class="tok-kw">const</span> notes_index: <span class="tok-type">u32</span> = <span class="tok-kw">if</span> (notes.len != <span class="tok-number">0</span>) blk: {</span>
<span class="line" id="L11358">        <span class="tok-kw">const</span> notes_start = astgen.extra.items.len;</span>
<span class="line" id="L11359">        <span class="tok-kw">try</span> astgen.extra.ensureTotalCapacity(astgen.gpa, notes_start + <span class="tok-number">1</span> + notes.len);</span>
<span class="line" id="L11360">        astgen.extra.appendAssumeCapacity(<span class="tok-builtin">@intCast</span>(notes.len));</span>
<span class="line" id="L11361">        astgen.extra.appendSliceAssumeCapacity(notes);</span>
<span class="line" id="L11362">        <span class="tok-kw">break</span> :blk <span class="tok-builtin">@intCast</span>(notes_start);</span>
<span class="line" id="L11363">    } <span class="tok-kw">else</span> <span class="tok-number">0</span>;</span>
<span class="line" id="L11364">    <span class="tok-kw">try</span> astgen.compile_errors.append(astgen.gpa, .{</span>
<span class="line" id="L11365">        .msg = msg,</span>
<span class="line" id="L11366">        .node = node,</span>
<span class="line" id="L11367">        .token = <span class="tok-number">0</span>,</span>
<span class="line" id="L11368">        .byte_offset = <span class="tok-number">0</span>,</span>
<span class="line" id="L11369">        .notes = notes_index,</span>
<span class="line" id="L11370">    });</span>
<span class="line" id="L11371">}</span>
<span class="line" id="L11372"></span>
<span class="line" id="L11373"><span class="tok-kw">fn</span> <span class="tok-fn">failNodeNotes</span>(</span>
<span class="line" id="L11374">    astgen: *AstGen,</span>
<span class="line" id="L11375">    node: Ast.Node.Index,</span>
<span class="line" id="L11376">    <span class="tok-kw">comptime</span> format: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L11377">    args: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L11378">    notes: []<span class="tok-kw">const</span> <span class="tok-type">u32</span>,</span>
<span class="line" id="L11379">) InnerError {</span>
<span class="line" id="L11380">    <span class="tok-kw">try</span> appendErrorNodeNotes(astgen, node, format, args, notes);</span>
<span class="line" id="L11381">    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AnalysisFail;</span>
<span class="line" id="L11382">}</span>
<span class="line" id="L11383"></span>
<span class="line" id="L11384"><span class="tok-kw">fn</span> <span class="tok-fn">failTok</span>(</span>
<span class="line" id="L11385">    astgen: *AstGen,</span>
<span class="line" id="L11386">    token: Ast.TokenIndex,</span>
<span class="line" id="L11387">    <span class="tok-kw">comptime</span> format: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L11388">    args: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L11389">) InnerError {</span>
<span class="line" id="L11390">    <span class="tok-kw">return</span> astgen.failTokNotes(token, format, args, &amp;[<span class="tok-number">0</span>]<span class="tok-type">u32</span>{});</span>
<span class="line" id="L11391">}</span>
<span class="line" id="L11392"></span>
<span class="line" id="L11393"><span class="tok-kw">fn</span> <span class="tok-fn">appendErrorTok</span>(</span>
<span class="line" id="L11394">    astgen: *AstGen,</span>
<span class="line" id="L11395">    token: Ast.TokenIndex,</span>
<span class="line" id="L11396">    <span class="tok-kw">comptime</span> format: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L11397">    args: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L11398">) !<span class="tok-type">void</span> {</span>
<span class="line" id="L11399">    <span class="tok-kw">try</span> astgen.appendErrorTokNotesOff(token, <span class="tok-number">0</span>, format, args, &amp;[<span class="tok-number">0</span>]<span class="tok-type">u32</span>{});</span>
<span class="line" id="L11400">}</span>
<span class="line" id="L11401"></span>
<span class="line" id="L11402"><span class="tok-kw">fn</span> <span class="tok-fn">failTokNotes</span>(</span>
<span class="line" id="L11403">    astgen: *AstGen,</span>
<span class="line" id="L11404">    token: Ast.TokenIndex,</span>
<span class="line" id="L11405">    <span class="tok-kw">comptime</span> format: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L11406">    args: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L11407">    notes: []<span class="tok-kw">const</span> <span class="tok-type">u32</span>,</span>
<span class="line" id="L11408">) InnerError {</span>
<span class="line" id="L11409">    <span class="tok-kw">try</span> appendErrorTokNotesOff(astgen, token, <span class="tok-number">0</span>, format, args, notes);</span>
<span class="line" id="L11410">    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AnalysisFail;</span>
<span class="line" id="L11411">}</span>
<span class="line" id="L11412"></span>
<span class="line" id="L11413"><span class="tok-kw">fn</span> <span class="tok-fn">appendErrorTokNotes</span>(</span>
<span class="line" id="L11414">    astgen: *AstGen,</span>
<span class="line" id="L11415">    token: Ast.TokenIndex,</span>
<span class="line" id="L11416">    <span class="tok-kw">comptime</span> format: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L11417">    args: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L11418">    notes: []<span class="tok-kw">const</span> <span class="tok-type">u32</span>,</span>
<span class="line" id="L11419">) !<span class="tok-type">void</span> {</span>
<span class="line" id="L11420">    <span class="tok-kw">return</span> appendErrorTokNotesOff(astgen, token, <span class="tok-number">0</span>, format, args, notes);</span>
<span class="line" id="L11421">}</span>
<span class="line" id="L11422"></span>
<span class="line" id="L11423"><span class="tok-comment">/// Same as `fail`, except given a token plus an offset from its starting byte</span></span>
<span class="line" id="L11424"><span class="tok-comment">/// offset.</span></span>
<span class="line" id="L11425"><span class="tok-kw">fn</span> <span class="tok-fn">failOff</span>(</span>
<span class="line" id="L11426">    astgen: *AstGen,</span>
<span class="line" id="L11427">    token: Ast.TokenIndex,</span>
<span class="line" id="L11428">    byte_offset: <span class="tok-type">u32</span>,</span>
<span class="line" id="L11429">    <span class="tok-kw">comptime</span> format: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L11430">    args: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L11431">) InnerError {</span>
<span class="line" id="L11432">    <span class="tok-kw">try</span> appendErrorTokNotesOff(astgen, token, byte_offset, format, args, &amp;.{});</span>
<span class="line" id="L11433">    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AnalysisFail;</span>
<span class="line" id="L11434">}</span>
<span class="line" id="L11435"></span>
<span class="line" id="L11436"><span class="tok-kw">fn</span> <span class="tok-fn">appendErrorTokNotesOff</span>(</span>
<span class="line" id="L11437">    astgen: *AstGen,</span>
<span class="line" id="L11438">    token: Ast.TokenIndex,</span>
<span class="line" id="L11439">    byte_offset: <span class="tok-type">u32</span>,</span>
<span class="line" id="L11440">    <span class="tok-kw">comptime</span> format: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L11441">    args: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L11442">    notes: []<span class="tok-kw">const</span> <span class="tok-type">u32</span>,</span>
<span class="line" id="L11443">) !<span class="tok-type">void</span> {</span>
<span class="line" id="L11444">    <span class="tok-builtin">@setCold</span>(<span class="tok-null">true</span>);</span>
<span class="line" id="L11445">    <span class="tok-kw">const</span> gpa = astgen.gpa;</span>
<span class="line" id="L11446">    <span class="tok-kw">const</span> string_bytes = &amp;astgen.string_bytes;</span>
<span class="line" id="L11447">    <span class="tok-kw">const</span> msg: Zir.NullTerminatedString = <span class="tok-builtin">@enumFromInt</span>(string_bytes.items.len);</span>
<span class="line" id="L11448">    <span class="tok-kw">try</span> string_bytes.writer(gpa).print(format ++ <span class="tok-str">&quot;\x00&quot;</span>, args);</span>
<span class="line" id="L11449">    <span class="tok-kw">const</span> notes_index: <span class="tok-type">u32</span> = <span class="tok-kw">if</span> (notes.len != <span class="tok-number">0</span>) blk: {</span>
<span class="line" id="L11450">        <span class="tok-kw">const</span> notes_start = astgen.extra.items.len;</span>
<span class="line" id="L11451">        <span class="tok-kw">try</span> astgen.extra.ensureTotalCapacity(gpa, notes_start + <span class="tok-number">1</span> + notes.len);</span>
<span class="line" id="L11452">        astgen.extra.appendAssumeCapacity(<span class="tok-builtin">@intCast</span>(notes.len));</span>
<span class="line" id="L11453">        astgen.extra.appendSliceAssumeCapacity(notes);</span>
<span class="line" id="L11454">        <span class="tok-kw">break</span> :blk <span class="tok-builtin">@intCast</span>(notes_start);</span>
<span class="line" id="L11455">    } <span class="tok-kw">else</span> <span class="tok-number">0</span>;</span>
<span class="line" id="L11456">    <span class="tok-kw">try</span> astgen.compile_errors.append(gpa, .{</span>
<span class="line" id="L11457">        .msg = msg,</span>
<span class="line" id="L11458">        .node = <span class="tok-number">0</span>,</span>
<span class="line" id="L11459">        .token = token,</span>
<span class="line" id="L11460">        .byte_offset = byte_offset,</span>
<span class="line" id="L11461">        .notes = notes_index,</span>
<span class="line" id="L11462">    });</span>
<span class="line" id="L11463">}</span>
<span class="line" id="L11464"></span>
<span class="line" id="L11465"><span class="tok-kw">fn</span> <span class="tok-fn">errNoteTok</span>(</span>
<span class="line" id="L11466">    astgen: *AstGen,</span>
<span class="line" id="L11467">    token: Ast.TokenIndex,</span>
<span class="line" id="L11468">    <span class="tok-kw">comptime</span> format: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L11469">    args: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L11470">) Allocator.Error!<span class="tok-type">u32</span> {</span>
<span class="line" id="L11471">    <span class="tok-kw">return</span> errNoteTokOff(astgen, token, <span class="tok-number">0</span>, format, args);</span>
<span class="line" id="L11472">}</span>
<span class="line" id="L11473"></span>
<span class="line" id="L11474"><span class="tok-kw">fn</span> <span class="tok-fn">errNoteTokOff</span>(</span>
<span class="line" id="L11475">    astgen: *AstGen,</span>
<span class="line" id="L11476">    token: Ast.TokenIndex,</span>
<span class="line" id="L11477">    byte_offset: <span class="tok-type">u32</span>,</span>
<span class="line" id="L11478">    <span class="tok-kw">comptime</span> format: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L11479">    args: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L11480">) Allocator.Error!<span class="tok-type">u32</span> {</span>
<span class="line" id="L11481">    <span class="tok-builtin">@setCold</span>(<span class="tok-null">true</span>);</span>
<span class="line" id="L11482">    <span class="tok-kw">const</span> string_bytes = &amp;astgen.string_bytes;</span>
<span class="line" id="L11483">    <span class="tok-kw">const</span> msg: Zir.NullTerminatedString = <span class="tok-builtin">@enumFromInt</span>(string_bytes.items.len);</span>
<span class="line" id="L11484">    <span class="tok-kw">try</span> string_bytes.writer(astgen.gpa).print(format ++ <span class="tok-str">&quot;\x00&quot;</span>, args);</span>
<span class="line" id="L11485">    <span class="tok-kw">return</span> astgen.addExtra(Zir.Inst.CompileErrors.Item{</span>
<span class="line" id="L11486">        .msg = msg,</span>
<span class="line" id="L11487">        .node = <span class="tok-number">0</span>,</span>
<span class="line" id="L11488">        .token = token,</span>
<span class="line" id="L11489">        .byte_offset = byte_offset,</span>
<span class="line" id="L11490">        .notes = <span class="tok-number">0</span>,</span>
<span class="line" id="L11491">    });</span>
<span class="line" id="L11492">}</span>
<span class="line" id="L11493"></span>
<span class="line" id="L11494"><span class="tok-kw">fn</span> <span class="tok-fn">errNoteNode</span>(</span>
<span class="line" id="L11495">    astgen: *AstGen,</span>
<span class="line" id="L11496">    node: Ast.Node.Index,</span>
<span class="line" id="L11497">    <span class="tok-kw">comptime</span> format: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L11498">    args: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L11499">) Allocator.Error!<span class="tok-type">u32</span> {</span>
<span class="line" id="L11500">    <span class="tok-builtin">@setCold</span>(<span class="tok-null">true</span>);</span>
<span class="line" id="L11501">    <span class="tok-kw">const</span> string_bytes = &amp;astgen.string_bytes;</span>
<span class="line" id="L11502">    <span class="tok-kw">const</span> msg: Zir.NullTerminatedString = <span class="tok-builtin">@enumFromInt</span>(string_bytes.items.len);</span>
<span class="line" id="L11503">    <span class="tok-kw">try</span> string_bytes.writer(astgen.gpa).print(format ++ <span class="tok-str">&quot;\x00&quot;</span>, args);</span>
<span class="line" id="L11504">    <span class="tok-kw">return</span> astgen.addExtra(Zir.Inst.CompileErrors.Item{</span>
<span class="line" id="L11505">        .msg = msg,</span>
<span class="line" id="L11506">        .node = node,</span>
<span class="line" id="L11507">        .token = <span class="tok-number">0</span>,</span>
<span class="line" id="L11508">        .byte_offset = <span class="tok-number">0</span>,</span>
<span class="line" id="L11509">        .notes = <span class="tok-number">0</span>,</span>
<span class="line" id="L11510">    });</span>
<span class="line" id="L11511">}</span>
<span class="line" id="L11512"></span>
<span class="line" id="L11513"><span class="tok-kw">fn</span> <span class="tok-fn">identAsString</span>(astgen: *AstGen, ident_token: Ast.TokenIndex) !Zir.NullTerminatedString {</span>
<span class="line" id="L11514">    <span class="tok-kw">const</span> gpa = astgen.gpa;</span>
<span class="line" id="L11515">    <span class="tok-kw">const</span> string_bytes = &amp;astgen.string_bytes;</span>
<span class="line" id="L11516">    <span class="tok-kw">const</span> str_index: <span class="tok-type">u32</span> = <span class="tok-builtin">@intCast</span>(string_bytes.items.len);</span>
<span class="line" id="L11517">    <span class="tok-kw">try</span> astgen.appendIdentStr(ident_token, string_bytes);</span>
<span class="line" id="L11518">    <span class="tok-kw">const</span> key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = string_bytes.items[str_index..];</span>
<span class="line" id="L11519">    <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> astgen.string_table.getOrPutContextAdapted(gpa, key, StringIndexAdapter{</span>
<span class="line" id="L11520">        .bytes = string_bytes,</span>
<span class="line" id="L11521">    }, StringIndexContext{</span>
<span class="line" id="L11522">        .bytes = string_bytes,</span>
<span class="line" id="L11523">    });</span>
<span class="line" id="L11524">    <span class="tok-kw">if</span> (gop.found_existing) {</span>
<span class="line" id="L11525">        string_bytes.shrinkRetainingCapacity(str_index);</span>
<span class="line" id="L11526">        <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(gop.key_ptr.*);</span>
<span class="line" id="L11527">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L11528">        gop.key_ptr.* = str_index;</span>
<span class="line" id="L11529">        <span class="tok-kw">try</span> string_bytes.append(gpa, <span class="tok-number">0</span>);</span>
<span class="line" id="L11530">        <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(str_index);</span>
<span class="line" id="L11531">    }</span>
<span class="line" id="L11532">}</span>
<span class="line" id="L11533"></span>
<span class="line" id="L11534"><span class="tok-comment">/// Adds a doc comment block to `string_bytes` by walking backwards from `end_token`.</span></span>
<span class="line" id="L11535"><span class="tok-comment">/// `end_token` must point at the first token after the last doc coment line.</span></span>
<span class="line" id="L11536"><span class="tok-comment">/// Returns 0 if no doc comment is present.</span></span>
<span class="line" id="L11537"><span class="tok-kw">fn</span> <span class="tok-fn">docCommentAsString</span>(astgen: *AstGen, end_token: Ast.TokenIndex) !Zir.NullTerminatedString {</span>
<span class="line" id="L11538">    <span class="tok-kw">if</span> (end_token == <span class="tok-number">0</span>) <span class="tok-kw">return</span> .empty;</span>
<span class="line" id="L11539"></span>
<span class="line" id="L11540">    <span class="tok-kw">const</span> token_tags = astgen.tree.tokens.items(.tag);</span>
<span class="line" id="L11541"></span>
<span class="line" id="L11542">    <span class="tok-kw">var</span> tok = end_token - <span class="tok-number">1</span>;</span>
<span class="line" id="L11543">    <span class="tok-kw">while</span> (token_tags[tok] == .doc_comment) {</span>
<span class="line" id="L11544">        <span class="tok-kw">if</span> (tok == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;</span>
<span class="line" id="L11545">        tok -= <span class="tok-number">1</span>;</span>
<span class="line" id="L11546">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L11547">        tok += <span class="tok-number">1</span>;</span>
<span class="line" id="L11548">    }</span>
<span class="line" id="L11549"></span>
<span class="line" id="L11550">    <span class="tok-kw">return</span> docCommentAsStringFromFirst(astgen, end_token, tok);</span>
<span class="line" id="L11551">}</span>
<span class="line" id="L11552"></span>
<span class="line" id="L11553"><span class="tok-comment">/// end_token must be &gt; the index of the last doc comment.</span></span>
<span class="line" id="L11554"><span class="tok-kw">fn</span> <span class="tok-fn">docCommentAsStringFromFirst</span>(</span>
<span class="line" id="L11555">    astgen: *AstGen,</span>
<span class="line" id="L11556">    end_token: Ast.TokenIndex,</span>
<span class="line" id="L11557">    start_token: Ast.TokenIndex,</span>
<span class="line" id="L11558">) !Zir.NullTerminatedString {</span>
<span class="line" id="L11559">    <span class="tok-kw">if</span> (start_token == end_token) <span class="tok-kw">return</span> .empty;</span>
<span class="line" id="L11560"></span>
<span class="line" id="L11561">    <span class="tok-kw">const</span> gpa = astgen.gpa;</span>
<span class="line" id="L11562">    <span class="tok-kw">const</span> string_bytes = &amp;astgen.string_bytes;</span>
<span class="line" id="L11563">    <span class="tok-kw">const</span> str_index: <span class="tok-type">u32</span> = <span class="tok-builtin">@intCast</span>(string_bytes.items.len);</span>
<span class="line" id="L11564">    <span class="tok-kw">const</span> token_starts = astgen.tree.tokens.items(.start);</span>
<span class="line" id="L11565">    <span class="tok-kw">const</span> token_tags = astgen.tree.tokens.items(.tag);</span>
<span class="line" id="L11566"></span>
<span class="line" id="L11567">    <span class="tok-kw">const</span> total_bytes = token_starts[end_token] - token_starts[start_token];</span>
<span class="line" id="L11568">    <span class="tok-kw">try</span> string_bytes.ensureUnusedCapacity(gpa, total_bytes);</span>
<span class="line" id="L11569"></span>
<span class="line" id="L11570">    <span class="tok-kw">var</span> current_token = start_token;</span>
<span class="line" id="L11571">    <span class="tok-kw">while</span> (current_token &lt; end_token) : (current_token += <span class="tok-number">1</span>) {</span>
<span class="line" id="L11572">        <span class="tok-kw">switch</span> (token_tags[current_token]) {</span>
<span class="line" id="L11573">            .doc_comment =&gt; {</span>
<span class="line" id="L11574">                <span class="tok-kw">const</span> tok_bytes = astgen.tree.tokenSlice(current_token)[<span class="tok-number">3</span>..];</span>
<span class="line" id="L11575">                string_bytes.appendSliceAssumeCapacity(tok_bytes);</span>
<span class="line" id="L11576">                <span class="tok-kw">if</span> (current_token != end_token - <span class="tok-number">1</span>) {</span>
<span class="line" id="L11577">                    string_bytes.appendAssumeCapacity(<span class="tok-str">'\n'</span>);</span>
<span class="line" id="L11578">                }</span>
<span class="line" id="L11579">            },</span>
<span class="line" id="L11580">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">break</span>,</span>
<span class="line" id="L11581">        }</span>
<span class="line" id="L11582">    }</span>
<span class="line" id="L11583"></span>
<span class="line" id="L11584">    <span class="tok-kw">const</span> key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = string_bytes.items[str_index..];</span>
<span class="line" id="L11585">    <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> astgen.string_table.getOrPutContextAdapted(gpa, key, StringIndexAdapter{</span>
<span class="line" id="L11586">        .bytes = string_bytes,</span>
<span class="line" id="L11587">    }, StringIndexContext{</span>
<span class="line" id="L11588">        .bytes = string_bytes,</span>
<span class="line" id="L11589">    });</span>
<span class="line" id="L11590"></span>
<span class="line" id="L11591">    <span class="tok-kw">if</span> (gop.found_existing) {</span>
<span class="line" id="L11592">        string_bytes.shrinkRetainingCapacity(str_index);</span>
<span class="line" id="L11593">        <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(gop.key_ptr.*);</span>
<span class="line" id="L11594">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L11595">        gop.key_ptr.* = str_index;</span>
<span class="line" id="L11596">        <span class="tok-kw">try</span> string_bytes.append(gpa, <span class="tok-number">0</span>);</span>
<span class="line" id="L11597">        <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(str_index);</span>
<span class="line" id="L11598">    }</span>
<span class="line" id="L11599">}</span>
<span class="line" id="L11600"></span>
<span class="line" id="L11601"><span class="tok-kw">const</span> IndexSlice = <span class="tok-kw">struct</span> { index: Zir.NullTerminatedString, len: <span class="tok-type">u32</span> };</span>
<span class="line" id="L11602"></span>
<span class="line" id="L11603"><span class="tok-kw">fn</span> <span class="tok-fn">strLitAsString</span>(astgen: *AstGen, str_lit_token: Ast.TokenIndex) !IndexSlice {</span>
<span class="line" id="L11604">    <span class="tok-kw">const</span> gpa = astgen.gpa;</span>
<span class="line" id="L11605">    <span class="tok-kw">const</span> string_bytes = &amp;astgen.string_bytes;</span>
<span class="line" id="L11606">    <span class="tok-kw">const</span> str_index: <span class="tok-type">u32</span> = <span class="tok-builtin">@intCast</span>(string_bytes.items.len);</span>
<span class="line" id="L11607">    <span class="tok-kw">const</span> token_bytes = astgen.tree.tokenSlice(str_lit_token);</span>
<span class="line" id="L11608">    <span class="tok-kw">try</span> astgen.parseStrLit(str_lit_token, string_bytes, token_bytes, <span class="tok-number">0</span>);</span>
<span class="line" id="L11609">    <span class="tok-kw">const</span> key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = string_bytes.items[str_index..];</span>
<span class="line" id="L11610">    <span class="tok-kw">if</span> (std.mem.indexOfScalar(<span class="tok-type">u8</span>, key, <span class="tok-number">0</span>)) |_| <span class="tok-kw">return</span> .{</span>
<span class="line" id="L11611">        .index = <span class="tok-builtin">@enumFromInt</span>(str_index),</span>
<span class="line" id="L11612">        .len = <span class="tok-builtin">@intCast</span>(key.len),</span>
<span class="line" id="L11613">    };</span>
<span class="line" id="L11614">    <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> astgen.string_table.getOrPutContextAdapted(gpa, key, StringIndexAdapter{</span>
<span class="line" id="L11615">        .bytes = string_bytes,</span>
<span class="line" id="L11616">    }, StringIndexContext{</span>
<span class="line" id="L11617">        .bytes = string_bytes,</span>
<span class="line" id="L11618">    });</span>
<span class="line" id="L11619">    <span class="tok-kw">if</span> (gop.found_existing) {</span>
<span class="line" id="L11620">        string_bytes.shrinkRetainingCapacity(str_index);</span>
<span class="line" id="L11621">        <span class="tok-kw">return</span> .{</span>
<span class="line" id="L11622">            .index = <span class="tok-builtin">@enumFromInt</span>(gop.key_ptr.*),</span>
<span class="line" id="L11623">            .len = <span class="tok-builtin">@intCast</span>(key.len),</span>
<span class="line" id="L11624">        };</span>
<span class="line" id="L11625">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L11626">        gop.key_ptr.* = str_index;</span>
<span class="line" id="L11627">        <span class="tok-comment">// Still need a null byte because we are using the same table</span>
</span>
<span class="line" id="L11628">        <span class="tok-comment">// to lookup null terminated strings, so if we get a match, it has to</span>
</span>
<span class="line" id="L11629">        <span class="tok-comment">// be null terminated for that to work.</span>
</span>
<span class="line" id="L11630">        <span class="tok-kw">try</span> string_bytes.append(gpa, <span class="tok-number">0</span>);</span>
<span class="line" id="L11631">        <span class="tok-kw">return</span> .{</span>
<span class="line" id="L11632">            .index = <span class="tok-builtin">@enumFromInt</span>(str_index),</span>
<span class="line" id="L11633">            .len = <span class="tok-builtin">@intCast</span>(key.len),</span>
<span class="line" id="L11634">        };</span>
<span class="line" id="L11635">    }</span>
<span class="line" id="L11636">}</span>
<span class="line" id="L11637"></span>
<span class="line" id="L11638"><span class="tok-kw">fn</span> <span class="tok-fn">strLitNodeAsString</span>(astgen: *AstGen, node: Ast.Node.Index) !IndexSlice {</span>
<span class="line" id="L11639">    <span class="tok-kw">const</span> tree = astgen.tree;</span>
<span class="line" id="L11640">    <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);</span>
<span class="line" id="L11641"></span>
<span class="line" id="L11642">    <span class="tok-kw">const</span> start = node_datas[node].lhs;</span>
<span class="line" id="L11643">    <span class="tok-kw">const</span> end = node_datas[node].rhs;</span>
<span class="line" id="L11644"></span>
<span class="line" id="L11645">    <span class="tok-kw">const</span> gpa = astgen.gpa;</span>
<span class="line" id="L11646">    <span class="tok-kw">const</span> string_bytes = &amp;astgen.string_bytes;</span>
<span class="line" id="L11647">    <span class="tok-kw">const</span> str_index = string_bytes.items.len;</span>
<span class="line" id="L11648"></span>
<span class="line" id="L11649">    <span class="tok-comment">// First line: do not append a newline.</span>
</span>
<span class="line" id="L11650">    <span class="tok-kw">var</span> tok_i = start;</span>
<span class="line" id="L11651">    {</span>
<span class="line" id="L11652">        <span class="tok-kw">const</span> slice = tree.tokenSlice(tok_i);</span>
<span class="line" id="L11653">        <span class="tok-kw">const</span> carriage_return_ending: <span class="tok-type">usize</span> = <span class="tok-kw">if</span> (slice[slice.len - <span class="tok-number">2</span>] == <span class="tok-str">'\r'</span>) <span class="tok-number">2</span> <span class="tok-kw">else</span> <span class="tok-number">1</span>;</span>
<span class="line" id="L11654">        <span class="tok-kw">const</span> line_bytes = slice[<span class="tok-number">2</span> .. slice.len - carriage_return_ending];</span>
<span class="line" id="L11655">        <span class="tok-kw">try</span> string_bytes.appendSlice(gpa, line_bytes);</span>
<span class="line" id="L11656">        tok_i += <span class="tok-number">1</span>;</span>
<span class="line" id="L11657">    }</span>
<span class="line" id="L11658">    <span class="tok-comment">// Following lines: each line prepends a newline.</span>
</span>
<span class="line" id="L11659">    <span class="tok-kw">while</span> (tok_i &lt;= end) : (tok_i += <span class="tok-number">1</span>) {</span>
<span class="line" id="L11660">        <span class="tok-kw">const</span> slice = tree.tokenSlice(tok_i);</span>
<span class="line" id="L11661">        <span class="tok-kw">const</span> carriage_return_ending: <span class="tok-type">usize</span> = <span class="tok-kw">if</span> (slice[slice.len - <span class="tok-number">2</span>] == <span class="tok-str">'\r'</span>) <span class="tok-number">2</span> <span class="tok-kw">else</span> <span class="tok-number">1</span>;</span>
<span class="line" id="L11662">        <span class="tok-kw">const</span> line_bytes = slice[<span class="tok-number">2</span> .. slice.len - carriage_return_ending];</span>
<span class="line" id="L11663">        <span class="tok-kw">try</span> string_bytes.ensureUnusedCapacity(gpa, line_bytes.len + <span class="tok-number">1</span>);</span>
<span class="line" id="L11664">        string_bytes.appendAssumeCapacity(<span class="tok-str">'\n'</span>);</span>
<span class="line" id="L11665">        string_bytes.appendSliceAssumeCapacity(line_bytes);</span>
<span class="line" id="L11666">    }</span>
<span class="line" id="L11667">    <span class="tok-kw">const</span> len = string_bytes.items.len - str_index;</span>
<span class="line" id="L11668">    <span class="tok-kw">try</span> string_bytes.append(gpa, <span class="tok-number">0</span>);</span>
<span class="line" id="L11669">    <span class="tok-kw">return</span> IndexSlice{</span>
<span class="line" id="L11670">        .index = <span class="tok-builtin">@enumFromInt</span>(str_index),</span>
<span class="line" id="L11671">        .len = <span class="tok-builtin">@intCast</span>(len),</span>
<span class="line" id="L11672">    };</span>
<span class="line" id="L11673">}</span>
<span class="line" id="L11674"></span>
<span class="line" id="L11675"><span class="tok-kw">fn</span> <span class="tok-fn">testNameString</span>(astgen: *AstGen, str_lit_token: Ast.TokenIndex) !Zir.NullTerminatedString {</span>
<span class="line" id="L11676">    <span class="tok-kw">const</span> gpa = astgen.gpa;</span>
<span class="line" id="L11677">    <span class="tok-kw">const</span> string_bytes = &amp;astgen.string_bytes;</span>
<span class="line" id="L11678">    <span class="tok-kw">const</span> str_index: <span class="tok-type">u32</span> = <span class="tok-builtin">@intCast</span>(string_bytes.items.len);</span>
<span class="line" id="L11679">    <span class="tok-kw">const</span> token_bytes = astgen.tree.tokenSlice(str_lit_token);</span>
<span class="line" id="L11680">    <span class="tok-kw">try</span> string_bytes.append(gpa, <span class="tok-number">0</span>); <span class="tok-comment">// Indicates this is a test.</span>
</span>
<span class="line" id="L11681">    <span class="tok-kw">try</span> astgen.parseStrLit(str_lit_token, string_bytes, token_bytes, <span class="tok-number">0</span>);</span>
<span class="line" id="L11682">    <span class="tok-kw">const</span> slice = string_bytes.items[str_index + <span class="tok-number">1</span> ..];</span>
<span class="line" id="L11683">    <span class="tok-kw">if</span> (mem.indexOfScalar(<span class="tok-type">u8</span>, slice, <span class="tok-number">0</span>) != <span class="tok-null">null</span>) {</span>
<span class="line" id="L11684">        <span class="tok-kw">return</span> astgen.failTok(str_lit_token, <span class="tok-str">&quot;test name cannot contain null bytes&quot;</span>, .{});</span>
<span class="line" id="L11685">    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (slice.len == <span class="tok-number">0</span>) {</span>
<span class="line" id="L11686">        <span class="tok-kw">return</span> astgen.failTok(str_lit_token, <span class="tok-str">&quot;empty test name must be omitted&quot;</span>, .{});</span>
<span class="line" id="L11687">    }</span>
<span class="line" id="L11688">    <span class="tok-kw">try</span> string_bytes.append(gpa, <span class="tok-number">0</span>);</span>
<span class="line" id="L11689">    <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(str_index);</span>
<span class="line" id="L11690">}</span>
<span class="line" id="L11691"></span>
<span class="line" id="L11692"><span class="tok-kw">const</span> Scope = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L11693">    tag: Tag,</span>
<span class="line" id="L11694"></span>
<span class="line" id="L11695">    <span class="tok-kw">fn</span> <span class="tok-fn">cast</span>(base: *Scope, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) ?*T {</span>
<span class="line" id="L11696">        <span class="tok-kw">if</span> (T == Defer) {</span>
<span class="line" id="L11697">            <span class="tok-kw">switch</span> (base.tag) {</span>
<span class="line" id="L11698">                .defer_normal, .defer_error =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@fieldParentPtr</span>(T, <span class="tok-str">&quot;base&quot;</span>, base),</span>
<span class="line" id="L11699">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-null">null</span>,</span>
<span class="line" id="L11700">            }</span>
<span class="line" id="L11701">        }</span>
<span class="line" id="L11702">        <span class="tok-kw">if</span> (T == Namespace) {</span>
<span class="line" id="L11703">            <span class="tok-kw">switch</span> (base.tag) {</span>
<span class="line" id="L11704">                .namespace =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@fieldParentPtr</span>(T, <span class="tok-str">&quot;base&quot;</span>, base),</span>
<span class="line" id="L11705">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-null">null</span>,</span>
<span class="line" id="L11706">            }</span>
<span class="line" id="L11707">        }</span>
<span class="line" id="L11708">        <span class="tok-kw">if</span> (base.tag != T.base_tag)</span>
<span class="line" id="L11709">            <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L11710"></span>
<span class="line" id="L11711">        <span class="tok-kw">return</span> <span class="tok-builtin">@fieldParentPtr</span>(T, <span class="tok-str">&quot;base&quot;</span>, base);</span>
<span class="line" id="L11712">    }</span>
<span class="line" id="L11713"></span>
<span class="line" id="L11714">    <span class="tok-kw">fn</span> <span class="tok-fn">parent</span>(base: *Scope) ?*Scope {</span>
<span class="line" id="L11715">        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (base.tag) {</span>
<span class="line" id="L11716">            .gen_zir =&gt; base.cast(GenZir).?.parent,</span>
<span class="line" id="L11717">            .local_val =&gt; base.cast(LocalVal).?.parent,</span>
<span class="line" id="L11718">            .local_ptr =&gt; base.cast(LocalPtr).?.parent,</span>
<span class="line" id="L11719">            .defer_normal, .defer_error =&gt; base.cast(Defer).?.parent,</span>
<span class="line" id="L11720">            .namespace =&gt; base.cast(Namespace).?.parent,</span>
<span class="line" id="L11721">            .top =&gt; <span class="tok-null">null</span>,</span>
<span class="line" id="L11722">        };</span>
<span class="line" id="L11723">    }</span>
<span class="line" id="L11724"></span>
<span class="line" id="L11725">    <span class="tok-kw">const</span> Tag = <span class="tok-kw">enum</span> {</span>
<span class="line" id="L11726">        gen_zir,</span>
<span class="line" id="L11727">        local_val,</span>
<span class="line" id="L11728">        local_ptr,</span>
<span class="line" id="L11729">        defer_normal,</span>
<span class="line" id="L11730">        defer_error,</span>
<span class="line" id="L11731">        namespace,</span>
<span class="line" id="L11732">        top,</span>
<span class="line" id="L11733">    };</span>
<span class="line" id="L11734"></span>
<span class="line" id="L11735">    <span class="tok-comment">/// The category of identifier. These tag names are user-visible in compile errors.</span></span>
<span class="line" id="L11736">    <span class="tok-kw">const</span> IdCat = <span class="tok-kw">enum</span> {</span>
<span class="line" id="L11737">        @&quot;function parameter&quot;,</span>
<span class="line" id="L11738">        @&quot;local constant&quot;,</span>
<span class="line" id="L11739">        @&quot;local variable&quot;,</span>
<span class="line" id="L11740">        @&quot;switch tag capture&quot;,</span>
<span class="line" id="L11741">        capture,</span>
<span class="line" id="L11742">    };</span>
<span class="line" id="L11743"></span>
<span class="line" id="L11744">    <span class="tok-comment">/// This is always a `const` local and importantly the `inst` is a value type, not a pointer.</span></span>
<span class="line" id="L11745">    <span class="tok-comment">/// This structure lives as long as the AST generation of the Block</span></span>
<span class="line" id="L11746">    <span class="tok-comment">/// node that contains the variable.</span></span>
<span class="line" id="L11747">    <span class="tok-kw">const</span> LocalVal = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L11748">        <span class="tok-kw">const</span> base_tag: Tag = .local_val;</span>
<span class="line" id="L11749">        base: Scope = Scope{ .tag = base_tag },</span>
<span class="line" id="L11750">        <span class="tok-comment">/// Parents can be: `LocalVal`, `LocalPtr`, `GenZir`, `Defer`, `Namespace`.</span></span>
<span class="line" id="L11751">        parent: *Scope,</span>
<span class="line" id="L11752">        gen_zir: *GenZir,</span>
<span class="line" id="L11753">        inst: Zir.Inst.Ref,</span>
<span class="line" id="L11754">        <span class="tok-comment">/// Source location of the corresponding variable declaration.</span></span>
<span class="line" id="L11755">        token_src: Ast.TokenIndex,</span>
<span class="line" id="L11756">        <span class="tok-comment">/// Track the first identifer where it is referenced.</span></span>
<span class="line" id="L11757">        <span class="tok-comment">/// 0 means never referenced.</span></span>
<span class="line" id="L11758">        used: Ast.TokenIndex = <span class="tok-number">0</span>,</span>
<span class="line" id="L11759">        <span class="tok-comment">/// Track the identifier where it is discarded, like this `_ = foo;`.</span></span>
<span class="line" id="L11760">        <span class="tok-comment">/// 0 means never discarded.</span></span>
<span class="line" id="L11761">        discarded: Ast.TokenIndex = <span class="tok-number">0</span>,</span>
<span class="line" id="L11762">        <span class="tok-comment">/// String table index.</span></span>
<span class="line" id="L11763">        name: Zir.NullTerminatedString,</span>
<span class="line" id="L11764">        id_cat: IdCat,</span>
<span class="line" id="L11765">    };</span>
<span class="line" id="L11766"></span>
<span class="line" id="L11767">    <span class="tok-comment">/// This could be a `const` or `var` local. It has a pointer instead of a value.</span></span>
<span class="line" id="L11768">    <span class="tok-comment">/// This structure lives as long as the AST generation of the Block</span></span>
<span class="line" id="L11769">    <span class="tok-comment">/// node that contains the variable.</span></span>
<span class="line" id="L11770">    <span class="tok-kw">const</span> LocalPtr = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L11771">        <span class="tok-kw">const</span> base_tag: Tag = .local_ptr;</span>
<span class="line" id="L11772">        base: Scope = Scope{ .tag = base_tag },</span>
<span class="line" id="L11773">        <span class="tok-comment">/// Parents can be: `LocalVal`, `LocalPtr`, `GenZir`, `Defer`, `Namespace`.</span></span>
<span class="line" id="L11774">        parent: *Scope,</span>
<span class="line" id="L11775">        gen_zir: *GenZir,</span>
<span class="line" id="L11776">        ptr: Zir.Inst.Ref,</span>
<span class="line" id="L11777">        <span class="tok-comment">/// Source location of the corresponding variable declaration.</span></span>
<span class="line" id="L11778">        token_src: Ast.TokenIndex,</span>
<span class="line" id="L11779">        <span class="tok-comment">/// Track the first identifer where it is referenced.</span></span>
<span class="line" id="L11780">        <span class="tok-comment">/// 0 means never referenced.</span></span>
<span class="line" id="L11781">        used: Ast.TokenIndex = <span class="tok-number">0</span>,</span>
<span class="line" id="L11782">        <span class="tok-comment">/// Track the identifier where it is discarded, like this `_ = foo;`.</span></span>
<span class="line" id="L11783">        <span class="tok-comment">/// 0 means never discarded.</span></span>
<span class="line" id="L11784">        discarded: Ast.TokenIndex = <span class="tok-number">0</span>,</span>
<span class="line" id="L11785">        <span class="tok-comment">/// Whether this value is used as an lvalue after inititialization.</span></span>
<span class="line" id="L11786">        <span class="tok-comment">/// If not, we know it can be `const`, so will emit a compile error if it is `var`.</span></span>
<span class="line" id="L11787">        used_as_lvalue: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,</span>
<span class="line" id="L11788">        <span class="tok-comment">/// String table index.</span></span>
<span class="line" id="L11789">        name: Zir.NullTerminatedString,</span>
<span class="line" id="L11790">        id_cat: IdCat,</span>
<span class="line" id="L11791">        <span class="tok-comment">/// true means we find out during Sema whether the value is comptime.</span></span>
<span class="line" id="L11792">        <span class="tok-comment">/// false means it is already known at AstGen the value is runtime-known.</span></span>
<span class="line" id="L11793">        maybe_comptime: <span class="tok-type">bool</span>,</span>
<span class="line" id="L11794">    };</span>
<span class="line" id="L11795"></span>
<span class="line" id="L11796">    <span class="tok-kw">const</span> Defer = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L11797">        base: Scope,</span>
<span class="line" id="L11798">        <span class="tok-comment">/// Parents can be: `LocalVal`, `LocalPtr`, `GenZir`, `Defer`, `Namespace`.</span></span>
<span class="line" id="L11799">        parent: *Scope,</span>
<span class="line" id="L11800">        index: <span class="tok-type">u32</span>,</span>
<span class="line" id="L11801">        len: <span class="tok-type">u32</span>,</span>
<span class="line" id="L11802">        remapped_err_code: Zir.Inst.OptionalIndex = .none,</span>
<span class="line" id="L11803">    };</span>
<span class="line" id="L11804"></span>
<span class="line" id="L11805">    <span class="tok-comment">/// Represents a global scope that has any number of declarations in it.</span></span>
<span class="line" id="L11806">    <span class="tok-comment">/// Each declaration has this as the parent scope.</span></span>
<span class="line" id="L11807">    <span class="tok-kw">const</span> Namespace = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L11808">        <span class="tok-kw">const</span> base_tag: Tag = .namespace;</span>
<span class="line" id="L11809">        base: Scope = Scope{ .tag = base_tag },</span>
<span class="line" id="L11810"></span>
<span class="line" id="L11811">        <span class="tok-comment">/// Parents can be: `LocalVal`, `LocalPtr`, `GenZir`, `Defer`, `Namespace`.</span></span>
<span class="line" id="L11812">        parent: *Scope,</span>
<span class="line" id="L11813">        <span class="tok-comment">/// Maps string table index to the source location of declaration,</span></span>
<span class="line" id="L11814">        <span class="tok-comment">/// for the purposes of reporting name shadowing compile errors.</span></span>
<span class="line" id="L11815">        decls: std.AutoHashMapUnmanaged(Zir.NullTerminatedString, Ast.Node.Index) = .{},</span>
<span class="line" id="L11816">        node: Ast.Node.Index,</span>
<span class="line" id="L11817">        inst: Zir.Inst.Index,</span>
<span class="line" id="L11818">        maybe_generic: <span class="tok-type">bool</span>,</span>
<span class="line" id="L11819"></span>
<span class="line" id="L11820">        <span class="tok-comment">/// The astgen scope containing this namespace.</span></span>
<span class="line" id="L11821">        <span class="tok-comment">/// Only valid during astgen.</span></span>
<span class="line" id="L11822">        declaring_gz: ?*GenZir,</span>
<span class="line" id="L11823"></span>
<span class="line" id="L11824">        <span class="tok-comment">/// Set of captures used by this namespace.</span></span>
<span class="line" id="L11825">        captures: std.AutoArrayHashMapUnmanaged(Zir.Inst.Capture, <span class="tok-type">void</span>) = .{},</span>
<span class="line" id="L11826"></span>
<span class="line" id="L11827">        <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *Namespace, gpa: Allocator) <span class="tok-type">void</span> {</span>
<span class="line" id="L11828">            self.decls.deinit(gpa);</span>
<span class="line" id="L11829">            self.captures.deinit(gpa);</span>
<span class="line" id="L11830">            self.* = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L11831">        }</span>
<span class="line" id="L11832">    };</span>
<span class="line" id="L11833"></span>
<span class="line" id="L11834">    <span class="tok-kw">const</span> Top = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L11835">        <span class="tok-kw">const</span> base_tag: Scope.Tag = .top;</span>
<span class="line" id="L11836">        base: Scope = Scope{ .tag = base_tag },</span>
<span class="line" id="L11837">    };</span>
<span class="line" id="L11838">};</span>
<span class="line" id="L11839"></span>
<span class="line" id="L11840"><span class="tok-comment">/// This is a temporary structure; references to it are valid only</span></span>
<span class="line" id="L11841"><span class="tok-comment">/// while constructing a `Zir`.</span></span>
<span class="line" id="L11842"><span class="tok-kw">const</span> GenZir = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L11843">    <span class="tok-kw">const</span> base_tag: Scope.Tag = .gen_zir;</span>
<span class="line" id="L11844">    base: Scope = Scope{ .tag = base_tag },</span>
<span class="line" id="L11845">    <span class="tok-comment">/// Whether we're already in a scope known to be comptime. This is set</span></span>
<span class="line" id="L11846">    <span class="tok-comment">/// whenever we know Sema will analyze the current block with `is_comptime`,</span></span>
<span class="line" id="L11847">    <span class="tok-comment">/// for instance when we're within a `struct_decl` or a `block_comptime`.</span></span>
<span class="line" id="L11848">    is_comptime: <span class="tok-type">bool</span>,</span>
<span class="line" id="L11849">    <span class="tok-comment">/// Whether we're in an expression within a `@TypeOf` operand. In this case, closure of runtime</span></span>
<span class="line" id="L11850">    <span class="tok-comment">/// variables is permitted where it is usually not.</span></span>
<span class="line" id="L11851">    is_typeof: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,</span>
<span class="line" id="L11852">    <span class="tok-comment">/// This is set to true for a `GenZir` of a `block_inline`, indicating that</span></span>
<span class="line" id="L11853">    <span class="tok-comment">/// exits from this block should use `break_inline` rather than `break`.</span></span>
<span class="line" id="L11854">    is_inline: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,</span>
<span class="line" id="L11855">    c_import: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,</span>
<span class="line" id="L11856">    <span class="tok-comment">/// How decls created in this scope should be named.</span></span>
<span class="line" id="L11857">    anon_name_strategy: Zir.Inst.NameStrategy = .anon,</span>
<span class="line" id="L11858">    <span class="tok-comment">/// The containing decl AST node.</span></span>
<span class="line" id="L11859">    decl_node_index: Ast.Node.Index,</span>
<span class="line" id="L11860">    <span class="tok-comment">/// The containing decl line index, absolute.</span></span>
<span class="line" id="L11861">    decl_line: <span class="tok-type">u32</span>,</span>
<span class="line" id="L11862">    <span class="tok-comment">/// Parents can be: `LocalVal`, `LocalPtr`, `GenZir`, `Defer`, `Namespace`.</span></span>
<span class="line" id="L11863">    parent: *Scope,</span>
<span class="line" id="L11864">    <span class="tok-comment">/// All `GenZir` scopes for the same ZIR share this.</span></span>
<span class="line" id="L11865">    astgen: *AstGen,</span>
<span class="line" id="L11866">    <span class="tok-comment">/// Keeps track of the list of instructions in this scope. Possibly shared.</span></span>
<span class="line" id="L11867">    <span class="tok-comment">/// Indexes to instructions in `astgen`.</span></span>
<span class="line" id="L11868">    instructions: *ArrayListUnmanaged(Zir.Inst.Index),</span>
<span class="line" id="L11869">    <span class="tok-comment">/// A sub-block may share its instructions ArrayList with containing GenZir,</span></span>
<span class="line" id="L11870">    <span class="tok-comment">/// if use is strictly nested. This saves prior size of list for unstacking.</span></span>
<span class="line" id="L11871">    instructions_top: <span class="tok-type">usize</span>,</span>
<span class="line" id="L11872">    label: ?Label = <span class="tok-null">null</span>,</span>
<span class="line" id="L11873">    break_block: Zir.Inst.OptionalIndex = .none,</span>
<span class="line" id="L11874">    continue_block: Zir.Inst.OptionalIndex = .none,</span>
<span class="line" id="L11875">    <span class="tok-comment">/// Only valid when setBreakResultInfo is called.</span></span>
<span class="line" id="L11876">    break_result_info: AstGen.ResultInfo = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L11877"></span>
<span class="line" id="L11878">    suspend_node: Ast.Node.Index = <span class="tok-number">0</span>,</span>
<span class="line" id="L11879">    nosuspend_node: Ast.Node.Index = <span class="tok-number">0</span>,</span>
<span class="line" id="L11880">    <span class="tok-comment">/// Set if this GenZir is a defer.</span></span>
<span class="line" id="L11881">    cur_defer_node: Ast.Node.Index = <span class="tok-number">0</span>,</span>
<span class="line" id="L11882">    <span class="tok-comment">// Set if this GenZir is a defer or it is inside a defer.</span>
</span>
<span class="line" id="L11883">    any_defer_node: Ast.Node.Index = <span class="tok-number">0</span>,</span>
<span class="line" id="L11884"></span>
<span class="line" id="L11885">    <span class="tok-kw">const</span> unstacked_top = std.math.maxInt(<span class="tok-type">usize</span>);</span>
<span class="line" id="L11886">    <span class="tok-comment">/// Call unstack before adding any new instructions to containing GenZir.</span></span>
<span class="line" id="L11887">    <span class="tok-kw">fn</span> <span class="tok-fn">unstack</span>(self: *GenZir) <span class="tok-type">void</span> {</span>
<span class="line" id="L11888">        <span class="tok-kw">if</span> (self.instructions_top != unstacked_top) {</span>
<span class="line" id="L11889">            self.instructions.items.len = self.instructions_top;</span>
<span class="line" id="L11890">            self.instructions_top = unstacked_top;</span>
<span class="line" id="L11891">        }</span>
<span class="line" id="L11892">    }</span>
<span class="line" id="L11893"></span>
<span class="line" id="L11894">    <span class="tok-kw">fn</span> <span class="tok-fn">isEmpty</span>(self: *<span class="tok-kw">const</span> GenZir) <span class="tok-type">bool</span> {</span>
<span class="line" id="L11895">        <span class="tok-kw">return</span> (self.instructions_top == unstacked_top) <span class="tok-kw">or</span></span>
<span class="line" id="L11896">            (self.instructions.items.len == self.instructions_top);</span>
<span class="line" id="L11897">    }</span>
<span class="line" id="L11898"></span>
<span class="line" id="L11899">    <span class="tok-kw">fn</span> <span class="tok-fn">instructionsSlice</span>(self: *<span class="tok-kw">const</span> GenZir) []Zir.Inst.Index {</span>
<span class="line" id="L11900">        <span class="tok-kw">return</span> <span class="tok-kw">if</span> (self.instructions_top == unstacked_top)</span>
<span class="line" id="L11901">            &amp;[<span class="tok-number">0</span>]Zir.Inst.Index{}</span>
<span class="line" id="L11902">        <span class="tok-kw">else</span></span>
<span class="line" id="L11903">            self.instructions.items[self.instructions_top..];</span>
<span class="line" id="L11904">    }</span>
<span class="line" id="L11905"></span>
<span class="line" id="L11906">    <span class="tok-kw">fn</span> <span class="tok-fn">instructionsSliceUpto</span>(self: *<span class="tok-kw">const</span> GenZir, stacked_gz: *GenZir) []Zir.Inst.Index {</span>
<span class="line" id="L11907">        <span class="tok-kw">return</span> <span class="tok-kw">if</span> (self.instructions_top == unstacked_top)</span>
<span class="line" id="L11908">            &amp;[<span class="tok-number">0</span>]Zir.Inst.Index{}</span>
<span class="line" id="L11909">        <span class="tok-kw">else</span> <span class="tok-kw">if</span> (self.instructions == stacked_gz.instructions <span class="tok-kw">and</span> stacked_gz.instructions_top != unstacked_top)</span>
<span class="line" id="L11910">            self.instructions.items[self.instructions_top..stacked_gz.instructions_top]</span>
<span class="line" id="L11911">        <span class="tok-kw">else</span></span>
<span class="line" id="L11912">            self.instructions.items[self.instructions_top..];</span>
<span class="line" id="L11913">    }</span>
<span class="line" id="L11914"></span>
<span class="line" id="L11915">    <span class="tok-kw">fn</span> <span class="tok-fn">makeSubBlock</span>(gz: *GenZir, scope: *Scope) GenZir {</span>
<span class="line" id="L11916">        <span class="tok-kw">return</span> .{</span>
<span class="line" id="L11917">            .is_comptime = gz.is_comptime,</span>
<span class="line" id="L11918">            .is_typeof = gz.is_typeof,</span>
<span class="line" id="L11919">            .c_import = gz.c_import,</span>
<span class="line" id="L11920">            .decl_node_index = gz.decl_node_index,</span>
<span class="line" id="L11921">            .decl_line = gz.decl_line,</span>
<span class="line" id="L11922">            .parent = scope,</span>
<span class="line" id="L11923">            .astgen = gz.astgen,</span>
<span class="line" id="L11924">            .suspend_node = gz.suspend_node,</span>
<span class="line" id="L11925">            .nosuspend_node = gz.nosuspend_node,</span>
<span class="line" id="L11926">            .any_defer_node = gz.any_defer_node,</span>
<span class="line" id="L11927">            .instructions = gz.instructions,</span>
<span class="line" id="L11928">            .instructions_top = gz.instructions.items.len,</span>
<span class="line" id="L11929">        };</span>
<span class="line" id="L11930">    }</span>
<span class="line" id="L11931"></span>
<span class="line" id="L11932">    <span class="tok-kw">const</span> Label = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L11933">        token: Ast.TokenIndex,</span>
<span class="line" id="L11934">        block_inst: Zir.Inst.Index,</span>
<span class="line" id="L11935">        used: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,</span>
<span class="line" id="L11936">    };</span>
<span class="line" id="L11937"></span>
<span class="line" id="L11938">    <span class="tok-comment">/// Assumes nothing stacked on `gz`.</span></span>
<span class="line" id="L11939">    <span class="tok-kw">fn</span> <span class="tok-fn">endsWithNoReturn</span>(gz: GenZir) <span class="tok-type">bool</span> {</span>
<span class="line" id="L11940">        <span class="tok-kw">if</span> (gz.isEmpty()) <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L11941">        <span class="tok-kw">const</span> tags = gz.astgen.instructions.items(.tag);</span>
<span class="line" id="L11942">        <span class="tok-kw">const</span> last_inst = gz.instructions.items[gz.instructions.items.len - <span class="tok-number">1</span>];</span>
<span class="line" id="L11943">        <span class="tok-kw">return</span> tags[<span class="tok-builtin">@intFromEnum</span>(last_inst)].isNoReturn();</span>
<span class="line" id="L11944">    }</span>
<span class="line" id="L11945"></span>
<span class="line" id="L11946">    <span class="tok-comment">/// TODO all uses of this should be replaced with uses of `endsWithNoReturn`.</span></span>
<span class="line" id="L11947">    <span class="tok-kw">fn</span> <span class="tok-fn">refIsNoReturn</span>(gz: GenZir, inst_ref: Zir.Inst.Ref) <span class="tok-type">bool</span> {</span>
<span class="line" id="L11948">        <span class="tok-kw">if</span> (inst_ref == .unreachable_value) <span class="tok-kw">return</span> <span class="tok-null">true</span>;</span>
<span class="line" id="L11949">        <span class="tok-kw">if</span> (inst_ref.toIndex()) |inst_index| {</span>
<span class="line" id="L11950">            <span class="tok-kw">return</span> gz.astgen.instructions.items(.tag)[<span class="tok-builtin">@intFromEnum</span>(inst_index)].isNoReturn();</span>
<span class="line" id="L11951">        }</span>
<span class="line" id="L11952">        <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L11953">    }</span>
<span class="line" id="L11954"></span>
<span class="line" id="L11955">    <span class="tok-kw">fn</span> <span class="tok-fn">nodeIndexToRelative</span>(gz: GenZir, node_index: Ast.Node.Index) <span class="tok-type">i32</span> {</span>
<span class="line" id="L11956">        <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, <span class="tok-builtin">@bitCast</span>(node_index)) - <span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, <span class="tok-builtin">@bitCast</span>(gz.decl_node_index));</span>
<span class="line" id="L11957">    }</span>
<span class="line" id="L11958"></span>
<span class="line" id="L11959">    <span class="tok-kw">fn</span> <span class="tok-fn">tokenIndexToRelative</span>(gz: GenZir, token: Ast.TokenIndex) <span class="tok-type">u32</span> {</span>
<span class="line" id="L11960">        <span class="tok-kw">return</span> token - gz.srcToken();</span>
<span class="line" id="L11961">    }</span>
<span class="line" id="L11962"></span>
<span class="line" id="L11963">    <span class="tok-kw">fn</span> <span class="tok-fn">srcToken</span>(gz: GenZir) Ast.TokenIndex {</span>
<span class="line" id="L11964">        <span class="tok-kw">return</span> gz.astgen.tree.firstToken(gz.decl_node_index);</span>
<span class="line" id="L11965">    }</span>
<span class="line" id="L11966"></span>
<span class="line" id="L11967">    <span class="tok-kw">fn</span> <span class="tok-fn">setBreakResultInfo</span>(gz: *GenZir, parent_ri: AstGen.ResultInfo) <span class="tok-type">void</span> {</span>
<span class="line" id="L11968">        <span class="tok-comment">// Depending on whether the result location is a pointer or value, different</span>
</span>
<span class="line" id="L11969">        <span class="tok-comment">// ZIR needs to be generated. In the former case we rely on storing to the</span>
</span>
<span class="line" id="L11970">        <span class="tok-comment">// pointer to communicate the result, and use breakvoid; in the latter case</span>
</span>
<span class="line" id="L11971">        <span class="tok-comment">// the block break instructions will have the result values.</span>
</span>
<span class="line" id="L11972">        <span class="tok-kw">switch</span> (parent_ri.rl) {</span>
<span class="line" id="L11973">            .coerced_ty =&gt; |ty_inst| {</span>
<span class="line" id="L11974">                <span class="tok-comment">// Type coercion needs to happen before breaks.</span>
</span>
<span class="line" id="L11975">                gz.break_result_info = .{ .rl = .{ .ty = ty_inst }, .ctx = parent_ri.ctx };</span>
<span class="line" id="L11976">            },</span>
<span class="line" id="L11977">            .discard =&gt; {</span>
<span class="line" id="L11978">                <span class="tok-comment">// We don't forward the result context here. This prevents</span>
</span>
<span class="line" id="L11979">                <span class="tok-comment">// &quot;unnecessary discard&quot; errors from being caused by expressions</span>
</span>
<span class="line" id="L11980">                <span class="tok-comment">// far from the actual discard, such as a `break` from a</span>
</span>
<span class="line" id="L11981">                <span class="tok-comment">// discarded block.</span>
</span>
<span class="line" id="L11982">                gz.break_result_info = .{ .rl = .discard };</span>
<span class="line" id="L11983">            },</span>
<span class="line" id="L11984">            <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L11985">                gz.break_result_info = parent_ri;</span>
<span class="line" id="L11986">            },</span>
<span class="line" id="L11987">        }</span>
<span class="line" id="L11988">    }</span>
<span class="line" id="L11989"></span>
<span class="line" id="L11990">    <span class="tok-comment">/// Assumes nothing stacked on `gz`. Unstacks `gz`.</span></span>
<span class="line" id="L11991">    <span class="tok-kw">fn</span> <span class="tok-fn">setBoolBrBody</span>(gz: *GenZir, bool_br: Zir.Inst.Index, bool_br_lhs: Zir.Inst.Ref) !<span class="tok-type">void</span> {</span>
<span class="line" id="L11992">        <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L11993">        <span class="tok-kw">const</span> gpa = astgen.gpa;</span>
<span class="line" id="L11994">        <span class="tok-kw">const</span> body = gz.instructionsSlice();</span>
<span class="line" id="L11995">        <span class="tok-kw">const</span> body_len = astgen.countBodyLenAfterFixups(body);</span>
<span class="line" id="L11996">        <span class="tok-kw">try</span> astgen.extra.ensureUnusedCapacity(</span>
<span class="line" id="L11997">            gpa,</span>
<span class="line" id="L11998">            <span class="tok-builtin">@typeInfo</span>(Zir.Inst.BoolBr).Struct.fields.len + body_len,</span>
<span class="line" id="L11999">        );</span>
<span class="line" id="L12000">        <span class="tok-kw">const</span> zir_datas = astgen.instructions.items(.data);</span>
<span class="line" id="L12001">        zir_datas[<span class="tok-builtin">@intFromEnum</span>(bool_br)].pl_node.payload_index = astgen.addExtraAssumeCapacity(Zir.Inst.BoolBr{</span>
<span class="line" id="L12002">            .lhs = bool_br_lhs,</span>
<span class="line" id="L12003">            .body_len = body_len,</span>
<span class="line" id="L12004">        });</span>
<span class="line" id="L12005">        astgen.appendBodyWithFixups(body);</span>
<span class="line" id="L12006">        gz.unstack();</span>
<span class="line" id="L12007">    }</span>
<span class="line" id="L12008"></span>
<span class="line" id="L12009">    <span class="tok-comment">/// Assumes nothing stacked on `gz`. Unstacks `gz`.</span></span>
<span class="line" id="L12010">    <span class="tok-kw">fn</span> <span class="tok-fn">setBlockBody</span>(gz: *GenZir, inst: Zir.Inst.Index) !<span class="tok-type">void</span> {</span>
<span class="line" id="L12011">        <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L12012">        <span class="tok-kw">const</span> gpa = astgen.gpa;</span>
<span class="line" id="L12013">        <span class="tok-kw">const</span> body = gz.instructionsSlice();</span>
<span class="line" id="L12014">        <span class="tok-kw">const</span> body_len = astgen.countBodyLenAfterFixups(body);</span>
<span class="line" id="L12015">        <span class="tok-kw">try</span> astgen.extra.ensureUnusedCapacity(</span>
<span class="line" id="L12016">            gpa,</span>
<span class="line" id="L12017">            <span class="tok-builtin">@typeInfo</span>(Zir.Inst.Block).Struct.fields.len + body_len,</span>
<span class="line" id="L12018">        );</span>
<span class="line" id="L12019">        <span class="tok-kw">const</span> zir_datas = astgen.instructions.items(.data);</span>
<span class="line" id="L12020">        zir_datas[<span class="tok-builtin">@intFromEnum</span>(inst)].pl_node.payload_index = astgen.addExtraAssumeCapacity(</span>
<span class="line" id="L12021">            Zir.Inst.Block{ .body_len = body_len },</span>
<span class="line" id="L12022">        );</span>
<span class="line" id="L12023">        astgen.appendBodyWithFixups(body);</span>
<span class="line" id="L12024">        gz.unstack();</span>
<span class="line" id="L12025">    }</span>
<span class="line" id="L12026"></span>
<span class="line" id="L12027">    <span class="tok-comment">/// Assumes nothing stacked on `gz`. Unstacks `gz`.</span></span>
<span class="line" id="L12028">    <span class="tok-kw">fn</span> <span class="tok-fn">setTryBody</span>(gz: *GenZir, inst: Zir.Inst.Index, operand: Zir.Inst.Ref) !<span class="tok-type">void</span> {</span>
<span class="line" id="L12029">        <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L12030">        <span class="tok-kw">const</span> gpa = astgen.gpa;</span>
<span class="line" id="L12031">        <span class="tok-kw">const</span> body = gz.instructionsSlice();</span>
<span class="line" id="L12032">        <span class="tok-kw">const</span> body_len = astgen.countBodyLenAfterFixups(body);</span>
<span class="line" id="L12033">        <span class="tok-kw">try</span> astgen.extra.ensureUnusedCapacity(</span>
<span class="line" id="L12034">            gpa,</span>
<span class="line" id="L12035">            <span class="tok-builtin">@typeInfo</span>(Zir.Inst.Try).Struct.fields.len + body_len,</span>
<span class="line" id="L12036">        );</span>
<span class="line" id="L12037">        <span class="tok-kw">const</span> zir_datas = astgen.instructions.items(.data);</span>
<span class="line" id="L12038">        zir_datas[<span class="tok-builtin">@intFromEnum</span>(inst)].pl_node.payload_index = astgen.addExtraAssumeCapacity(</span>
<span class="line" id="L12039">            Zir.Inst.Try{</span>
<span class="line" id="L12040">                .operand = operand,</span>
<span class="line" id="L12041">                .body_len = body_len,</span>
<span class="line" id="L12042">            },</span>
<span class="line" id="L12043">        );</span>
<span class="line" id="L12044">        astgen.appendBodyWithFixups(body);</span>
<span class="line" id="L12045">        gz.unstack();</span>
<span class="line" id="L12046">    }</span>
<span class="line" id="L12047"></span>
<span class="line" id="L12048">    <span class="tok-comment">/// Must be called with the following stack set up:</span></span>
<span class="line" id="L12049">    <span class="tok-comment">///  * gz (bottom)</span></span>
<span class="line" id="L12050">    <span class="tok-comment">///  * align_gz</span></span>
<span class="line" id="L12051">    <span class="tok-comment">///  * addrspace_gz</span></span>
<span class="line" id="L12052">    <span class="tok-comment">///  * section_gz</span></span>
<span class="line" id="L12053">    <span class="tok-comment">///  * cc_gz</span></span>
<span class="line" id="L12054">    <span class="tok-comment">///  * ret_gz</span></span>
<span class="line" id="L12055">    <span class="tok-comment">///  * body_gz (top)</span></span>
<span class="line" id="L12056">    <span class="tok-comment">/// Unstacks all of those except for `gz`.</span></span>
<span class="line" id="L12057">    <span class="tok-kw">fn</span> <span class="tok-fn">addFunc</span>(gz: *GenZir, args: <span class="tok-kw">struct</span> {</span>
<span class="line" id="L12058">        src_node: Ast.Node.Index,</span>
<span class="line" id="L12059">        lbrace_line: <span class="tok-type">u32</span> = <span class="tok-number">0</span>,</span>
<span class="line" id="L12060">        lbrace_column: <span class="tok-type">u32</span> = <span class="tok-number">0</span>,</span>
<span class="line" id="L12061">        param_block: Zir.Inst.Index,</span>
<span class="line" id="L12062"></span>
<span class="line" id="L12063">        align_gz: ?*GenZir,</span>
<span class="line" id="L12064">        addrspace_gz: ?*GenZir,</span>
<span class="line" id="L12065">        section_gz: ?*GenZir,</span>
<span class="line" id="L12066">        cc_gz: ?*GenZir,</span>
<span class="line" id="L12067">        ret_gz: ?*GenZir,</span>
<span class="line" id="L12068">        body_gz: ?*GenZir,</span>
<span class="line" id="L12069"></span>
<span class="line" id="L12070">        align_ref: Zir.Inst.Ref,</span>
<span class="line" id="L12071">        addrspace_ref: Zir.Inst.Ref,</span>
<span class="line" id="L12072">        section_ref: Zir.Inst.Ref,</span>
<span class="line" id="L12073">        cc_ref: Zir.Inst.Ref,</span>
<span class="line" id="L12074">        ret_ref: Zir.Inst.Ref,</span>
<span class="line" id="L12075"></span>
<span class="line" id="L12076">        lib_name: Zir.NullTerminatedString,</span>
<span class="line" id="L12077">        noalias_bits: <span class="tok-type">u32</span>,</span>
<span class="line" id="L12078">        is_var_args: <span class="tok-type">bool</span>,</span>
<span class="line" id="L12079">        is_inferred_error: <span class="tok-type">bool</span>,</span>
<span class="line" id="L12080">        is_test: <span class="tok-type">bool</span>,</span>
<span class="line" id="L12081">        is_extern: <span class="tok-type">bool</span>,</span>
<span class="line" id="L12082">        is_noinline: <span class="tok-type">bool</span>,</span>
<span class="line" id="L12083">    }) !Zir.Inst.Ref {</span>
<span class="line" id="L12084">        assert(args.src_node != <span class="tok-number">0</span>);</span>
<span class="line" id="L12085">        <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L12086">        <span class="tok-kw">const</span> gpa = astgen.gpa;</span>
<span class="line" id="L12087">        <span class="tok-kw">const</span> ret_ref = <span class="tok-kw">if</span> (args.ret_ref == .void_type) .none <span class="tok-kw">else</span> args.ret_ref;</span>
<span class="line" id="L12088">        <span class="tok-kw">const</span> new_index: Zir.Inst.Index = <span class="tok-builtin">@enumFromInt</span>(astgen.instructions.len);</span>
<span class="line" id="L12089"></span>
<span class="line" id="L12090">        <span class="tok-kw">try</span> astgen.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);</span>
<span class="line" id="L12091"></span>
<span class="line" id="L12092">        <span class="tok-kw">var</span> body: []Zir.Inst.Index = &amp;[<span class="tok-number">0</span>]Zir.Inst.Index{};</span>
<span class="line" id="L12093">        <span class="tok-kw">var</span> ret_body: []Zir.Inst.Index = &amp;[<span class="tok-number">0</span>]Zir.Inst.Index{};</span>
<span class="line" id="L12094">        <span class="tok-kw">var</span> src_locs_and_hash_buffer: [<span class="tok-number">7</span>]<span class="tok-type">u32</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L12095">        <span class="tok-kw">var</span> src_locs_and_hash: []<span class="tok-type">u32</span> = src_locs_and_hash_buffer[<span class="tok-number">0</span>..<span class="tok-number">0</span>];</span>
<span class="line" id="L12096">        <span class="tok-kw">if</span> (args.body_gz) |body_gz| {</span>
<span class="line" id="L12097">            <span class="tok-kw">const</span> tree = astgen.tree;</span>
<span class="line" id="L12098">            <span class="tok-kw">const</span> node_tags = tree.nodes.items(.tag);</span>
<span class="line" id="L12099">            <span class="tok-kw">const</span> node_datas = tree.nodes.items(.data);</span>
<span class="line" id="L12100">            <span class="tok-kw">const</span> token_starts = tree.tokens.items(.start);</span>
<span class="line" id="L12101">            <span class="tok-kw">const</span> fn_decl = args.src_node;</span>
<span class="line" id="L12102">            assert(node_tags[fn_decl] == .fn_decl <span class="tok-kw">or</span> node_tags[fn_decl] == .test_decl);</span>
<span class="line" id="L12103">            <span class="tok-kw">const</span> block = node_datas[fn_decl].rhs;</span>
<span class="line" id="L12104">            <span class="tok-kw">const</span> rbrace_start = token_starts[tree.lastToken(block)];</span>
<span class="line" id="L12105">            astgen.advanceSourceCursor(rbrace_start);</span>
<span class="line" id="L12106">            <span class="tok-kw">const</span> rbrace_line: <span class="tok-type">u32</span> = <span class="tok-builtin">@intCast</span>(astgen.source_line - gz.decl_line);</span>
<span class="line" id="L12107">            <span class="tok-kw">const</span> rbrace_column: <span class="tok-type">u32</span> = <span class="tok-builtin">@intCast</span>(astgen.source_column);</span>
<span class="line" id="L12108"></span>
<span class="line" id="L12109">            <span class="tok-kw">const</span> columns = args.lbrace_column | (rbrace_column &lt;&lt; <span class="tok-number">16</span>);</span>
<span class="line" id="L12110"></span>
<span class="line" id="L12111">            <span class="tok-kw">const</span> proto_hash: std.zig.SrcHash = <span class="tok-kw">switch</span> (node_tags[fn_decl]) {</span>
<span class="line" id="L12112">                .fn_decl =&gt; sig_hash: {</span>
<span class="line" id="L12113">                    <span class="tok-kw">const</span> proto_node = node_datas[fn_decl].lhs;</span>
<span class="line" id="L12114">                    <span class="tok-kw">break</span> :sig_hash std.zig.hashSrc(tree.getNodeSource(proto_node));</span>
<span class="line" id="L12115">                },</span>
<span class="line" id="L12116">                .test_decl =&gt; std.zig.hashSrc(<span class="tok-str">&quot;&quot;</span>), <span class="tok-comment">// tests don't have a prototype</span>
</span>
<span class="line" id="L12117">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L12118">            };</span>
<span class="line" id="L12119">            <span class="tok-kw">const</span> proto_hash_arr: [<span class="tok-number">4</span>]<span class="tok-type">u32</span> = <span class="tok-builtin">@bitCast</span>(proto_hash);</span>
<span class="line" id="L12120"></span>
<span class="line" id="L12121">            src_locs_and_hash_buffer = .{</span>
<span class="line" id="L12122">                args.lbrace_line,</span>
<span class="line" id="L12123">                rbrace_line,</span>
<span class="line" id="L12124">                columns,</span>
<span class="line" id="L12125">                proto_hash_arr[<span class="tok-number">0</span>],</span>
<span class="line" id="L12126">                proto_hash_arr[<span class="tok-number">1</span>],</span>
<span class="line" id="L12127">                proto_hash_arr[<span class="tok-number">2</span>],</span>
<span class="line" id="L12128">                proto_hash_arr[<span class="tok-number">3</span>],</span>
<span class="line" id="L12129">            };</span>
<span class="line" id="L12130">            src_locs_and_hash = &amp;src_locs_and_hash_buffer;</span>
<span class="line" id="L12131"></span>
<span class="line" id="L12132">            body = body_gz.instructionsSlice();</span>
<span class="line" id="L12133">            <span class="tok-kw">if</span> (args.ret_gz) |ret_gz|</span>
<span class="line" id="L12134">                ret_body = ret_gz.instructionsSliceUpto(body_gz);</span>
<span class="line" id="L12135">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L12136">            <span class="tok-kw">if</span> (args.ret_gz) |ret_gz|</span>
<span class="line" id="L12137">                ret_body = ret_gz.instructionsSlice();</span>
<span class="line" id="L12138">        }</span>
<span class="line" id="L12139">        <span class="tok-kw">const</span> body_len = astgen.countBodyLenAfterFixups(body);</span>
<span class="line" id="L12140"></span>
<span class="line" id="L12141">        <span class="tok-kw">if</span> (args.cc_ref != .none <span class="tok-kw">or</span> args.lib_name != .empty <span class="tok-kw">or</span> args.is_var_args <span class="tok-kw">or</span> args.is_test <span class="tok-kw">or</span></span>
<span class="line" id="L12142">            args.is_extern <span class="tok-kw">or</span> args.align_ref != .none <span class="tok-kw">or</span> args.section_ref != .none <span class="tok-kw">or</span></span>
<span class="line" id="L12143">            args.addrspace_ref != .none <span class="tok-kw">or</span> args.noalias_bits != <span class="tok-number">0</span> <span class="tok-kw">or</span> args.is_noinline)</span>
<span class="line" id="L12144">        {</span>
<span class="line" id="L12145">            <span class="tok-kw">var</span> align_body: []Zir.Inst.Index = &amp;.{};</span>
<span class="line" id="L12146">            <span class="tok-kw">var</span> addrspace_body: []Zir.Inst.Index = &amp;.{};</span>
<span class="line" id="L12147">            <span class="tok-kw">var</span> section_body: []Zir.Inst.Index = &amp;.{};</span>
<span class="line" id="L12148">            <span class="tok-kw">var</span> cc_body: []Zir.Inst.Index = &amp;.{};</span>
<span class="line" id="L12149">            <span class="tok-kw">if</span> (args.ret_gz != <span class="tok-null">null</span>) {</span>
<span class="line" id="L12150">                align_body = args.align_gz.?.instructionsSliceUpto(args.addrspace_gz.?);</span>
<span class="line" id="L12151">                addrspace_body = args.addrspace_gz.?.instructionsSliceUpto(args.section_gz.?);</span>
<span class="line" id="L12152">                section_body = args.section_gz.?.instructionsSliceUpto(args.cc_gz.?);</span>
<span class="line" id="L12153">                cc_body = args.cc_gz.?.instructionsSliceUpto(args.ret_gz.?);</span>
<span class="line" id="L12154">            }</span>
<span class="line" id="L12155"></span>
<span class="line" id="L12156">            <span class="tok-kw">try</span> astgen.extra.ensureUnusedCapacity(</span>
<span class="line" id="L12157">                gpa,</span>
<span class="line" id="L12158">                <span class="tok-builtin">@typeInfo</span>(Zir.Inst.FuncFancy).Struct.fields.len +</span>
<span class="line" id="L12159">                    fancyFnExprExtraLen(astgen, align_body, args.align_ref) +</span>
<span class="line" id="L12160">                    fancyFnExprExtraLen(astgen, addrspace_body, args.addrspace_ref) +</span>
<span class="line" id="L12161">                    fancyFnExprExtraLen(astgen, section_body, args.section_ref) +</span>
<span class="line" id="L12162">                    fancyFnExprExtraLen(astgen, cc_body, args.cc_ref) +</span>
<span class="line" id="L12163">                    fancyFnExprExtraLen(astgen, ret_body, ret_ref) +</span>
<span class="line" id="L12164">                    body_len + src_locs_and_hash.len +</span>
<span class="line" id="L12165">                    <span class="tok-builtin">@intFromBool</span>(args.lib_name != .empty) +</span>
<span class="line" id="L12166">                    <span class="tok-builtin">@intFromBool</span>(args.noalias_bits != <span class="tok-number">0</span>),</span>
<span class="line" id="L12167">            );</span>
<span class="line" id="L12168">            <span class="tok-kw">const</span> payload_index = astgen.addExtraAssumeCapacity(Zir.Inst.FuncFancy{</span>
<span class="line" id="L12169">                .param_block = args.param_block,</span>
<span class="line" id="L12170">                .body_len = body_len,</span>
<span class="line" id="L12171">                .bits = .{</span>
<span class="line" id="L12172">                    .is_var_args = args.is_var_args,</span>
<span class="line" id="L12173">                    .is_inferred_error = args.is_inferred_error,</span>
<span class="line" id="L12174">                    .is_test = args.is_test,</span>
<span class="line" id="L12175">                    .is_extern = args.is_extern,</span>
<span class="line" id="L12176">                    .is_noinline = args.is_noinline,</span>
<span class="line" id="L12177">                    .has_lib_name = args.lib_name != .empty,</span>
<span class="line" id="L12178">                    .has_any_noalias = args.noalias_bits != <span class="tok-number">0</span>,</span>
<span class="line" id="L12179"></span>
<span class="line" id="L12180">                    .has_align_ref = args.align_ref != .none,</span>
<span class="line" id="L12181">                    .has_addrspace_ref = args.addrspace_ref != .none,</span>
<span class="line" id="L12182">                    .has_section_ref = args.section_ref != .none,</span>
<span class="line" id="L12183">                    .has_cc_ref = args.cc_ref != .none,</span>
<span class="line" id="L12184">                    .has_ret_ty_ref = ret_ref != .none,</span>
<span class="line" id="L12185"></span>
<span class="line" id="L12186">                    .has_align_body = align_body.len != <span class="tok-number">0</span>,</span>
<span class="line" id="L12187">                    .has_addrspace_body = addrspace_body.len != <span class="tok-number">0</span>,</span>
<span class="line" id="L12188">                    .has_section_body = section_body.len != <span class="tok-number">0</span>,</span>
<span class="line" id="L12189">                    .has_cc_body = cc_body.len != <span class="tok-number">0</span>,</span>
<span class="line" id="L12190">                    .has_ret_ty_body = ret_body.len != <span class="tok-number">0</span>,</span>
<span class="line" id="L12191">                },</span>
<span class="line" id="L12192">            });</span>
<span class="line" id="L12193">            <span class="tok-kw">if</span> (args.lib_name != .empty) {</span>
<span class="line" id="L12194">                astgen.extra.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(args.lib_name));</span>
<span class="line" id="L12195">            }</span>
<span class="line" id="L12196"></span>
<span class="line" id="L12197">            <span class="tok-kw">const</span> zir_datas = astgen.instructions.items(.data);</span>
<span class="line" id="L12198">            <span class="tok-kw">if</span> (align_body.len != <span class="tok-number">0</span>) {</span>
<span class="line" id="L12199">                astgen.extra.appendAssumeCapacity(countBodyLenAfterFixups(astgen, align_body));</span>
<span class="line" id="L12200">                astgen.appendBodyWithFixups(align_body);</span>
<span class="line" id="L12201">                <span class="tok-kw">const</span> break_extra = zir_datas[<span class="tok-builtin">@intFromEnum</span>(align_body[align_body.len - <span class="tok-number">1</span>])].@&quot;break&quot;.payload_index;</span>
<span class="line" id="L12202">                astgen.extra.items[break_extra + std.meta.fieldIndex(Zir.Inst.Break, <span class="tok-str">&quot;block_inst&quot;</span>).?] =</span>
<span class="line" id="L12203">                    <span class="tok-builtin">@intFromEnum</span>(new_index);</span>
<span class="line" id="L12204">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (args.align_ref != .none) {</span>
<span class="line" id="L12205">                astgen.extra.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(args.align_ref));</span>
<span class="line" id="L12206">            }</span>
<span class="line" id="L12207">            <span class="tok-kw">if</span> (addrspace_body.len != <span class="tok-number">0</span>) {</span>
<span class="line" id="L12208">                astgen.extra.appendAssumeCapacity(countBodyLenAfterFixups(astgen, addrspace_body));</span>
<span class="line" id="L12209">                astgen.appendBodyWithFixups(addrspace_body);</span>
<span class="line" id="L12210">                <span class="tok-kw">const</span> break_extra =</span>
<span class="line" id="L12211">                    zir_datas[<span class="tok-builtin">@intFromEnum</span>(addrspace_body[addrspace_body.len - <span class="tok-number">1</span>])].@&quot;break&quot;.payload_index;</span>
<span class="line" id="L12212">                astgen.extra.items[break_extra + std.meta.fieldIndex(Zir.Inst.Break, <span class="tok-str">&quot;block_inst&quot;</span>).?] =</span>
<span class="line" id="L12213">                    <span class="tok-builtin">@intFromEnum</span>(new_index);</span>
<span class="line" id="L12214">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (args.addrspace_ref != .none) {</span>
<span class="line" id="L12215">                astgen.extra.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(args.addrspace_ref));</span>
<span class="line" id="L12216">            }</span>
<span class="line" id="L12217">            <span class="tok-kw">if</span> (section_body.len != <span class="tok-number">0</span>) {</span>
<span class="line" id="L12218">                astgen.extra.appendAssumeCapacity(countBodyLenAfterFixups(astgen, section_body));</span>
<span class="line" id="L12219">                astgen.appendBodyWithFixups(section_body);</span>
<span class="line" id="L12220">                <span class="tok-kw">const</span> break_extra =</span>
<span class="line" id="L12221">                    zir_datas[<span class="tok-builtin">@intFromEnum</span>(section_body[section_body.len - <span class="tok-number">1</span>])].@&quot;break&quot;.payload_index;</span>
<span class="line" id="L12222">                astgen.extra.items[break_extra + std.meta.fieldIndex(Zir.Inst.Break, <span class="tok-str">&quot;block_inst&quot;</span>).?] =</span>
<span class="line" id="L12223">                    <span class="tok-builtin">@intFromEnum</span>(new_index);</span>
<span class="line" id="L12224">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (args.section_ref != .none) {</span>
<span class="line" id="L12225">                astgen.extra.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(args.section_ref));</span>
<span class="line" id="L12226">            }</span>
<span class="line" id="L12227">            <span class="tok-kw">if</span> (cc_body.len != <span class="tok-number">0</span>) {</span>
<span class="line" id="L12228">                astgen.extra.appendAssumeCapacity(countBodyLenAfterFixups(astgen, cc_body));</span>
<span class="line" id="L12229">                astgen.appendBodyWithFixups(cc_body);</span>
<span class="line" id="L12230">                <span class="tok-kw">const</span> break_extra = zir_datas[<span class="tok-builtin">@intFromEnum</span>(cc_body[cc_body.len - <span class="tok-number">1</span>])].@&quot;break&quot;.payload_index;</span>
<span class="line" id="L12231">                astgen.extra.items[break_extra + std.meta.fieldIndex(Zir.Inst.Break, <span class="tok-str">&quot;block_inst&quot;</span>).?] =</span>
<span class="line" id="L12232">                    <span class="tok-builtin">@intFromEnum</span>(new_index);</span>
<span class="line" id="L12233">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (args.cc_ref != .none) {</span>
<span class="line" id="L12234">                astgen.extra.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(args.cc_ref));</span>
<span class="line" id="L12235">            }</span>
<span class="line" id="L12236">            <span class="tok-kw">if</span> (ret_body.len != <span class="tok-number">0</span>) {</span>
<span class="line" id="L12237">                astgen.extra.appendAssumeCapacity(countBodyLenAfterFixups(astgen, ret_body));</span>
<span class="line" id="L12238">                astgen.appendBodyWithFixups(ret_body);</span>
<span class="line" id="L12239">                <span class="tok-kw">const</span> break_extra = zir_datas[<span class="tok-builtin">@intFromEnum</span>(ret_body[ret_body.len - <span class="tok-number">1</span>])].@&quot;break&quot;.payload_index;</span>
<span class="line" id="L12240">                astgen.extra.items[break_extra + std.meta.fieldIndex(Zir.Inst.Break, <span class="tok-str">&quot;block_inst&quot;</span>).?] =</span>
<span class="line" id="L12241">                    <span class="tok-builtin">@intFromEnum</span>(new_index);</span>
<span class="line" id="L12242">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (ret_ref != .none) {</span>
<span class="line" id="L12243">                astgen.extra.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(ret_ref));</span>
<span class="line" id="L12244">            }</span>
<span class="line" id="L12245"></span>
<span class="line" id="L12246">            <span class="tok-kw">if</span> (args.noalias_bits != <span class="tok-number">0</span>) {</span>
<span class="line" id="L12247">                astgen.extra.appendAssumeCapacity(args.noalias_bits);</span>
<span class="line" id="L12248">            }</span>
<span class="line" id="L12249"></span>
<span class="line" id="L12250">            astgen.appendBodyWithFixups(body);</span>
<span class="line" id="L12251">            astgen.extra.appendSliceAssumeCapacity(src_locs_and_hash);</span>
<span class="line" id="L12252"></span>
<span class="line" id="L12253">            <span class="tok-comment">// Order is important when unstacking.</span>
</span>
<span class="line" id="L12254">            <span class="tok-kw">if</span> (args.body_gz) |body_gz| body_gz.unstack();</span>
<span class="line" id="L12255">            <span class="tok-kw">if</span> (args.ret_gz != <span class="tok-null">null</span>) {</span>
<span class="line" id="L12256">                args.ret_gz.?.unstack();</span>
<span class="line" id="L12257">                args.cc_gz.?.unstack();</span>
<span class="line" id="L12258">                args.section_gz.?.unstack();</span>
<span class="line" id="L12259">                args.addrspace_gz.?.unstack();</span>
<span class="line" id="L12260">                args.align_gz.?.unstack();</span>
<span class="line" id="L12261">            }</span>
<span class="line" id="L12262"></span>
<span class="line" id="L12263">            <span class="tok-kw">try</span> gz.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);</span>
<span class="line" id="L12264"></span>
<span class="line" id="L12265">            astgen.instructions.appendAssumeCapacity(.{</span>
<span class="line" id="L12266">                .tag = .func_fancy,</span>
<span class="line" id="L12267">                .data = .{ .pl_node = .{</span>
<span class="line" id="L12268">                    .src_node = gz.nodeIndexToRelative(args.src_node),</span>
<span class="line" id="L12269">                    .payload_index = payload_index,</span>
<span class="line" id="L12270">                } },</span>
<span class="line" id="L12271">            });</span>
<span class="line" id="L12272">            gz.instructions.appendAssumeCapacity(new_index);</span>
<span class="line" id="L12273">            <span class="tok-kw">return</span> new_index.toRef();</span>
<span class="line" id="L12274">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L12275">            <span class="tok-kw">try</span> astgen.extra.ensureUnusedCapacity(</span>
<span class="line" id="L12276">                gpa,</span>
<span class="line" id="L12277">                <span class="tok-builtin">@typeInfo</span>(Zir.Inst.Func).Struct.fields.len + <span class="tok-number">1</span> +</span>
<span class="line" id="L12278">                    fancyFnExprExtraLen(astgen, ret_body, ret_ref) +</span>
<span class="line" id="L12279">                    body_len + src_locs_and_hash.len,</span>
<span class="line" id="L12280">            );</span>
<span class="line" id="L12281"></span>
<span class="line" id="L12282">            <span class="tok-kw">const</span> ret_body_len = <span class="tok-kw">if</span> (ret_body.len != <span class="tok-number">0</span>)</span>
<span class="line" id="L12283">                countBodyLenAfterFixups(astgen, ret_body)</span>
<span class="line" id="L12284">            <span class="tok-kw">else</span></span>
<span class="line" id="L12285">                <span class="tok-builtin">@intFromBool</span>(ret_ref != .none);</span>
<span class="line" id="L12286"></span>
<span class="line" id="L12287">            <span class="tok-kw">const</span> payload_index = astgen.addExtraAssumeCapacity(Zir.Inst.Func{</span>
<span class="line" id="L12288">                .param_block = args.param_block,</span>
<span class="line" id="L12289">                .ret_body_len = ret_body_len,</span>
<span class="line" id="L12290">                .body_len = body_len,</span>
<span class="line" id="L12291">            });</span>
<span class="line" id="L12292">            <span class="tok-kw">const</span> zir_datas = astgen.instructions.items(.data);</span>
<span class="line" id="L12293">            <span class="tok-kw">if</span> (ret_body.len != <span class="tok-number">0</span>) {</span>
<span class="line" id="L12294">                astgen.appendBodyWithFixups(ret_body);</span>
<span class="line" id="L12295"></span>
<span class="line" id="L12296">                <span class="tok-kw">const</span> break_extra = zir_datas[<span class="tok-builtin">@intFromEnum</span>(ret_body[ret_body.len - <span class="tok-number">1</span>])].@&quot;break&quot;.payload_index;</span>
<span class="line" id="L12297">                astgen.extra.items[break_extra + std.meta.fieldIndex(Zir.Inst.Break, <span class="tok-str">&quot;block_inst&quot;</span>).?] =</span>
<span class="line" id="L12298">                    <span class="tok-builtin">@intFromEnum</span>(new_index);</span>
<span class="line" id="L12299">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (ret_ref != .none) {</span>
<span class="line" id="L12300">                astgen.extra.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(ret_ref));</span>
<span class="line" id="L12301">            }</span>
<span class="line" id="L12302">            astgen.appendBodyWithFixups(body);</span>
<span class="line" id="L12303">            astgen.extra.appendSliceAssumeCapacity(src_locs_and_hash);</span>
<span class="line" id="L12304"></span>
<span class="line" id="L12305">            <span class="tok-comment">// Order is important when unstacking.</span>
</span>
<span class="line" id="L12306">            <span class="tok-kw">if</span> (args.body_gz) |body_gz| body_gz.unstack();</span>
<span class="line" id="L12307">            <span class="tok-kw">if</span> (args.ret_gz) |ret_gz| ret_gz.unstack();</span>
<span class="line" id="L12308">            <span class="tok-kw">if</span> (args.cc_gz) |cc_gz| cc_gz.unstack();</span>
<span class="line" id="L12309">            <span class="tok-kw">if</span> (args.section_gz) |section_gz| section_gz.unstack();</span>
<span class="line" id="L12310">            <span class="tok-kw">if</span> (args.addrspace_gz) |addrspace_gz| addrspace_gz.unstack();</span>
<span class="line" id="L12311">            <span class="tok-kw">if</span> (args.align_gz) |align_gz| align_gz.unstack();</span>
<span class="line" id="L12312"></span>
<span class="line" id="L12313">            <span class="tok-kw">try</span> gz.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);</span>
<span class="line" id="L12314"></span>
<span class="line" id="L12315">            <span class="tok-kw">const</span> tag: Zir.Inst.Tag = <span class="tok-kw">if</span> (args.is_inferred_error) .func_inferred <span class="tok-kw">else</span> .func;</span>
<span class="line" id="L12316">            astgen.instructions.appendAssumeCapacity(.{</span>
<span class="line" id="L12317">                .tag = tag,</span>
<span class="line" id="L12318">                .data = .{ .pl_node = .{</span>
<span class="line" id="L12319">                    .src_node = gz.nodeIndexToRelative(args.src_node),</span>
<span class="line" id="L12320">                    .payload_index = payload_index,</span>
<span class="line" id="L12321">                } },</span>
<span class="line" id="L12322">            });</span>
<span class="line" id="L12323">            gz.instructions.appendAssumeCapacity(new_index);</span>
<span class="line" id="L12324">            <span class="tok-kw">return</span> new_index.toRef();</span>
<span class="line" id="L12325">        }</span>
<span class="line" id="L12326">    }</span>
<span class="line" id="L12327"></span>
<span class="line" id="L12328">    <span class="tok-kw">fn</span> <span class="tok-fn">fancyFnExprExtraLen</span>(astgen: *AstGen, body: []Zir.Inst.Index, ref: Zir.Inst.Ref) <span class="tok-type">u32</span> {</span>
<span class="line" id="L12329">        <span class="tok-comment">// In the case of non-empty body, there is one for the body length,</span>
</span>
<span class="line" id="L12330">        <span class="tok-comment">// and then one for each instruction.</span>
</span>
<span class="line" id="L12331">        <span class="tok-kw">return</span> countBodyLenAfterFixups(astgen, body) + <span class="tok-builtin">@intFromBool</span>(ref != .none);</span>
<span class="line" id="L12332">    }</span>
<span class="line" id="L12333"></span>
<span class="line" id="L12334">    <span class="tok-kw">fn</span> <span class="tok-fn">addVar</span>(gz: *GenZir, args: <span class="tok-kw">struct</span> {</span>
<span class="line" id="L12335">        align_inst: Zir.Inst.Ref,</span>
<span class="line" id="L12336">        lib_name: Zir.NullTerminatedString,</span>
<span class="line" id="L12337">        var_type: Zir.Inst.Ref,</span>
<span class="line" id="L12338">        init: Zir.Inst.Ref,</span>
<span class="line" id="L12339">        is_extern: <span class="tok-type">bool</span>,</span>
<span class="line" id="L12340">        is_const: <span class="tok-type">bool</span>,</span>
<span class="line" id="L12341">        is_threadlocal: <span class="tok-type">bool</span>,</span>
<span class="line" id="L12342">    }) !Zir.Inst.Ref {</span>
<span class="line" id="L12343">        <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L12344">        <span class="tok-kw">const</span> gpa = astgen.gpa;</span>
<span class="line" id="L12345"></span>
<span class="line" id="L12346">        <span class="tok-kw">try</span> gz.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);</span>
<span class="line" id="L12347">        <span class="tok-kw">try</span> astgen.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);</span>
<span class="line" id="L12348"></span>
<span class="line" id="L12349">        <span class="tok-kw">try</span> astgen.extra.ensureUnusedCapacity(</span>
<span class="line" id="L12350">            gpa,</span>
<span class="line" id="L12351">            <span class="tok-builtin">@typeInfo</span>(Zir.Inst.ExtendedVar).Struct.fields.len +</span>
<span class="line" id="L12352">                <span class="tok-builtin">@intFromBool</span>(args.lib_name != .empty) +</span>
<span class="line" id="L12353">                <span class="tok-builtin">@intFromBool</span>(args.align_inst != .none) +</span>
<span class="line" id="L12354">                <span class="tok-builtin">@intFromBool</span>(args.init != .none),</span>
<span class="line" id="L12355">        );</span>
<span class="line" id="L12356">        <span class="tok-kw">const</span> payload_index = astgen.addExtraAssumeCapacity(Zir.Inst.ExtendedVar{</span>
<span class="line" id="L12357">            .var_type = args.var_type,</span>
<span class="line" id="L12358">        });</span>
<span class="line" id="L12359">        <span class="tok-kw">if</span> (args.lib_name != .empty) {</span>
<span class="line" id="L12360">            astgen.extra.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(args.lib_name));</span>
<span class="line" id="L12361">        }</span>
<span class="line" id="L12362">        <span class="tok-kw">if</span> (args.align_inst != .none) {</span>
<span class="line" id="L12363">            astgen.extra.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(args.align_inst));</span>
<span class="line" id="L12364">        }</span>
<span class="line" id="L12365">        <span class="tok-kw">if</span> (args.init != .none) {</span>
<span class="line" id="L12366">            astgen.extra.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(args.init));</span>
<span class="line" id="L12367">        }</span>
<span class="line" id="L12368"></span>
<span class="line" id="L12369">        <span class="tok-kw">const</span> new_index: Zir.Inst.Index = <span class="tok-builtin">@enumFromInt</span>(astgen.instructions.len);</span>
<span class="line" id="L12370">        astgen.instructions.appendAssumeCapacity(.{</span>
<span class="line" id="L12371">            .tag = .extended,</span>
<span class="line" id="L12372">            .data = .{ .extended = .{</span>
<span class="line" id="L12373">                .opcode = .variable,</span>
<span class="line" id="L12374">                .small = <span class="tok-builtin">@bitCast</span>(Zir.Inst.ExtendedVar.Small{</span>
<span class="line" id="L12375">                    .has_lib_name = args.lib_name != .empty,</span>
<span class="line" id="L12376">                    .has_align = args.align_inst != .none,</span>
<span class="line" id="L12377">                    .has_init = args.init != .none,</span>
<span class="line" id="L12378">                    .is_extern = args.is_extern,</span>
<span class="line" id="L12379">                    .is_const = args.is_const,</span>
<span class="line" id="L12380">                    .is_threadlocal = args.is_threadlocal,</span>
<span class="line" id="L12381">                }),</span>
<span class="line" id="L12382">                .operand = payload_index,</span>
<span class="line" id="L12383">            } },</span>
<span class="line" id="L12384">        });</span>
<span class="line" id="L12385">        gz.instructions.appendAssumeCapacity(new_index);</span>
<span class="line" id="L12386">        <span class="tok-kw">return</span> new_index.toRef();</span>
<span class="line" id="L12387">    }</span>
<span class="line" id="L12388"></span>
<span class="line" id="L12389">    <span class="tok-kw">fn</span> <span class="tok-fn">addInt</span>(gz: *GenZir, integer: <span class="tok-type">u64</span>) !Zir.Inst.Ref {</span>
<span class="line" id="L12390">        <span class="tok-kw">return</span> gz.add(.{</span>
<span class="line" id="L12391">            .tag = .int,</span>
<span class="line" id="L12392">            .data = .{ .int = integer },</span>
<span class="line" id="L12393">        });</span>
<span class="line" id="L12394">    }</span>
<span class="line" id="L12395"></span>
<span class="line" id="L12396">    <span class="tok-kw">fn</span> <span class="tok-fn">addIntBig</span>(gz: *GenZir, limbs: []<span class="tok-kw">const</span> std.math.big.Limb) !Zir.Inst.Ref {</span>
<span class="line" id="L12397">        <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L12398">        <span class="tok-kw">const</span> gpa = astgen.gpa;</span>
<span class="line" id="L12399">        <span class="tok-kw">try</span> gz.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);</span>
<span class="line" id="L12400">        <span class="tok-kw">try</span> astgen.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);</span>
<span class="line" id="L12401">        <span class="tok-kw">try</span> astgen.string_bytes.ensureUnusedCapacity(gpa, <span class="tok-builtin">@sizeOf</span>(std.math.big.Limb) * limbs.len);</span>
<span class="line" id="L12402"></span>
<span class="line" id="L12403">        <span class="tok-kw">const</span> new_index: Zir.Inst.Index = <span class="tok-builtin">@enumFromInt</span>(astgen.instructions.len);</span>
<span class="line" id="L12404">        astgen.instructions.appendAssumeCapacity(.{</span>
<span class="line" id="L12405">            .tag = .int_big,</span>
<span class="line" id="L12406">            .data = .{ .str = .{</span>
<span class="line" id="L12407">                .start = <span class="tok-builtin">@enumFromInt</span>(astgen.string_bytes.items.len),</span>
<span class="line" id="L12408">                .len = <span class="tok-builtin">@intCast</span>(limbs.len),</span>
<span class="line" id="L12409">            } },</span>
<span class="line" id="L12410">        });</span>
<span class="line" id="L12411">        gz.instructions.appendAssumeCapacity(new_index);</span>
<span class="line" id="L12412">        astgen.string_bytes.appendSliceAssumeCapacity(mem.sliceAsBytes(limbs));</span>
<span class="line" id="L12413">        <span class="tok-kw">return</span> new_index.toRef();</span>
<span class="line" id="L12414">    }</span>
<span class="line" id="L12415"></span>
<span class="line" id="L12416">    <span class="tok-kw">fn</span> <span class="tok-fn">addFloat</span>(gz: *GenZir, number: <span class="tok-type">f64</span>) !Zir.Inst.Ref {</span>
<span class="line" id="L12417">        <span class="tok-kw">return</span> gz.add(.{</span>
<span class="line" id="L12418">            .tag = .float,</span>
<span class="line" id="L12419">            .data = .{ .float = number },</span>
<span class="line" id="L12420">        });</span>
<span class="line" id="L12421">    }</span>
<span class="line" id="L12422"></span>
<span class="line" id="L12423">    <span class="tok-kw">fn</span> <span class="tok-fn">addUnNode</span>(</span>
<span class="line" id="L12424">        gz: *GenZir,</span>
<span class="line" id="L12425">        tag: Zir.Inst.Tag,</span>
<span class="line" id="L12426">        operand: Zir.Inst.Ref,</span>
<span class="line" id="L12427">        <span class="tok-comment">/// Absolute node index. This function does the conversion to offset from Decl.</span></span>
<span class="line" id="L12428">        src_node: Ast.Node.Index,</span>
<span class="line" id="L12429">    ) !Zir.Inst.Ref {</span>
<span class="line" id="L12430">        assert(operand != .none);</span>
<span class="line" id="L12431">        <span class="tok-kw">return</span> gz.add(.{</span>
<span class="line" id="L12432">            .tag = tag,</span>
<span class="line" id="L12433">            .data = .{ .un_node = .{</span>
<span class="line" id="L12434">                .operand = operand,</span>
<span class="line" id="L12435">                .src_node = gz.nodeIndexToRelative(src_node),</span>
<span class="line" id="L12436">            } },</span>
<span class="line" id="L12437">        });</span>
<span class="line" id="L12438">    }</span>
<span class="line" id="L12439"></span>
<span class="line" id="L12440">    <span class="tok-kw">fn</span> <span class="tok-fn">makeUnNode</span>(</span>
<span class="line" id="L12441">        gz: *GenZir,</span>
<span class="line" id="L12442">        tag: Zir.Inst.Tag,</span>
<span class="line" id="L12443">        operand: Zir.Inst.Ref,</span>
<span class="line" id="L12444">        <span class="tok-comment">/// Absolute node index. This function does the conversion to offset from Decl.</span></span>
<span class="line" id="L12445">        src_node: Ast.Node.Index,</span>
<span class="line" id="L12446">    ) !Zir.Inst.Index {</span>
<span class="line" id="L12447">        assert(operand != .none);</span>
<span class="line" id="L12448">        <span class="tok-kw">const</span> new_index: Zir.Inst.Index = <span class="tok-builtin">@enumFromInt</span>(gz.astgen.instructions.len);</span>
<span class="line" id="L12449">        <span class="tok-kw">try</span> gz.astgen.instructions.append(gz.astgen.gpa, .{</span>
<span class="line" id="L12450">            .tag = tag,</span>
<span class="line" id="L12451">            .data = .{ .un_node = .{</span>
<span class="line" id="L12452">                .operand = operand,</span>
<span class="line" id="L12453">                .src_node = gz.nodeIndexToRelative(src_node),</span>
<span class="line" id="L12454">            } },</span>
<span class="line" id="L12455">        });</span>
<span class="line" id="L12456">        <span class="tok-kw">return</span> new_index;</span>
<span class="line" id="L12457">    }</span>
<span class="line" id="L12458"></span>
<span class="line" id="L12459">    <span class="tok-kw">fn</span> <span class="tok-fn">addPlNode</span>(</span>
<span class="line" id="L12460">        gz: *GenZir,</span>
<span class="line" id="L12461">        tag: Zir.Inst.Tag,</span>
<span class="line" id="L12462">        <span class="tok-comment">/// Absolute node index. This function does the conversion to offset from Decl.</span></span>
<span class="line" id="L12463">        src_node: Ast.Node.Index,</span>
<span class="line" id="L12464">        extra: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L12465">    ) !Zir.Inst.Ref {</span>
<span class="line" id="L12466">        <span class="tok-kw">const</span> gpa = gz.astgen.gpa;</span>
<span class="line" id="L12467">        <span class="tok-kw">try</span> gz.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);</span>
<span class="line" id="L12468">        <span class="tok-kw">try</span> gz.astgen.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);</span>
<span class="line" id="L12469"></span>
<span class="line" id="L12470">        <span class="tok-kw">const</span> payload_index = <span class="tok-kw">try</span> gz.astgen.addExtra(extra);</span>
<span class="line" id="L12471">        <span class="tok-kw">const</span> new_index: Zir.Inst.Index = <span class="tok-builtin">@enumFromInt</span>(gz.astgen.instructions.len);</span>
<span class="line" id="L12472">        gz.astgen.instructions.appendAssumeCapacity(.{</span>
<span class="line" id="L12473">            .tag = tag,</span>
<span class="line" id="L12474">            .data = .{ .pl_node = .{</span>
<span class="line" id="L12475">                .src_node = gz.nodeIndexToRelative(src_node),</span>
<span class="line" id="L12476">                .payload_index = payload_index,</span>
<span class="line" id="L12477">            } },</span>
<span class="line" id="L12478">        });</span>
<span class="line" id="L12479">        gz.instructions.appendAssumeCapacity(new_index);</span>
<span class="line" id="L12480">        <span class="tok-kw">return</span> new_index.toRef();</span>
<span class="line" id="L12481">    }</span>
<span class="line" id="L12482"></span>
<span class="line" id="L12483">    <span class="tok-kw">fn</span> <span class="tok-fn">addPlNodePayloadIndex</span>(</span>
<span class="line" id="L12484">        gz: *GenZir,</span>
<span class="line" id="L12485">        tag: Zir.Inst.Tag,</span>
<span class="line" id="L12486">        <span class="tok-comment">/// Absolute node index. This function does the conversion to offset from Decl.</span></span>
<span class="line" id="L12487">        src_node: Ast.Node.Index,</span>
<span class="line" id="L12488">        payload_index: <span class="tok-type">u32</span>,</span>
<span class="line" id="L12489">    ) !Zir.Inst.Ref {</span>
<span class="line" id="L12490">        <span class="tok-kw">return</span> <span class="tok-kw">try</span> gz.add(.{</span>
<span class="line" id="L12491">            .tag = tag,</span>
<span class="line" id="L12492">            .data = .{ .pl_node = .{</span>
<span class="line" id="L12493">                .src_node = gz.nodeIndexToRelative(src_node),</span>
<span class="line" id="L12494">                .payload_index = payload_index,</span>
<span class="line" id="L12495">            } },</span>
<span class="line" id="L12496">        });</span>
<span class="line" id="L12497">    }</span>
<span class="line" id="L12498"></span>
<span class="line" id="L12499">    <span class="tok-comment">/// Supports `param_gz` stacked on `gz`. Assumes nothing stacked on `param_gz`. Unstacks `param_gz`.</span></span>
<span class="line" id="L12500">    <span class="tok-kw">fn</span> <span class="tok-fn">addParam</span>(</span>
<span class="line" id="L12501">        gz: *GenZir,</span>
<span class="line" id="L12502">        param_gz: *GenZir,</span>
<span class="line" id="L12503">        tag: Zir.Inst.Tag,</span>
<span class="line" id="L12504">        <span class="tok-comment">/// Absolute token index. This function does the conversion to Decl offset.</span></span>
<span class="line" id="L12505">        abs_tok_index: Ast.TokenIndex,</span>
<span class="line" id="L12506">        name: Zir.NullTerminatedString,</span>
<span class="line" id="L12507">        first_doc_comment: ?Ast.TokenIndex,</span>
<span class="line" id="L12508">    ) !Zir.Inst.Index {</span>
<span class="line" id="L12509">        <span class="tok-kw">const</span> gpa = gz.astgen.gpa;</span>
<span class="line" id="L12510">        <span class="tok-kw">const</span> param_body = param_gz.instructionsSlice();</span>
<span class="line" id="L12511">        <span class="tok-kw">const</span> body_len = gz.astgen.countBodyLenAfterFixups(param_body);</span>
<span class="line" id="L12512">        <span class="tok-kw">try</span> gz.astgen.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);</span>
<span class="line" id="L12513">        <span class="tok-kw">try</span> gz.astgen.extra.ensureUnusedCapacity(gpa, <span class="tok-builtin">@typeInfo</span>(Zir.Inst.Param).Struct.fields.len + body_len);</span>
<span class="line" id="L12514"></span>
<span class="line" id="L12515">        <span class="tok-kw">const</span> doc_comment_index = <span class="tok-kw">if</span> (first_doc_comment) |first|</span>
<span class="line" id="L12516">            <span class="tok-kw">try</span> gz.astgen.docCommentAsStringFromFirst(abs_tok_index, first)</span>
<span class="line" id="L12517">        <span class="tok-kw">else</span></span>
<span class="line" id="L12518">            .empty;</span>
<span class="line" id="L12519"></span>
<span class="line" id="L12520">        <span class="tok-kw">const</span> payload_index = gz.astgen.addExtraAssumeCapacity(Zir.Inst.Param{</span>
<span class="line" id="L12521">            .name = name,</span>
<span class="line" id="L12522">            .doc_comment = doc_comment_index,</span>
<span class="line" id="L12523">            .body_len = <span class="tok-builtin">@intCast</span>(body_len),</span>
<span class="line" id="L12524">        });</span>
<span class="line" id="L12525">        gz.astgen.appendBodyWithFixups(param_body);</span>
<span class="line" id="L12526">        param_gz.unstack();</span>
<span class="line" id="L12527"></span>
<span class="line" id="L12528">        <span class="tok-kw">const</span> new_index: Zir.Inst.Index = <span class="tok-builtin">@enumFromInt</span>(gz.astgen.instructions.len);</span>
<span class="line" id="L12529">        gz.astgen.instructions.appendAssumeCapacity(.{</span>
<span class="line" id="L12530">            .tag = tag,</span>
<span class="line" id="L12531">            .data = .{ .pl_tok = .{</span>
<span class="line" id="L12532">                .src_tok = gz.tokenIndexToRelative(abs_tok_index),</span>
<span class="line" id="L12533">                .payload_index = payload_index,</span>
<span class="line" id="L12534">            } },</span>
<span class="line" id="L12535">        });</span>
<span class="line" id="L12536">        gz.instructions.appendAssumeCapacity(new_index);</span>
<span class="line" id="L12537">        <span class="tok-kw">return</span> new_index;</span>
<span class="line" id="L12538">    }</span>
<span class="line" id="L12539"></span>
<span class="line" id="L12540">    <span class="tok-kw">fn</span> <span class="tok-fn">addExtendedPayload</span>(gz: *GenZir, opcode: Zir.Inst.Extended, extra: <span class="tok-kw">anytype</span>) !Zir.Inst.Ref {</span>
<span class="line" id="L12541">        <span class="tok-kw">return</span> addExtendedPayloadSmall(gz, opcode, <span class="tok-null">undefined</span>, extra);</span>
<span class="line" id="L12542">    }</span>
<span class="line" id="L12543"></span>
<span class="line" id="L12544">    <span class="tok-kw">fn</span> <span class="tok-fn">addExtendedPayloadSmall</span>(</span>
<span class="line" id="L12545">        gz: *GenZir,</span>
<span class="line" id="L12546">        opcode: Zir.Inst.Extended,</span>
<span class="line" id="L12547">        small: <span class="tok-type">u16</span>,</span>
<span class="line" id="L12548">        extra: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L12549">    ) !Zir.Inst.Ref {</span>
<span class="line" id="L12550">        <span class="tok-kw">const</span> gpa = gz.astgen.gpa;</span>
<span class="line" id="L12551"></span>
<span class="line" id="L12552">        <span class="tok-kw">try</span> gz.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);</span>
<span class="line" id="L12553">        <span class="tok-kw">try</span> gz.astgen.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);</span>
<span class="line" id="L12554"></span>
<span class="line" id="L12555">        <span class="tok-kw">const</span> payload_index = <span class="tok-kw">try</span> gz.astgen.addExtra(extra);</span>
<span class="line" id="L12556">        <span class="tok-kw">const</span> new_index: Zir.Inst.Index = <span class="tok-builtin">@enumFromInt</span>(gz.astgen.instructions.len);</span>
<span class="line" id="L12557">        gz.astgen.instructions.appendAssumeCapacity(.{</span>
<span class="line" id="L12558">            .tag = .extended,</span>
<span class="line" id="L12559">            .data = .{ .extended = .{</span>
<span class="line" id="L12560">                .opcode = opcode,</span>
<span class="line" id="L12561">                .small = small,</span>
<span class="line" id="L12562">                .operand = payload_index,</span>
<span class="line" id="L12563">            } },</span>
<span class="line" id="L12564">        });</span>
<span class="line" id="L12565">        gz.instructions.appendAssumeCapacity(new_index);</span>
<span class="line" id="L12566">        <span class="tok-kw">return</span> new_index.toRef();</span>
<span class="line" id="L12567">    }</span>
<span class="line" id="L12568"></span>
<span class="line" id="L12569">    <span class="tok-kw">fn</span> <span class="tok-fn">addExtendedMultiOp</span>(</span>
<span class="line" id="L12570">        gz: *GenZir,</span>
<span class="line" id="L12571">        opcode: Zir.Inst.Extended,</span>
<span class="line" id="L12572">        node: Ast.Node.Index,</span>
<span class="line" id="L12573">        operands: []<span class="tok-kw">const</span> Zir.Inst.Ref,</span>
<span class="line" id="L12574">    ) !Zir.Inst.Ref {</span>
<span class="line" id="L12575">        <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L12576">        <span class="tok-kw">const</span> gpa = astgen.gpa;</span>
<span class="line" id="L12577"></span>
<span class="line" id="L12578">        <span class="tok-kw">try</span> gz.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);</span>
<span class="line" id="L12579">        <span class="tok-kw">try</span> astgen.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);</span>
<span class="line" id="L12580">        <span class="tok-kw">try</span> astgen.extra.ensureUnusedCapacity(</span>
<span class="line" id="L12581">            gpa,</span>
<span class="line" id="L12582">            <span class="tok-builtin">@typeInfo</span>(Zir.Inst.NodeMultiOp).Struct.fields.len + operands.len,</span>
<span class="line" id="L12583">        );</span>
<span class="line" id="L12584"></span>
<span class="line" id="L12585">        <span class="tok-kw">const</span> payload_index = astgen.addExtraAssumeCapacity(Zir.Inst.NodeMultiOp{</span>
<span class="line" id="L12586">            .src_node = gz.nodeIndexToRelative(node),</span>
<span class="line" id="L12587">        });</span>
<span class="line" id="L12588">        <span class="tok-kw">const</span> new_index: Zir.Inst.Index = <span class="tok-builtin">@enumFromInt</span>(astgen.instructions.len);</span>
<span class="line" id="L12589">        astgen.instructions.appendAssumeCapacity(.{</span>
<span class="line" id="L12590">            .tag = .extended,</span>
<span class="line" id="L12591">            .data = .{ .extended = .{</span>
<span class="line" id="L12592">                .opcode = opcode,</span>
<span class="line" id="L12593">                .small = <span class="tok-builtin">@intCast</span>(operands.len),</span>
<span class="line" id="L12594">                .operand = payload_index,</span>
<span class="line" id="L12595">            } },</span>
<span class="line" id="L12596">        });</span>
<span class="line" id="L12597">        gz.instructions.appendAssumeCapacity(new_index);</span>
<span class="line" id="L12598">        astgen.appendRefsAssumeCapacity(operands);</span>
<span class="line" id="L12599">        <span class="tok-kw">return</span> new_index.toRef();</span>
<span class="line" id="L12600">    }</span>
<span class="line" id="L12601"></span>
<span class="line" id="L12602">    <span class="tok-kw">fn</span> <span class="tok-fn">addExtendedMultiOpPayloadIndex</span>(</span>
<span class="line" id="L12603">        gz: *GenZir,</span>
<span class="line" id="L12604">        opcode: Zir.Inst.Extended,</span>
<span class="line" id="L12605">        payload_index: <span class="tok-type">u32</span>,</span>
<span class="line" id="L12606">        trailing_len: <span class="tok-type">usize</span>,</span>
<span class="line" id="L12607">    ) !Zir.Inst.Ref {</span>
<span class="line" id="L12608">        <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L12609">        <span class="tok-kw">const</span> gpa = astgen.gpa;</span>
<span class="line" id="L12610"></span>
<span class="line" id="L12611">        <span class="tok-kw">try</span> gz.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);</span>
<span class="line" id="L12612">        <span class="tok-kw">try</span> astgen.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);</span>
<span class="line" id="L12613">        <span class="tok-kw">const</span> new_index: Zir.Inst.Index = <span class="tok-builtin">@enumFromInt</span>(astgen.instructions.len);</span>
<span class="line" id="L12614">        astgen.instructions.appendAssumeCapacity(.{</span>
<span class="line" id="L12615">            .tag = .extended,</span>
<span class="line" id="L12616">            .data = .{ .extended = .{</span>
<span class="line" id="L12617">                .opcode = opcode,</span>
<span class="line" id="L12618">                .small = <span class="tok-builtin">@intCast</span>(trailing_len),</span>
<span class="line" id="L12619">                .operand = payload_index,</span>
<span class="line" id="L12620">            } },</span>
<span class="line" id="L12621">        });</span>
<span class="line" id="L12622">        gz.instructions.appendAssumeCapacity(new_index);</span>
<span class="line" id="L12623">        <span class="tok-kw">return</span> new_index.toRef();</span>
<span class="line" id="L12624">    }</span>
<span class="line" id="L12625"></span>
<span class="line" id="L12626">    <span class="tok-kw">fn</span> <span class="tok-fn">addExtendedNodeSmall</span>(</span>
<span class="line" id="L12627">        gz: *GenZir,</span>
<span class="line" id="L12628">        opcode: Zir.Inst.Extended,</span>
<span class="line" id="L12629">        src_node: Ast.Node.Index,</span>
<span class="line" id="L12630">        small: <span class="tok-type">u16</span>,</span>
<span class="line" id="L12631">    ) !Zir.Inst.Ref {</span>
<span class="line" id="L12632">        <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L12633">        <span class="tok-kw">const</span> gpa = astgen.gpa;</span>
<span class="line" id="L12634"></span>
<span class="line" id="L12635">        <span class="tok-kw">try</span> gz.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);</span>
<span class="line" id="L12636">        <span class="tok-kw">try</span> astgen.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);</span>
<span class="line" id="L12637">        <span class="tok-kw">const</span> new_index: Zir.Inst.Index = <span class="tok-builtin">@enumFromInt</span>(astgen.instructions.len);</span>
<span class="line" id="L12638">        astgen.instructions.appendAssumeCapacity(.{</span>
<span class="line" id="L12639">            .tag = .extended,</span>
<span class="line" id="L12640">            .data = .{ .extended = .{</span>
<span class="line" id="L12641">                .opcode = opcode,</span>
<span class="line" id="L12642">                .small = small,</span>
<span class="line" id="L12643">                .operand = <span class="tok-builtin">@bitCast</span>(gz.nodeIndexToRelative(src_node)),</span>
<span class="line" id="L12644">            } },</span>
<span class="line" id="L12645">        });</span>
<span class="line" id="L12646">        gz.instructions.appendAssumeCapacity(new_index);</span>
<span class="line" id="L12647">        <span class="tok-kw">return</span> new_index.toRef();</span>
<span class="line" id="L12648">    }</span>
<span class="line" id="L12649"></span>
<span class="line" id="L12650">    <span class="tok-kw">fn</span> <span class="tok-fn">addUnTok</span>(</span>
<span class="line" id="L12651">        gz: *GenZir,</span>
<span class="line" id="L12652">        tag: Zir.Inst.Tag,</span>
<span class="line" id="L12653">        operand: Zir.Inst.Ref,</span>
<span class="line" id="L12654">        <span class="tok-comment">/// Absolute token index. This function does the conversion to Decl offset.</span></span>
<span class="line" id="L12655">        abs_tok_index: Ast.TokenIndex,</span>
<span class="line" id="L12656">    ) !Zir.Inst.Ref {</span>
<span class="line" id="L12657">        assert(operand != .none);</span>
<span class="line" id="L12658">        <span class="tok-kw">return</span> gz.add(.{</span>
<span class="line" id="L12659">            .tag = tag,</span>
<span class="line" id="L12660">            .data = .{ .un_tok = .{</span>
<span class="line" id="L12661">                .operand = operand,</span>
<span class="line" id="L12662">                .src_tok = gz.tokenIndexToRelative(abs_tok_index),</span>
<span class="line" id="L12663">            } },</span>
<span class="line" id="L12664">        });</span>
<span class="line" id="L12665">    }</span>
<span class="line" id="L12666"></span>
<span class="line" id="L12667">    <span class="tok-kw">fn</span> <span class="tok-fn">makeUnTok</span>(</span>
<span class="line" id="L12668">        gz: *GenZir,</span>
<span class="line" id="L12669">        tag: Zir.Inst.Tag,</span>
<span class="line" id="L12670">        operand: Zir.Inst.Ref,</span>
<span class="line" id="L12671">        <span class="tok-comment">/// Absolute token index. This function does the conversion to Decl offset.</span></span>
<span class="line" id="L12672">        abs_tok_index: Ast.TokenIndex,</span>
<span class="line" id="L12673">    ) !Zir.Inst.Index {</span>
<span class="line" id="L12674">        <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L12675">        <span class="tok-kw">const</span> new_index: Zir.Inst.Index = <span class="tok-builtin">@enumFromInt</span>(astgen.instructions.len);</span>
<span class="line" id="L12676">        assert(operand != .none);</span>
<span class="line" id="L12677">        <span class="tok-kw">try</span> astgen.instructions.append(astgen.gpa, .{</span>
<span class="line" id="L12678">            .tag = tag,</span>
<span class="line" id="L12679">            .data = .{ .un_tok = .{</span>
<span class="line" id="L12680">                .operand = operand,</span>
<span class="line" id="L12681">                .src_tok = gz.tokenIndexToRelative(abs_tok_index),</span>
<span class="line" id="L12682">            } },</span>
<span class="line" id="L12683">        });</span>
<span class="line" id="L12684">        <span class="tok-kw">return</span> new_index;</span>
<span class="line" id="L12685">    }</span>
<span class="line" id="L12686"></span>
<span class="line" id="L12687">    <span class="tok-kw">fn</span> <span class="tok-fn">addStrTok</span>(</span>
<span class="line" id="L12688">        gz: *GenZir,</span>
<span class="line" id="L12689">        tag: Zir.Inst.Tag,</span>
<span class="line" id="L12690">        str_index: Zir.NullTerminatedString,</span>
<span class="line" id="L12691">        <span class="tok-comment">/// Absolute token index. This function does the conversion to Decl offset.</span></span>
<span class="line" id="L12692">        abs_tok_index: Ast.TokenIndex,</span>
<span class="line" id="L12693">    ) !Zir.Inst.Ref {</span>
<span class="line" id="L12694">        <span class="tok-kw">return</span> gz.add(.{</span>
<span class="line" id="L12695">            .tag = tag,</span>
<span class="line" id="L12696">            .data = .{ .str_tok = .{</span>
<span class="line" id="L12697">                .start = str_index,</span>
<span class="line" id="L12698">                .src_tok = gz.tokenIndexToRelative(abs_tok_index),</span>
<span class="line" id="L12699">            } },</span>
<span class="line" id="L12700">        });</span>
<span class="line" id="L12701">    }</span>
<span class="line" id="L12702"></span>
<span class="line" id="L12703">    <span class="tok-kw">fn</span> <span class="tok-fn">addSaveErrRetIndex</span>(</span>
<span class="line" id="L12704">        gz: *GenZir,</span>
<span class="line" id="L12705">        cond: <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {</span>
<span class="line" id="L12706">            always: <span class="tok-type">void</span>,</span>
<span class="line" id="L12707">            if_of_error_type: Zir.Inst.Ref,</span>
<span class="line" id="L12708">        },</span>
<span class="line" id="L12709">    ) !Zir.Inst.Index {</span>
<span class="line" id="L12710">        <span class="tok-kw">return</span> gz.addAsIndex(.{</span>
<span class="line" id="L12711">            .tag = .save_err_ret_index,</span>
<span class="line" id="L12712">            .data = .{ .save_err_ret_index = .{</span>
<span class="line" id="L12713">                .operand = <span class="tok-kw">switch</span> (cond) {</span>
<span class="line" id="L12714">                    .if_of_error_type =&gt; |x| x,</span>
<span class="line" id="L12715">                    <span class="tok-kw">else</span> =&gt; .none,</span>
<span class="line" id="L12716">                },</span>
<span class="line" id="L12717">            } },</span>
<span class="line" id="L12718">        });</span>
<span class="line" id="L12719">    }</span>
<span class="line" id="L12720"></span>
<span class="line" id="L12721">    <span class="tok-kw">const</span> BranchTarget = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {</span>
<span class="line" id="L12722">        ret,</span>
<span class="line" id="L12723">        block: Zir.Inst.Index,</span>
<span class="line" id="L12724">    };</span>
<span class="line" id="L12725"></span>
<span class="line" id="L12726">    <span class="tok-kw">fn</span> <span class="tok-fn">addRestoreErrRetIndex</span>(</span>
<span class="line" id="L12727">        gz: *GenZir,</span>
<span class="line" id="L12728">        bt: BranchTarget,</span>
<span class="line" id="L12729">        cond: <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {</span>
<span class="line" id="L12730">            always: <span class="tok-type">void</span>,</span>
<span class="line" id="L12731">            if_non_error: Zir.Inst.Ref,</span>
<span class="line" id="L12732">        },</span>
<span class="line" id="L12733">        src_node: Ast.Node.Index,</span>
<span class="line" id="L12734">    ) !Zir.Inst.Index {</span>
<span class="line" id="L12735">        <span class="tok-kw">switch</span> (cond) {</span>
<span class="line" id="L12736">            .always =&gt; <span class="tok-kw">return</span> gz.addAsIndex(.{</span>
<span class="line" id="L12737">                .tag = .restore_err_ret_index_unconditional,</span>
<span class="line" id="L12738">                .data = .{ .un_node = .{</span>
<span class="line" id="L12739">                    .operand = <span class="tok-kw">switch</span> (bt) {</span>
<span class="line" id="L12740">                        .ret =&gt; .none,</span>
<span class="line" id="L12741">                        .block =&gt; |b| b.toRef(),</span>
<span class="line" id="L12742">                    },</span>
<span class="line" id="L12743">                    .src_node = gz.nodeIndexToRelative(src_node),</span>
<span class="line" id="L12744">                } },</span>
<span class="line" id="L12745">            }),</span>
<span class="line" id="L12746">            .if_non_error =&gt; |operand| <span class="tok-kw">switch</span> (bt) {</span>
<span class="line" id="L12747">                .ret =&gt; <span class="tok-kw">return</span> gz.addAsIndex(.{</span>
<span class="line" id="L12748">                    .tag = .restore_err_ret_index_fn_entry,</span>
<span class="line" id="L12749">                    .data = .{ .un_node = .{</span>
<span class="line" id="L12750">                        .operand = operand,</span>
<span class="line" id="L12751">                        .src_node = gz.nodeIndexToRelative(src_node),</span>
<span class="line" id="L12752">                    } },</span>
<span class="line" id="L12753">                }),</span>
<span class="line" id="L12754">                .block =&gt; |block| <span class="tok-kw">return</span> (<span class="tok-kw">try</span> gz.addExtendedPayload(</span>
<span class="line" id="L12755">                    .restore_err_ret_index,</span>
<span class="line" id="L12756">                    Zir.Inst.RestoreErrRetIndex{</span>
<span class="line" id="L12757">                        .src_node = gz.nodeIndexToRelative(src_node),</span>
<span class="line" id="L12758">                        .block = block.toRef(),</span>
<span class="line" id="L12759">                        .operand = operand,</span>
<span class="line" id="L12760">                    },</span>
<span class="line" id="L12761">                )).toIndex().?,</span>
<span class="line" id="L12762">            },</span>
<span class="line" id="L12763">        }</span>
<span class="line" id="L12764">    }</span>
<span class="line" id="L12765"></span>
<span class="line" id="L12766">    <span class="tok-kw">fn</span> <span class="tok-fn">addBreak</span>(</span>
<span class="line" id="L12767">        gz: *GenZir,</span>
<span class="line" id="L12768">        tag: Zir.Inst.Tag,</span>
<span class="line" id="L12769">        block_inst: Zir.Inst.Index,</span>
<span class="line" id="L12770">        operand: Zir.Inst.Ref,</span>
<span class="line" id="L12771">    ) !Zir.Inst.Index {</span>
<span class="line" id="L12772">        <span class="tok-kw">const</span> gpa = gz.astgen.gpa;</span>
<span class="line" id="L12773">        <span class="tok-kw">try</span> gz.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);</span>
<span class="line" id="L12774"></span>
<span class="line" id="L12775">        <span class="tok-kw">const</span> new_index = <span class="tok-kw">try</span> gz.makeBreak(tag, block_inst, operand);</span>
<span class="line" id="L12776">        gz.instructions.appendAssumeCapacity(new_index);</span>
<span class="line" id="L12777">        <span class="tok-kw">return</span> new_index;</span>
<span class="line" id="L12778">    }</span>
<span class="line" id="L12779"></span>
<span class="line" id="L12780">    <span class="tok-kw">fn</span> <span class="tok-fn">makeBreak</span>(</span>
<span class="line" id="L12781">        gz: *GenZir,</span>
<span class="line" id="L12782">        tag: Zir.Inst.Tag,</span>
<span class="line" id="L12783">        block_inst: Zir.Inst.Index,</span>
<span class="line" id="L12784">        operand: Zir.Inst.Ref,</span>
<span class="line" id="L12785">    ) !Zir.Inst.Index {</span>
<span class="line" id="L12786">        <span class="tok-kw">return</span> gz.makeBreakCommon(tag, block_inst, operand, <span class="tok-null">null</span>);</span>
<span class="line" id="L12787">    }</span>
<span class="line" id="L12788"></span>
<span class="line" id="L12789">    <span class="tok-kw">fn</span> <span class="tok-fn">addBreakWithSrcNode</span>(</span>
<span class="line" id="L12790">        gz: *GenZir,</span>
<span class="line" id="L12791">        tag: Zir.Inst.Tag,</span>
<span class="line" id="L12792">        block_inst: Zir.Inst.Index,</span>
<span class="line" id="L12793">        operand: Zir.Inst.Ref,</span>
<span class="line" id="L12794">        operand_src_node: Ast.Node.Index,</span>
<span class="line" id="L12795">    ) !Zir.Inst.Index {</span>
<span class="line" id="L12796">        <span class="tok-kw">const</span> gpa = gz.astgen.gpa;</span>
<span class="line" id="L12797">        <span class="tok-kw">try</span> gz.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);</span>
<span class="line" id="L12798"></span>
<span class="line" id="L12799">        <span class="tok-kw">const</span> new_index = <span class="tok-kw">try</span> gz.makeBreakWithSrcNode(tag, block_inst, operand, operand_src_node);</span>
<span class="line" id="L12800">        gz.instructions.appendAssumeCapacity(new_index);</span>
<span class="line" id="L12801">        <span class="tok-kw">return</span> new_index;</span>
<span class="line" id="L12802">    }</span>
<span class="line" id="L12803"></span>
<span class="line" id="L12804">    <span class="tok-kw">fn</span> <span class="tok-fn">makeBreakWithSrcNode</span>(</span>
<span class="line" id="L12805">        gz: *GenZir,</span>
<span class="line" id="L12806">        tag: Zir.Inst.Tag,</span>
<span class="line" id="L12807">        block_inst: Zir.Inst.Index,</span>
<span class="line" id="L12808">        operand: Zir.Inst.Ref,</span>
<span class="line" id="L12809">        operand_src_node: Ast.Node.Index,</span>
<span class="line" id="L12810">    ) !Zir.Inst.Index {</span>
<span class="line" id="L12811">        <span class="tok-kw">return</span> gz.makeBreakCommon(tag, block_inst, operand, operand_src_node);</span>
<span class="line" id="L12812">    }</span>
<span class="line" id="L12813"></span>
<span class="line" id="L12814">    <span class="tok-kw">fn</span> <span class="tok-fn">makeBreakCommon</span>(</span>
<span class="line" id="L12815">        gz: *GenZir,</span>
<span class="line" id="L12816">        tag: Zir.Inst.Tag,</span>
<span class="line" id="L12817">        block_inst: Zir.Inst.Index,</span>
<span class="line" id="L12818">        operand: Zir.Inst.Ref,</span>
<span class="line" id="L12819">        operand_src_node: ?Ast.Node.Index,</span>
<span class="line" id="L12820">    ) !Zir.Inst.Index {</span>
<span class="line" id="L12821">        <span class="tok-kw">const</span> gpa = gz.astgen.gpa;</span>
<span class="line" id="L12822">        <span class="tok-kw">try</span> gz.astgen.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);</span>
<span class="line" id="L12823">        <span class="tok-kw">try</span> gz.astgen.extra.ensureUnusedCapacity(gpa, <span class="tok-builtin">@typeInfo</span>(Zir.Inst.Break).Struct.fields.len);</span>
<span class="line" id="L12824"></span>
<span class="line" id="L12825">        <span class="tok-kw">const</span> new_index: Zir.Inst.Index = <span class="tok-builtin">@enumFromInt</span>(gz.astgen.instructions.len);</span>
<span class="line" id="L12826">        gz.astgen.instructions.appendAssumeCapacity(.{</span>
<span class="line" id="L12827">            .tag = tag,</span>
<span class="line" id="L12828">            .data = .{ .@&quot;break&quot; = .{</span>
<span class="line" id="L12829">                .operand = operand,</span>
<span class="line" id="L12830">                .payload_index = gz.astgen.addExtraAssumeCapacity(Zir.Inst.Break{</span>
<span class="line" id="L12831">                    .operand_src_node = <span class="tok-kw">if</span> (operand_src_node) |src_node|</span>
<span class="line" id="L12832">                        gz.nodeIndexToRelative(src_node)</span>
<span class="line" id="L12833">                    <span class="tok-kw">else</span></span>
<span class="line" id="L12834">                        Zir.Inst.Break.no_src_node,</span>
<span class="line" id="L12835">                    .block_inst = block_inst,</span>
<span class="line" id="L12836">                }),</span>
<span class="line" id="L12837">            } },</span>
<span class="line" id="L12838">        });</span>
<span class="line" id="L12839">        <span class="tok-kw">return</span> new_index;</span>
<span class="line" id="L12840">    }</span>
<span class="line" id="L12841"></span>
<span class="line" id="L12842">    <span class="tok-kw">fn</span> <span class="tok-fn">addBin</span>(</span>
<span class="line" id="L12843">        gz: *GenZir,</span>
<span class="line" id="L12844">        tag: Zir.Inst.Tag,</span>
<span class="line" id="L12845">        lhs: Zir.Inst.Ref,</span>
<span class="line" id="L12846">        rhs: Zir.Inst.Ref,</span>
<span class="line" id="L12847">    ) !Zir.Inst.Ref {</span>
<span class="line" id="L12848">        assert(lhs != .none);</span>
<span class="line" id="L12849">        assert(rhs != .none);</span>
<span class="line" id="L12850">        <span class="tok-kw">return</span> gz.add(.{</span>
<span class="line" id="L12851">            .tag = tag,</span>
<span class="line" id="L12852">            .data = .{ .bin = .{</span>
<span class="line" id="L12853">                .lhs = lhs,</span>
<span class="line" id="L12854">                .rhs = rhs,</span>
<span class="line" id="L12855">            } },</span>
<span class="line" id="L12856">        });</span>
<span class="line" id="L12857">    }</span>
<span class="line" id="L12858"></span>
<span class="line" id="L12859">    <span class="tok-kw">fn</span> <span class="tok-fn">addDefer</span>(gz: *GenZir, index: <span class="tok-type">u32</span>, len: <span class="tok-type">u32</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L12860">        _ = <span class="tok-kw">try</span> gz.add(.{</span>
<span class="line" id="L12861">            .tag = .@&quot;defer&quot;,</span>
<span class="line" id="L12862">            .data = .{ .@&quot;defer&quot; = .{</span>
<span class="line" id="L12863">                .index = index,</span>
<span class="line" id="L12864">                .len = len,</span>
<span class="line" id="L12865">            } },</span>
<span class="line" id="L12866">        });</span>
<span class="line" id="L12867">    }</span>
<span class="line" id="L12868"></span>
<span class="line" id="L12869">    <span class="tok-kw">fn</span> <span class="tok-fn">addDecl</span>(</span>
<span class="line" id="L12870">        gz: *GenZir,</span>
<span class="line" id="L12871">        tag: Zir.Inst.Tag,</span>
<span class="line" id="L12872">        decl_index: <span class="tok-type">u32</span>,</span>
<span class="line" id="L12873">        src_node: Ast.Node.Index,</span>
<span class="line" id="L12874">    ) !Zir.Inst.Ref {</span>
<span class="line" id="L12875">        <span class="tok-kw">return</span> gz.add(.{</span>
<span class="line" id="L12876">            .tag = tag,</span>
<span class="line" id="L12877">            .data = .{ .pl_node = .{</span>
<span class="line" id="L12878">                .src_node = gz.nodeIndexToRelative(src_node),</span>
<span class="line" id="L12879">                .payload_index = decl_index,</span>
<span class="line" id="L12880">            } },</span>
<span class="line" id="L12881">        });</span>
<span class="line" id="L12882">    }</span>
<span class="line" id="L12883"></span>
<span class="line" id="L12884">    <span class="tok-kw">fn</span> <span class="tok-fn">addNode</span>(</span>
<span class="line" id="L12885">        gz: *GenZir,</span>
<span class="line" id="L12886">        tag: Zir.Inst.Tag,</span>
<span class="line" id="L12887">        <span class="tok-comment">/// Absolute node index. This function does the conversion to offset from Decl.</span></span>
<span class="line" id="L12888">        src_node: Ast.Node.Index,</span>
<span class="line" id="L12889">    ) !Zir.Inst.Ref {</span>
<span class="line" id="L12890">        <span class="tok-kw">return</span> gz.add(.{</span>
<span class="line" id="L12891">            .tag = tag,</span>
<span class="line" id="L12892">            .data = .{ .node = gz.nodeIndexToRelative(src_node) },</span>
<span class="line" id="L12893">        });</span>
<span class="line" id="L12894">    }</span>
<span class="line" id="L12895"></span>
<span class="line" id="L12896">    <span class="tok-kw">fn</span> <span class="tok-fn">addInstNode</span>(</span>
<span class="line" id="L12897">        gz: *GenZir,</span>
<span class="line" id="L12898">        tag: Zir.Inst.Tag,</span>
<span class="line" id="L12899">        inst: Zir.Inst.Index,</span>
<span class="line" id="L12900">        <span class="tok-comment">/// Absolute node index. This function does the conversion to offset from Decl.</span></span>
<span class="line" id="L12901">        src_node: Ast.Node.Index,</span>
<span class="line" id="L12902">    ) !Zir.Inst.Ref {</span>
<span class="line" id="L12903">        <span class="tok-kw">return</span> gz.add(.{</span>
<span class="line" id="L12904">            .tag = tag,</span>
<span class="line" id="L12905">            .data = .{ .inst_node = .{</span>
<span class="line" id="L12906">                .inst = inst,</span>
<span class="line" id="L12907">                .src_node = gz.nodeIndexToRelative(src_node),</span>
<span class="line" id="L12908">            } },</span>
<span class="line" id="L12909">        });</span>
<span class="line" id="L12910">    }</span>
<span class="line" id="L12911"></span>
<span class="line" id="L12912">    <span class="tok-kw">fn</span> <span class="tok-fn">addNodeExtended</span>(</span>
<span class="line" id="L12913">        gz: *GenZir,</span>
<span class="line" id="L12914">        opcode: Zir.Inst.Extended,</span>
<span class="line" id="L12915">        <span class="tok-comment">/// Absolute node index. This function does the conversion to offset from Decl.</span></span>
<span class="line" id="L12916">        src_node: Ast.Node.Index,</span>
<span class="line" id="L12917">    ) !Zir.Inst.Ref {</span>
<span class="line" id="L12918">        <span class="tok-kw">return</span> gz.add(.{</span>
<span class="line" id="L12919">            .tag = .extended,</span>
<span class="line" id="L12920">            .data = .{ .extended = .{</span>
<span class="line" id="L12921">                .opcode = opcode,</span>
<span class="line" id="L12922">                .small = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L12923">                .operand = <span class="tok-builtin">@bitCast</span>(gz.nodeIndexToRelative(src_node)),</span>
<span class="line" id="L12924">            } },</span>
<span class="line" id="L12925">        });</span>
<span class="line" id="L12926">    }</span>
<span class="line" id="L12927"></span>
<span class="line" id="L12928">    <span class="tok-kw">fn</span> <span class="tok-fn">addAllocExtended</span>(</span>
<span class="line" id="L12929">        gz: *GenZir,</span>
<span class="line" id="L12930">        args: <span class="tok-kw">struct</span> {</span>
<span class="line" id="L12931">            <span class="tok-comment">/// Absolute node index. This function does the conversion to offset from Decl.</span></span>
<span class="line" id="L12932">            node: Ast.Node.Index,</span>
<span class="line" id="L12933">            type_inst: Zir.Inst.Ref,</span>
<span class="line" id="L12934">            align_inst: Zir.Inst.Ref,</span>
<span class="line" id="L12935">            is_const: <span class="tok-type">bool</span>,</span>
<span class="line" id="L12936">            is_comptime: <span class="tok-type">bool</span>,</span>
<span class="line" id="L12937">        },</span>
<span class="line" id="L12938">    ) !Zir.Inst.Ref {</span>
<span class="line" id="L12939">        <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L12940">        <span class="tok-kw">const</span> gpa = astgen.gpa;</span>
<span class="line" id="L12941"></span>
<span class="line" id="L12942">        <span class="tok-kw">try</span> gz.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);</span>
<span class="line" id="L12943">        <span class="tok-kw">try</span> astgen.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);</span>
<span class="line" id="L12944">        <span class="tok-kw">try</span> astgen.extra.ensureUnusedCapacity(</span>
<span class="line" id="L12945">            gpa,</span>
<span class="line" id="L12946">            <span class="tok-builtin">@typeInfo</span>(Zir.Inst.AllocExtended).Struct.fields.len +</span>
<span class="line" id="L12947">                <span class="tok-builtin">@intFromBool</span>(args.type_inst != .none) +</span>
<span class="line" id="L12948">                <span class="tok-builtin">@intFromBool</span>(args.align_inst != .none),</span>
<span class="line" id="L12949">        );</span>
<span class="line" id="L12950">        <span class="tok-kw">const</span> payload_index = gz.astgen.addExtraAssumeCapacity(Zir.Inst.AllocExtended{</span>
<span class="line" id="L12951">            .src_node = gz.nodeIndexToRelative(args.node),</span>
<span class="line" id="L12952">        });</span>
<span class="line" id="L12953">        <span class="tok-kw">if</span> (args.type_inst != .none) {</span>
<span class="line" id="L12954">            astgen.extra.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(args.type_inst));</span>
<span class="line" id="L12955">        }</span>
<span class="line" id="L12956">        <span class="tok-kw">if</span> (args.align_inst != .none) {</span>
<span class="line" id="L12957">            astgen.extra.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(args.align_inst));</span>
<span class="line" id="L12958">        }</span>
<span class="line" id="L12959"></span>
<span class="line" id="L12960">        <span class="tok-kw">const</span> has_type: <span class="tok-type">u4</span> = <span class="tok-builtin">@intFromBool</span>(args.type_inst != .none);</span>
<span class="line" id="L12961">        <span class="tok-kw">const</span> has_align: <span class="tok-type">u4</span> = <span class="tok-builtin">@intFromBool</span>(args.align_inst != .none);</span>
<span class="line" id="L12962">        <span class="tok-kw">const</span> is_const: <span class="tok-type">u4</span> = <span class="tok-builtin">@intFromBool</span>(args.is_const);</span>
<span class="line" id="L12963">        <span class="tok-kw">const</span> is_comptime: <span class="tok-type">u4</span> = <span class="tok-builtin">@intFromBool</span>(args.is_comptime);</span>
<span class="line" id="L12964">        <span class="tok-kw">const</span> small: <span class="tok-type">u16</span> = has_type | (has_align &lt;&lt; <span class="tok-number">1</span>) | (is_const &lt;&lt; <span class="tok-number">2</span>) | (is_comptime &lt;&lt; <span class="tok-number">3</span>);</span>
<span class="line" id="L12965"></span>
<span class="line" id="L12966">        <span class="tok-kw">const</span> new_index: Zir.Inst.Index = <span class="tok-builtin">@enumFromInt</span>(astgen.instructions.len);</span>
<span class="line" id="L12967">        astgen.instructions.appendAssumeCapacity(.{</span>
<span class="line" id="L12968">            .tag = .extended,</span>
<span class="line" id="L12969">            .data = .{ .extended = .{</span>
<span class="line" id="L12970">                .opcode = .alloc,</span>
<span class="line" id="L12971">                .small = small,</span>
<span class="line" id="L12972">                .operand = payload_index,</span>
<span class="line" id="L12973">            } },</span>
<span class="line" id="L12974">        });</span>
<span class="line" id="L12975">        gz.instructions.appendAssumeCapacity(new_index);</span>
<span class="line" id="L12976">        <span class="tok-kw">return</span> new_index.toRef();</span>
<span class="line" id="L12977">    }</span>
<span class="line" id="L12978"></span>
<span class="line" id="L12979">    <span class="tok-kw">fn</span> <span class="tok-fn">addAsm</span>(</span>
<span class="line" id="L12980">        gz: *GenZir,</span>
<span class="line" id="L12981">        args: <span class="tok-kw">struct</span> {</span>
<span class="line" id="L12982">            tag: Zir.Inst.Extended,</span>
<span class="line" id="L12983">            <span class="tok-comment">/// Absolute node index. This function does the conversion to offset from Decl.</span></span>
<span class="line" id="L12984">            node: Ast.Node.Index,</span>
<span class="line" id="L12985">            asm_source: Zir.NullTerminatedString,</span>
<span class="line" id="L12986">            output_type_bits: <span class="tok-type">u32</span>,</span>
<span class="line" id="L12987">            is_volatile: <span class="tok-type">bool</span>,</span>
<span class="line" id="L12988">            outputs: []<span class="tok-kw">const</span> Zir.Inst.Asm.Output,</span>
<span class="line" id="L12989">            inputs: []<span class="tok-kw">const</span> Zir.Inst.Asm.Input,</span>
<span class="line" id="L12990">            clobbers: []<span class="tok-kw">const</span> <span class="tok-type">u32</span>,</span>
<span class="line" id="L12991">        },</span>
<span class="line" id="L12992">    ) !Zir.Inst.Ref {</span>
<span class="line" id="L12993">        <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L12994">        <span class="tok-kw">const</span> gpa = astgen.gpa;</span>
<span class="line" id="L12995"></span>
<span class="line" id="L12996">        <span class="tok-kw">try</span> gz.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);</span>
<span class="line" id="L12997">        <span class="tok-kw">try</span> astgen.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);</span>
<span class="line" id="L12998">        <span class="tok-kw">try</span> astgen.extra.ensureUnusedCapacity(gpa, <span class="tok-builtin">@typeInfo</span>(Zir.Inst.Asm).Struct.fields.len +</span>
<span class="line" id="L12999">            args.outputs.len * <span class="tok-builtin">@typeInfo</span>(Zir.Inst.Asm.Output).Struct.fields.len +</span>
<span class="line" id="L13000">            args.inputs.len * <span class="tok-builtin">@typeInfo</span>(Zir.Inst.Asm.Input).Struct.fields.len +</span>
<span class="line" id="L13001">            args.clobbers.len);</span>
<span class="line" id="L13002"></span>
<span class="line" id="L13003">        <span class="tok-kw">const</span> payload_index = gz.astgen.addExtraAssumeCapacity(Zir.Inst.Asm{</span>
<span class="line" id="L13004">            .src_node = gz.nodeIndexToRelative(args.node),</span>
<span class="line" id="L13005">            .asm_source = args.asm_source,</span>
<span class="line" id="L13006">            .output_type_bits = args.output_type_bits,</span>
<span class="line" id="L13007">        });</span>
<span class="line" id="L13008">        <span class="tok-kw">for</span> (args.outputs) |output| {</span>
<span class="line" id="L13009">            _ = gz.astgen.addExtraAssumeCapacity(output);</span>
<span class="line" id="L13010">        }</span>
<span class="line" id="L13011">        <span class="tok-kw">for</span> (args.inputs) |input| {</span>
<span class="line" id="L13012">            _ = gz.astgen.addExtraAssumeCapacity(input);</span>
<span class="line" id="L13013">        }</span>
<span class="line" id="L13014">        gz.astgen.extra.appendSliceAssumeCapacity(args.clobbers);</span>
<span class="line" id="L13015"></span>
<span class="line" id="L13016">        <span class="tok-comment">//  * 0b00000000_000XXXXX - `outputs_len`.</span>
</span>
<span class="line" id="L13017">        <span class="tok-comment">//  * 0b000000XX_XXX00000 - `inputs_len`.</span>
</span>
<span class="line" id="L13018">        <span class="tok-comment">//  * 0b0XXXXX00_00000000 - `clobbers_len`.</span>
</span>
<span class="line" id="L13019">        <span class="tok-comment">//  * 0bX0000000_00000000 - is volatile</span>
</span>
<span class="line" id="L13020">        <span class="tok-kw">const</span> small: <span class="tok-type">u16</span> = <span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, <span class="tok-builtin">@intCast</span>(args.outputs.len)) |</span>
<span class="line" id="L13021">            <span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, <span class="tok-builtin">@intCast</span>(args.inputs.len &lt;&lt; <span class="tok-number">5</span>)) |</span>
<span class="line" id="L13022">            <span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, <span class="tok-builtin">@intCast</span>(args.clobbers.len &lt;&lt; <span class="tok-number">10</span>)) |</span>
<span class="line" id="L13023">            (<span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, <span class="tok-builtin">@intFromBool</span>(args.is_volatile)) &lt;&lt; <span class="tok-number">15</span>);</span>
<span class="line" id="L13024"></span>
<span class="line" id="L13025">        <span class="tok-kw">const</span> new_index: Zir.Inst.Index = <span class="tok-builtin">@enumFromInt</span>(astgen.instructions.len);</span>
<span class="line" id="L13026">        astgen.instructions.appendAssumeCapacity(.{</span>
<span class="line" id="L13027">            .tag = .extended,</span>
<span class="line" id="L13028">            .data = .{ .extended = .{</span>
<span class="line" id="L13029">                .opcode = args.tag,</span>
<span class="line" id="L13030">                .small = small,</span>
<span class="line" id="L13031">                .operand = payload_index,</span>
<span class="line" id="L13032">            } },</span>
<span class="line" id="L13033">        });</span>
<span class="line" id="L13034">        gz.instructions.appendAssumeCapacity(new_index);</span>
<span class="line" id="L13035">        <span class="tok-kw">return</span> new_index.toRef();</span>
<span class="line" id="L13036">    }</span>
<span class="line" id="L13037"></span>
<span class="line" id="L13038">    <span class="tok-comment">/// Note that this returns a `Zir.Inst.Index` not a ref.</span></span>
<span class="line" id="L13039">    <span class="tok-comment">/// Does *not* append the block instruction to the scope.</span></span>
<span class="line" id="L13040">    <span class="tok-comment">/// Leaves the `payload_index` field undefined.</span></span>
<span class="line" id="L13041">    <span class="tok-kw">fn</span> <span class="tok-fn">makeBlockInst</span>(gz: *GenZir, tag: Zir.Inst.Tag, node: Ast.Node.Index) !Zir.Inst.Index {</span>
<span class="line" id="L13042">        <span class="tok-kw">const</span> new_index: Zir.Inst.Index = <span class="tok-builtin">@enumFromInt</span>(gz.astgen.instructions.len);</span>
<span class="line" id="L13043">        <span class="tok-kw">const</span> gpa = gz.astgen.gpa;</span>
<span class="line" id="L13044">        <span class="tok-kw">try</span> gz.astgen.instructions.append(gpa, .{</span>
<span class="line" id="L13045">            .tag = tag,</span>
<span class="line" id="L13046">            .data = .{ .pl_node = .{</span>
<span class="line" id="L13047">                .src_node = gz.nodeIndexToRelative(node),</span>
<span class="line" id="L13048">                .payload_index = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L13049">            } },</span>
<span class="line" id="L13050">        });</span>
<span class="line" id="L13051">        <span class="tok-kw">return</span> new_index;</span>
<span class="line" id="L13052">    }</span>
<span class="line" id="L13053"></span>
<span class="line" id="L13054">    <span class="tok-comment">/// Note that this returns a `Zir.Inst.Index` not a ref.</span></span>
<span class="line" id="L13055">    <span class="tok-comment">/// Leaves the `payload_index` field undefined.</span></span>
<span class="line" id="L13056">    <span class="tok-kw">fn</span> <span class="tok-fn">addCondBr</span>(gz: *GenZir, tag: Zir.Inst.Tag, node: Ast.Node.Index) !Zir.Inst.Index {</span>
<span class="line" id="L13057">        <span class="tok-kw">const</span> gpa = gz.astgen.gpa;</span>
<span class="line" id="L13058">        <span class="tok-kw">try</span> gz.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);</span>
<span class="line" id="L13059">        <span class="tok-kw">const</span> new_index: Zir.Inst.Index = <span class="tok-builtin">@enumFromInt</span>(gz.astgen.instructions.len);</span>
<span class="line" id="L13060">        <span class="tok-kw">try</span> gz.astgen.instructions.append(gpa, .{</span>
<span class="line" id="L13061">            .tag = tag,</span>
<span class="line" id="L13062">            .data = .{ .pl_node = .{</span>
<span class="line" id="L13063">                .src_node = gz.nodeIndexToRelative(node),</span>
<span class="line" id="L13064">                .payload_index = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L13065">            } },</span>
<span class="line" id="L13066">        });</span>
<span class="line" id="L13067">        gz.instructions.appendAssumeCapacity(new_index);</span>
<span class="line" id="L13068">        <span class="tok-kw">return</span> new_index;</span>
<span class="line" id="L13069">    }</span>
<span class="line" id="L13070"></span>
<span class="line" id="L13071">    <span class="tok-kw">fn</span> <span class="tok-fn">setStruct</span>(gz: *GenZir, inst: Zir.Inst.Index, args: <span class="tok-kw">struct</span> {</span>
<span class="line" id="L13072">        src_node: Ast.Node.Index,</span>
<span class="line" id="L13073">        captures_len: <span class="tok-type">u32</span>,</span>
<span class="line" id="L13074">        fields_len: <span class="tok-type">u32</span>,</span>
<span class="line" id="L13075">        decls_len: <span class="tok-type">u32</span>,</span>
<span class="line" id="L13076">        has_backing_int: <span class="tok-type">bool</span>,</span>
<span class="line" id="L13077">        layout: std.builtin.Type.ContainerLayout,</span>
<span class="line" id="L13078">        known_non_opv: <span class="tok-type">bool</span>,</span>
<span class="line" id="L13079">        known_comptime_only: <span class="tok-type">bool</span>,</span>
<span class="line" id="L13080">        is_tuple: <span class="tok-type">bool</span>,</span>
<span class="line" id="L13081">        any_comptime_fields: <span class="tok-type">bool</span>,</span>
<span class="line" id="L13082">        any_default_inits: <span class="tok-type">bool</span>,</span>
<span class="line" id="L13083">        any_aligned_fields: <span class="tok-type">bool</span>,</span>
<span class="line" id="L13084">        fields_hash: std.zig.SrcHash,</span>
<span class="line" id="L13085">    }) !<span class="tok-type">void</span> {</span>
<span class="line" id="L13086">        <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L13087">        <span class="tok-kw">const</span> gpa = astgen.gpa;</span>
<span class="line" id="L13088"></span>
<span class="line" id="L13089">        <span class="tok-comment">// Node 0 is valid for the root `struct_decl` of a file!</span>
</span>
<span class="line" id="L13090">        assert(args.src_node != <span class="tok-number">0</span> <span class="tok-kw">or</span> gz.parent.tag == .top);</span>
<span class="line" id="L13091"></span>
<span class="line" id="L13092">        <span class="tok-kw">const</span> fields_hash_arr: [<span class="tok-number">4</span>]<span class="tok-type">u32</span> = <span class="tok-builtin">@bitCast</span>(args.fields_hash);</span>
<span class="line" id="L13093"></span>
<span class="line" id="L13094">        <span class="tok-kw">try</span> astgen.extra.ensureUnusedCapacity(gpa, <span class="tok-builtin">@typeInfo</span>(Zir.Inst.StructDecl).Struct.fields.len + <span class="tok-number">3</span>);</span>
<span class="line" id="L13095">        <span class="tok-kw">const</span> payload_index = astgen.addExtraAssumeCapacity(Zir.Inst.StructDecl{</span>
<span class="line" id="L13096">            .fields_hash_0 = fields_hash_arr[<span class="tok-number">0</span>],</span>
<span class="line" id="L13097">            .fields_hash_1 = fields_hash_arr[<span class="tok-number">1</span>],</span>
<span class="line" id="L13098">            .fields_hash_2 = fields_hash_arr[<span class="tok-number">2</span>],</span>
<span class="line" id="L13099">            .fields_hash_3 = fields_hash_arr[<span class="tok-number">3</span>],</span>
<span class="line" id="L13100">            .src_node = gz.nodeIndexToRelative(args.src_node),</span>
<span class="line" id="L13101">        });</span>
<span class="line" id="L13102"></span>
<span class="line" id="L13103">        <span class="tok-kw">if</span> (args.captures_len != <span class="tok-number">0</span>) {</span>
<span class="line" id="L13104">            astgen.extra.appendAssumeCapacity(args.captures_len);</span>
<span class="line" id="L13105">        }</span>
<span class="line" id="L13106">        <span class="tok-kw">if</span> (args.fields_len != <span class="tok-number">0</span>) {</span>
<span class="line" id="L13107">            astgen.extra.appendAssumeCapacity(args.fields_len);</span>
<span class="line" id="L13108">        }</span>
<span class="line" id="L13109">        <span class="tok-kw">if</span> (args.decls_len != <span class="tok-number">0</span>) {</span>
<span class="line" id="L13110">            astgen.extra.appendAssumeCapacity(args.decls_len);</span>
<span class="line" id="L13111">        }</span>
<span class="line" id="L13112">        astgen.instructions.set(<span class="tok-builtin">@intFromEnum</span>(inst), .{</span>
<span class="line" id="L13113">            .tag = .extended,</span>
<span class="line" id="L13114">            .data = .{ .extended = .{</span>
<span class="line" id="L13115">                .opcode = .struct_decl,</span>
<span class="line" id="L13116">                .small = <span class="tok-builtin">@bitCast</span>(Zir.Inst.StructDecl.Small{</span>
<span class="line" id="L13117">                    .has_captures_len = args.captures_len != <span class="tok-number">0</span>,</span>
<span class="line" id="L13118">                    .has_fields_len = args.fields_len != <span class="tok-number">0</span>,</span>
<span class="line" id="L13119">                    .has_decls_len = args.decls_len != <span class="tok-number">0</span>,</span>
<span class="line" id="L13120">                    .has_backing_int = args.has_backing_int,</span>
<span class="line" id="L13121">                    .known_non_opv = args.known_non_opv,</span>
<span class="line" id="L13122">                    .known_comptime_only = args.known_comptime_only,</span>
<span class="line" id="L13123">                    .is_tuple = args.is_tuple,</span>
<span class="line" id="L13124">                    .name_strategy = gz.anon_name_strategy,</span>
<span class="line" id="L13125">                    .layout = args.layout,</span>
<span class="line" id="L13126">                    .any_comptime_fields = args.any_comptime_fields,</span>
<span class="line" id="L13127">                    .any_default_inits = args.any_default_inits,</span>
<span class="line" id="L13128">                    .any_aligned_fields = args.any_aligned_fields,</span>
<span class="line" id="L13129">                }),</span>
<span class="line" id="L13130">                .operand = payload_index,</span>
<span class="line" id="L13131">            } },</span>
<span class="line" id="L13132">        });</span>
<span class="line" id="L13133">    }</span>
<span class="line" id="L13134"></span>
<span class="line" id="L13135">    <span class="tok-kw">fn</span> <span class="tok-fn">setUnion</span>(gz: *GenZir, inst: Zir.Inst.Index, args: <span class="tok-kw">struct</span> {</span>
<span class="line" id="L13136">        src_node: Ast.Node.Index,</span>
<span class="line" id="L13137">        tag_type: Zir.Inst.Ref,</span>
<span class="line" id="L13138">        captures_len: <span class="tok-type">u32</span>,</span>
<span class="line" id="L13139">        body_len: <span class="tok-type">u32</span>,</span>
<span class="line" id="L13140">        fields_len: <span class="tok-type">u32</span>,</span>
<span class="line" id="L13141">        decls_len: <span class="tok-type">u32</span>,</span>
<span class="line" id="L13142">        layout: std.builtin.Type.ContainerLayout,</span>
<span class="line" id="L13143">        auto_enum_tag: <span class="tok-type">bool</span>,</span>
<span class="line" id="L13144">        any_aligned_fields: <span class="tok-type">bool</span>,</span>
<span class="line" id="L13145">        fields_hash: std.zig.SrcHash,</span>
<span class="line" id="L13146">    }) !<span class="tok-type">void</span> {</span>
<span class="line" id="L13147">        <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L13148">        <span class="tok-kw">const</span> gpa = astgen.gpa;</span>
<span class="line" id="L13149"></span>
<span class="line" id="L13150">        assert(args.src_node != <span class="tok-number">0</span>);</span>
<span class="line" id="L13151"></span>
<span class="line" id="L13152">        <span class="tok-kw">const</span> fields_hash_arr: [<span class="tok-number">4</span>]<span class="tok-type">u32</span> = <span class="tok-builtin">@bitCast</span>(args.fields_hash);</span>
<span class="line" id="L13153"></span>
<span class="line" id="L13154">        <span class="tok-kw">try</span> astgen.extra.ensureUnusedCapacity(gpa, <span class="tok-builtin">@typeInfo</span>(Zir.Inst.UnionDecl).Struct.fields.len + <span class="tok-number">5</span>);</span>
<span class="line" id="L13155">        <span class="tok-kw">const</span> payload_index = astgen.addExtraAssumeCapacity(Zir.Inst.UnionDecl{</span>
<span class="line" id="L13156">            .fields_hash_0 = fields_hash_arr[<span class="tok-number">0</span>],</span>
<span class="line" id="L13157">            .fields_hash_1 = fields_hash_arr[<span class="tok-number">1</span>],</span>
<span class="line" id="L13158">            .fields_hash_2 = fields_hash_arr[<span class="tok-number">2</span>],</span>
<span class="line" id="L13159">            .fields_hash_3 = fields_hash_arr[<span class="tok-number">3</span>],</span>
<span class="line" id="L13160">            .src_node = gz.nodeIndexToRelative(args.src_node),</span>
<span class="line" id="L13161">        });</span>
<span class="line" id="L13162"></span>
<span class="line" id="L13163">        <span class="tok-kw">if</span> (args.tag_type != .none) {</span>
<span class="line" id="L13164">            astgen.extra.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(args.tag_type));</span>
<span class="line" id="L13165">        }</span>
<span class="line" id="L13166">        <span class="tok-kw">if</span> (args.captures_len != <span class="tok-number">0</span>) {</span>
<span class="line" id="L13167">            astgen.extra.appendAssumeCapacity(args.captures_len);</span>
<span class="line" id="L13168">        }</span>
<span class="line" id="L13169">        <span class="tok-kw">if</span> (args.body_len != <span class="tok-number">0</span>) {</span>
<span class="line" id="L13170">            astgen.extra.appendAssumeCapacity(args.body_len);</span>
<span class="line" id="L13171">        }</span>
<span class="line" id="L13172">        <span class="tok-kw">if</span> (args.fields_len != <span class="tok-number">0</span>) {</span>
<span class="line" id="L13173">            astgen.extra.appendAssumeCapacity(args.fields_len);</span>
<span class="line" id="L13174">        }</span>
<span class="line" id="L13175">        <span class="tok-kw">if</span> (args.decls_len != <span class="tok-number">0</span>) {</span>
<span class="line" id="L13176">            astgen.extra.appendAssumeCapacity(args.decls_len);</span>
<span class="line" id="L13177">        }</span>
<span class="line" id="L13178">        astgen.instructions.set(<span class="tok-builtin">@intFromEnum</span>(inst), .{</span>
<span class="line" id="L13179">            .tag = .extended,</span>
<span class="line" id="L13180">            .data = .{ .extended = .{</span>
<span class="line" id="L13181">                .opcode = .union_decl,</span>
<span class="line" id="L13182">                .small = <span class="tok-builtin">@bitCast</span>(Zir.Inst.UnionDecl.Small{</span>
<span class="line" id="L13183">                    .has_tag_type = args.tag_type != .none,</span>
<span class="line" id="L13184">                    .has_captures_len = args.captures_len != <span class="tok-number">0</span>,</span>
<span class="line" id="L13185">                    .has_body_len = args.body_len != <span class="tok-number">0</span>,</span>
<span class="line" id="L13186">                    .has_fields_len = args.fields_len != <span class="tok-number">0</span>,</span>
<span class="line" id="L13187">                    .has_decls_len = args.decls_len != <span class="tok-number">0</span>,</span>
<span class="line" id="L13188">                    .name_strategy = gz.anon_name_strategy,</span>
<span class="line" id="L13189">                    .layout = args.layout,</span>
<span class="line" id="L13190">                    .auto_enum_tag = args.auto_enum_tag,</span>
<span class="line" id="L13191">                    .any_aligned_fields = args.any_aligned_fields,</span>
<span class="line" id="L13192">                }),</span>
<span class="line" id="L13193">                .operand = payload_index,</span>
<span class="line" id="L13194">            } },</span>
<span class="line" id="L13195">        });</span>
<span class="line" id="L13196">    }</span>
<span class="line" id="L13197"></span>
<span class="line" id="L13198">    <span class="tok-kw">fn</span> <span class="tok-fn">setEnum</span>(gz: *GenZir, inst: Zir.Inst.Index, args: <span class="tok-kw">struct</span> {</span>
<span class="line" id="L13199">        src_node: Ast.Node.Index,</span>
<span class="line" id="L13200">        tag_type: Zir.Inst.Ref,</span>
<span class="line" id="L13201">        captures_len: <span class="tok-type">u32</span>,</span>
<span class="line" id="L13202">        body_len: <span class="tok-type">u32</span>,</span>
<span class="line" id="L13203">        fields_len: <span class="tok-type">u32</span>,</span>
<span class="line" id="L13204">        decls_len: <span class="tok-type">u32</span>,</span>
<span class="line" id="L13205">        nonexhaustive: <span class="tok-type">bool</span>,</span>
<span class="line" id="L13206">        fields_hash: std.zig.SrcHash,</span>
<span class="line" id="L13207">    }) !<span class="tok-type">void</span> {</span>
<span class="line" id="L13208">        <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L13209">        <span class="tok-kw">const</span> gpa = astgen.gpa;</span>
<span class="line" id="L13210"></span>
<span class="line" id="L13211">        assert(args.src_node != <span class="tok-number">0</span>);</span>
<span class="line" id="L13212"></span>
<span class="line" id="L13213">        <span class="tok-kw">const</span> fields_hash_arr: [<span class="tok-number">4</span>]<span class="tok-type">u32</span> = <span class="tok-builtin">@bitCast</span>(args.fields_hash);</span>
<span class="line" id="L13214"></span>
<span class="line" id="L13215">        <span class="tok-kw">try</span> astgen.extra.ensureUnusedCapacity(gpa, <span class="tok-builtin">@typeInfo</span>(Zir.Inst.EnumDecl).Struct.fields.len + <span class="tok-number">5</span>);</span>
<span class="line" id="L13216">        <span class="tok-kw">const</span> payload_index = astgen.addExtraAssumeCapacity(Zir.Inst.EnumDecl{</span>
<span class="line" id="L13217">            .fields_hash_0 = fields_hash_arr[<span class="tok-number">0</span>],</span>
<span class="line" id="L13218">            .fields_hash_1 = fields_hash_arr[<span class="tok-number">1</span>],</span>
<span class="line" id="L13219">            .fields_hash_2 = fields_hash_arr[<span class="tok-number">2</span>],</span>
<span class="line" id="L13220">            .fields_hash_3 = fields_hash_arr[<span class="tok-number">3</span>],</span>
<span class="line" id="L13221">            .src_node = gz.nodeIndexToRelative(args.src_node),</span>
<span class="line" id="L13222">        });</span>
<span class="line" id="L13223"></span>
<span class="line" id="L13224">        <span class="tok-kw">if</span> (args.tag_type != .none) {</span>
<span class="line" id="L13225">            astgen.extra.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(args.tag_type));</span>
<span class="line" id="L13226">        }</span>
<span class="line" id="L13227">        <span class="tok-kw">if</span> (args.captures_len != <span class="tok-number">0</span>) {</span>
<span class="line" id="L13228">            astgen.extra.appendAssumeCapacity(args.captures_len);</span>
<span class="line" id="L13229">        }</span>
<span class="line" id="L13230">        <span class="tok-kw">if</span> (args.body_len != <span class="tok-number">0</span>) {</span>
<span class="line" id="L13231">            astgen.extra.appendAssumeCapacity(args.body_len);</span>
<span class="line" id="L13232">        }</span>
<span class="line" id="L13233">        <span class="tok-kw">if</span> (args.fields_len != <span class="tok-number">0</span>) {</span>
<span class="line" id="L13234">            astgen.extra.appendAssumeCapacity(args.fields_len);</span>
<span class="line" id="L13235">        }</span>
<span class="line" id="L13236">        <span class="tok-kw">if</span> (args.decls_len != <span class="tok-number">0</span>) {</span>
<span class="line" id="L13237">            astgen.extra.appendAssumeCapacity(args.decls_len);</span>
<span class="line" id="L13238">        }</span>
<span class="line" id="L13239">        astgen.instructions.set(<span class="tok-builtin">@intFromEnum</span>(inst), .{</span>
<span class="line" id="L13240">            .tag = .extended,</span>
<span class="line" id="L13241">            .data = .{ .extended = .{</span>
<span class="line" id="L13242">                .opcode = .enum_decl,</span>
<span class="line" id="L13243">                .small = <span class="tok-builtin">@bitCast</span>(Zir.Inst.EnumDecl.Small{</span>
<span class="line" id="L13244">                    .has_tag_type = args.tag_type != .none,</span>
<span class="line" id="L13245">                    .has_captures_len = args.captures_len != <span class="tok-number">0</span>,</span>
<span class="line" id="L13246">                    .has_body_len = args.body_len != <span class="tok-number">0</span>,</span>
<span class="line" id="L13247">                    .has_fields_len = args.fields_len != <span class="tok-number">0</span>,</span>
<span class="line" id="L13248">                    .has_decls_len = args.decls_len != <span class="tok-number">0</span>,</span>
<span class="line" id="L13249">                    .name_strategy = gz.anon_name_strategy,</span>
<span class="line" id="L13250">                    .nonexhaustive = args.nonexhaustive,</span>
<span class="line" id="L13251">                }),</span>
<span class="line" id="L13252">                .operand = payload_index,</span>
<span class="line" id="L13253">            } },</span>
<span class="line" id="L13254">        });</span>
<span class="line" id="L13255">    }</span>
<span class="line" id="L13256"></span>
<span class="line" id="L13257">    <span class="tok-kw">fn</span> <span class="tok-fn">setOpaque</span>(gz: *GenZir, inst: Zir.Inst.Index, args: <span class="tok-kw">struct</span> {</span>
<span class="line" id="L13258">        src_node: Ast.Node.Index,</span>
<span class="line" id="L13259">        captures_len: <span class="tok-type">u32</span>,</span>
<span class="line" id="L13260">        decls_len: <span class="tok-type">u32</span>,</span>
<span class="line" id="L13261">    }) !<span class="tok-type">void</span> {</span>
<span class="line" id="L13262">        <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L13263">        <span class="tok-kw">const</span> gpa = astgen.gpa;</span>
<span class="line" id="L13264"></span>
<span class="line" id="L13265">        assert(args.src_node != <span class="tok-number">0</span>);</span>
<span class="line" id="L13266"></span>
<span class="line" id="L13267">        <span class="tok-kw">try</span> astgen.extra.ensureUnusedCapacity(gpa, <span class="tok-builtin">@typeInfo</span>(Zir.Inst.OpaqueDecl).Struct.fields.len + <span class="tok-number">2</span>);</span>
<span class="line" id="L13268">        <span class="tok-kw">const</span> payload_index = astgen.addExtraAssumeCapacity(Zir.Inst.OpaqueDecl{</span>
<span class="line" id="L13269">            .src_node = gz.nodeIndexToRelative(args.src_node),</span>
<span class="line" id="L13270">        });</span>
<span class="line" id="L13271"></span>
<span class="line" id="L13272">        <span class="tok-kw">if</span> (args.captures_len != <span class="tok-number">0</span>) {</span>
<span class="line" id="L13273">            astgen.extra.appendAssumeCapacity(args.captures_len);</span>
<span class="line" id="L13274">        }</span>
<span class="line" id="L13275">        <span class="tok-kw">if</span> (args.decls_len != <span class="tok-number">0</span>) {</span>
<span class="line" id="L13276">            astgen.extra.appendAssumeCapacity(args.decls_len);</span>
<span class="line" id="L13277">        }</span>
<span class="line" id="L13278">        astgen.instructions.set(<span class="tok-builtin">@intFromEnum</span>(inst), .{</span>
<span class="line" id="L13279">            .tag = .extended,</span>
<span class="line" id="L13280">            .data = .{ .extended = .{</span>
<span class="line" id="L13281">                .opcode = .opaque_decl,</span>
<span class="line" id="L13282">                .small = <span class="tok-builtin">@bitCast</span>(Zir.Inst.OpaqueDecl.Small{</span>
<span class="line" id="L13283">                    .has_captures_len = args.captures_len != <span class="tok-number">0</span>,</span>
<span class="line" id="L13284">                    .has_decls_len = args.decls_len != <span class="tok-number">0</span>,</span>
<span class="line" id="L13285">                    .name_strategy = gz.anon_name_strategy,</span>
<span class="line" id="L13286">                }),</span>
<span class="line" id="L13287">                .operand = payload_index,</span>
<span class="line" id="L13288">            } },</span>
<span class="line" id="L13289">        });</span>
<span class="line" id="L13290">    }</span>
<span class="line" id="L13291"></span>
<span class="line" id="L13292">    <span class="tok-kw">fn</span> <span class="tok-fn">add</span>(gz: *GenZir, inst: Zir.Inst) !Zir.Inst.Ref {</span>
<span class="line" id="L13293">        <span class="tok-kw">return</span> (<span class="tok-kw">try</span> gz.addAsIndex(inst)).toRef();</span>
<span class="line" id="L13294">    }</span>
<span class="line" id="L13295"></span>
<span class="line" id="L13296">    <span class="tok-kw">fn</span> <span class="tok-fn">addAsIndex</span>(gz: *GenZir, inst: Zir.Inst) !Zir.Inst.Index {</span>
<span class="line" id="L13297">        <span class="tok-kw">const</span> gpa = gz.astgen.gpa;</span>
<span class="line" id="L13298">        <span class="tok-kw">try</span> gz.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);</span>
<span class="line" id="L13299">        <span class="tok-kw">try</span> gz.astgen.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);</span>
<span class="line" id="L13300"></span>
<span class="line" id="L13301">        <span class="tok-kw">const</span> new_index: Zir.Inst.Index = <span class="tok-builtin">@enumFromInt</span>(gz.astgen.instructions.len);</span>
<span class="line" id="L13302">        gz.astgen.instructions.appendAssumeCapacity(inst);</span>
<span class="line" id="L13303">        gz.instructions.appendAssumeCapacity(new_index);</span>
<span class="line" id="L13304">        <span class="tok-kw">return</span> new_index;</span>
<span class="line" id="L13305">    }</span>
<span class="line" id="L13306"></span>
<span class="line" id="L13307">    <span class="tok-kw">fn</span> <span class="tok-fn">reserveInstructionIndex</span>(gz: *GenZir) !Zir.Inst.Index {</span>
<span class="line" id="L13308">        <span class="tok-kw">const</span> gpa = gz.astgen.gpa;</span>
<span class="line" id="L13309">        <span class="tok-kw">try</span> gz.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);</span>
<span class="line" id="L13310">        <span class="tok-kw">try</span> gz.astgen.instructions.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);</span>
<span class="line" id="L13311"></span>
<span class="line" id="L13312">        <span class="tok-kw">const</span> new_index: Zir.Inst.Index = <span class="tok-builtin">@enumFromInt</span>(gz.astgen.instructions.len);</span>
<span class="line" id="L13313">        gz.astgen.instructions.len += <span class="tok-number">1</span>;</span>
<span class="line" id="L13314">        gz.instructions.appendAssumeCapacity(new_index);</span>
<span class="line" id="L13315">        <span class="tok-kw">return</span> new_index;</span>
<span class="line" id="L13316">    }</span>
<span class="line" id="L13317"></span>
<span class="line" id="L13318">    <span class="tok-kw">fn</span> <span class="tok-fn">addRet</span>(gz: *GenZir, ri: ResultInfo, operand: Zir.Inst.Ref, node: Ast.Node.Index) !<span class="tok-type">void</span> {</span>
<span class="line" id="L13319">        <span class="tok-kw">switch</span> (ri.rl) {</span>
<span class="line" id="L13320">            .ptr =&gt; |ptr_res| _ = <span class="tok-kw">try</span> gz.addUnNode(.ret_load, ptr_res.inst, node),</span>
<span class="line" id="L13321">            .coerced_ty =&gt; _ = <span class="tok-kw">try</span> gz.addUnNode(.ret_node, operand, node),</span>
<span class="line" id="L13322">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L13323">        }</span>
<span class="line" id="L13324">    }</span>
<span class="line" id="L13325"></span>
<span class="line" id="L13326">    <span class="tok-kw">fn</span> <span class="tok-fn">addDbgVar</span>(gz: *GenZir, tag: Zir.Inst.Tag, name: Zir.NullTerminatedString, inst: Zir.Inst.Ref) !<span class="tok-type">void</span> {</span>
<span class="line" id="L13327">        <span class="tok-kw">if</span> (gz.is_comptime) <span class="tok-kw">return</span>;</span>
<span class="line" id="L13328"></span>
<span class="line" id="L13329">        _ = <span class="tok-kw">try</span> gz.add(.{ .tag = tag, .data = .{</span>
<span class="line" id="L13330">            .str_op = .{</span>
<span class="line" id="L13331">                .str = name,</span>
<span class="line" id="L13332">                .operand = inst,</span>
<span class="line" id="L13333">            },</span>
<span class="line" id="L13334">        } });</span>
<span class="line" id="L13335">    }</span>
<span class="line" id="L13336">};</span>
<span class="line" id="L13337"></span>
<span class="line" id="L13338"><span class="tok-comment">/// This can only be for short-lived references; the memory becomes invalidated</span></span>
<span class="line" id="L13339"><span class="tok-comment">/// when another string is added.</span></span>
<span class="line" id="L13340"><span class="tok-kw">fn</span> <span class="tok-fn">nullTerminatedString</span>(astgen: AstGen, index: Zir.NullTerminatedString) [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L13341">    <span class="tok-kw">return</span> <span class="tok-builtin">@ptrCast</span>(astgen.string_bytes.items[<span class="tok-builtin">@intFromEnum</span>(index)..]);</span>
<span class="line" id="L13342">}</span>
<span class="line" id="L13343"></span>
<span class="line" id="L13344"><span class="tok-comment">/// Local variables shadowing detection, including function parameters.</span></span>
<span class="line" id="L13345"><span class="tok-kw">fn</span> <span class="tok-fn">detectLocalShadowing</span>(</span>
<span class="line" id="L13346">    astgen: *AstGen,</span>
<span class="line" id="L13347">    scope: *Scope,</span>
<span class="line" id="L13348">    ident_name: Zir.NullTerminatedString,</span>
<span class="line" id="L13349">    name_token: Ast.TokenIndex,</span>
<span class="line" id="L13350">    token_bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L13351">    id_cat: Scope.IdCat,</span>
<span class="line" id="L13352">) !<span class="tok-type">void</span> {</span>
<span class="line" id="L13353">    <span class="tok-kw">const</span> gpa = astgen.gpa;</span>
<span class="line" id="L13354">    <span class="tok-kw">if</span> (token_bytes[<span class="tok-number">0</span>] != <span class="tok-str">'@'</span> <span class="tok-kw">and</span> isPrimitive(token_bytes)) {</span>
<span class="line" id="L13355">        <span class="tok-kw">return</span> astgen.failTokNotes(name_token, <span class="tok-str">&quot;name shadows primitive '{s}'&quot;</span>, .{</span>
<span class="line" id="L13356">            token_bytes,</span>
<span class="line" id="L13357">        }, &amp;[_]<span class="tok-type">u32</span>{</span>
<span class="line" id="L13358">            <span class="tok-kw">try</span> astgen.errNoteTok(name_token, <span class="tok-str">&quot;consider using @\&quot;{s}\&quot; to disambiguate&quot;</span>, .{</span>
<span class="line" id="L13359">                token_bytes,</span>
<span class="line" id="L13360">            }),</span>
<span class="line" id="L13361">        });</span>
<span class="line" id="L13362">    }</span>
<span class="line" id="L13363"></span>
<span class="line" id="L13364">    <span class="tok-kw">var</span> s = scope;</span>
<span class="line" id="L13365">    <span class="tok-kw">var</span> outer_scope = <span class="tok-null">false</span>;</span>
<span class="line" id="L13366">    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) <span class="tok-kw">switch</span> (s.tag) {</span>
<span class="line" id="L13367">        .local_val =&gt; {</span>
<span class="line" id="L13368">            <span class="tok-kw">const</span> local_val = s.cast(Scope.LocalVal).?;</span>
<span class="line" id="L13369">            <span class="tok-kw">if</span> (local_val.name == ident_name) {</span>
<span class="line" id="L13370">                <span class="tok-kw">const</span> name_slice = mem.span(astgen.nullTerminatedString(ident_name));</span>
<span class="line" id="L13371">                <span class="tok-kw">const</span> name = <span class="tok-kw">try</span> gpa.dupe(<span class="tok-type">u8</span>, name_slice);</span>
<span class="line" id="L13372">                <span class="tok-kw">defer</span> gpa.free(name);</span>
<span class="line" id="L13373">                <span class="tok-kw">if</span> (outer_scope) {</span>
<span class="line" id="L13374">                    <span class="tok-kw">return</span> astgen.failTokNotes(name_token, <span class="tok-str">&quot;{s} '{s}' shadows {s} from outer scope&quot;</span>, .{</span>
<span class="line" id="L13375">                        <span class="tok-builtin">@tagName</span>(id_cat), name, <span class="tok-builtin">@tagName</span>(local_val.id_cat),</span>
<span class="line" id="L13376">                    }, &amp;[_]<span class="tok-type">u32</span>{</span>
<span class="line" id="L13377">                        <span class="tok-kw">try</span> astgen.errNoteTok(</span>
<span class="line" id="L13378">                            local_val.token_src,</span>
<span class="line" id="L13379">                            <span class="tok-str">&quot;previous declaration here&quot;</span>,</span>
<span class="line" id="L13380">                            .{},</span>
<span class="line" id="L13381">                        ),</span>
<span class="line" id="L13382">                    });</span>
<span class="line" id="L13383">                }</span>
<span class="line" id="L13384">                <span class="tok-kw">return</span> astgen.failTokNotes(name_token, <span class="tok-str">&quot;redeclaration of {s} '{s}'&quot;</span>, .{</span>
<span class="line" id="L13385">                    <span class="tok-builtin">@tagName</span>(local_val.id_cat), name,</span>
<span class="line" id="L13386">                }, &amp;[_]<span class="tok-type">u32</span>{</span>
<span class="line" id="L13387">                    <span class="tok-kw">try</span> astgen.errNoteTok(</span>
<span class="line" id="L13388">                        local_val.token_src,</span>
<span class="line" id="L13389">                        <span class="tok-str">&quot;previous declaration here&quot;</span>,</span>
<span class="line" id="L13390">                        .{},</span>
<span class="line" id="L13391">                    ),</span>
<span class="line" id="L13392">                });</span>
<span class="line" id="L13393">            }</span>
<span class="line" id="L13394">            s = local_val.parent;</span>
<span class="line" id="L13395">        },</span>
<span class="line" id="L13396">        .local_ptr =&gt; {</span>
<span class="line" id="L13397">            <span class="tok-kw">const</span> local_ptr = s.cast(Scope.LocalPtr).?;</span>
<span class="line" id="L13398">            <span class="tok-kw">if</span> (local_ptr.name == ident_name) {</span>
<span class="line" id="L13399">                <span class="tok-kw">const</span> name_slice = mem.span(astgen.nullTerminatedString(ident_name));</span>
<span class="line" id="L13400">                <span class="tok-kw">const</span> name = <span class="tok-kw">try</span> gpa.dupe(<span class="tok-type">u8</span>, name_slice);</span>
<span class="line" id="L13401">                <span class="tok-kw">defer</span> gpa.free(name);</span>
<span class="line" id="L13402">                <span class="tok-kw">if</span> (outer_scope) {</span>
<span class="line" id="L13403">                    <span class="tok-kw">return</span> astgen.failTokNotes(name_token, <span class="tok-str">&quot;{s} '{s}' shadows {s} from outer scope&quot;</span>, .{</span>
<span class="line" id="L13404">                        <span class="tok-builtin">@tagName</span>(id_cat), name, <span class="tok-builtin">@tagName</span>(local_ptr.id_cat),</span>
<span class="line" id="L13405">                    }, &amp;[_]<span class="tok-type">u32</span>{</span>
<span class="line" id="L13406">                        <span class="tok-kw">try</span> astgen.errNoteTok(</span>
<span class="line" id="L13407">                            local_ptr.token_src,</span>
<span class="line" id="L13408">                            <span class="tok-str">&quot;previous declaration here&quot;</span>,</span>
<span class="line" id="L13409">                            .{},</span>
<span class="line" id="L13410">                        ),</span>
<span class="line" id="L13411">                    });</span>
<span class="line" id="L13412">                }</span>
<span class="line" id="L13413">                <span class="tok-kw">return</span> astgen.failTokNotes(name_token, <span class="tok-str">&quot;redeclaration of {s} '{s}'&quot;</span>, .{</span>
<span class="line" id="L13414">                    <span class="tok-builtin">@tagName</span>(local_ptr.id_cat), name,</span>
<span class="line" id="L13415">                }, &amp;[_]<span class="tok-type">u32</span>{</span>
<span class="line" id="L13416">                    <span class="tok-kw">try</span> astgen.errNoteTok(</span>
<span class="line" id="L13417">                        local_ptr.token_src,</span>
<span class="line" id="L13418">                        <span class="tok-str">&quot;previous declaration here&quot;</span>,</span>
<span class="line" id="L13419">                        .{},</span>
<span class="line" id="L13420">                    ),</span>
<span class="line" id="L13421">                });</span>
<span class="line" id="L13422">            }</span>
<span class="line" id="L13423">            s = local_ptr.parent;</span>
<span class="line" id="L13424">        },</span>
<span class="line" id="L13425">        .namespace =&gt; {</span>
<span class="line" id="L13426">            outer_scope = <span class="tok-null">true</span>;</span>
<span class="line" id="L13427">            <span class="tok-kw">const</span> ns = s.cast(Scope.Namespace).?;</span>
<span class="line" id="L13428">            <span class="tok-kw">const</span> decl_node = ns.decls.get(ident_name) <span class="tok-kw">orelse</span> {</span>
<span class="line" id="L13429">                s = ns.parent;</span>
<span class="line" id="L13430">                <span class="tok-kw">continue</span>;</span>
<span class="line" id="L13431">            };</span>
<span class="line" id="L13432">            <span class="tok-kw">const</span> name_slice = mem.span(astgen.nullTerminatedString(ident_name));</span>
<span class="line" id="L13433">            <span class="tok-kw">const</span> name = <span class="tok-kw">try</span> gpa.dupe(<span class="tok-type">u8</span>, name_slice);</span>
<span class="line" id="L13434">            <span class="tok-kw">defer</span> gpa.free(name);</span>
<span class="line" id="L13435">            <span class="tok-kw">return</span> astgen.failTokNotes(name_token, <span class="tok-str">&quot;{s} shadows declaration of '{s}'&quot;</span>, .{</span>
<span class="line" id="L13436">                <span class="tok-builtin">@tagName</span>(id_cat), name,</span>
<span class="line" id="L13437">            }, &amp;[_]<span class="tok-type">u32</span>{</span>
<span class="line" id="L13438">                <span class="tok-kw">try</span> astgen.errNoteNode(decl_node, <span class="tok-str">&quot;declared here&quot;</span>, .{}),</span>
<span class="line" id="L13439">            });</span>
<span class="line" id="L13440">        },</span>
<span class="line" id="L13441">        .gen_zir =&gt; {</span>
<span class="line" id="L13442">            s = s.cast(GenZir).?.parent;</span>
<span class="line" id="L13443">            outer_scope = <span class="tok-null">true</span>;</span>
<span class="line" id="L13444">        },</span>
<span class="line" id="L13445">        .defer_normal, .defer_error =&gt; s = s.cast(Scope.Defer).?.parent,</span>
<span class="line" id="L13446">        .top =&gt; <span class="tok-kw">break</span>,</span>
<span class="line" id="L13447">    };</span>
<span class="line" id="L13448">}</span>
<span class="line" id="L13449"></span>
<span class="line" id="L13450"><span class="tok-kw">const</span> LineColumn = <span class="tok-kw">struct</span> { <span class="tok-type">u32</span>, <span class="tok-type">u32</span> };</span>
<span class="line" id="L13451"></span>
<span class="line" id="L13452"><span class="tok-comment">/// Advances the source cursor to the main token of `node` if not in comptime scope.</span></span>
<span class="line" id="L13453"><span class="tok-comment">/// Usually paired with `emitDbgStmt`.</span></span>
<span class="line" id="L13454"><span class="tok-kw">fn</span> <span class="tok-fn">maybeAdvanceSourceCursorToMainToken</span>(gz: *GenZir, node: Ast.Node.Index) LineColumn {</span>
<span class="line" id="L13455">    <span class="tok-kw">if</span> (gz.is_comptime) <span class="tok-kw">return</span> .{ gz.astgen.source_line - gz.decl_line, gz.astgen.source_column };</span>
<span class="line" id="L13456"></span>
<span class="line" id="L13457">    <span class="tok-kw">const</span> tree = gz.astgen.tree;</span>
<span class="line" id="L13458">    <span class="tok-kw">const</span> token_starts = tree.tokens.items(.start);</span>
<span class="line" id="L13459">    <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);</span>
<span class="line" id="L13460">    <span class="tok-kw">const</span> node_start = token_starts[main_tokens[node]];</span>
<span class="line" id="L13461">    gz.astgen.advanceSourceCursor(node_start);</span>
<span class="line" id="L13462"></span>
<span class="line" id="L13463">    <span class="tok-kw">return</span> .{ gz.astgen.source_line - gz.decl_line, gz.astgen.source_column };</span>
<span class="line" id="L13464">}</span>
<span class="line" id="L13465"></span>
<span class="line" id="L13466"><span class="tok-comment">/// Advances the source cursor to the beginning of `node`.</span></span>
<span class="line" id="L13467"><span class="tok-kw">fn</span> <span class="tok-fn">advanceSourceCursorToNode</span>(astgen: *AstGen, node: Ast.Node.Index) <span class="tok-type">void</span> {</span>
<span class="line" id="L13468">    <span class="tok-kw">const</span> tree = astgen.tree;</span>
<span class="line" id="L13469">    <span class="tok-kw">const</span> token_starts = tree.tokens.items(.start);</span>
<span class="line" id="L13470">    <span class="tok-kw">const</span> node_start = token_starts[tree.firstToken(node)];</span>
<span class="line" id="L13471">    astgen.advanceSourceCursor(node_start);</span>
<span class="line" id="L13472">}</span>
<span class="line" id="L13473"></span>
<span class="line" id="L13474"><span class="tok-comment">/// Advances the source cursor to an absolute byte offset `end` in the file.</span></span>
<span class="line" id="L13475"><span class="tok-kw">fn</span> <span class="tok-fn">advanceSourceCursor</span>(astgen: *AstGen, end: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L13476">    <span class="tok-kw">const</span> source = astgen.tree.source;</span>
<span class="line" id="L13477">    <span class="tok-kw">var</span> i = astgen.source_offset;</span>
<span class="line" id="L13478">    <span class="tok-kw">var</span> line = astgen.source_line;</span>
<span class="line" id="L13479">    <span class="tok-kw">var</span> column = astgen.source_column;</span>
<span class="line" id="L13480">    assert(i &lt;= end);</span>
<span class="line" id="L13481">    <span class="tok-kw">while</span> (i &lt; end) : (i += <span class="tok-number">1</span>) {</span>
<span class="line" id="L13482">        <span class="tok-kw">if</span> (source[i] == <span class="tok-str">'\n'</span>) {</span>
<span class="line" id="L13483">            line += <span class="tok-number">1</span>;</span>
<span class="line" id="L13484">            column = <span class="tok-number">0</span>;</span>
<span class="line" id="L13485">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L13486">            column += <span class="tok-number">1</span>;</span>
<span class="line" id="L13487">        }</span>
<span class="line" id="L13488">    }</span>
<span class="line" id="L13489">    astgen.source_offset = i;</span>
<span class="line" id="L13490">    astgen.source_line = line;</span>
<span class="line" id="L13491">    astgen.source_column = column;</span>
<span class="line" id="L13492">}</span>
<span class="line" id="L13493"></span>
<span class="line" id="L13494"><span class="tok-kw">fn</span> <span class="tok-fn">scanDecls</span>(astgen: *AstGen, namespace: *Scope.Namespace, members: []<span class="tok-kw">const</span> Ast.Node.Index) !<span class="tok-type">u32</span> {</span>
<span class="line" id="L13495">    <span class="tok-kw">const</span> gpa = astgen.gpa;</span>
<span class="line" id="L13496">    <span class="tok-kw">const</span> tree = astgen.tree;</span>
<span class="line" id="L13497">    <span class="tok-kw">const</span> node_tags = tree.nodes.items(.tag);</span>
<span class="line" id="L13498">    <span class="tok-kw">const</span> main_tokens = tree.nodes.items(.main_token);</span>
<span class="line" id="L13499">    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);</span>
<span class="line" id="L13500">    <span class="tok-kw">var</span> decl_count: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L13501">    <span class="tok-kw">for</span> (members) |member_node| {</span>
<span class="line" id="L13502">        <span class="tok-kw">const</span> name_token = <span class="tok-kw">switch</span> (node_tags[member_node]) {</span>
<span class="line" id="L13503">            .global_var_decl,</span>
<span class="line" id="L13504">            .local_var_decl,</span>
<span class="line" id="L13505">            .simple_var_decl,</span>
<span class="line" id="L13506">            .aligned_var_decl,</span>
<span class="line" id="L13507">            =&gt; blk: {</span>
<span class="line" id="L13508">                decl_count += <span class="tok-number">1</span>;</span>
<span class="line" id="L13509">                <span class="tok-kw">break</span> :blk main_tokens[member_node] + <span class="tok-number">1</span>;</span>
<span class="line" id="L13510">            },</span>
<span class="line" id="L13511"></span>
<span class="line" id="L13512">            .fn_proto_simple,</span>
<span class="line" id="L13513">            .fn_proto_multi,</span>
<span class="line" id="L13514">            .fn_proto_one,</span>
<span class="line" id="L13515">            .fn_proto,</span>
<span class="line" id="L13516">            .fn_decl,</span>
<span class="line" id="L13517">            =&gt; blk: {</span>
<span class="line" id="L13518">                decl_count += <span class="tok-number">1</span>;</span>
<span class="line" id="L13519">                <span class="tok-kw">const</span> ident = main_tokens[member_node] + <span class="tok-number">1</span>;</span>
<span class="line" id="L13520">                <span class="tok-kw">if</span> (token_tags[ident] != .identifier) {</span>
<span class="line" id="L13521">                    <span class="tok-kw">switch</span> (astgen.failNode(member_node, <span class="tok-str">&quot;missing function name&quot;</span>, .{})) {</span>
<span class="line" id="L13522">                        <span class="tok-kw">error</span>.AnalysisFail =&gt; <span class="tok-kw">continue</span>,</span>
<span class="line" id="L13523">                        <span class="tok-kw">error</span>.OutOfMemory =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory,</span>
<span class="line" id="L13524">                    }</span>
<span class="line" id="L13525">                }</span>
<span class="line" id="L13526">                <span class="tok-kw">break</span> :blk ident;</span>
<span class="line" id="L13527">            },</span>
<span class="line" id="L13528"></span>
<span class="line" id="L13529">            .@&quot;comptime&quot;, .@&quot;usingnamespace&quot;, .test_decl =&gt; {</span>
<span class="line" id="L13530">                decl_count += <span class="tok-number">1</span>;</span>
<span class="line" id="L13531">                <span class="tok-kw">continue</span>;</span>
<span class="line" id="L13532">            },</span>
<span class="line" id="L13533"></span>
<span class="line" id="L13534">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">continue</span>,</span>
<span class="line" id="L13535">        };</span>
<span class="line" id="L13536"></span>
<span class="line" id="L13537">        <span class="tok-kw">const</span> token_bytes = astgen.tree.tokenSlice(name_token);</span>
<span class="line" id="L13538">        <span class="tok-kw">if</span> (token_bytes[<span class="tok-number">0</span>] != <span class="tok-str">'@'</span> <span class="tok-kw">and</span> isPrimitive(token_bytes)) {</span>
<span class="line" id="L13539">            <span class="tok-kw">switch</span> (astgen.failTokNotes(name_token, <span class="tok-str">&quot;name shadows primitive '{s}'&quot;</span>, .{</span>
<span class="line" id="L13540">                token_bytes,</span>
<span class="line" id="L13541">            }, &amp;[_]<span class="tok-type">u32</span>{</span>
<span class="line" id="L13542">                <span class="tok-kw">try</span> astgen.errNoteTok(name_token, <span class="tok-str">&quot;consider using @\&quot;{s}\&quot; to disambiguate&quot;</span>, .{</span>
<span class="line" id="L13543">                    token_bytes,</span>
<span class="line" id="L13544">                }),</span>
<span class="line" id="L13545">            })) {</span>
<span class="line" id="L13546">                <span class="tok-kw">error</span>.AnalysisFail =&gt; <span class="tok-kw">continue</span>,</span>
<span class="line" id="L13547">                <span class="tok-kw">error</span>.OutOfMemory =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory,</span>
<span class="line" id="L13548">            }</span>
<span class="line" id="L13549">        }</span>
<span class="line" id="L13550"></span>
<span class="line" id="L13551">        <span class="tok-kw">const</span> name_str_index = <span class="tok-kw">try</span> astgen.identAsString(name_token);</span>
<span class="line" id="L13552">        <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> namespace.decls.getOrPut(gpa, name_str_index);</span>
<span class="line" id="L13553">        <span class="tok-kw">if</span> (gop.found_existing) {</span>
<span class="line" id="L13554">            <span class="tok-kw">const</span> name = <span class="tok-kw">try</span> gpa.dupe(<span class="tok-type">u8</span>, mem.span(astgen.nullTerminatedString(name_str_index)));</span>
<span class="line" id="L13555">            <span class="tok-kw">defer</span> gpa.free(name);</span>
<span class="line" id="L13556">            <span class="tok-kw">switch</span> (astgen.failNodeNotes(member_node, <span class="tok-str">&quot;redeclaration of '{s}'&quot;</span>, .{</span>
<span class="line" id="L13557">                name,</span>
<span class="line" id="L13558">            }, &amp;[_]<span class="tok-type">u32</span>{</span>
<span class="line" id="L13559">                <span class="tok-kw">try</span> astgen.errNoteNode(gop.value_ptr.*, <span class="tok-str">&quot;other declaration here&quot;</span>, .{}),</span>
<span class="line" id="L13560">            })) {</span>
<span class="line" id="L13561">                <span class="tok-kw">error</span>.AnalysisFail =&gt; <span class="tok-kw">continue</span>,</span>
<span class="line" id="L13562">                <span class="tok-kw">error</span>.OutOfMemory =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory,</span>
<span class="line" id="L13563">            }</span>
<span class="line" id="L13564">        }</span>
<span class="line" id="L13565"></span>
<span class="line" id="L13566">        <span class="tok-kw">var</span> s = namespace.parent;</span>
<span class="line" id="L13567">        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) <span class="tok-kw">switch</span> (s.tag) {</span>
<span class="line" id="L13568">            .local_val =&gt; {</span>
<span class="line" id="L13569">                <span class="tok-kw">const</span> local_val = s.cast(Scope.LocalVal).?;</span>
<span class="line" id="L13570">                <span class="tok-kw">if</span> (local_val.name == name_str_index) {</span>
<span class="line" id="L13571">                    <span class="tok-kw">return</span> astgen.failTokNotes(name_token, <span class="tok-str">&quot;declaration '{s}' shadows {s} from outer scope&quot;</span>, .{</span>
<span class="line" id="L13572">                        token_bytes, <span class="tok-builtin">@tagName</span>(local_val.id_cat),</span>
<span class="line" id="L13573">                    }, &amp;[_]<span class="tok-type">u32</span>{</span>
<span class="line" id="L13574">                        <span class="tok-kw">try</span> astgen.errNoteTok(</span>
<span class="line" id="L13575">                            local_val.token_src,</span>
<span class="line" id="L13576">                            <span class="tok-str">&quot;previous declaration here&quot;</span>,</span>
<span class="line" id="L13577">                            .{},</span>
<span class="line" id="L13578">                        ),</span>
<span class="line" id="L13579">                    });</span>
<span class="line" id="L13580">                }</span>
<span class="line" id="L13581">                s = local_val.parent;</span>
<span class="line" id="L13582">            },</span>
<span class="line" id="L13583">            .local_ptr =&gt; {</span>
<span class="line" id="L13584">                <span class="tok-kw">const</span> local_ptr = s.cast(Scope.LocalPtr).?;</span>
<span class="line" id="L13585">                <span class="tok-kw">if</span> (local_ptr.name == name_str_index) {</span>
<span class="line" id="L13586">                    <span class="tok-kw">return</span> astgen.failTokNotes(name_token, <span class="tok-str">&quot;declaration '{s}' shadows {s} from outer scope&quot;</span>, .{</span>
<span class="line" id="L13587">                        token_bytes, <span class="tok-builtin">@tagName</span>(local_ptr.id_cat),</span>
<span class="line" id="L13588">                    }, &amp;[_]<span class="tok-type">u32</span>{</span>
<span class="line" id="L13589">                        <span class="tok-kw">try</span> astgen.errNoteTok(</span>
<span class="line" id="L13590">                            local_ptr.token_src,</span>
<span class="line" id="L13591">                            <span class="tok-str">&quot;previous declaration here&quot;</span>,</span>
<span class="line" id="L13592">                            .{},</span>
<span class="line" id="L13593">                        ),</span>
<span class="line" id="L13594">                    });</span>
<span class="line" id="L13595">                }</span>
<span class="line" id="L13596">                s = local_ptr.parent;</span>
<span class="line" id="L13597">            },</span>
<span class="line" id="L13598">            .namespace =&gt; s = s.cast(Scope.Namespace).?.parent,</span>
<span class="line" id="L13599">            .gen_zir =&gt; s = s.cast(GenZir).?.parent,</span>
<span class="line" id="L13600">            .defer_normal, .defer_error =&gt; s = s.cast(Scope.Defer).?.parent,</span>
<span class="line" id="L13601">            .top =&gt; <span class="tok-kw">break</span>,</span>
<span class="line" id="L13602">        };</span>
<span class="line" id="L13603">        gop.value_ptr.* = member_node;</span>
<span class="line" id="L13604">    }</span>
<span class="line" id="L13605">    <span class="tok-kw">return</span> decl_count;</span>
<span class="line" id="L13606">}</span>
<span class="line" id="L13607"></span>
<span class="line" id="L13608"><span class="tok-kw">fn</span> <span class="tok-fn">isInferred</span>(astgen: *AstGen, ref: Zir.Inst.Ref) <span class="tok-type">bool</span> {</span>
<span class="line" id="L13609">    <span class="tok-kw">const</span> inst = ref.toIndex() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L13610">    <span class="tok-kw">const</span> zir_tags = astgen.instructions.items(.tag);</span>
<span class="line" id="L13611">    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (zir_tags[<span class="tok-builtin">@intFromEnum</span>(inst)]) {</span>
<span class="line" id="L13612">        .alloc_inferred,</span>
<span class="line" id="L13613">        .alloc_inferred_mut,</span>
<span class="line" id="L13614">        .alloc_inferred_comptime,</span>
<span class="line" id="L13615">        .alloc_inferred_comptime_mut,</span>
<span class="line" id="L13616">        =&gt; <span class="tok-null">true</span>,</span>
<span class="line" id="L13617"></span>
<span class="line" id="L13618">        .extended =&gt; {</span>
<span class="line" id="L13619">            <span class="tok-kw">const</span> zir_data = astgen.instructions.items(.data);</span>
<span class="line" id="L13620">            <span class="tok-kw">if</span> (zir_data[<span class="tok-builtin">@intFromEnum</span>(inst)].extended.opcode != .alloc) <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L13621">            <span class="tok-kw">const</span> small: Zir.Inst.AllocExtended.Small = <span class="tok-builtin">@bitCast</span>(zir_data[<span class="tok-builtin">@intFromEnum</span>(inst)].extended.small);</span>
<span class="line" id="L13622">            <span class="tok-kw">return</span> !small.has_type;</span>
<span class="line" id="L13623">        },</span>
<span class="line" id="L13624"></span>
<span class="line" id="L13625">        <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,</span>
<span class="line" id="L13626">    };</span>
<span class="line" id="L13627">}</span>
<span class="line" id="L13628"></span>
<span class="line" id="L13629"><span class="tok-comment">/// Assumes capacity for body has already been added. Needed capacity taking into</span></span>
<span class="line" id="L13630"><span class="tok-comment">/// account fixups can be found with `countBodyLenAfterFixups`.</span></span>
<span class="line" id="L13631"><span class="tok-kw">fn</span> <span class="tok-fn">appendBodyWithFixups</span>(astgen: *AstGen, body: []<span class="tok-kw">const</span> Zir.Inst.Index) <span class="tok-type">void</span> {</span>
<span class="line" id="L13632">    <span class="tok-kw">return</span> appendBodyWithFixupsArrayList(astgen, &amp;astgen.extra, body);</span>
<span class="line" id="L13633">}</span>
<span class="line" id="L13634"></span>
<span class="line" id="L13635"><span class="tok-kw">fn</span> <span class="tok-fn">appendBodyWithFixupsArrayList</span>(</span>
<span class="line" id="L13636">    astgen: *AstGen,</span>
<span class="line" id="L13637">    list: *std.ArrayListUnmanaged(<span class="tok-type">u32</span>),</span>
<span class="line" id="L13638">    body: []<span class="tok-kw">const</span> Zir.Inst.Index,</span>
<span class="line" id="L13639">) <span class="tok-type">void</span> {</span>
<span class="line" id="L13640">    <span class="tok-kw">for</span> (body) |body_inst| {</span>
<span class="line" id="L13641">        appendPossiblyRefdBodyInst(astgen, list, body_inst);</span>
<span class="line" id="L13642">    }</span>
<span class="line" id="L13643">}</span>
<span class="line" id="L13644"></span>
<span class="line" id="L13645"><span class="tok-kw">fn</span> <span class="tok-fn">appendPossiblyRefdBodyInst</span>(</span>
<span class="line" id="L13646">    astgen: *AstGen,</span>
<span class="line" id="L13647">    list: *std.ArrayListUnmanaged(<span class="tok-type">u32</span>),</span>
<span class="line" id="L13648">    body_inst: Zir.Inst.Index,</span>
<span class="line" id="L13649">) <span class="tok-type">void</span> {</span>
<span class="line" id="L13650">    list.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(body_inst));</span>
<span class="line" id="L13651">    <span class="tok-kw">const</span> kv = astgen.ref_table.fetchRemove(body_inst) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L13652">    <span class="tok-kw">const</span> ref_inst = kv.value;</span>
<span class="line" id="L13653">    <span class="tok-kw">return</span> appendPossiblyRefdBodyInst(astgen, list, ref_inst);</span>
<span class="line" id="L13654">}</span>
<span class="line" id="L13655"></span>
<span class="line" id="L13656"><span class="tok-kw">fn</span> <span class="tok-fn">countBodyLenAfterFixups</span>(astgen: *AstGen, body: []<span class="tok-kw">const</span> Zir.Inst.Index) <span class="tok-type">u32</span> {</span>
<span class="line" id="L13657">    <span class="tok-kw">var</span> count = body.len;</span>
<span class="line" id="L13658">    <span class="tok-kw">for</span> (body) |body_inst| {</span>
<span class="line" id="L13659">        <span class="tok-kw">var</span> check_inst = body_inst;</span>
<span class="line" id="L13660">        <span class="tok-kw">while</span> (astgen.ref_table.get(check_inst)) |ref_inst| {</span>
<span class="line" id="L13661">            count += <span class="tok-number">1</span>;</span>
<span class="line" id="L13662">            check_inst = ref_inst;</span>
<span class="line" id="L13663">        }</span>
<span class="line" id="L13664">    }</span>
<span class="line" id="L13665">    <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(count);</span>
<span class="line" id="L13666">}</span>
<span class="line" id="L13667"></span>
<span class="line" id="L13668"><span class="tok-kw">fn</span> <span class="tok-fn">emitDbgStmt</span>(gz: *GenZir, lc: LineColumn) !<span class="tok-type">void</span> {</span>
<span class="line" id="L13669">    <span class="tok-kw">if</span> (gz.is_comptime) <span class="tok-kw">return</span>;</span>
<span class="line" id="L13670">    <span class="tok-kw">if</span> (gz.instructions.items.len &gt; gz.instructions_top) {</span>
<span class="line" id="L13671">        <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L13672">        <span class="tok-kw">const</span> last = gz.instructions.items[gz.instructions.items.len - <span class="tok-number">1</span>];</span>
<span class="line" id="L13673">        <span class="tok-kw">if</span> (astgen.instructions.items(.tag)[<span class="tok-builtin">@intFromEnum</span>(last)] == .dbg_stmt) {</span>
<span class="line" id="L13674">            astgen.instructions.items(.data)[<span class="tok-builtin">@intFromEnum</span>(last)].dbg_stmt = .{</span>
<span class="line" id="L13675">                .line = lc[<span class="tok-number">0</span>],</span>
<span class="line" id="L13676">                .column = lc[<span class="tok-number">1</span>],</span>
<span class="line" id="L13677">            };</span>
<span class="line" id="L13678">            <span class="tok-kw">return</span>;</span>
<span class="line" id="L13679">        }</span>
<span class="line" id="L13680">    }</span>
<span class="line" id="L13681"></span>
<span class="line" id="L13682">    _ = <span class="tok-kw">try</span> gz.add(.{ .tag = .dbg_stmt, .data = .{</span>
<span class="line" id="L13683">        .dbg_stmt = .{</span>
<span class="line" id="L13684">            .line = lc[<span class="tok-number">0</span>],</span>
<span class="line" id="L13685">            .column = lc[<span class="tok-number">1</span>],</span>
<span class="line" id="L13686">        },</span>
<span class="line" id="L13687">    } });</span>
<span class="line" id="L13688">}</span>
<span class="line" id="L13689"></span>
<span class="line" id="L13690"><span class="tok-comment">/// In some cases, Sema expects us to generate a `dbg_stmt` at the instruction</span></span>
<span class="line" id="L13691"><span class="tok-comment">/// *index* directly preceding the next instruction (e.g. if a call is %10, it</span></span>
<span class="line" id="L13692"><span class="tok-comment">/// expects a dbg_stmt at %9). TODO: this logic may allow redundant dbg_stmt</span></span>
<span class="line" id="L13693"><span class="tok-comment">/// instructions; fix up Sema so we don't need it!</span></span>
<span class="line" id="L13694"><span class="tok-kw">fn</span> <span class="tok-fn">emitDbgStmtForceCurrentIndex</span>(gz: *GenZir, lc: LineColumn) !<span class="tok-type">void</span> {</span>
<span class="line" id="L13695">    <span class="tok-kw">const</span> astgen = gz.astgen;</span>
<span class="line" id="L13696">    <span class="tok-kw">if</span> (gz.instructions.items.len &gt; gz.instructions_top <span class="tok-kw">and</span></span>
<span class="line" id="L13697">        <span class="tok-builtin">@intFromEnum</span>(gz.instructions.items[gz.instructions.items.len - <span class="tok-number">1</span>]) == astgen.instructions.len - <span class="tok-number">1</span>)</span>
<span class="line" id="L13698">    {</span>
<span class="line" id="L13699">        <span class="tok-kw">const</span> last = astgen.instructions.len - <span class="tok-number">1</span>;</span>
<span class="line" id="L13700">        <span class="tok-kw">if</span> (astgen.instructions.items(.tag)[last] == .dbg_stmt) {</span>
<span class="line" id="L13701">            astgen.instructions.items(.data)[last].dbg_stmt = .{</span>
<span class="line" id="L13702">                .line = lc[<span class="tok-number">0</span>],</span>
<span class="line" id="L13703">                .column = lc[<span class="tok-number">1</span>],</span>
<span class="line" id="L13704">            };</span>
<span class="line" id="L13705">            <span class="tok-kw">return</span>;</span>
<span class="line" id="L13706">        }</span>
<span class="line" id="L13707">    }</span>
<span class="line" id="L13708"></span>
<span class="line" id="L13709">    _ = <span class="tok-kw">try</span> gz.add(.{ .tag = .dbg_stmt, .data = .{</span>
<span class="line" id="L13710">        .dbg_stmt = .{</span>
<span class="line" id="L13711">            .line = lc[<span class="tok-number">0</span>],</span>
<span class="line" id="L13712">            .column = lc[<span class="tok-number">1</span>],</span>
<span class="line" id="L13713">        },</span>
<span class="line" id="L13714">    } });</span>
<span class="line" id="L13715">}</span>
<span class="line" id="L13716"></span>
<span class="line" id="L13717"><span class="tok-kw">fn</span> <span class="tok-fn">lowerAstErrors</span>(astgen: *AstGen) !<span class="tok-type">void</span> {</span>
<span class="line" id="L13718">    <span class="tok-kw">const</span> tree = astgen.tree;</span>
<span class="line" id="L13719">    assert(tree.errors.len &gt; <span class="tok-number">0</span>);</span>
<span class="line" id="L13720"></span>
<span class="line" id="L13721">    <span class="tok-kw">const</span> gpa = astgen.gpa;</span>
<span class="line" id="L13722">    <span class="tok-kw">const</span> parse_err = tree.errors[<span class="tok-number">0</span>];</span>
<span class="line" id="L13723"></span>
<span class="line" id="L13724">    <span class="tok-kw">var</span> msg: std.ArrayListUnmanaged(<span class="tok-type">u8</span>) = .{};</span>
<span class="line" id="L13725">    <span class="tok-kw">defer</span> msg.deinit(gpa);</span>
<span class="line" id="L13726"></span>
<span class="line" id="L13727">    <span class="tok-kw">const</span> token_starts = tree.tokens.items(.start);</span>
<span class="line" id="L13728">    <span class="tok-kw">const</span> token_tags = tree.tokens.items(.tag);</span>
<span class="line" id="L13729"></span>
<span class="line" id="L13730">    <span class="tok-kw">var</span> notes: std.ArrayListUnmanaged(<span class="tok-type">u32</span>) = .{};</span>
<span class="line" id="L13731">    <span class="tok-kw">defer</span> notes.deinit(gpa);</span>
<span class="line" id="L13732"></span>
<span class="line" id="L13733">    <span class="tok-kw">if</span> (token_tags[parse_err.token + <span class="tok-builtin">@intFromBool</span>(parse_err.token_is_prev)] == .invalid) {</span>
<span class="line" id="L13734">        <span class="tok-kw">const</span> tok = parse_err.token + <span class="tok-builtin">@intFromBool</span>(parse_err.token_is_prev);</span>
<span class="line" id="L13735">        <span class="tok-kw">const</span> bad_off: <span class="tok-type">u32</span> = <span class="tok-builtin">@intCast</span>(tree.tokenSlice(parse_err.token + <span class="tok-builtin">@intFromBool</span>(parse_err.token_is_prev)).len);</span>
<span class="line" id="L13736">        <span class="tok-kw">const</span> byte_abs = token_starts[parse_err.token + <span class="tok-builtin">@intFromBool</span>(parse_err.token_is_prev)] + bad_off;</span>
<span class="line" id="L13737">        <span class="tok-kw">try</span> notes.append(gpa, <span class="tok-kw">try</span> astgen.errNoteTokOff(tok, bad_off, <span class="tok-str">&quot;invalid byte: '{'}'&quot;</span>, .{</span>
<span class="line" id="L13738">            std.zig.fmtEscapes(tree.source[byte_abs..][<span class="tok-number">0</span>..<span class="tok-number">1</span>]),</span>
<span class="line" id="L13739">        }));</span>
<span class="line" id="L13740">    }</span>
<span class="line" id="L13741"></span>
<span class="line" id="L13742">    <span class="tok-kw">for</span> (tree.errors[<span class="tok-number">1</span>..]) |note| {</span>
<span class="line" id="L13743">        <span class="tok-kw">if</span> (!note.is_note) <span class="tok-kw">break</span>;</span>
<span class="line" id="L13744"></span>
<span class="line" id="L13745">        msg.clearRetainingCapacity();</span>
<span class="line" id="L13746">        <span class="tok-kw">try</span> tree.renderError(note, msg.writer(gpa));</span>
<span class="line" id="L13747">        <span class="tok-kw">try</span> notes.append(gpa, <span class="tok-kw">try</span> astgen.errNoteTok(note.token, <span class="tok-str">&quot;{s}&quot;</span>, .{msg.items}));</span>
<span class="line" id="L13748">    }</span>
<span class="line" id="L13749"></span>
<span class="line" id="L13750">    <span class="tok-kw">const</span> extra_offset = tree.errorOffset(parse_err);</span>
<span class="line" id="L13751">    msg.clearRetainingCapacity();</span>
<span class="line" id="L13752">    <span class="tok-kw">try</span> tree.renderError(parse_err, msg.writer(gpa));</span>
<span class="line" id="L13753">    <span class="tok-kw">try</span> astgen.appendErrorTokNotesOff(parse_err.token, extra_offset, <span class="tok-str">&quot;{s}&quot;</span>, .{msg.items}, notes.items);</span>
<span class="line" id="L13754">}</span>
<span class="line" id="L13755"></span>
<span class="line" id="L13756"><span class="tok-kw">const</span> DeclarationName = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {</span>
<span class="line" id="L13757">    named: Ast.TokenIndex,</span>
<span class="line" id="L13758">    named_test: Ast.TokenIndex,</span>
<span class="line" id="L13759">    unnamed_test,</span>
<span class="line" id="L13760">    decltest: Zir.NullTerminatedString,</span>
<span class="line" id="L13761">    @&quot;comptime&quot;,</span>
<span class="line" id="L13762">    @&quot;usingnamespace&quot;,</span>
<span class="line" id="L13763">};</span>
<span class="line" id="L13764"></span>
<span class="line" id="L13765"><span class="tok-comment">/// Sets all extra data for a `declaration` instruction.</span></span>
<span class="line" id="L13766"><span class="tok-comment">/// Unstacks `value_gz`, `align_gz`, `linksection_gz`, and `addrspace_gz`.</span></span>
<span class="line" id="L13767"><span class="tok-kw">fn</span> <span class="tok-fn">setDeclaration</span>(</span>
<span class="line" id="L13768">    decl_inst: Zir.Inst.Index,</span>
<span class="line" id="L13769">    src_hash: std.zig.SrcHash,</span>
<span class="line" id="L13770">    name: DeclarationName,</span>
<span class="line" id="L13771">    line_offset: <span class="tok-type">u32</span>,</span>
<span class="line" id="L13772">    is_pub: <span class="tok-type">bool</span>,</span>
<span class="line" id="L13773">    is_export: <span class="tok-type">bool</span>,</span>
<span class="line" id="L13774">    doc_comment: Zir.NullTerminatedString,</span>
<span class="line" id="L13775">    value_gz: *GenZir,</span>
<span class="line" id="L13776">    <span class="tok-comment">/// May be `null` if all these blocks would be empty.</span></span>
<span class="line" id="L13777">    <span class="tok-comment">/// If `null`, then `value_gz` must have nothing stacked on it.</span></span>
<span class="line" id="L13778">    extra_gzs: ?<span class="tok-kw">struct</span> {</span>
<span class="line" id="L13779">        <span class="tok-comment">/// Must be stacked on `value_gz`.</span></span>
<span class="line" id="L13780">        align_gz: *GenZir,</span>
<span class="line" id="L13781">        <span class="tok-comment">/// Must be stacked on `align_gz`.</span></span>
<span class="line" id="L13782">        linksection_gz: *GenZir,</span>
<span class="line" id="L13783">        <span class="tok-comment">/// Must be stacked on `linksection_gz`, and have nothing stacked on it.</span></span>
<span class="line" id="L13784">        addrspace_gz: *GenZir,</span>
<span class="line" id="L13785">    },</span>
<span class="line" id="L13786">) !<span class="tok-type">void</span> {</span>
<span class="line" id="L13787">    <span class="tok-kw">const</span> astgen = value_gz.astgen;</span>
<span class="line" id="L13788">    <span class="tok-kw">const</span> gpa = astgen.gpa;</span>
<span class="line" id="L13789"></span>
<span class="line" id="L13790">    <span class="tok-kw">const</span> empty_body: []Zir.Inst.Index = &amp;.{};</span>
<span class="line" id="L13791">    <span class="tok-kw">const</span> value_body, <span class="tok-kw">const</span> align_body, <span class="tok-kw">const</span> linksection_body, <span class="tok-kw">const</span> addrspace_body = <span class="tok-kw">if</span> (extra_gzs) |e| .{</span>
<span class="line" id="L13792">        value_gz.instructionsSliceUpto(e.align_gz),</span>
<span class="line" id="L13793">        e.align_gz.instructionsSliceUpto(e.linksection_gz),</span>
<span class="line" id="L13794">        e.linksection_gz.instructionsSliceUpto(e.addrspace_gz),</span>
<span class="line" id="L13795">        e.addrspace_gz.instructionsSlice(),</span>
<span class="line" id="L13796">    } <span class="tok-kw">else</span> .{ value_gz.instructionsSlice(), empty_body, empty_body, empty_body };</span>
<span class="line" id="L13797"></span>
<span class="line" id="L13798">    <span class="tok-kw">const</span> value_len = astgen.countBodyLenAfterFixups(value_body);</span>
<span class="line" id="L13799">    <span class="tok-kw">const</span> align_len = astgen.countBodyLenAfterFixups(align_body);</span>
<span class="line" id="L13800">    <span class="tok-kw">const</span> linksection_len = astgen.countBodyLenAfterFixups(linksection_body);</span>
<span class="line" id="L13801">    <span class="tok-kw">const</span> addrspace_len = astgen.countBodyLenAfterFixups(addrspace_body);</span>
<span class="line" id="L13802"></span>
<span class="line" id="L13803">    <span class="tok-kw">const</span> true_doc_comment: Zir.NullTerminatedString = <span class="tok-kw">switch</span> (name) {</span>
<span class="line" id="L13804">        .decltest =&gt; |test_name| test_name,</span>
<span class="line" id="L13805">        <span class="tok-kw">else</span> =&gt; doc_comment,</span>
<span class="line" id="L13806">    };</span>
<span class="line" id="L13807"></span>
<span class="line" id="L13808">    <span class="tok-kw">const</span> src_hash_arr: [<span class="tok-number">4</span>]<span class="tok-type">u32</span> = <span class="tok-builtin">@bitCast</span>(src_hash);</span>
<span class="line" id="L13809"></span>
<span class="line" id="L13810">    <span class="tok-kw">const</span> extra: Zir.Inst.Declaration = .{</span>
<span class="line" id="L13811">        .src_hash_0 = src_hash_arr[<span class="tok-number">0</span>],</span>
<span class="line" id="L13812">        .src_hash_1 = src_hash_arr[<span class="tok-number">1</span>],</span>
<span class="line" id="L13813">        .src_hash_2 = src_hash_arr[<span class="tok-number">2</span>],</span>
<span class="line" id="L13814">        .src_hash_3 = src_hash_arr[<span class="tok-number">3</span>],</span>
<span class="line" id="L13815">        .name = <span class="tok-kw">switch</span> (name) {</span>
<span class="line" id="L13816">            .named =&gt; |tok| <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@intFromEnum</span>(<span class="tok-kw">try</span> astgen.identAsString(tok))),</span>
<span class="line" id="L13817">            .named_test =&gt; |tok| <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@intFromEnum</span>(<span class="tok-kw">try</span> astgen.testNameString(tok))),</span>
<span class="line" id="L13818">            .unnamed_test =&gt; .unnamed_test,</span>
<span class="line" id="L13819">            .decltest =&gt; .decltest,</span>
<span class="line" id="L13820">            .@&quot;comptime&quot; =&gt; .@&quot;comptime&quot;,</span>
<span class="line" id="L13821">            .@&quot;usingnamespace&quot; =&gt; .@&quot;usingnamespace&quot;,</span>
<span class="line" id="L13822">        },</span>
<span class="line" id="L13823">        .line_offset = line_offset,</span>
<span class="line" id="L13824">        .flags = .{</span>
<span class="line" id="L13825">            .value_body_len = <span class="tok-builtin">@intCast</span>(value_len),</span>
<span class="line" id="L13826">            .is_pub = is_pub,</span>
<span class="line" id="L13827">            .is_export = is_export,</span>
<span class="line" id="L13828">            .has_doc_comment = true_doc_comment != .empty,</span>
<span class="line" id="L13829">            .has_align_linksection_addrspace = align_len != <span class="tok-number">0</span> <span class="tok-kw">or</span> linksection_len != <span class="tok-number">0</span> <span class="tok-kw">or</span> addrspace_len != <span class="tok-number">0</span>,</span>
<span class="line" id="L13830">        },</span>
<span class="line" id="L13831">    };</span>
<span class="line" id="L13832">    astgen.instructions.items(.data)[<span class="tok-builtin">@intFromEnum</span>(decl_inst)].pl_node.payload_index = <span class="tok-kw">try</span> astgen.addExtra(extra);</span>
<span class="line" id="L13833">    <span class="tok-kw">if</span> (extra.flags.has_doc_comment) {</span>
<span class="line" id="L13834">        <span class="tok-kw">try</span> astgen.extra.append(gpa, <span class="tok-builtin">@intFromEnum</span>(true_doc_comment));</span>
<span class="line" id="L13835">    }</span>
<span class="line" id="L13836">    <span class="tok-kw">if</span> (extra.flags.has_align_linksection_addrspace) {</span>
<span class="line" id="L13837">        <span class="tok-kw">try</span> astgen.extra.appendSlice(gpa, &amp;.{</span>
<span class="line" id="L13838">            align_len,</span>
<span class="line" id="L13839">            linksection_len,</span>
<span class="line" id="L13840">            addrspace_len,</span>
<span class="line" id="L13841">        });</span>
<span class="line" id="L13842">    }</span>
<span class="line" id="L13843">    <span class="tok-kw">try</span> astgen.extra.ensureUnusedCapacity(gpa, value_len + align_len + linksection_len + addrspace_len);</span>
<span class="line" id="L13844">    astgen.appendBodyWithFixups(value_body);</span>
<span class="line" id="L13845">    <span class="tok-kw">if</span> (extra.flags.has_align_linksection_addrspace) {</span>
<span class="line" id="L13846">        astgen.appendBodyWithFixups(align_body);</span>
<span class="line" id="L13847">        astgen.appendBodyWithFixups(linksection_body);</span>
<span class="line" id="L13848">        astgen.appendBodyWithFixups(addrspace_body);</span>
<span class="line" id="L13849">    }</span>
<span class="line" id="L13850"></span>
<span class="line" id="L13851">    <span class="tok-kw">if</span> (extra_gzs) |e| {</span>
<span class="line" id="L13852">        e.addrspace_gz.unstack();</span>
<span class="line" id="L13853">        e.linksection_gz.unstack();</span>
<span class="line" id="L13854">        e.align_gz.unstack();</span>
<span class="line" id="L13855">    }</span>
<span class="line" id="L13856">    value_gz.unstack();</span>
<span class="line" id="L13857">}</span>
<span class="line" id="L13858"></span>
</code></pre></body>
</html>