<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>zig/Zir.zig - source view</title>
    <link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAgklEQVR4AWMYWuD7EllJIM4G4g4g5oIJ/odhOJ8wToOxSTXgNxDHoeiBMfA4+wGShjyYOCkG/IGqWQziEzYAoUAeiF9D5U+DxEg14DRU7jWIT5IBIOdCxf+A+CQZAAoopEB7QJwBCBwHiip8UYmRdrAlDpIMgApwQZNnNii5Dq0MBgCxxycBnwEd+wAAAABJRU5ErkJggg==">
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style>
      body{
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        margin: 0;
        line-height: 1.5;
      }

      pre > code {
        display: block;
        overflow: auto;
        line-height: normal;
        margin: 0em;
      }
      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #005C7A;
      }
      .tok-comment {
          color: #545454;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #005C5C;
      }
      .tok-number {
          color: #005C5C;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }
      pre {
        counter-reset: line;
      }
      pre .line:before {
        counter-increment: line;
        content: counter(line);
        display: inline-block;
        padding-right: 1em;
        width: 2em;
        text-align: right;
        color: #999;
      }
      
      .line {
        width: 100%;
        display: inline-block;
      }
      .line:target {
        border-top: 1px solid #ccc;
        border-bottom: 1px solid #ccc;
        background: #fafafa;
      }

      @media (prefers-color-scheme: dark) {
        body{
            background:#222;
            color: #ccc;
        }
        pre > code {
            color: #ccc;
            background: #222;
            border: unset;
        }
        .line:target {
            border-top: 1px solid #444;
            border-bottom: 1px solid #444;
            background: #333;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
</head>
<body>
<pre><code><span class="line" id="L1"><span class="tok-comment">//! Zig Intermediate Representation. Astgen.zig converts AST nodes to these</span></span>
<span class="line" id="L2"><span class="tok-comment">//! untyped IR instructions. Next, Sema.zig processes these into AIR.</span></span>
<span class="line" id="L3"><span class="tok-comment">//! The minimum amount of information needed to represent a list of ZIR instructions.</span></span>
<span class="line" id="L4"><span class="tok-comment">//! Once this structure is completed, it can be used to generate AIR, followed by</span></span>
<span class="line" id="L5"><span class="tok-comment">//! machine code, without any memory access into the AST tree token list, node list,</span></span>
<span class="line" id="L6"><span class="tok-comment">//! or source bytes. Exceptions include:</span></span>
<span class="line" id="L7"><span class="tok-comment">//!  * Compile errors, which may need to reach into these data structures to</span></span>
<span class="line" id="L8"><span class="tok-comment">//!    create a useful report.</span></span>
<span class="line" id="L9"><span class="tok-comment">//!  * In the future, possibly inline assembly, which needs to get parsed and</span></span>
<span class="line" id="L10"><span class="tok-comment">//!    handled by the codegen backend, and errors reported there. However for now,</span></span>
<span class="line" id="L11"><span class="tok-comment">//!    inline assembly is not an exception.</span></span>
<span class="line" id="L12"></span>
<span class="line" id="L13"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);</span>
<span class="line" id="L14"><span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);</span>
<span class="line" id="L15"><span class="tok-kw">const</span> mem = std.mem;</span>
<span class="line" id="L16"><span class="tok-kw">const</span> Allocator = std.mem.Allocator;</span>
<span class="line" id="L17"><span class="tok-kw">const</span> assert = std.debug.assert;</span>
<span class="line" id="L18"><span class="tok-kw">const</span> BigIntConst = std.math.big.int.Const;</span>
<span class="line" id="L19"><span class="tok-kw">const</span> BigIntMutable = std.math.big.int.Mutable;</span>
<span class="line" id="L20"><span class="tok-kw">const</span> Ast = std.zig.Ast;</span>
<span class="line" id="L21"></span>
<span class="line" id="L22"><span class="tok-kw">const</span> Zir = <span class="tok-builtin">@This</span>();</span>
<span class="line" id="L23"><span class="tok-kw">const</span> LazySrcLoc = std.zig.LazySrcLoc;</span>
<span class="line" id="L24"></span>
<span class="line" id="L25">instructions: std.MultiArrayList(Inst).Slice,</span>
<span class="line" id="L26"><span class="tok-comment">/// In order to store references to strings in fewer bytes, we copy all</span></span>
<span class="line" id="L27"><span class="tok-comment">/// string bytes into here. String bytes can be null. It is up to whomever</span></span>
<span class="line" id="L28"><span class="tok-comment">/// is referencing the data here whether they want to store both index and length,</span></span>
<span class="line" id="L29"><span class="tok-comment">/// thus allowing null bytes, or store only index, and use null-termination. The</span></span>
<span class="line" id="L30"><span class="tok-comment">/// `string_bytes` array is agnostic to either usage.</span></span>
<span class="line" id="L31"><span class="tok-comment">/// Index 0 is reserved for special cases.</span></span>
<span class="line" id="L32">string_bytes: []<span class="tok-type">u8</span>,</span>
<span class="line" id="L33"><span class="tok-comment">/// The meaning of this data is determined by `Inst.Tag` value.</span></span>
<span class="line" id="L34"><span class="tok-comment">/// The first few indexes are reserved. See `ExtraIndex` for the values.</span></span>
<span class="line" id="L35">extra: []<span class="tok-type">u32</span>,</span>
<span class="line" id="L36"></span>
<span class="line" id="L37"><span class="tok-comment">/// The data stored at byte offset 0 when ZIR is stored in a file.</span></span>
<span class="line" id="L38"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Header = <span class="tok-kw">extern</span> <span class="tok-kw">struct</span> {</span>
<span class="line" id="L39">    instructions_len: <span class="tok-type">u32</span>,</span>
<span class="line" id="L40">    string_bytes_len: <span class="tok-type">u32</span>,</span>
<span class="line" id="L41">    extra_len: <span class="tok-type">u32</span>,</span>
<span class="line" id="L42">    <span class="tok-comment">/// We could leave this as padding, however it triggers a Valgrind warning because</span></span>
<span class="line" id="L43">    <span class="tok-comment">/// we read and write undefined bytes to the file system. This is harmless, but</span></span>
<span class="line" id="L44">    <span class="tok-comment">/// it's essentially free to have a zero field here and makes the warning go away,</span></span>
<span class="line" id="L45">    <span class="tok-comment">/// making it more likely that following Valgrind warnings will be taken seriously.</span></span>
<span class="line" id="L46">    unused: <span class="tok-type">u32</span> = <span class="tok-number">0</span>,</span>
<span class="line" id="L47">    stat_inode: std.fs.File.INode,</span>
<span class="line" id="L48">    stat_size: <span class="tok-type">u64</span>,</span>
<span class="line" id="L49">    stat_mtime: <span class="tok-type">i128</span>,</span>
<span class="line" id="L50">};</span>
<span class="line" id="L51"></span>
<span class="line" id="L52"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ExtraIndex = <span class="tok-kw">enum</span>(<span class="tok-type">u32</span>) {</span>
<span class="line" id="L53">    <span class="tok-comment">/// If this is 0, no compile errors. Otherwise there is a `CompileErrors`</span></span>
<span class="line" id="L54">    <span class="tok-comment">/// payload at this index.</span></span>
<span class="line" id="L55">    compile_errors,</span>
<span class="line" id="L56">    <span class="tok-comment">/// If this is 0, this file contains no imports. Otherwise there is a `Imports`</span></span>
<span class="line" id="L57">    <span class="tok-comment">/// payload at this index.</span></span>
<span class="line" id="L58">    imports,</span>
<span class="line" id="L59"></span>
<span class="line" id="L60">    _,</span>
<span class="line" id="L61">};</span>
<span class="line" id="L62"></span>
<span class="line" id="L63"><span class="tok-kw">fn</span> <span class="tok-fn">ExtraData</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">type</span> {</span>
<span class="line" id="L64">    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> { data: T, end: <span class="tok-type">usize</span> };</span>
<span class="line" id="L65">}</span>
<span class="line" id="L66"></span>
<span class="line" id="L67"><span class="tok-comment">/// Returns the requested data, as well as the new index which is at the start of the</span></span>
<span class="line" id="L68"><span class="tok-comment">/// trailers for the object.</span></span>
<span class="line" id="L69"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">extraData</span>(code: Zir, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, index: <span class="tok-type">usize</span>) ExtraData(T) {</span>
<span class="line" id="L70">    <span class="tok-kw">const</span> fields = <span class="tok-builtin">@typeInfo</span>(T).Struct.fields;</span>
<span class="line" id="L71">    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = index;</span>
<span class="line" id="L72">    <span class="tok-kw">var</span> result: T = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L73">    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (fields) |field| {</span>
<span class="line" id="L74">        <span class="tok-builtin">@field</span>(result, field.name) = <span class="tok-kw">switch</span> (field.<span class="tok-type">type</span>) {</span>
<span class="line" id="L75">            <span class="tok-type">u32</span> =&gt; code.extra[i],</span>
<span class="line" id="L76"></span>
<span class="line" id="L77">            Inst.Ref,</span>
<span class="line" id="L78">            Inst.Index,</span>
<span class="line" id="L79">            Inst.Declaration.Name,</span>
<span class="line" id="L80">            NullTerminatedString,</span>
<span class="line" id="L81">            =&gt; <span class="tok-builtin">@enumFromInt</span>(code.extra[i]),</span>
<span class="line" id="L82"></span>
<span class="line" id="L83">            <span class="tok-type">i32</span>,</span>
<span class="line" id="L84">            Inst.Call.Flags,</span>
<span class="line" id="L85">            Inst.BuiltinCall.Flags,</span>
<span class="line" id="L86">            Inst.SwitchBlock.Bits,</span>
<span class="line" id="L87">            Inst.SwitchBlockErrUnion.Bits,</span>
<span class="line" id="L88">            Inst.FuncFancy.Bits,</span>
<span class="line" id="L89">            Inst.Declaration.Flags,</span>
<span class="line" id="L90">            =&gt; <span class="tok-builtin">@bitCast</span>(code.extra[i]),</span>
<span class="line" id="L91"></span>
<span class="line" id="L92">            <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;bad field type&quot;</span>),</span>
<span class="line" id="L93">        };</span>
<span class="line" id="L94">        i += <span class="tok-number">1</span>;</span>
<span class="line" id="L95">    }</span>
<span class="line" id="L96">    <span class="tok-kw">return</span> .{</span>
<span class="line" id="L97">        .data = result,</span>
<span class="line" id="L98">        .end = i,</span>
<span class="line" id="L99">    };</span>
<span class="line" id="L100">}</span>
<span class="line" id="L101"></span>
<span class="line" id="L102"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> NullTerminatedString = <span class="tok-kw">enum</span>(<span class="tok-type">u32</span>) {</span>
<span class="line" id="L103">    empty = <span class="tok-number">0</span>,</span>
<span class="line" id="L104">    _,</span>
<span class="line" id="L105">};</span>
<span class="line" id="L106"></span>
<span class="line" id="L107"><span class="tok-comment">/// Given an index into `string_bytes` returns the null-terminated string found there.</span></span>
<span class="line" id="L108"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nullTerminatedString</span>(code: Zir, index: NullTerminatedString) [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L109">    <span class="tok-kw">const</span> start = <span class="tok-builtin">@intFromEnum</span>(index);</span>
<span class="line" id="L110">    <span class="tok-kw">var</span> end: <span class="tok-type">u32</span> = start;</span>
<span class="line" id="L111">    <span class="tok-kw">while</span> (code.string_bytes[end] != <span class="tok-number">0</span>) {</span>
<span class="line" id="L112">        end += <span class="tok-number">1</span>;</span>
<span class="line" id="L113">    }</span>
<span class="line" id="L114">    <span class="tok-kw">return</span> code.string_bytes[start..end :<span class="tok-number">0</span>];</span>
<span class="line" id="L115">}</span>
<span class="line" id="L116"></span>
<span class="line" id="L117"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">refSlice</span>(code: Zir, start: <span class="tok-type">usize</span>, len: <span class="tok-type">usize</span>) []Inst.Ref {</span>
<span class="line" id="L118">    <span class="tok-kw">return</span> <span class="tok-builtin">@ptrCast</span>(code.extra[start..][<span class="tok-number">0</span>..len]);</span>
<span class="line" id="L119">}</span>
<span class="line" id="L120"></span>
<span class="line" id="L121"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bodySlice</span>(zir: Zir, start: <span class="tok-type">usize</span>, len: <span class="tok-type">usize</span>) []Inst.Index {</span>
<span class="line" id="L122">    <span class="tok-kw">return</span> <span class="tok-builtin">@ptrCast</span>(zir.extra[start..][<span class="tok-number">0</span>..len]);</span>
<span class="line" id="L123">}</span>
<span class="line" id="L124"></span>
<span class="line" id="L125"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hasCompileErrors</span>(code: Zir) <span class="tok-type">bool</span> {</span>
<span class="line" id="L126">    <span class="tok-kw">return</span> code.extra[<span class="tok-builtin">@intFromEnum</span>(ExtraIndex.compile_errors)] != <span class="tok-number">0</span>;</span>
<span class="line" id="L127">}</span>
<span class="line" id="L128"></span>
<span class="line" id="L129"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(code: *Zir, gpa: Allocator) <span class="tok-type">void</span> {</span>
<span class="line" id="L130">    code.instructions.deinit(gpa);</span>
<span class="line" id="L131">    gpa.free(code.string_bytes);</span>
<span class="line" id="L132">    gpa.free(code.extra);</span>
<span class="line" id="L133">    code.* = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L134">}</span>
<span class="line" id="L135"></span>
<span class="line" id="L136"><span class="tok-comment">/// These are untyped instructions generated from an Abstract Syntax Tree.</span></span>
<span class="line" id="L137"><span class="tok-comment">/// The data here is immutable because it is possible to have multiple</span></span>
<span class="line" id="L138"><span class="tok-comment">/// analyses on the same ZIR happening at the same time.</span></span>
<span class="line" id="L139"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Inst = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L140">    tag: Tag,</span>
<span class="line" id="L141">    data: Data,</span>
<span class="line" id="L142"></span>
<span class="line" id="L143">    <span class="tok-comment">/// These names are used directly as the instruction names in the text format.</span></span>
<span class="line" id="L144">    <span class="tok-comment">/// See `data_field_map` for a list of which `Data` fields are used by each `Tag`.</span></span>
<span class="line" id="L145">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Tag = <span class="tok-kw">enum</span>(<span class="tok-type">u8</span>) {</span>
<span class="line" id="L146">        <span class="tok-comment">/// Arithmetic addition, asserts no integer overflow.</span></span>
<span class="line" id="L147">        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Bin`.</span></span>
<span class="line" id="L148">        add,</span>
<span class="line" id="L149">        <span class="tok-comment">/// Twos complement wrapping integer addition.</span></span>
<span class="line" id="L150">        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Bin`.</span></span>
<span class="line" id="L151">        addwrap,</span>
<span class="line" id="L152">        <span class="tok-comment">/// Saturating addition.</span></span>
<span class="line" id="L153">        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Bin`.</span></span>
<span class="line" id="L154">        add_sat,</span>
<span class="line" id="L155">        <span class="tok-comment">/// The same as `add` except no safety check.</span></span>
<span class="line" id="L156">        add_unsafe,</span>
<span class="line" id="L157">        <span class="tok-comment">/// Arithmetic subtraction. Asserts no integer overflow.</span></span>
<span class="line" id="L158">        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Bin`.</span></span>
<span class="line" id="L159">        sub,</span>
<span class="line" id="L160">        <span class="tok-comment">/// Twos complement wrapping integer subtraction.</span></span>
<span class="line" id="L161">        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Bin`.</span></span>
<span class="line" id="L162">        subwrap,</span>
<span class="line" id="L163">        <span class="tok-comment">/// Saturating subtraction.</span></span>
<span class="line" id="L164">        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Bin`.</span></span>
<span class="line" id="L165">        sub_sat,</span>
<span class="line" id="L166">        <span class="tok-comment">/// Arithmetic multiplication. Asserts no integer overflow.</span></span>
<span class="line" id="L167">        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Bin`.</span></span>
<span class="line" id="L168">        mul,</span>
<span class="line" id="L169">        <span class="tok-comment">/// Twos complement wrapping integer multiplication.</span></span>
<span class="line" id="L170">        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Bin`.</span></span>
<span class="line" id="L171">        mulwrap,</span>
<span class="line" id="L172">        <span class="tok-comment">/// Saturating multiplication.</span></span>
<span class="line" id="L173">        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Bin`.</span></span>
<span class="line" id="L174">        mul_sat,</span>
<span class="line" id="L175">        <span class="tok-comment">/// Implements the `@divExact` builtin.</span></span>
<span class="line" id="L176">        <span class="tok-comment">/// Uses the `pl_node` union field with payload `Bin`.</span></span>
<span class="line" id="L177">        div_exact,</span>
<span class="line" id="L178">        <span class="tok-comment">/// Implements the `@divFloor` builtin.</span></span>
<span class="line" id="L179">        <span class="tok-comment">/// Uses the `pl_node` union field with payload `Bin`.</span></span>
<span class="line" id="L180">        div_floor,</span>
<span class="line" id="L181">        <span class="tok-comment">/// Implements the `@divTrunc` builtin.</span></span>
<span class="line" id="L182">        <span class="tok-comment">/// Uses the `pl_node` union field with payload `Bin`.</span></span>
<span class="line" id="L183">        div_trunc,</span>
<span class="line" id="L184">        <span class="tok-comment">/// Implements the `@mod` builtin.</span></span>
<span class="line" id="L185">        <span class="tok-comment">/// Uses the `pl_node` union field with payload `Bin`.</span></span>
<span class="line" id="L186">        mod,</span>
<span class="line" id="L187">        <span class="tok-comment">/// Implements the `@rem` builtin.</span></span>
<span class="line" id="L188">        <span class="tok-comment">/// Uses the `pl_node` union field with payload `Bin`.</span></span>
<span class="line" id="L189">        rem,</span>
<span class="line" id="L190">        <span class="tok-comment">/// Ambiguously remainder division or modulus. If the computation would possibly have</span></span>
<span class="line" id="L191">        <span class="tok-comment">/// a different value depending on whether the operation is remainder division or modulus,</span></span>
<span class="line" id="L192">        <span class="tok-comment">/// a compile error is emitted. Otherwise the computation is performed.</span></span>
<span class="line" id="L193">        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Bin`.</span></span>
<span class="line" id="L194">        mod_rem,</span>
<span class="line" id="L195">        <span class="tok-comment">/// Integer shift-left. Zeroes are shifted in from the right hand side.</span></span>
<span class="line" id="L196">        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Bin`.</span></span>
<span class="line" id="L197">        shl,</span>
<span class="line" id="L198">        <span class="tok-comment">/// Implements the `@shlExact` builtin.</span></span>
<span class="line" id="L199">        <span class="tok-comment">/// Uses the `pl_node` union field with payload `Bin`.</span></span>
<span class="line" id="L200">        shl_exact,</span>
<span class="line" id="L201">        <span class="tok-comment">/// Saturating shift-left.</span></span>
<span class="line" id="L202">        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Bin`.</span></span>
<span class="line" id="L203">        shl_sat,</span>
<span class="line" id="L204">        <span class="tok-comment">/// Integer shift-right. Arithmetic or logical depending on the signedness of</span></span>
<span class="line" id="L205">        <span class="tok-comment">/// the integer type.</span></span>
<span class="line" id="L206">        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Bin`.</span></span>
<span class="line" id="L207">        shr,</span>
<span class="line" id="L208">        <span class="tok-comment">/// Implements the `@shrExact` builtin.</span></span>
<span class="line" id="L209">        <span class="tok-comment">/// Uses the `pl_node` union field with payload `Bin`.</span></span>
<span class="line" id="L210">        shr_exact,</span>
<span class="line" id="L211"></span>
<span class="line" id="L212">        <span class="tok-comment">/// Declares a parameter of the current function. Used for:</span></span>
<span class="line" id="L213">        <span class="tok-comment">/// * debug info</span></span>
<span class="line" id="L214">        <span class="tok-comment">/// * checking shadowing against declarations in the current namespace</span></span>
<span class="line" id="L215">        <span class="tok-comment">/// * parameter type expressions referencing other parameters</span></span>
<span class="line" id="L216">        <span class="tok-comment">/// These occur in the block outside a function body (the same block as</span></span>
<span class="line" id="L217">        <span class="tok-comment">/// contains the func instruction).</span></span>
<span class="line" id="L218">        <span class="tok-comment">/// Uses the `pl_tok` field. Token is the parameter name, payload is a `Param`.</span></span>
<span class="line" id="L219">        param,</span>
<span class="line" id="L220">        <span class="tok-comment">/// Same as `param` except the parameter is marked comptime.</span></span>
<span class="line" id="L221">        param_comptime,</span>
<span class="line" id="L222">        <span class="tok-comment">/// Same as `param` except the parameter is marked anytype.</span></span>
<span class="line" id="L223">        <span class="tok-comment">/// Uses the `str_tok` field. Token is the parameter name. String is the parameter name.</span></span>
<span class="line" id="L224">        param_anytype,</span>
<span class="line" id="L225">        <span class="tok-comment">/// Same as `param` except the parameter is marked both comptime and anytype.</span></span>
<span class="line" id="L226">        <span class="tok-comment">/// Uses the `str_tok` field. Token is the parameter name. String is the parameter name.</span></span>
<span class="line" id="L227">        param_anytype_comptime,</span>
<span class="line" id="L228">        <span class="tok-comment">/// Array concatenation. `a ++ b`</span></span>
<span class="line" id="L229">        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Bin`.</span></span>
<span class="line" id="L230">        array_cat,</span>
<span class="line" id="L231">        <span class="tok-comment">/// Array multiplication `a ** b`</span></span>
<span class="line" id="L232">        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `ArrayMul`.</span></span>
<span class="line" id="L233">        array_mul,</span>
<span class="line" id="L234">        <span class="tok-comment">/// `[N]T` syntax. No source location provided.</span></span>
<span class="line" id="L235">        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Bin`. lhs is length, rhs is element type.</span></span>
<span class="line" id="L236">        array_type,</span>
<span class="line" id="L237">        <span class="tok-comment">/// `[N:S]T` syntax. Source location is the array type expression node.</span></span>
<span class="line" id="L238">        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `ArrayTypeSentinel`.</span></span>
<span class="line" id="L239">        array_type_sentinel,</span>
<span class="line" id="L240">        <span class="tok-comment">/// `@Vector` builtin.</span></span>
<span class="line" id="L241">        <span class="tok-comment">/// Uses the `pl_node` union field with `Bin` payload.</span></span>
<span class="line" id="L242">        <span class="tok-comment">/// lhs is length, rhs is element type.</span></span>
<span class="line" id="L243">        vector_type,</span>
<span class="line" id="L244">        <span class="tok-comment">/// Given a pointer type, returns its element type. Reaches through any optional or error</span></span>
<span class="line" id="L245">        <span class="tok-comment">/// union types wrapping the pointer. Asserts that the underlying type is a pointer type.</span></span>
<span class="line" id="L246">        <span class="tok-comment">/// Returns generic poison if the element type is `anyopaque`.</span></span>
<span class="line" id="L247">        <span class="tok-comment">/// Uses the `un_node` field.</span></span>
<span class="line" id="L248">        elem_type,</span>
<span class="line" id="L249">        <span class="tok-comment">/// Given an indexable pointer (slice, many-ptr, single-ptr-to-array), returns its</span></span>
<span class="line" id="L250">        <span class="tok-comment">/// element type. Emits a compile error if the type is not an indexable pointer.</span></span>
<span class="line" id="L251">        <span class="tok-comment">/// Uses the `un_node` field.</span></span>
<span class="line" id="L252">        indexable_ptr_elem_type,</span>
<span class="line" id="L253">        <span class="tok-comment">/// Given a vector type, returns its element type.</span></span>
<span class="line" id="L254">        <span class="tok-comment">/// Uses the `un_node` field.</span></span>
<span class="line" id="L255">        vector_elem_type,</span>
<span class="line" id="L256">        <span class="tok-comment">/// Given a pointer to an indexable object, returns the len property. This is</span></span>
<span class="line" id="L257">        <span class="tok-comment">/// used by for loops. This instruction also emits a for-loop specific compile</span></span>
<span class="line" id="L258">        <span class="tok-comment">/// error if the indexable object is not indexable.</span></span>
<span class="line" id="L259">        <span class="tok-comment">/// Uses the `un_node` field. The AST node is the for loop node.</span></span>
<span class="line" id="L260">        indexable_ptr_len,</span>
<span class="line" id="L261">        <span class="tok-comment">/// Create a `anyframe-&gt;T` type.</span></span>
<span class="line" id="L262">        <span class="tok-comment">/// Uses the `un_node` field.</span></span>
<span class="line" id="L263">        anyframe_type,</span>
<span class="line" id="L264">        <span class="tok-comment">/// Type coercion to the function's return type.</span></span>
<span class="line" id="L265">        <span class="tok-comment">/// Uses the `pl_node` field. Payload is `As`. AST node could be many things.</span></span>
<span class="line" id="L266">        as_node,</span>
<span class="line" id="L267">        <span class="tok-comment">/// Same as `as_node` but ignores runtime to comptime int error.</span></span>
<span class="line" id="L268">        as_shift_operand,</span>
<span class="line" id="L269">        <span class="tok-comment">/// Bitwise AND. `&amp;`</span></span>
<span class="line" id="L270">        bit_and,</span>
<span class="line" id="L271">        <span class="tok-comment">/// Reinterpret the memory representation of a value as a different type.</span></span>
<span class="line" id="L272">        <span class="tok-comment">/// Uses the pl_node field with payload `Bin`.</span></span>
<span class="line" id="L273">        bitcast,</span>
<span class="line" id="L274">        <span class="tok-comment">/// Bitwise NOT. `~`</span></span>
<span class="line" id="L275">        <span class="tok-comment">/// Uses `un_node`.</span></span>
<span class="line" id="L276">        bit_not,</span>
<span class="line" id="L277">        <span class="tok-comment">/// Bitwise OR. `|`</span></span>
<span class="line" id="L278">        bit_or,</span>
<span class="line" id="L279">        <span class="tok-comment">/// A labeled block of code, which can return a value.</span></span>
<span class="line" id="L280">        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Block`.</span></span>
<span class="line" id="L281">        block,</span>
<span class="line" id="L282">        <span class="tok-comment">/// Like `block`, but forces full evaluation of its contents at compile-time.</span></span>
<span class="line" id="L283">        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Block`.</span></span>
<span class="line" id="L284">        block_comptime,</span>
<span class="line" id="L285">        <span class="tok-comment">/// A list of instructions which are analyzed in the parent context, without</span></span>
<span class="line" id="L286">        <span class="tok-comment">/// generating a runtime block. Must terminate with an &quot;inline&quot; variant of</span></span>
<span class="line" id="L287">        <span class="tok-comment">/// a noreturn instruction.</span></span>
<span class="line" id="L288">        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Block`.</span></span>
<span class="line" id="L289">        block_inline,</span>
<span class="line" id="L290">        <span class="tok-comment">/// This instruction may only ever appear in the list of declarations for a</span></span>
<span class="line" id="L291">        <span class="tok-comment">/// namespace type, e.g. within a `struct_decl` instruction. It represents a</span></span>
<span class="line" id="L292">        <span class="tok-comment">/// single source declaration (`const`/`var`/`fn`), containing the name,</span></span>
<span class="line" id="L293">        <span class="tok-comment">/// attributes, type, and value of the declaration.</span></span>
<span class="line" id="L294">        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Declaration`.</span></span>
<span class="line" id="L295">        declaration,</span>
<span class="line" id="L296">        <span class="tok-comment">/// Implements `suspend {...}`.</span></span>
<span class="line" id="L297">        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Block`.</span></span>
<span class="line" id="L298">        suspend_block,</span>
<span class="line" id="L299">        <span class="tok-comment">/// Boolean NOT. See also `bit_not`.</span></span>
<span class="line" id="L300">        <span class="tok-comment">/// Uses the `un_node` field.</span></span>
<span class="line" id="L301">        bool_not,</span>
<span class="line" id="L302">        <span class="tok-comment">/// Short-circuiting boolean `and`. `lhs` is a boolean `Ref` and the other operand</span></span>
<span class="line" id="L303">        <span class="tok-comment">/// is a block, which is evaluated if `lhs` is `true`.</span></span>
<span class="line" id="L304">        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `BoolBr`.</span></span>
<span class="line" id="L305">        bool_br_and,</span>
<span class="line" id="L306">        <span class="tok-comment">/// Short-circuiting boolean `or`. `lhs` is a boolean `Ref` and the other operand</span></span>
<span class="line" id="L307">        <span class="tok-comment">/// is a block, which is evaluated if `lhs` is `false`.</span></span>
<span class="line" id="L308">        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `BoolBr`.</span></span>
<span class="line" id="L309">        bool_br_or,</span>
<span class="line" id="L310">        <span class="tok-comment">/// Return a value from a block.</span></span>
<span class="line" id="L311">        <span class="tok-comment">/// Uses the `break` union field.</span></span>
<span class="line" id="L312">        <span class="tok-comment">/// Uses the source information from previous instruction.</span></span>
<span class="line" id="L313">        @&quot;break&quot;,</span>
<span class="line" id="L314">        <span class="tok-comment">/// Return a value from a block. This instruction is used as the terminator</span></span>
<span class="line" id="L315">        <span class="tok-comment">/// of a `block_inline`. It allows using the return value from `Sema.analyzeBody`.</span></span>
<span class="line" id="L316">        <span class="tok-comment">/// This instruction may also be used when it is known that there is only one</span></span>
<span class="line" id="L317">        <span class="tok-comment">/// break instruction in a block, and the target block is the parent.</span></span>
<span class="line" id="L318">        <span class="tok-comment">/// Uses the `break` union field.</span></span>
<span class="line" id="L319">        break_inline,</span>
<span class="line" id="L320">        <span class="tok-comment">/// Checks that comptime control flow does not happen inside a runtime block.</span></span>
<span class="line" id="L321">        <span class="tok-comment">/// Uses the `un_node` union field.</span></span>
<span class="line" id="L322">        check_comptime_control_flow,</span>
<span class="line" id="L323">        <span class="tok-comment">/// Function call.</span></span>
<span class="line" id="L324">        <span class="tok-comment">/// Uses the `pl_node` union field with payload `Call`.</span></span>
<span class="line" id="L325">        <span class="tok-comment">/// AST node is the function call.</span></span>
<span class="line" id="L326">        call,</span>
<span class="line" id="L327">        <span class="tok-comment">/// Function call using `a.b()` syntax.</span></span>
<span class="line" id="L328">        <span class="tok-comment">/// Uses the named field as the callee. If there is no such field, searches in the type for</span></span>
<span class="line" id="L329">        <span class="tok-comment">/// a decl matching the field name. The decl is resolved and we ensure that it's a function</span></span>
<span class="line" id="L330">        <span class="tok-comment">/// which can accept the object as the first parameter, with one pointer fixup. This</span></span>
<span class="line" id="L331">        <span class="tok-comment">/// function is then used as the callee, with the object as an implicit first parameter.</span></span>
<span class="line" id="L332">        <span class="tok-comment">/// Uses the `pl_node` union field with payload `FieldCall`.</span></span>
<span class="line" id="L333">        <span class="tok-comment">/// AST node is the function call.</span></span>
<span class="line" id="L334">        field_call,</span>
<span class="line" id="L335">        <span class="tok-comment">/// Implements the `@call` builtin.</span></span>
<span class="line" id="L336">        <span class="tok-comment">/// Uses the `pl_node` union field with payload `BuiltinCall`.</span></span>
<span class="line" id="L337">        <span class="tok-comment">/// AST node is the builtin call.</span></span>
<span class="line" id="L338">        builtin_call,</span>
<span class="line" id="L339">        <span class="tok-comment">/// `&lt;`</span></span>
<span class="line" id="L340">        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Bin`.</span></span>
<span class="line" id="L341">        cmp_lt,</span>
<span class="line" id="L342">        <span class="tok-comment">/// `&lt;=`</span></span>
<span class="line" id="L343">        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Bin`.</span></span>
<span class="line" id="L344">        cmp_lte,</span>
<span class="line" id="L345">        <span class="tok-comment">/// `==`</span></span>
<span class="line" id="L346">        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Bin`.</span></span>
<span class="line" id="L347">        cmp_eq,</span>
<span class="line" id="L348">        <span class="tok-comment">/// `&gt;=`</span></span>
<span class="line" id="L349">        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Bin`.</span></span>
<span class="line" id="L350">        cmp_gte,</span>
<span class="line" id="L351">        <span class="tok-comment">/// `&gt;`</span></span>
<span class="line" id="L352">        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Bin`.</span></span>
<span class="line" id="L353">        cmp_gt,</span>
<span class="line" id="L354">        <span class="tok-comment">/// `!=`</span></span>
<span class="line" id="L355">        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Bin`.</span></span>
<span class="line" id="L356">        cmp_neq,</span>
<span class="line" id="L357">        <span class="tok-comment">/// Conditional branch. Splits control flow based on a boolean condition value.</span></span>
<span class="line" id="L358">        <span class="tok-comment">/// Uses the `pl_node` union field. AST node is an if, while, for, etc.</span></span>
<span class="line" id="L359">        <span class="tok-comment">/// Payload is `CondBr`.</span></span>
<span class="line" id="L360">        condbr,</span>
<span class="line" id="L361">        <span class="tok-comment">/// Same as `condbr`, except the condition is coerced to a comptime value, and</span></span>
<span class="line" id="L362">        <span class="tok-comment">/// only the taken branch is analyzed. The then block and else block must</span></span>
<span class="line" id="L363">        <span class="tok-comment">/// terminate with an &quot;inline&quot; variant of a noreturn instruction.</span></span>
<span class="line" id="L364">        condbr_inline,</span>
<span class="line" id="L365">        <span class="tok-comment">/// Given an operand which is an error union, splits control flow. In</span></span>
<span class="line" id="L366">        <span class="tok-comment">/// case of error, control flow goes into the block that is part of this</span></span>
<span class="line" id="L367">        <span class="tok-comment">/// instruction, which is guaranteed to end with a return instruction</span></span>
<span class="line" id="L368">        <span class="tok-comment">/// and never breaks out of the block.</span></span>
<span class="line" id="L369">        <span class="tok-comment">/// In the case of non-error, control flow proceeds to the next instruction</span></span>
<span class="line" id="L370">        <span class="tok-comment">/// after the `try`, with the result of this instruction being the unwrapped</span></span>
<span class="line" id="L371">        <span class="tok-comment">/// payload value, as if `err_union_payload_unsafe` was executed on the operand.</span></span>
<span class="line" id="L372">        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Try`.</span></span>
<span class="line" id="L373">        @&quot;try&quot;,</span>
<span class="line" id="L374">        <span class="tok-comment">/// Same as `try` except the operand is a pointer and the result is a pointer.</span></span>
<span class="line" id="L375">        try_ptr,</span>
<span class="line" id="L376">        <span class="tok-comment">/// An error set type definition. Contains a list of field names.</span></span>
<span class="line" id="L377">        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `ErrorSetDecl`.</span></span>
<span class="line" id="L378">        error_set_decl,</span>
<span class="line" id="L379">        error_set_decl_anon,</span>
<span class="line" id="L380">        error_set_decl_func,</span>
<span class="line" id="L381">        <span class="tok-comment">/// Declares the beginning of a statement. Used for debug info.</span></span>
<span class="line" id="L382">        <span class="tok-comment">/// Uses the `dbg_stmt` union field. The line and column are offset</span></span>
<span class="line" id="L383">        <span class="tok-comment">/// from the parent declaration.</span></span>
<span class="line" id="L384">        dbg_stmt,</span>
<span class="line" id="L385">        <span class="tok-comment">/// Marks a variable declaration. Used for debug info.</span></span>
<span class="line" id="L386">        <span class="tok-comment">/// Uses the `str_op` union field. The string is the local variable name,</span></span>
<span class="line" id="L387">        <span class="tok-comment">/// and the operand is the pointer to the variable's location. The local</span></span>
<span class="line" id="L388">        <span class="tok-comment">/// may be a const or a var.</span></span>
<span class="line" id="L389">        dbg_var_ptr,</span>
<span class="line" id="L390">        <span class="tok-comment">/// Same as `dbg_var_ptr` but the local is always a const and the operand</span></span>
<span class="line" id="L391">        <span class="tok-comment">/// is the local's value.</span></span>
<span class="line" id="L392">        dbg_var_val,</span>
<span class="line" id="L393">        <span class="tok-comment">/// Uses a name to identify a Decl and takes a pointer to it.</span></span>
<span class="line" id="L394">        <span class="tok-comment">/// Uses the `str_tok` union field.</span></span>
<span class="line" id="L395">        decl_ref,</span>
<span class="line" id="L396">        <span class="tok-comment">/// Uses a name to identify a Decl and uses it as a value.</span></span>
<span class="line" id="L397">        <span class="tok-comment">/// Uses the `str_tok` union field.</span></span>
<span class="line" id="L398">        decl_val,</span>
<span class="line" id="L399">        <span class="tok-comment">/// Load the value from a pointer. Assumes `x.*` syntax.</span></span>
<span class="line" id="L400">        <span class="tok-comment">/// Uses `un_node` field. AST node is the `x.*` syntax.</span></span>
<span class="line" id="L401">        load,</span>
<span class="line" id="L402">        <span class="tok-comment">/// Arithmetic division. Asserts no integer overflow.</span></span>
<span class="line" id="L403">        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Bin`.</span></span>
<span class="line" id="L404">        div,</span>
<span class="line" id="L405">        <span class="tok-comment">/// Given a pointer to an array, slice, or pointer, returns a pointer to the element at</span></span>
<span class="line" id="L406">        <span class="tok-comment">/// the provided index.</span></span>
<span class="line" id="L407">        <span class="tok-comment">/// Uses the `pl_node` union field. AST node is a[b] syntax. Payload is `Bin`.</span></span>
<span class="line" id="L408">        elem_ptr_node,</span>
<span class="line" id="L409">        <span class="tok-comment">/// Same as `elem_ptr_node` but used only for for loop.</span></span>
<span class="line" id="L410">        <span class="tok-comment">/// Uses the `pl_node` union field. AST node is the condition of a for loop.</span></span>
<span class="line" id="L411">        <span class="tok-comment">/// Payload is `Bin`.</span></span>
<span class="line" id="L412">        <span class="tok-comment">/// No OOB safety check is emitted.</span></span>
<span class="line" id="L413">        elem_ptr,</span>
<span class="line" id="L414">        <span class="tok-comment">/// Given an array, slice, or pointer, returns the element at the provided index.</span></span>
<span class="line" id="L415">        <span class="tok-comment">/// Uses the `pl_node` union field. AST node is a[b] syntax. Payload is `Bin`.</span></span>
<span class="line" id="L416">        elem_val_node,</span>
<span class="line" id="L417">        <span class="tok-comment">/// Same as `elem_val_node` but used only for for loop.</span></span>
<span class="line" id="L418">        <span class="tok-comment">/// Uses the `pl_node` union field. AST node is the condition of a for loop.</span></span>
<span class="line" id="L419">        <span class="tok-comment">/// Payload is `Bin`.</span></span>
<span class="line" id="L420">        <span class="tok-comment">/// No OOB safety check is emitted.</span></span>
<span class="line" id="L421">        elem_val,</span>
<span class="line" id="L422">        <span class="tok-comment">/// Same as `elem_val` but takes the index as an immediate value.</span></span>
<span class="line" id="L423">        <span class="tok-comment">/// No OOB safety check is emitted. A prior instruction must validate this operation.</span></span>
<span class="line" id="L424">        <span class="tok-comment">/// Uses the `elem_val_imm` union field.</span></span>
<span class="line" id="L425">        elem_val_imm,</span>
<span class="line" id="L426">        <span class="tok-comment">/// Emits a compile error if the operand is not `void`.</span></span>
<span class="line" id="L427">        <span class="tok-comment">/// Uses the `un_node` field.</span></span>
<span class="line" id="L428">        ensure_result_used,</span>
<span class="line" id="L429">        <span class="tok-comment">/// Emits a compile error if an error is ignored.</span></span>
<span class="line" id="L430">        <span class="tok-comment">/// Uses the `un_node` field.</span></span>
<span class="line" id="L431">        ensure_result_non_error,</span>
<span class="line" id="L432">        <span class="tok-comment">/// Emits a compile error error union payload is not void.</span></span>
<span class="line" id="L433">        ensure_err_union_payload_void,</span>
<span class="line" id="L434">        <span class="tok-comment">/// Create a `E!T` type.</span></span>
<span class="line" id="L435">        <span class="tok-comment">/// Uses the `pl_node` field with `Bin` payload.</span></span>
<span class="line" id="L436">        error_union_type,</span>
<span class="line" id="L437">        <span class="tok-comment">/// `error.Foo` syntax. Uses the `str_tok` field of the Data union.</span></span>
<span class="line" id="L438">        error_value,</span>
<span class="line" id="L439">        <span class="tok-comment">/// Implements the `@export` builtin function, based on either an identifier to a Decl,</span></span>
<span class="line" id="L440">        <span class="tok-comment">/// or field access of a Decl. The thing being exported is the Decl.</span></span>
<span class="line" id="L441">        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Export`.</span></span>
<span class="line" id="L442">        @&quot;export&quot;,</span>
<span class="line" id="L443">        <span class="tok-comment">/// Implements the `@export` builtin function, based on a comptime-known value.</span></span>
<span class="line" id="L444">        <span class="tok-comment">/// The thing being exported is the comptime-known value which is the operand.</span></span>
<span class="line" id="L445">        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `ExportValue`.</span></span>
<span class="line" id="L446">        export_value,</span>
<span class="line" id="L447">        <span class="tok-comment">/// Given a pointer to a struct or object that contains virtual fields, returns a pointer</span></span>
<span class="line" id="L448">        <span class="tok-comment">/// to the named field. The field name is stored in string_bytes. Used by a.b syntax.</span></span>
<span class="line" id="L449">        <span class="tok-comment">/// Uses `pl_node` field. The AST node is the a.b syntax. Payload is Field.</span></span>
<span class="line" id="L450">        field_ptr,</span>
<span class="line" id="L451">        <span class="tok-comment">/// Given a struct or object that contains virtual fields, returns the named field.</span></span>
<span class="line" id="L452">        <span class="tok-comment">/// The field name is stored in string_bytes. Used by a.b syntax.</span></span>
<span class="line" id="L453">        <span class="tok-comment">/// This instruction also accepts a pointer.</span></span>
<span class="line" id="L454">        <span class="tok-comment">/// Uses `pl_node` field. The AST node is the a.b syntax. Payload is Field.</span></span>
<span class="line" id="L455">        field_val,</span>
<span class="line" id="L456">        <span class="tok-comment">/// Given a pointer to a struct or object that contains virtual fields, returns a pointer</span></span>
<span class="line" id="L457">        <span class="tok-comment">/// to the named field. The field name is a comptime instruction. Used by @field.</span></span>
<span class="line" id="L458">        <span class="tok-comment">/// Uses `pl_node` field. The AST node is the builtin call. Payload is FieldNamed.</span></span>
<span class="line" id="L459">        field_ptr_named,</span>
<span class="line" id="L460">        <span class="tok-comment">/// Given a struct or object that contains virtual fields, returns the named field.</span></span>
<span class="line" id="L461">        <span class="tok-comment">/// The field name is a comptime instruction. Used by @field.</span></span>
<span class="line" id="L462">        <span class="tok-comment">/// Uses `pl_node` field. The AST node is the builtin call. Payload is FieldNamed.</span></span>
<span class="line" id="L463">        field_val_named,</span>
<span class="line" id="L464">        <span class="tok-comment">/// Returns a function type, or a function instance, depending on whether</span></span>
<span class="line" id="L465">        <span class="tok-comment">/// the body_len is 0. Calling convention is auto.</span></span>
<span class="line" id="L466">        <span class="tok-comment">/// Uses the `pl_node` union field. `payload_index` points to a `Func`.</span></span>
<span class="line" id="L467">        func,</span>
<span class="line" id="L468">        <span class="tok-comment">/// Same as `func` but has an inferred error set.</span></span>
<span class="line" id="L469">        func_inferred,</span>
<span class="line" id="L470">        <span class="tok-comment">/// Represents a function declaration or function prototype, depending on</span></span>
<span class="line" id="L471">        <span class="tok-comment">/// whether body_len is 0.</span></span>
<span class="line" id="L472">        <span class="tok-comment">/// Uses the `pl_node` union field. `payload_index` points to a `FuncFancy`.</span></span>
<span class="line" id="L473">        func_fancy,</span>
<span class="line" id="L474">        <span class="tok-comment">/// Implements the `@import` builtin.</span></span>
<span class="line" id="L475">        <span class="tok-comment">/// Uses the `str_tok` field.</span></span>
<span class="line" id="L476">        import,</span>
<span class="line" id="L477">        <span class="tok-comment">/// Integer literal that fits in a u64. Uses the `int` union field.</span></span>
<span class="line" id="L478">        int,</span>
<span class="line" id="L479">        <span class="tok-comment">/// Arbitrary sized integer literal. Uses the `str` union field.</span></span>
<span class="line" id="L480">        int_big,</span>
<span class="line" id="L481">        <span class="tok-comment">/// A float literal that fits in a f64. Uses the float union value.</span></span>
<span class="line" id="L482">        float,</span>
<span class="line" id="L483">        <span class="tok-comment">/// A float literal that fits in a f128. Uses the `pl_node` union value.</span></span>
<span class="line" id="L484">        <span class="tok-comment">/// Payload is `Float128`.</span></span>
<span class="line" id="L485">        float128,</span>
<span class="line" id="L486">        <span class="tok-comment">/// Make an integer type out of signedness and bit count.</span></span>
<span class="line" id="L487">        <span class="tok-comment">/// Payload is `int_type`</span></span>
<span class="line" id="L488">        int_type,</span>
<span class="line" id="L489">        <span class="tok-comment">/// Return a boolean false if an optional is null. `x != null`</span></span>
<span class="line" id="L490">        <span class="tok-comment">/// Uses the `un_node` field.</span></span>
<span class="line" id="L491">        is_non_null,</span>
<span class="line" id="L492">        <span class="tok-comment">/// Return a boolean false if an optional is null. `x.* != null`</span></span>
<span class="line" id="L493">        <span class="tok-comment">/// Uses the `un_node` field.</span></span>
<span class="line" id="L494">        is_non_null_ptr,</span>
<span class="line" id="L495">        <span class="tok-comment">/// Return a boolean false if value is an error</span></span>
<span class="line" id="L496">        <span class="tok-comment">/// Uses the `un_node` field.</span></span>
<span class="line" id="L497">        is_non_err,</span>
<span class="line" id="L498">        <span class="tok-comment">/// Return a boolean false if dereferenced pointer is an error</span></span>
<span class="line" id="L499">        <span class="tok-comment">/// Uses the `un_node` field.</span></span>
<span class="line" id="L500">        is_non_err_ptr,</span>
<span class="line" id="L501">        <span class="tok-comment">/// Same as `is_non_er` but doesn't validate that the type can be an error.</span></span>
<span class="line" id="L502">        <span class="tok-comment">/// Uses the `un_node` field.</span></span>
<span class="line" id="L503">        ret_is_non_err,</span>
<span class="line" id="L504">        <span class="tok-comment">/// A labeled block of code that loops forever. At the end of the body will have either</span></span>
<span class="line" id="L505">        <span class="tok-comment">/// a `repeat` instruction or a `repeat_inline` instruction.</span></span>
<span class="line" id="L506">        <span class="tok-comment">/// Uses the `pl_node` field. The AST node is either a for loop or while loop.</span></span>
<span class="line" id="L507">        <span class="tok-comment">/// This ZIR instruction is needed because AIR does not (yet?) match ZIR, and Sema</span></span>
<span class="line" id="L508">        <span class="tok-comment">/// needs to emit more than 1 AIR block for this instruction.</span></span>
<span class="line" id="L509">        <span class="tok-comment">/// The payload is `Block`.</span></span>
<span class="line" id="L510">        loop,</span>
<span class="line" id="L511">        <span class="tok-comment">/// Sends runtime control flow back to the beginning of the current block.</span></span>
<span class="line" id="L512">        <span class="tok-comment">/// Uses the `node` field.</span></span>
<span class="line" id="L513">        repeat,</span>
<span class="line" id="L514">        <span class="tok-comment">/// Sends comptime control flow back to the beginning of the current block.</span></span>
<span class="line" id="L515">        <span class="tok-comment">/// Uses the `node` field.</span></span>
<span class="line" id="L516">        repeat_inline,</span>
<span class="line" id="L517">        <span class="tok-comment">/// Asserts that all the lengths provided match. Used to build a for loop.</span></span>
<span class="line" id="L518">        <span class="tok-comment">/// Return value is the length as a usize.</span></span>
<span class="line" id="L519">        <span class="tok-comment">/// Uses the `pl_node` field with payload `MultiOp`.</span></span>
<span class="line" id="L520">        <span class="tok-comment">/// There is exactly one item corresponding to each AST node inside the for</span></span>
<span class="line" id="L521">        <span class="tok-comment">/// loop condition. Any item may be `none`, indicating an unbounded range.</span></span>
<span class="line" id="L522">        <span class="tok-comment">/// Illegal behaviors:</span></span>
<span class="line" id="L523">        <span class="tok-comment">///  * If all lengths are unbounded ranges (always a compile error).</span></span>
<span class="line" id="L524">        <span class="tok-comment">///  * If any two lengths do not match each other.</span></span>
<span class="line" id="L525">        for_len,</span>
<span class="line" id="L526">        <span class="tok-comment">/// Merge two error sets into one, `E1 || E2`.</span></span>
<span class="line" id="L527">        <span class="tok-comment">/// Uses the `pl_node` field with payload `Bin`.</span></span>
<span class="line" id="L528">        merge_error_sets,</span>
<span class="line" id="L529">        <span class="tok-comment">/// Turns an R-Value into a const L-Value. In other words, it takes a value,</span></span>
<span class="line" id="L530">        <span class="tok-comment">/// stores it in a memory location, and returns a const pointer to it. If the value</span></span>
<span class="line" id="L531">        <span class="tok-comment">/// is `comptime`, the memory location is global static constant data. Otherwise,</span></span>
<span class="line" id="L532">        <span class="tok-comment">/// the memory location is in the stack frame, local to the scope containing the</span></span>
<span class="line" id="L533">        <span class="tok-comment">/// instruction.</span></span>
<span class="line" id="L534">        <span class="tok-comment">/// Uses the `un_tok` union field.</span></span>
<span class="line" id="L535">        ref,</span>
<span class="line" id="L536">        <span class="tok-comment">/// Sends control flow back to the function's callee.</span></span>
<span class="line" id="L537">        <span class="tok-comment">/// Includes an operand as the return value.</span></span>
<span class="line" id="L538">        <span class="tok-comment">/// Includes an AST node source location.</span></span>
<span class="line" id="L539">        <span class="tok-comment">/// Uses the `un_node` union field.</span></span>
<span class="line" id="L540">        ret_node,</span>
<span class="line" id="L541">        <span class="tok-comment">/// Sends control flow back to the function's callee.</span></span>
<span class="line" id="L542">        <span class="tok-comment">/// The operand is a `ret_ptr` instruction, where the return value can be found.</span></span>
<span class="line" id="L543">        <span class="tok-comment">/// Includes an AST node source location.</span></span>
<span class="line" id="L544">        <span class="tok-comment">/// Uses the `un_node` union field.</span></span>
<span class="line" id="L545">        ret_load,</span>
<span class="line" id="L546">        <span class="tok-comment">/// Sends control flow back to the function's callee.</span></span>
<span class="line" id="L547">        <span class="tok-comment">/// Includes an operand as the return value.</span></span>
<span class="line" id="L548">        <span class="tok-comment">/// Includes a token source location.</span></span>
<span class="line" id="L549">        <span class="tok-comment">/// Uses the `un_tok` union field.</span></span>
<span class="line" id="L550">        ret_implicit,</span>
<span class="line" id="L551">        <span class="tok-comment">/// Sends control flow back to the function's callee.</span></span>
<span class="line" id="L552">        <span class="tok-comment">/// The return operand is `error.foo` where `foo` is given by the string.</span></span>
<span class="line" id="L553">        <span class="tok-comment">/// If the current function has an inferred error set, the error given by the</span></span>
<span class="line" id="L554">        <span class="tok-comment">/// name is added to it.</span></span>
<span class="line" id="L555">        <span class="tok-comment">/// Uses the `str_tok` union field.</span></span>
<span class="line" id="L556">        ret_err_value,</span>
<span class="line" id="L557">        <span class="tok-comment">/// A string name is provided which is an anonymous error set value.</span></span>
<span class="line" id="L558">        <span class="tok-comment">/// If the current function has an inferred error set, the error given by the</span></span>
<span class="line" id="L559">        <span class="tok-comment">/// name is added to it.</span></span>
<span class="line" id="L560">        <span class="tok-comment">/// Results in the error code. Note that control flow is not diverted with</span></span>
<span class="line" id="L561">        <span class="tok-comment">/// this instruction; a following 'ret' instruction will do the diversion.</span></span>
<span class="line" id="L562">        <span class="tok-comment">/// Uses the `str_tok` union field.</span></span>
<span class="line" id="L563">        ret_err_value_code,</span>
<span class="line" id="L564">        <span class="tok-comment">/// Obtains a pointer to the return value.</span></span>
<span class="line" id="L565">        <span class="tok-comment">/// Uses the `node` union field.</span></span>
<span class="line" id="L566">        ret_ptr,</span>
<span class="line" id="L567">        <span class="tok-comment">/// Obtains the return type of the in-scope function.</span></span>
<span class="line" id="L568">        <span class="tok-comment">/// Uses the `node` union field.</span></span>
<span class="line" id="L569">        ret_type,</span>
<span class="line" id="L570">        <span class="tok-comment">/// Create a pointer type which can have a sentinel, alignment, address space, and/or bit range.</span></span>
<span class="line" id="L571">        <span class="tok-comment">/// Uses the `ptr_type` union field.</span></span>
<span class="line" id="L572">        ptr_type,</span>
<span class="line" id="L573">        <span class="tok-comment">/// Slice operation `lhs[rhs..]`. No sentinel and no end offset.</span></span>
<span class="line" id="L574">        <span class="tok-comment">/// Returns a pointer to the subslice.</span></span>
<span class="line" id="L575">        <span class="tok-comment">/// Uses the `pl_node` field. AST node is the slice syntax. Payload is `SliceStart`.</span></span>
<span class="line" id="L576">        slice_start,</span>
<span class="line" id="L577">        <span class="tok-comment">/// Slice operation `array_ptr[start..end]`. No sentinel.</span></span>
<span class="line" id="L578">        <span class="tok-comment">/// Returns a pointer to the subslice.</span></span>
<span class="line" id="L579">        <span class="tok-comment">/// Uses the `pl_node` field. AST node is the slice syntax. Payload is `SliceEnd`.</span></span>
<span class="line" id="L580">        slice_end,</span>
<span class="line" id="L581">        <span class="tok-comment">/// Slice operation `array_ptr[start..end:sentinel]`.</span></span>
<span class="line" id="L582">        <span class="tok-comment">/// Returns a pointer to the subslice.</span></span>
<span class="line" id="L583">        <span class="tok-comment">/// Uses the `pl_node` field. AST node is the slice syntax. Payload is `SliceSentinel`.</span></span>
<span class="line" id="L584">        slice_sentinel,</span>
<span class="line" id="L585">        <span class="tok-comment">/// Slice operation `array_ptr[start..][0..len]`. Optional sentinel.</span></span>
<span class="line" id="L586">        <span class="tok-comment">/// Returns a pointer to the subslice.</span></span>
<span class="line" id="L587">        <span class="tok-comment">/// Uses the `pl_node` field. AST node is the slice syntax. Payload is `SliceLength`.</span></span>
<span class="line" id="L588">        slice_length,</span>
<span class="line" id="L589">        <span class="tok-comment">/// Same as `store` except provides a source location.</span></span>
<span class="line" id="L590">        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Bin`.</span></span>
<span class="line" id="L591">        store_node,</span>
<span class="line" id="L592">        <span class="tok-comment">/// Same as `store_node` but the type of the value being stored will be</span></span>
<span class="line" id="L593">        <span class="tok-comment">/// used to infer the pointer type of an `alloc_inferred`.</span></span>
<span class="line" id="L594">        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Bin`.</span></span>
<span class="line" id="L595">        store_to_inferred_ptr,</span>
<span class="line" id="L596">        <span class="tok-comment">/// String Literal. Makes an anonymous Decl and then takes a pointer to it.</span></span>
<span class="line" id="L597">        <span class="tok-comment">/// Uses the `str` union field.</span></span>
<span class="line" id="L598">        str,</span>
<span class="line" id="L599">        <span class="tok-comment">/// Arithmetic negation. Asserts no integer overflow.</span></span>
<span class="line" id="L600">        <span class="tok-comment">/// Same as sub with a lhs of 0, split into a separate instruction to save memory.</span></span>
<span class="line" id="L601">        <span class="tok-comment">/// Uses `un_node`.</span></span>
<span class="line" id="L602">        negate,</span>
<span class="line" id="L603">        <span class="tok-comment">/// Twos complement wrapping integer negation.</span></span>
<span class="line" id="L604">        <span class="tok-comment">/// Same as subwrap with a lhs of 0, split into a separate instruction to save memory.</span></span>
<span class="line" id="L605">        <span class="tok-comment">/// Uses `un_node`.</span></span>
<span class="line" id="L606">        negate_wrap,</span>
<span class="line" id="L607">        <span class="tok-comment">/// Returns the type of a value.</span></span>
<span class="line" id="L608">        <span class="tok-comment">/// Uses the `un_node` field.</span></span>
<span class="line" id="L609">        typeof,</span>
<span class="line" id="L610">        <span class="tok-comment">/// Implements `@TypeOf` for one operand.</span></span>
<span class="line" id="L611">        <span class="tok-comment">/// Uses the `pl_node` field.</span></span>
<span class="line" id="L612">        typeof_builtin,</span>
<span class="line" id="L613">        <span class="tok-comment">/// Given a value, look at the type of it, which must be an integer type.</span></span>
<span class="line" id="L614">        <span class="tok-comment">/// Returns the integer type for the RHS of a shift operation.</span></span>
<span class="line" id="L615">        <span class="tok-comment">/// Uses the `un_node` field.</span></span>
<span class="line" id="L616">        typeof_log2_int_type,</span>
<span class="line" id="L617">        <span class="tok-comment">/// Asserts control-flow will not reach this instruction (`unreachable`).</span></span>
<span class="line" id="L618">        <span class="tok-comment">/// Uses the `@&quot;unreachable&quot;` union field.</span></span>
<span class="line" id="L619">        @&quot;unreachable&quot;,</span>
<span class="line" id="L620">        <span class="tok-comment">/// Bitwise XOR. `^`</span></span>
<span class="line" id="L621">        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Bin`.</span></span>
<span class="line" id="L622">        xor,</span>
<span class="line" id="L623">        <span class="tok-comment">/// Create an optional type '?T'</span></span>
<span class="line" id="L624">        <span class="tok-comment">/// Uses the `un_node` field.</span></span>
<span class="line" id="L625">        optional_type,</span>
<span class="line" id="L626">        <span class="tok-comment">/// ?T =&gt; T with safety.</span></span>
<span class="line" id="L627">        <span class="tok-comment">/// Given an optional value, returns the payload value, with a safety check that</span></span>
<span class="line" id="L628">        <span class="tok-comment">/// the value is non-null. Used for `orelse`, `if` and `while`.</span></span>
<span class="line" id="L629">        <span class="tok-comment">/// Uses the `un_node` field.</span></span>
<span class="line" id="L630">        optional_payload_safe,</span>
<span class="line" id="L631">        <span class="tok-comment">/// ?T =&gt; T without safety.</span></span>
<span class="line" id="L632">        <span class="tok-comment">/// Given an optional value, returns the payload value. No safety checks.</span></span>
<span class="line" id="L633">        <span class="tok-comment">/// Uses the `un_node` field.</span></span>
<span class="line" id="L634">        optional_payload_unsafe,</span>
<span class="line" id="L635">        <span class="tok-comment">/// *?T =&gt; *T with safety.</span></span>
<span class="line" id="L636">        <span class="tok-comment">/// Given a pointer to an optional value, returns a pointer to the payload value,</span></span>
<span class="line" id="L637">        <span class="tok-comment">/// with a safety check that the value is non-null. Used for `orelse`, `if` and `while`.</span></span>
<span class="line" id="L638">        <span class="tok-comment">/// Uses the `un_node` field.</span></span>
<span class="line" id="L639">        optional_payload_safe_ptr,</span>
<span class="line" id="L640">        <span class="tok-comment">/// *?T =&gt; *T without safety.</span></span>
<span class="line" id="L641">        <span class="tok-comment">/// Given a pointer to an optional value, returns a pointer to the payload value.</span></span>
<span class="line" id="L642">        <span class="tok-comment">/// No safety checks.</span></span>
<span class="line" id="L643">        <span class="tok-comment">/// Uses the `un_node` field.</span></span>
<span class="line" id="L644">        optional_payload_unsafe_ptr,</span>
<span class="line" id="L645">        <span class="tok-comment">/// E!T =&gt; T without safety.</span></span>
<span class="line" id="L646">        <span class="tok-comment">/// Given an error union value, returns the payload value. No safety checks.</span></span>
<span class="line" id="L647">        <span class="tok-comment">/// Uses the `un_node` field.</span></span>
<span class="line" id="L648">        err_union_payload_unsafe,</span>
<span class="line" id="L649">        <span class="tok-comment">/// *E!T =&gt; *T without safety.</span></span>
<span class="line" id="L650">        <span class="tok-comment">/// Given a pointer to a error union value, returns a pointer to the payload value.</span></span>
<span class="line" id="L651">        <span class="tok-comment">/// No safety checks.</span></span>
<span class="line" id="L652">        <span class="tok-comment">/// Uses the `un_node` field.</span></span>
<span class="line" id="L653">        err_union_payload_unsafe_ptr,</span>
<span class="line" id="L654">        <span class="tok-comment">/// E!T =&gt; E without safety.</span></span>
<span class="line" id="L655">        <span class="tok-comment">/// Given an error union value, returns the error code. No safety checks.</span></span>
<span class="line" id="L656">        <span class="tok-comment">/// Uses the `un_node` field.</span></span>
<span class="line" id="L657">        err_union_code,</span>
<span class="line" id="L658">        <span class="tok-comment">/// *E!T =&gt; E without safety.</span></span>
<span class="line" id="L659">        <span class="tok-comment">/// Given a pointer to an error union value, returns the error code. No safety checks.</span></span>
<span class="line" id="L660">        <span class="tok-comment">/// Uses the `un_node` field.</span></span>
<span class="line" id="L661">        err_union_code_ptr,</span>
<span class="line" id="L662">        <span class="tok-comment">/// An enum literal. Uses the `str_tok` union field.</span></span>
<span class="line" id="L663">        enum_literal,</span>
<span class="line" id="L664">        <span class="tok-comment">/// A switch expression. Uses the `pl_node` union field.</span></span>
<span class="line" id="L665">        <span class="tok-comment">/// AST node is the switch, payload is `SwitchBlock`.</span></span>
<span class="line" id="L666">        switch_block,</span>
<span class="line" id="L667">        <span class="tok-comment">/// A switch expression. Uses the `pl_node` union field.</span></span>
<span class="line" id="L668">        <span class="tok-comment">/// AST node is the switch, payload is `SwitchBlock`. Operand is a pointer.</span></span>
<span class="line" id="L669">        switch_block_ref,</span>
<span class="line" id="L670">        <span class="tok-comment">/// A switch on an error union `a catch |err| switch (err) {...}`.</span></span>
<span class="line" id="L671">        <span class="tok-comment">/// Uses the `pl_node` union field. AST node is the `catch`, payload is `SwitchBlockErrUnion`.</span></span>
<span class="line" id="L672">        switch_block_err_union,</span>
<span class="line" id="L673">        <span class="tok-comment">/// Check that operand type supports the dereference operand (.*).</span></span>
<span class="line" id="L674">        <span class="tok-comment">/// Uses the `un_node` field.</span></span>
<span class="line" id="L675">        validate_deref,</span>
<span class="line" id="L676">        <span class="tok-comment">/// Check that the operand's type is an array or tuple with the given number of elements.</span></span>
<span class="line" id="L677">        <span class="tok-comment">/// Uses the `pl_node` field. Payload is `ValidateDestructure`.</span></span>
<span class="line" id="L678">        validate_destructure,</span>
<span class="line" id="L679">        <span class="tok-comment">/// Given a struct or union, and a field name as a Ref,</span></span>
<span class="line" id="L680">        <span class="tok-comment">/// returns the field type. Uses the `pl_node` field. Payload is `FieldTypeRef`.</span></span>
<span class="line" id="L681">        field_type_ref,</span>
<span class="line" id="L682">        <span class="tok-comment">/// Given a pointer, initializes all error unions and optionals in the pointee to payloads,</span></span>
<span class="line" id="L683">        <span class="tok-comment">/// returning the base payload pointer. For instance, converts *E!?T into a valid *T</span></span>
<span class="line" id="L684">        <span class="tok-comment">/// (clobbering any existing error or null value).</span></span>
<span class="line" id="L685">        <span class="tok-comment">/// Uses the `un_node` field.</span></span>
<span class="line" id="L686">        opt_eu_base_ptr_init,</span>
<span class="line" id="L687">        <span class="tok-comment">/// Coerce a given value such that when a reference is taken, the resulting pointer will be</span></span>
<span class="line" id="L688">        <span class="tok-comment">/// coercible to the given type. For instance, given a value of type 'u32' and the pointer</span></span>
<span class="line" id="L689">        <span class="tok-comment">/// type '*u64', coerces the value to a 'u64'. Asserts that the type is a pointer type.</span></span>
<span class="line" id="L690">        <span class="tok-comment">/// Uses the `pl_node` field. Payload is `Bin`.</span></span>
<span class="line" id="L691">        <span class="tok-comment">/// LHS is the pointer type, RHS is the value.</span></span>
<span class="line" id="L692">        coerce_ptr_elem_ty,</span>
<span class="line" id="L693">        <span class="tok-comment">/// Given a type, validate that it is a pointer type suitable for return from the address-of</span></span>
<span class="line" id="L694">        <span class="tok-comment">/// operator. Emit a compile error if not.</span></span>
<span class="line" id="L695">        <span class="tok-comment">/// Uses the `un_tok` union field. Token is the `&amp;` operator. Operand is the type.</span></span>
<span class="line" id="L696">        validate_ref_ty,</span>
<span class="line" id="L697"></span>
<span class="line" id="L698">        <span class="tok-comment">// The following tags all relate to struct initialization expressions.</span>
</span>
<span class="line" id="L699"></span>
<span class="line" id="L700">        <span class="tok-comment">/// A struct literal with a specified explicit type, with no fields.</span></span>
<span class="line" id="L701">        <span class="tok-comment">/// Uses the `un_node` field.</span></span>
<span class="line" id="L702">        struct_init_empty,</span>
<span class="line" id="L703">        <span class="tok-comment">/// An anonymous struct literal with a known result type, with no fields.</span></span>
<span class="line" id="L704">        <span class="tok-comment">/// Uses the `un_node` field.</span></span>
<span class="line" id="L705">        struct_init_empty_result,</span>
<span class="line" id="L706">        <span class="tok-comment">/// An anonymous struct literal with no fields, returned by reference, with a known result</span></span>
<span class="line" id="L707">        <span class="tok-comment">/// type for the pointer. Asserts that the type is a pointer.</span></span>
<span class="line" id="L708">        <span class="tok-comment">/// Uses the `un_node` field.</span></span>
<span class="line" id="L709">        struct_init_empty_ref_result,</span>
<span class="line" id="L710">        <span class="tok-comment">/// Struct initialization without a type. Creates a value of an anonymous struct type.</span></span>
<span class="line" id="L711">        <span class="tok-comment">/// Uses the `pl_node` field. Payload is `StructInitAnon`.</span></span>
<span class="line" id="L712">        struct_init_anon,</span>
<span class="line" id="L713">        <span class="tok-comment">/// Finalizes a typed struct or union initialization, performs validation, and returns the</span></span>
<span class="line" id="L714">        <span class="tok-comment">/// struct or union value. The given type must be validated prior to this instruction, using</span></span>
<span class="line" id="L715">        <span class="tok-comment">/// `validate_struct_init_ty` or `validate_struct_init_result_ty`. If the given type is</span></span>
<span class="line" id="L716">        <span class="tok-comment">/// generic poison, this is downgraded to an anonymous initialization.</span></span>
<span class="line" id="L717">        <span class="tok-comment">/// Uses the `pl_node` field. Payload is `StructInit`.</span></span>
<span class="line" id="L718">        struct_init,</span>
<span class="line" id="L719">        <span class="tok-comment">/// Struct initialization syntax, make the result a pointer. Equivalent to `struct_init`</span></span>
<span class="line" id="L720">        <span class="tok-comment">/// followed by `ref` - this ZIR tag exists as an optimization for a common pattern.</span></span>
<span class="line" id="L721">        <span class="tok-comment">/// Uses the `pl_node` field. Payload is `StructInit`.</span></span>
<span class="line" id="L722">        struct_init_ref,</span>
<span class="line" id="L723">        <span class="tok-comment">/// Checks that the type supports struct init syntax. Always returns void.</span></span>
<span class="line" id="L724">        <span class="tok-comment">/// Uses the `un_node` field.</span></span>
<span class="line" id="L725">        validate_struct_init_ty,</span>
<span class="line" id="L726">        <span class="tok-comment">/// Like `validate_struct_init_ty`, but additionally accepts types which structs coerce to.</span></span>
<span class="line" id="L727">        <span class="tok-comment">/// Used on the known result type of a struct init expression. Always returns void.</span></span>
<span class="line" id="L728">        <span class="tok-comment">/// Uses the `un_node` field.</span></span>
<span class="line" id="L729">        validate_struct_init_result_ty,</span>
<span class="line" id="L730">        <span class="tok-comment">/// Given a set of `struct_init_field_ptr` instructions, assumes they are all part of a</span></span>
<span class="line" id="L731">        <span class="tok-comment">/// struct initialization expression, and emits compile errors for duplicate fields as well</span></span>
<span class="line" id="L732">        <span class="tok-comment">/// as missing fields, if applicable.</span></span>
<span class="line" id="L733">        <span class="tok-comment">/// This instruction asserts that there is at least one struct_init_field_ptr instruction,</span></span>
<span class="line" id="L734">        <span class="tok-comment">/// because it must use one of them to find out the struct type.</span></span>
<span class="line" id="L735">        <span class="tok-comment">/// Uses the `pl_node` field. Payload is `Block`.</span></span>
<span class="line" id="L736">        validate_ptr_struct_init,</span>
<span class="line" id="L737">        <span class="tok-comment">/// Given a type being used for a struct initialization expression, returns the type of the</span></span>
<span class="line" id="L738">        <span class="tok-comment">/// field with the given name.</span></span>
<span class="line" id="L739">        <span class="tok-comment">/// Uses the `pl_node` field. Payload is `FieldType`.</span></span>
<span class="line" id="L740">        struct_init_field_type,</span>
<span class="line" id="L741">        <span class="tok-comment">/// Given a pointer being used as the result pointer of a struct initialization expression,</span></span>
<span class="line" id="L742">        <span class="tok-comment">/// return a pointer to the field of the given name.</span></span>
<span class="line" id="L743">        <span class="tok-comment">/// Uses the `pl_node` field. The AST node is the field initializer. Payload is Field.</span></span>
<span class="line" id="L744">        struct_init_field_ptr,</span>
<span class="line" id="L745"></span>
<span class="line" id="L746">        <span class="tok-comment">// The following tags all relate to array initialization expressions.</span>
</span>
<span class="line" id="L747"></span>
<span class="line" id="L748">        <span class="tok-comment">/// Array initialization without a type. Creates a value of a tuple type.</span></span>
<span class="line" id="L749">        <span class="tok-comment">/// Uses the `pl_node` field. Payload is `MultiOp`.</span></span>
<span class="line" id="L750">        array_init_anon,</span>
<span class="line" id="L751">        <span class="tok-comment">/// Array initialization syntax with a known type. The given type must be validated prior to</span></span>
<span class="line" id="L752">        <span class="tok-comment">/// this instruction, using some `validate_array_init_*_ty` instruction.</span></span>
<span class="line" id="L753">        <span class="tok-comment">/// Uses the `pl_node` field. Payload is `MultiOp`, where the first operand is the type.</span></span>
<span class="line" id="L754">        array_init,</span>
<span class="line" id="L755">        <span class="tok-comment">/// Array initialization syntax, make the result a pointer. Equivalent to `array_init`</span></span>
<span class="line" id="L756">        <span class="tok-comment">/// followed by `ref`- this ZIR tag exists as an optimization for a common pattern.</span></span>
<span class="line" id="L757">        <span class="tok-comment">/// Uses the `pl_node` field. Payload is `MultiOp`, where the first operand is the type.</span></span>
<span class="line" id="L758">        array_init_ref,</span>
<span class="line" id="L759">        <span class="tok-comment">/// Checks that the type supports array init syntax. Always returns void.</span></span>
<span class="line" id="L760">        <span class="tok-comment">/// Uses the `pl_node` field. Payload is `ArrayInit`.</span></span>
<span class="line" id="L761">        validate_array_init_ty,</span>
<span class="line" id="L762">        <span class="tok-comment">/// Like `validate_array_init_ty`, but additionally accepts types which arrays coerce to.</span></span>
<span class="line" id="L763">        <span class="tok-comment">/// Used on the known result type of an array init expression. Always returns void.</span></span>
<span class="line" id="L764">        <span class="tok-comment">/// Uses the `pl_node` field. Payload is `ArrayInit`.</span></span>
<span class="line" id="L765">        validate_array_init_result_ty,</span>
<span class="line" id="L766">        <span class="tok-comment">/// Given a pointer or slice type and an element count, return the expected type of an array</span></span>
<span class="line" id="L767">        <span class="tok-comment">/// initializer such that a pointer to the initializer has the given pointer type, checking</span></span>
<span class="line" id="L768">        <span class="tok-comment">/// that this type supports array init syntax and emitting a compile error if not. Preserves</span></span>
<span class="line" id="L769">        <span class="tok-comment">/// error union and optional wrappers on the array type, if any.</span></span>
<span class="line" id="L770">        <span class="tok-comment">/// Asserts that the given type is a pointer or slice type.</span></span>
<span class="line" id="L771">        <span class="tok-comment">/// Uses the `pl_node` field. Payload is `ArrayInitRefTy`.</span></span>
<span class="line" id="L772">        validate_array_init_ref_ty,</span>
<span class="line" id="L773">        <span class="tok-comment">/// Given a set of `array_init_elem_ptr` instructions, assumes they are all part of an array</span></span>
<span class="line" id="L774">        <span class="tok-comment">/// initialization expression, and emits a compile error if the number of elements does not</span></span>
<span class="line" id="L775">        <span class="tok-comment">/// match the array type.</span></span>
<span class="line" id="L776">        <span class="tok-comment">/// This instruction asserts that there is at least one `array_init_elem_ptr` instruction,</span></span>
<span class="line" id="L777">        <span class="tok-comment">/// because it must use one of them to find out the array type.</span></span>
<span class="line" id="L778">        <span class="tok-comment">/// Uses the `pl_node` field. Payload is `Block`.</span></span>
<span class="line" id="L779">        validate_ptr_array_init,</span>
<span class="line" id="L780">        <span class="tok-comment">/// Given a type being used for an array initialization expression, returns the type of the</span></span>
<span class="line" id="L781">        <span class="tok-comment">/// element at the given index.</span></span>
<span class="line" id="L782">        <span class="tok-comment">/// Uses the `bin` union field. lhs is the indexable type, rhs is the index.</span></span>
<span class="line" id="L783">        array_init_elem_type,</span>
<span class="line" id="L784">        <span class="tok-comment">/// Given a pointer being used as the result pointer of an array initialization expression,</span></span>
<span class="line" id="L785">        <span class="tok-comment">/// return a pointer to the element at the given index.</span></span>
<span class="line" id="L786">        <span class="tok-comment">/// Uses the `pl_node` union field. AST node is an element inside array initialization</span></span>
<span class="line" id="L787">        <span class="tok-comment">/// syntax. Payload is `ElemPtrImm`.</span></span>
<span class="line" id="L788">        array_init_elem_ptr,</span>
<span class="line" id="L789"></span>
<span class="line" id="L790">        <span class="tok-comment">/// Implements the `@unionInit` builtin.</span></span>
<span class="line" id="L791">        <span class="tok-comment">/// Uses the `pl_node` field. Payload is `UnionInit`.</span></span>
<span class="line" id="L792">        union_init,</span>
<span class="line" id="L793">        <span class="tok-comment">/// Implements the `@typeInfo` builtin. Uses `un_node`.</span></span>
<span class="line" id="L794">        type_info,</span>
<span class="line" id="L795">        <span class="tok-comment">/// Implements the `@sizeOf` builtin. Uses `un_node`.</span></span>
<span class="line" id="L796">        size_of,</span>
<span class="line" id="L797">        <span class="tok-comment">/// Implements the `@bitSizeOf` builtin. Uses `un_node`.</span></span>
<span class="line" id="L798">        bit_size_of,</span>
<span class="line" id="L799"></span>
<span class="line" id="L800">        <span class="tok-comment">/// Implement builtin `@intFromPtr`. Uses `un_node`.</span></span>
<span class="line" id="L801">        <span class="tok-comment">/// Convert a pointer to a `usize` integer.</span></span>
<span class="line" id="L802">        int_from_ptr,</span>
<span class="line" id="L803">        <span class="tok-comment">/// Emit an error message and fail compilation.</span></span>
<span class="line" id="L804">        <span class="tok-comment">/// Uses the `un_node` field.</span></span>
<span class="line" id="L805">        compile_error,</span>
<span class="line" id="L806">        <span class="tok-comment">/// Changes the maximum number of backwards branches that compile-time</span></span>
<span class="line" id="L807">        <span class="tok-comment">/// code execution can use before giving up and making a compile error.</span></span>
<span class="line" id="L808">        <span class="tok-comment">/// Uses the `un_node` union field.</span></span>
<span class="line" id="L809">        set_eval_branch_quota,</span>
<span class="line" id="L810">        <span class="tok-comment">/// Converts an enum value into an integer. Resulting type will be the tag type</span></span>
<span class="line" id="L811">        <span class="tok-comment">/// of the enum. Uses `un_node`.</span></span>
<span class="line" id="L812">        int_from_enum,</span>
<span class="line" id="L813">        <span class="tok-comment">/// Implement builtin `@alignOf`. Uses `un_node`.</span></span>
<span class="line" id="L814">        align_of,</span>
<span class="line" id="L815">        <span class="tok-comment">/// Implement builtin `@intFromBool`. Uses `un_node`.</span></span>
<span class="line" id="L816">        int_from_bool,</span>
<span class="line" id="L817">        <span class="tok-comment">/// Implement builtin `@embedFile`. Uses `un_node`.</span></span>
<span class="line" id="L818">        embed_file,</span>
<span class="line" id="L819">        <span class="tok-comment">/// Implement builtin `@errorName`. Uses `un_node`.</span></span>
<span class="line" id="L820">        error_name,</span>
<span class="line" id="L821">        <span class="tok-comment">/// Implement builtin `@panic`. Uses `un_node`.</span></span>
<span class="line" id="L822">        panic,</span>
<span class="line" id="L823">        <span class="tok-comment">/// Implements `@trap`.</span></span>
<span class="line" id="L824">        <span class="tok-comment">/// Uses the `node` field.</span></span>
<span class="line" id="L825">        trap,</span>
<span class="line" id="L826">        <span class="tok-comment">/// Implement builtin `@setRuntimeSafety`. Uses `un_node`.</span></span>
<span class="line" id="L827">        set_runtime_safety,</span>
<span class="line" id="L828">        <span class="tok-comment">/// Implement builtin `@sqrt`. Uses `un_node`.</span></span>
<span class="line" id="L829">        sqrt,</span>
<span class="line" id="L830">        <span class="tok-comment">/// Implement builtin `@sin`. Uses `un_node`.</span></span>
<span class="line" id="L831">        sin,</span>
<span class="line" id="L832">        <span class="tok-comment">/// Implement builtin `@cos`. Uses `un_node`.</span></span>
<span class="line" id="L833">        cos,</span>
<span class="line" id="L834">        <span class="tok-comment">/// Implement builtin `@tan`. Uses `un_node`.</span></span>
<span class="line" id="L835">        tan,</span>
<span class="line" id="L836">        <span class="tok-comment">/// Implement builtin `@exp`. Uses `un_node`.</span></span>
<span class="line" id="L837">        exp,</span>
<span class="line" id="L838">        <span class="tok-comment">/// Implement builtin `@exp2`. Uses `un_node`.</span></span>
<span class="line" id="L839">        exp2,</span>
<span class="line" id="L840">        <span class="tok-comment">/// Implement builtin `@log`. Uses `un_node`.</span></span>
<span class="line" id="L841">        log,</span>
<span class="line" id="L842">        <span class="tok-comment">/// Implement builtin `@log2`. Uses `un_node`.</span></span>
<span class="line" id="L843">        log2,</span>
<span class="line" id="L844">        <span class="tok-comment">/// Implement builtin `@log10`. Uses `un_node`.</span></span>
<span class="line" id="L845">        log10,</span>
<span class="line" id="L846">        <span class="tok-comment">/// Implement builtin `@abs`. Uses `un_node`.</span></span>
<span class="line" id="L847">        abs,</span>
<span class="line" id="L848">        <span class="tok-comment">/// Implement builtin `@floor`. Uses `un_node`.</span></span>
<span class="line" id="L849">        floor,</span>
<span class="line" id="L850">        <span class="tok-comment">/// Implement builtin `@ceil`. Uses `un_node`.</span></span>
<span class="line" id="L851">        ceil,</span>
<span class="line" id="L852">        <span class="tok-comment">/// Implement builtin `@trunc`. Uses `un_node`.</span></span>
<span class="line" id="L853">        trunc,</span>
<span class="line" id="L854">        <span class="tok-comment">/// Implement builtin `@round`. Uses `un_node`.</span></span>
<span class="line" id="L855">        round,</span>
<span class="line" id="L856">        <span class="tok-comment">/// Implement builtin `@tagName`. Uses `un_node`.</span></span>
<span class="line" id="L857">        tag_name,</span>
<span class="line" id="L858">        <span class="tok-comment">/// Implement builtin `@typeName`. Uses `un_node`.</span></span>
<span class="line" id="L859">        type_name,</span>
<span class="line" id="L860">        <span class="tok-comment">/// Implement builtin `@Frame`. Uses `un_node`.</span></span>
<span class="line" id="L861">        frame_type,</span>
<span class="line" id="L862">        <span class="tok-comment">/// Implement builtin `@frameSize`. Uses `un_node`.</span></span>
<span class="line" id="L863">        frame_size,</span>
<span class="line" id="L864"></span>
<span class="line" id="L865">        <span class="tok-comment">/// Implements the `@intFromFloat` builtin.</span></span>
<span class="line" id="L866">        <span class="tok-comment">/// Uses `pl_node` with payload `Bin`. `lhs` is dest type, `rhs` is operand.</span></span>
<span class="line" id="L867">        int_from_float,</span>
<span class="line" id="L868">        <span class="tok-comment">/// Implements the `@floatFromInt` builtin.</span></span>
<span class="line" id="L869">        <span class="tok-comment">/// Uses `pl_node` with payload `Bin`. `lhs` is dest type, `rhs` is operand.</span></span>
<span class="line" id="L870">        float_from_int,</span>
<span class="line" id="L871">        <span class="tok-comment">/// Implements the `@ptrFromInt` builtin.</span></span>
<span class="line" id="L872">        <span class="tok-comment">/// Uses `pl_node` with payload `Bin`. `lhs` is dest type, `rhs` is operand.</span></span>
<span class="line" id="L873">        ptr_from_int,</span>
<span class="line" id="L874">        <span class="tok-comment">/// Converts an integer into an enum value.</span></span>
<span class="line" id="L875">        <span class="tok-comment">/// Uses `pl_node` with payload `Bin`. `lhs` is dest type, `rhs` is operand.</span></span>
<span class="line" id="L876">        enum_from_int,</span>
<span class="line" id="L877">        <span class="tok-comment">/// Convert a larger float type to any other float type, possibly causing</span></span>
<span class="line" id="L878">        <span class="tok-comment">/// a loss of precision.</span></span>
<span class="line" id="L879">        <span class="tok-comment">/// Uses the `pl_node` field. AST is the `@floatCast` syntax.</span></span>
<span class="line" id="L880">        <span class="tok-comment">/// Payload is `Bin` with lhs as the dest type, rhs the operand.</span></span>
<span class="line" id="L881">        float_cast,</span>
<span class="line" id="L882">        <span class="tok-comment">/// Implements the `@intCast` builtin.</span></span>
<span class="line" id="L883">        <span class="tok-comment">/// Uses `pl_node` with payload `Bin`. `lhs` is dest type, `rhs` is operand.</span></span>
<span class="line" id="L884">        <span class="tok-comment">/// Convert an integer value to another integer type, asserting that the destination type</span></span>
<span class="line" id="L885">        <span class="tok-comment">/// can hold the same mathematical value.</span></span>
<span class="line" id="L886">        int_cast,</span>
<span class="line" id="L887">        <span class="tok-comment">/// Implements the `@ptrCast` builtin.</span></span>
<span class="line" id="L888">        <span class="tok-comment">/// Uses `pl_node` with payload `Bin`. `lhs` is dest type, `rhs` is operand.</span></span>
<span class="line" id="L889">        <span class="tok-comment">/// Not every `@ptrCast` will correspond to this instruction - see also</span></span>
<span class="line" id="L890">        <span class="tok-comment">/// `ptr_cast_full` in `Extended`.</span></span>
<span class="line" id="L891">        ptr_cast,</span>
<span class="line" id="L892">        <span class="tok-comment">/// Implements the `@truncate` builtin.</span></span>
<span class="line" id="L893">        <span class="tok-comment">/// Uses `pl_node` with payload `Bin`. `lhs` is dest type, `rhs` is operand.</span></span>
<span class="line" id="L894">        truncate,</span>
<span class="line" id="L895"></span>
<span class="line" id="L896">        <span class="tok-comment">/// Implements the `@hasDecl` builtin.</span></span>
<span class="line" id="L897">        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Bin`.</span></span>
<span class="line" id="L898">        has_decl,</span>
<span class="line" id="L899">        <span class="tok-comment">/// Implements the `@hasField` builtin.</span></span>
<span class="line" id="L900">        <span class="tok-comment">/// Uses the `pl_node` union field. Payload is `Bin`.</span></span>
<span class="line" id="L901">        has_field,</span>
<span class="line" id="L902"></span>
<span class="line" id="L903">        <span class="tok-comment">/// Implements the `@clz` builtin. Uses the `un_node` union field.</span></span>
<span class="line" id="L904">        clz,</span>
<span class="line" id="L905">        <span class="tok-comment">/// Implements the `@ctz` builtin. Uses the `un_node` union field.</span></span>
<span class="line" id="L906">        ctz,</span>
<span class="line" id="L907">        <span class="tok-comment">/// Implements the `@popCount` builtin. Uses the `un_node` union field.</span></span>
<span class="line" id="L908">        pop_count,</span>
<span class="line" id="L909">        <span class="tok-comment">/// Implements the `@byteSwap` builtin. Uses the `un_node` union field.</span></span>
<span class="line" id="L910">        byte_swap,</span>
<span class="line" id="L911">        <span class="tok-comment">/// Implements the `@bitReverse` builtin. Uses the `un_node` union field.</span></span>
<span class="line" id="L912">        bit_reverse,</span>
<span class="line" id="L913"></span>
<span class="line" id="L914">        <span class="tok-comment">/// Implements the `@bitOffsetOf` builtin.</span></span>
<span class="line" id="L915">        <span class="tok-comment">/// Uses the `pl_node` union field with payload `Bin`.</span></span>
<span class="line" id="L916">        bit_offset_of,</span>
<span class="line" id="L917">        <span class="tok-comment">/// Implements the `@offsetOf` builtin.</span></span>
<span class="line" id="L918">        <span class="tok-comment">/// Uses the `pl_node` union field with payload `Bin`.</span></span>
<span class="line" id="L919">        offset_of,</span>
<span class="line" id="L920">        <span class="tok-comment">/// Implements the `@splat` builtin.</span></span>
<span class="line" id="L921">        <span class="tok-comment">/// Uses the `pl_node` union field with payload `Bin`.</span></span>
<span class="line" id="L922">        splat,</span>
<span class="line" id="L923">        <span class="tok-comment">/// Implements the `@reduce` builtin.</span></span>
<span class="line" id="L924">        <span class="tok-comment">/// Uses the `pl_node` union field with payload `Bin`.</span></span>
<span class="line" id="L925">        reduce,</span>
<span class="line" id="L926">        <span class="tok-comment">/// Implements the `@shuffle` builtin.</span></span>
<span class="line" id="L927">        <span class="tok-comment">/// Uses the `pl_node` union field with payload `Shuffle`.</span></span>
<span class="line" id="L928">        shuffle,</span>
<span class="line" id="L929">        <span class="tok-comment">/// Implements the `@atomicLoad` builtin.</span></span>
<span class="line" id="L930">        <span class="tok-comment">/// Uses the `pl_node` union field with payload `AtomicLoad`.</span></span>
<span class="line" id="L931">        atomic_load,</span>
<span class="line" id="L932">        <span class="tok-comment">/// Implements the `@atomicRmw` builtin.</span></span>
<span class="line" id="L933">        <span class="tok-comment">/// Uses the `pl_node` union field with payload `AtomicRmw`.</span></span>
<span class="line" id="L934">        atomic_rmw,</span>
<span class="line" id="L935">        <span class="tok-comment">/// Implements the `@atomicStore` builtin.</span></span>
<span class="line" id="L936">        <span class="tok-comment">/// Uses the `pl_node` union field with payload `AtomicStore`.</span></span>
<span class="line" id="L937">        atomic_store,</span>
<span class="line" id="L938">        <span class="tok-comment">/// Implements the `@mulAdd` builtin.</span></span>
<span class="line" id="L939">        <span class="tok-comment">/// Uses the `pl_node` union field with payload `MulAdd`.</span></span>
<span class="line" id="L940">        <span class="tok-comment">/// The addend communicates the type of the builtin.</span></span>
<span class="line" id="L941">        <span class="tok-comment">/// The mulends need to be coerced to the same type.</span></span>
<span class="line" id="L942">        mul_add,</span>
<span class="line" id="L943">        <span class="tok-comment">/// Implements the `@fieldParentPtr` builtin.</span></span>
<span class="line" id="L944">        <span class="tok-comment">/// Uses the `pl_node` union field with payload `FieldParentPtr`.</span></span>
<span class="line" id="L945">        field_parent_ptr,</span>
<span class="line" id="L946">        <span class="tok-comment">/// Implements the `@memcpy` builtin.</span></span>
<span class="line" id="L947">        <span class="tok-comment">/// Uses the `pl_node` union field with payload `Bin`.</span></span>
<span class="line" id="L948">        memcpy,</span>
<span class="line" id="L949">        <span class="tok-comment">/// Implements the `@memset` builtin.</span></span>
<span class="line" id="L950">        <span class="tok-comment">/// Uses the `pl_node` union field with payload `Bin`.</span></span>
<span class="line" id="L951">        memset,</span>
<span class="line" id="L952">        <span class="tok-comment">/// Implements the `@min` builtin for 2 args.</span></span>
<span class="line" id="L953">        <span class="tok-comment">/// Uses the `pl_node` union field with payload `Bin`</span></span>
<span class="line" id="L954">        min,</span>
<span class="line" id="L955">        <span class="tok-comment">/// Implements the `@max` builtin for 2 args.</span></span>
<span class="line" id="L956">        <span class="tok-comment">/// Uses the `pl_node` union field with payload `Bin`</span></span>
<span class="line" id="L957">        max,</span>
<span class="line" id="L958">        <span class="tok-comment">/// Implements the `@cImport` builtin.</span></span>
<span class="line" id="L959">        <span class="tok-comment">/// Uses the `pl_node` union field with payload `Block`.</span></span>
<span class="line" id="L960">        c_import,</span>
<span class="line" id="L961"></span>
<span class="line" id="L962">        <span class="tok-comment">/// Allocates stack local memory.</span></span>
<span class="line" id="L963">        <span class="tok-comment">/// Uses the `un_node` union field. The operand is the type of the allocated object.</span></span>
<span class="line" id="L964">        <span class="tok-comment">/// The node source location points to a var decl node.</span></span>
<span class="line" id="L965">        <span class="tok-comment">/// A `make_ptr_const` instruction should be used once the value has</span></span>
<span class="line" id="L966">        <span class="tok-comment">/// been stored to the allocation. To ensure comptime value detection</span></span>
<span class="line" id="L967">        <span class="tok-comment">/// functions, there are some restrictions on how this pointer should be</span></span>
<span class="line" id="L968">        <span class="tok-comment">/// used prior to the `make_ptr_const` instruction: no pointer derived</span></span>
<span class="line" id="L969">        <span class="tok-comment">/// from this `alloc` may be returned from a block or stored to another</span></span>
<span class="line" id="L970">        <span class="tok-comment">/// address. In other words, it must be trivial to determine whether any</span></span>
<span class="line" id="L971">        <span class="tok-comment">/// given pointer derives from this one.</span></span>
<span class="line" id="L972">        alloc,</span>
<span class="line" id="L973">        <span class="tok-comment">/// Same as `alloc` except mutable. As such, `make_ptr_const` need not be used,</span></span>
<span class="line" id="L974">        <span class="tok-comment">/// and there are no restrictions on the usage of the pointer.</span></span>
<span class="line" id="L975">        alloc_mut,</span>
<span class="line" id="L976">        <span class="tok-comment">/// Allocates comptime-mutable memory.</span></span>
<span class="line" id="L977">        <span class="tok-comment">/// Uses the `un_node` union field. The operand is the type of the allocated object.</span></span>
<span class="line" id="L978">        <span class="tok-comment">/// The node source location points to a var decl node.</span></span>
<span class="line" id="L979">        alloc_comptime_mut,</span>
<span class="line" id="L980">        <span class="tok-comment">/// Same as `alloc` except the type is inferred.</span></span>
<span class="line" id="L981">        <span class="tok-comment">/// Uses the `node` union field.</span></span>
<span class="line" id="L982">        alloc_inferred,</span>
<span class="line" id="L983">        <span class="tok-comment">/// Same as `alloc_inferred` except mutable.</span></span>
<span class="line" id="L984">        alloc_inferred_mut,</span>
<span class="line" id="L985">        <span class="tok-comment">/// Allocates comptime const memory.</span></span>
<span class="line" id="L986">        <span class="tok-comment">/// Uses the `node` union field. The type of the allocated object is inferred.</span></span>
<span class="line" id="L987">        <span class="tok-comment">/// The node source location points to a var decl node.</span></span>
<span class="line" id="L988">        alloc_inferred_comptime,</span>
<span class="line" id="L989">        <span class="tok-comment">/// Same as `alloc_comptime_mut` except the type is inferred.</span></span>
<span class="line" id="L990">        alloc_inferred_comptime_mut,</span>
<span class="line" id="L991">        <span class="tok-comment">/// Each `store_to_inferred_ptr` puts the type of the stored value into a set,</span></span>
<span class="line" id="L992">        <span class="tok-comment">/// and then `resolve_inferred_alloc` triggers peer type resolution on the set.</span></span>
<span class="line" id="L993">        <span class="tok-comment">/// The operand is a `alloc_inferred` or `alloc_inferred_mut` instruction, which</span></span>
<span class="line" id="L994">        <span class="tok-comment">/// is the allocation that needs to have its type inferred.</span></span>
<span class="line" id="L995">        <span class="tok-comment">/// Uses the `un_node` field. The AST node is the var decl.</span></span>
<span class="line" id="L996">        resolve_inferred_alloc,</span>
<span class="line" id="L997">        <span class="tok-comment">/// Turns a pointer coming from an `alloc` or `Extended.alloc` into a constant</span></span>
<span class="line" id="L998">        <span class="tok-comment">/// version of the same pointer. For inferred allocations this is instead implicitly</span></span>
<span class="line" id="L999">        <span class="tok-comment">/// handled by the `resolve_inferred_alloc` instruction.</span></span>
<span class="line" id="L1000">        <span class="tok-comment">/// Uses the `un_node` union field.</span></span>
<span class="line" id="L1001">        make_ptr_const,</span>
<span class="line" id="L1002"></span>
<span class="line" id="L1003">        <span class="tok-comment">/// Implements `resume` syntax. Uses `un_node` field.</span></span>
<span class="line" id="L1004">        @&quot;resume&quot;,</span>
<span class="line" id="L1005">        @&quot;await&quot;,</span>
<span class="line" id="L1006"></span>
<span class="line" id="L1007">        <span class="tok-comment">/// A defer statement.</span></span>
<span class="line" id="L1008">        <span class="tok-comment">/// Uses the `defer` union field.</span></span>
<span class="line" id="L1009">        @&quot;defer&quot;,</span>
<span class="line" id="L1010">        <span class="tok-comment">/// An errdefer statement with a code.</span></span>
<span class="line" id="L1011">        <span class="tok-comment">/// Uses the `err_defer_code` union field.</span></span>
<span class="line" id="L1012">        defer_err_code,</span>
<span class="line" id="L1013"></span>
<span class="line" id="L1014">        <span class="tok-comment">/// Requests that Sema update the saved error return trace index for the enclosing</span></span>
<span class="line" id="L1015">        <span class="tok-comment">/// block, if the operand is .none or of an error/error-union type.</span></span>
<span class="line" id="L1016">        <span class="tok-comment">/// Uses the `save_err_ret_index` field.</span></span>
<span class="line" id="L1017">        save_err_ret_index,</span>
<span class="line" id="L1018">        <span class="tok-comment">/// Specialized form of `Extended.restore_err_ret_index`.</span></span>
<span class="line" id="L1019">        <span class="tok-comment">/// Unconditionally restores the error return index to its last saved state</span></span>
<span class="line" id="L1020">        <span class="tok-comment">/// in the block referred to by `operand`. If `operand` is `none`, restores</span></span>
<span class="line" id="L1021">        <span class="tok-comment">/// to the point of function entry.</span></span>
<span class="line" id="L1022">        <span class="tok-comment">/// Uses the `un_node` field.</span></span>
<span class="line" id="L1023">        restore_err_ret_index_unconditional,</span>
<span class="line" id="L1024">        <span class="tok-comment">/// Specialized form of `Extended.restore_err_ret_index`.</span></span>
<span class="line" id="L1025">        <span class="tok-comment">/// Restores the error return index to its state at the entry of</span></span>
<span class="line" id="L1026">        <span class="tok-comment">/// the current function conditional on `operand` being a non-error.</span></span>
<span class="line" id="L1027">        <span class="tok-comment">/// If `operand` is `none`, restores unconditionally.</span></span>
<span class="line" id="L1028">        <span class="tok-comment">/// Uses the `un_node` field.</span></span>
<span class="line" id="L1029">        restore_err_ret_index_fn_entry,</span>
<span class="line" id="L1030"></span>
<span class="line" id="L1031">        <span class="tok-comment">/// The ZIR instruction tag is one of the `Extended` ones.</span></span>
<span class="line" id="L1032">        <span class="tok-comment">/// Uses the `extended` union field.</span></span>
<span class="line" id="L1033">        extended,</span>
<span class="line" id="L1034"></span>
<span class="line" id="L1035">        <span class="tok-comment">/// Returns whether the instruction is one of the control flow &quot;noreturn&quot; types.</span></span>
<span class="line" id="L1036">        <span class="tok-comment">/// Function calls do not count.</span></span>
<span class="line" id="L1037">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isNoReturn</span>(tag: Tag) <span class="tok-type">bool</span> {</span>
<span class="line" id="L1038">            <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (tag) {</span>
<span class="line" id="L1039">                .param,</span>
<span class="line" id="L1040">                .param_comptime,</span>
<span class="line" id="L1041">                .param_anytype,</span>
<span class="line" id="L1042">                .param_anytype_comptime,</span>
<span class="line" id="L1043">                .add,</span>
<span class="line" id="L1044">                .addwrap,</span>
<span class="line" id="L1045">                .add_sat,</span>
<span class="line" id="L1046">                .add_unsafe,</span>
<span class="line" id="L1047">                .alloc,</span>
<span class="line" id="L1048">                .alloc_mut,</span>
<span class="line" id="L1049">                .alloc_comptime_mut,</span>
<span class="line" id="L1050">                .alloc_inferred,</span>
<span class="line" id="L1051">                .alloc_inferred_mut,</span>
<span class="line" id="L1052">                .alloc_inferred_comptime,</span>
<span class="line" id="L1053">                .alloc_inferred_comptime_mut,</span>
<span class="line" id="L1054">                .make_ptr_const,</span>
<span class="line" id="L1055">                .array_cat,</span>
<span class="line" id="L1056">                .array_mul,</span>
<span class="line" id="L1057">                .array_type,</span>
<span class="line" id="L1058">                .array_type_sentinel,</span>
<span class="line" id="L1059">                .vector_type,</span>
<span class="line" id="L1060">                .elem_type,</span>
<span class="line" id="L1061">                .indexable_ptr_elem_type,</span>
<span class="line" id="L1062">                .vector_elem_type,</span>
<span class="line" id="L1063">                .indexable_ptr_len,</span>
<span class="line" id="L1064">                .anyframe_type,</span>
<span class="line" id="L1065">                .as_node,</span>
<span class="line" id="L1066">                .as_shift_operand,</span>
<span class="line" id="L1067">                .bit_and,</span>
<span class="line" id="L1068">                .bitcast,</span>
<span class="line" id="L1069">                .bit_or,</span>
<span class="line" id="L1070">                .block,</span>
<span class="line" id="L1071">                .block_comptime,</span>
<span class="line" id="L1072">                .block_inline,</span>
<span class="line" id="L1073">                .declaration,</span>
<span class="line" id="L1074">                .suspend_block,</span>
<span class="line" id="L1075">                .loop,</span>
<span class="line" id="L1076">                .bool_br_and,</span>
<span class="line" id="L1077">                .bool_br_or,</span>
<span class="line" id="L1078">                .bool_not,</span>
<span class="line" id="L1079">                .call,</span>
<span class="line" id="L1080">                .field_call,</span>
<span class="line" id="L1081">                .cmp_lt,</span>
<span class="line" id="L1082">                .cmp_lte,</span>
<span class="line" id="L1083">                .cmp_eq,</span>
<span class="line" id="L1084">                .cmp_gte,</span>
<span class="line" id="L1085">                .cmp_gt,</span>
<span class="line" id="L1086">                .cmp_neq,</span>
<span class="line" id="L1087">                .error_set_decl,</span>
<span class="line" id="L1088">                .error_set_decl_anon,</span>
<span class="line" id="L1089">                .error_set_decl_func,</span>
<span class="line" id="L1090">                .dbg_stmt,</span>
<span class="line" id="L1091">                .dbg_var_ptr,</span>
<span class="line" id="L1092">                .dbg_var_val,</span>
<span class="line" id="L1093">                .decl_ref,</span>
<span class="line" id="L1094">                .decl_val,</span>
<span class="line" id="L1095">                .load,</span>
<span class="line" id="L1096">                .div,</span>
<span class="line" id="L1097">                .elem_ptr,</span>
<span class="line" id="L1098">                .elem_val,</span>
<span class="line" id="L1099">                .elem_ptr_node,</span>
<span class="line" id="L1100">                .elem_val_node,</span>
<span class="line" id="L1101">                .elem_val_imm,</span>
<span class="line" id="L1102">                .ensure_result_used,</span>
<span class="line" id="L1103">                .ensure_result_non_error,</span>
<span class="line" id="L1104">                .ensure_err_union_payload_void,</span>
<span class="line" id="L1105">                .@&quot;export&quot;,</span>
<span class="line" id="L1106">                .export_value,</span>
<span class="line" id="L1107">                .field_ptr,</span>
<span class="line" id="L1108">                .field_val,</span>
<span class="line" id="L1109">                .field_ptr_named,</span>
<span class="line" id="L1110">                .field_val_named,</span>
<span class="line" id="L1111">                .func,</span>
<span class="line" id="L1112">                .func_inferred,</span>
<span class="line" id="L1113">                .func_fancy,</span>
<span class="line" id="L1114">                .has_decl,</span>
<span class="line" id="L1115">                .int,</span>
<span class="line" id="L1116">                .int_big,</span>
<span class="line" id="L1117">                .float,</span>
<span class="line" id="L1118">                .float128,</span>
<span class="line" id="L1119">                .int_type,</span>
<span class="line" id="L1120">                .is_non_null,</span>
<span class="line" id="L1121">                .is_non_null_ptr,</span>
<span class="line" id="L1122">                .is_non_err,</span>
<span class="line" id="L1123">                .is_non_err_ptr,</span>
<span class="line" id="L1124">                .ret_is_non_err,</span>
<span class="line" id="L1125">                .mod_rem,</span>
<span class="line" id="L1126">                .mul,</span>
<span class="line" id="L1127">                .mulwrap,</span>
<span class="line" id="L1128">                .mul_sat,</span>
<span class="line" id="L1129">                .ref,</span>
<span class="line" id="L1130">                .shl,</span>
<span class="line" id="L1131">                .shl_sat,</span>
<span class="line" id="L1132">                .shr,</span>
<span class="line" id="L1133">                .store_node,</span>
<span class="line" id="L1134">                .store_to_inferred_ptr,</span>
<span class="line" id="L1135">                .str,</span>
<span class="line" id="L1136">                .sub,</span>
<span class="line" id="L1137">                .subwrap,</span>
<span class="line" id="L1138">                .sub_sat,</span>
<span class="line" id="L1139">                .negate,</span>
<span class="line" id="L1140">                .negate_wrap,</span>
<span class="line" id="L1141">                .typeof,</span>
<span class="line" id="L1142">                .typeof_builtin,</span>
<span class="line" id="L1143">                .xor,</span>
<span class="line" id="L1144">                .optional_type,</span>
<span class="line" id="L1145">                .optional_payload_safe,</span>
<span class="line" id="L1146">                .optional_payload_unsafe,</span>
<span class="line" id="L1147">                .optional_payload_safe_ptr,</span>
<span class="line" id="L1148">                .optional_payload_unsafe_ptr,</span>
<span class="line" id="L1149">                .err_union_payload_unsafe,</span>
<span class="line" id="L1150">                .err_union_payload_unsafe_ptr,</span>
<span class="line" id="L1151">                .err_union_code,</span>
<span class="line" id="L1152">                .err_union_code_ptr,</span>
<span class="line" id="L1153">                .ptr_type,</span>
<span class="line" id="L1154">                .enum_literal,</span>
<span class="line" id="L1155">                .merge_error_sets,</span>
<span class="line" id="L1156">                .error_union_type,</span>
<span class="line" id="L1157">                .bit_not,</span>
<span class="line" id="L1158">                .error_value,</span>
<span class="line" id="L1159">                .slice_start,</span>
<span class="line" id="L1160">                .slice_end,</span>
<span class="line" id="L1161">                .slice_sentinel,</span>
<span class="line" id="L1162">                .slice_length,</span>
<span class="line" id="L1163">                .import,</span>
<span class="line" id="L1164">                .typeof_log2_int_type,</span>
<span class="line" id="L1165">                .resolve_inferred_alloc,</span>
<span class="line" id="L1166">                .set_eval_branch_quota,</span>
<span class="line" id="L1167">                .switch_block,</span>
<span class="line" id="L1168">                .switch_block_ref,</span>
<span class="line" id="L1169">                .switch_block_err_union,</span>
<span class="line" id="L1170">                .validate_deref,</span>
<span class="line" id="L1171">                .validate_destructure,</span>
<span class="line" id="L1172">                .union_init,</span>
<span class="line" id="L1173">                .field_type_ref,</span>
<span class="line" id="L1174">                .enum_from_int,</span>
<span class="line" id="L1175">                .int_from_enum,</span>
<span class="line" id="L1176">                .type_info,</span>
<span class="line" id="L1177">                .size_of,</span>
<span class="line" id="L1178">                .bit_size_of,</span>
<span class="line" id="L1179">                .int_from_ptr,</span>
<span class="line" id="L1180">                .align_of,</span>
<span class="line" id="L1181">                .int_from_bool,</span>
<span class="line" id="L1182">                .embed_file,</span>
<span class="line" id="L1183">                .error_name,</span>
<span class="line" id="L1184">                .set_runtime_safety,</span>
<span class="line" id="L1185">                .sqrt,</span>
<span class="line" id="L1186">                .sin,</span>
<span class="line" id="L1187">                .cos,</span>
<span class="line" id="L1188">                .tan,</span>
<span class="line" id="L1189">                .exp,</span>
<span class="line" id="L1190">                .exp2,</span>
<span class="line" id="L1191">                .log,</span>
<span class="line" id="L1192">                .log2,</span>
<span class="line" id="L1193">                .log10,</span>
<span class="line" id="L1194">                .abs,</span>
<span class="line" id="L1195">                .floor,</span>
<span class="line" id="L1196">                .ceil,</span>
<span class="line" id="L1197">                .trunc,</span>
<span class="line" id="L1198">                .round,</span>
<span class="line" id="L1199">                .tag_name,</span>
<span class="line" id="L1200">                .type_name,</span>
<span class="line" id="L1201">                .frame_type,</span>
<span class="line" id="L1202">                .frame_size,</span>
<span class="line" id="L1203">                .int_from_float,</span>
<span class="line" id="L1204">                .float_from_int,</span>
<span class="line" id="L1205">                .ptr_from_int,</span>
<span class="line" id="L1206">                .float_cast,</span>
<span class="line" id="L1207">                .int_cast,</span>
<span class="line" id="L1208">                .ptr_cast,</span>
<span class="line" id="L1209">                .truncate,</span>
<span class="line" id="L1210">                .has_field,</span>
<span class="line" id="L1211">                .clz,</span>
<span class="line" id="L1212">                .ctz,</span>
<span class="line" id="L1213">                .pop_count,</span>
<span class="line" id="L1214">                .byte_swap,</span>
<span class="line" id="L1215">                .bit_reverse,</span>
<span class="line" id="L1216">                .div_exact,</span>
<span class="line" id="L1217">                .div_floor,</span>
<span class="line" id="L1218">                .div_trunc,</span>
<span class="line" id="L1219">                .mod,</span>
<span class="line" id="L1220">                .rem,</span>
<span class="line" id="L1221">                .shl_exact,</span>
<span class="line" id="L1222">                .shr_exact,</span>
<span class="line" id="L1223">                .bit_offset_of,</span>
<span class="line" id="L1224">                .offset_of,</span>
<span class="line" id="L1225">                .splat,</span>
<span class="line" id="L1226">                .reduce,</span>
<span class="line" id="L1227">                .shuffle,</span>
<span class="line" id="L1228">                .atomic_load,</span>
<span class="line" id="L1229">                .atomic_rmw,</span>
<span class="line" id="L1230">                .atomic_store,</span>
<span class="line" id="L1231">                .mul_add,</span>
<span class="line" id="L1232">                .builtin_call,</span>
<span class="line" id="L1233">                .field_parent_ptr,</span>
<span class="line" id="L1234">                .max,</span>
<span class="line" id="L1235">                .memcpy,</span>
<span class="line" id="L1236">                .memset,</span>
<span class="line" id="L1237">                .min,</span>
<span class="line" id="L1238">                .c_import,</span>
<span class="line" id="L1239">                .@&quot;resume&quot;,</span>
<span class="line" id="L1240">                .@&quot;await&quot;,</span>
<span class="line" id="L1241">                .ret_err_value_code,</span>
<span class="line" id="L1242">                .extended,</span>
<span class="line" id="L1243">                .ret_ptr,</span>
<span class="line" id="L1244">                .ret_type,</span>
<span class="line" id="L1245">                .@&quot;try&quot;,</span>
<span class="line" id="L1246">                .try_ptr,</span>
<span class="line" id="L1247">                .@&quot;defer&quot;,</span>
<span class="line" id="L1248">                .defer_err_code,</span>
<span class="line" id="L1249">                .save_err_ret_index,</span>
<span class="line" id="L1250">                .for_len,</span>
<span class="line" id="L1251">                .opt_eu_base_ptr_init,</span>
<span class="line" id="L1252">                .coerce_ptr_elem_ty,</span>
<span class="line" id="L1253">                .struct_init_empty,</span>
<span class="line" id="L1254">                .struct_init_empty_result,</span>
<span class="line" id="L1255">                .struct_init_empty_ref_result,</span>
<span class="line" id="L1256">                .struct_init_anon,</span>
<span class="line" id="L1257">                .struct_init,</span>
<span class="line" id="L1258">                .struct_init_ref,</span>
<span class="line" id="L1259">                .validate_struct_init_ty,</span>
<span class="line" id="L1260">                .validate_struct_init_result_ty,</span>
<span class="line" id="L1261">                .validate_ptr_struct_init,</span>
<span class="line" id="L1262">                .struct_init_field_type,</span>
<span class="line" id="L1263">                .struct_init_field_ptr,</span>
<span class="line" id="L1264">                .array_init_anon,</span>
<span class="line" id="L1265">                .array_init,</span>
<span class="line" id="L1266">                .array_init_ref,</span>
<span class="line" id="L1267">                .validate_array_init_ty,</span>
<span class="line" id="L1268">                .validate_array_init_result_ty,</span>
<span class="line" id="L1269">                .validate_array_init_ref_ty,</span>
<span class="line" id="L1270">                .validate_ptr_array_init,</span>
<span class="line" id="L1271">                .array_init_elem_type,</span>
<span class="line" id="L1272">                .array_init_elem_ptr,</span>
<span class="line" id="L1273">                .validate_ref_ty,</span>
<span class="line" id="L1274">                .restore_err_ret_index_unconditional,</span>
<span class="line" id="L1275">                .restore_err_ret_index_fn_entry,</span>
<span class="line" id="L1276">                =&gt; <span class="tok-null">false</span>,</span>
<span class="line" id="L1277"></span>
<span class="line" id="L1278">                .@&quot;break&quot;,</span>
<span class="line" id="L1279">                .break_inline,</span>
<span class="line" id="L1280">                .condbr,</span>
<span class="line" id="L1281">                .condbr_inline,</span>
<span class="line" id="L1282">                .compile_error,</span>
<span class="line" id="L1283">                .ret_node,</span>
<span class="line" id="L1284">                .ret_load,</span>
<span class="line" id="L1285">                .ret_implicit,</span>
<span class="line" id="L1286">                .ret_err_value,</span>
<span class="line" id="L1287">                .@&quot;unreachable&quot;,</span>
<span class="line" id="L1288">                .repeat,</span>
<span class="line" id="L1289">                .repeat_inline,</span>
<span class="line" id="L1290">                .panic,</span>
<span class="line" id="L1291">                .trap,</span>
<span class="line" id="L1292">                .check_comptime_control_flow,</span>
<span class="line" id="L1293">                =&gt; <span class="tok-null">true</span>,</span>
<span class="line" id="L1294">            };</span>
<span class="line" id="L1295">        }</span>
<span class="line" id="L1296"></span>
<span class="line" id="L1297">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isParam</span>(tag: Tag) <span class="tok-type">bool</span> {</span>
<span class="line" id="L1298">            <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (tag) {</span>
<span class="line" id="L1299">                .param,</span>
<span class="line" id="L1300">                .param_comptime,</span>
<span class="line" id="L1301">                .param_anytype,</span>
<span class="line" id="L1302">                .param_anytype_comptime,</span>
<span class="line" id="L1303">                =&gt; <span class="tok-null">true</span>,</span>
<span class="line" id="L1304"></span>
<span class="line" id="L1305">                <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,</span>
<span class="line" id="L1306">            };</span>
<span class="line" id="L1307">        }</span>
<span class="line" id="L1308"></span>
<span class="line" id="L1309">        <span class="tok-comment">/// AstGen uses this to find out if `Ref.void_value` should be used in place</span></span>
<span class="line" id="L1310">        <span class="tok-comment">/// of the result of a given instruction. This allows Sema to forego adding</span></span>
<span class="line" id="L1311">        <span class="tok-comment">/// the instruction to the map after analysis.</span></span>
<span class="line" id="L1312">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isAlwaysVoid</span>(tag: Tag, data: Data) <span class="tok-type">bool</span> {</span>
<span class="line" id="L1313">            <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (tag) {</span>
<span class="line" id="L1314">                .dbg_stmt,</span>
<span class="line" id="L1315">                .dbg_var_ptr,</span>
<span class="line" id="L1316">                .dbg_var_val,</span>
<span class="line" id="L1317">                .ensure_result_used,</span>
<span class="line" id="L1318">                .ensure_result_non_error,</span>
<span class="line" id="L1319">                .ensure_err_union_payload_void,</span>
<span class="line" id="L1320">                .set_eval_branch_quota,</span>
<span class="line" id="L1321">                .atomic_store,</span>
<span class="line" id="L1322">                .store_node,</span>
<span class="line" id="L1323">                .store_to_inferred_ptr,</span>
<span class="line" id="L1324">                .resolve_inferred_alloc,</span>
<span class="line" id="L1325">                .validate_deref,</span>
<span class="line" id="L1326">                .validate_destructure,</span>
<span class="line" id="L1327">                .@&quot;export&quot;,</span>
<span class="line" id="L1328">                .export_value,</span>
<span class="line" id="L1329">                .set_runtime_safety,</span>
<span class="line" id="L1330">                .memcpy,</span>
<span class="line" id="L1331">                .memset,</span>
<span class="line" id="L1332">                .check_comptime_control_flow,</span>
<span class="line" id="L1333">                .@&quot;defer&quot;,</span>
<span class="line" id="L1334">                .defer_err_code,</span>
<span class="line" id="L1335">                .save_err_ret_index,</span>
<span class="line" id="L1336">                .restore_err_ret_index_unconditional,</span>
<span class="line" id="L1337">                .restore_err_ret_index_fn_entry,</span>
<span class="line" id="L1338">                .validate_struct_init_ty,</span>
<span class="line" id="L1339">                .validate_struct_init_result_ty,</span>
<span class="line" id="L1340">                .validate_ptr_struct_init,</span>
<span class="line" id="L1341">                .validate_array_init_ty,</span>
<span class="line" id="L1342">                .validate_array_init_result_ty,</span>
<span class="line" id="L1343">                .validate_ptr_array_init,</span>
<span class="line" id="L1344">                .validate_ref_ty,</span>
<span class="line" id="L1345">                =&gt; <span class="tok-null">true</span>,</span>
<span class="line" id="L1346"></span>
<span class="line" id="L1347">                .param,</span>
<span class="line" id="L1348">                .param_comptime,</span>
<span class="line" id="L1349">                .param_anytype,</span>
<span class="line" id="L1350">                .param_anytype_comptime,</span>
<span class="line" id="L1351">                .add,</span>
<span class="line" id="L1352">                .addwrap,</span>
<span class="line" id="L1353">                .add_sat,</span>
<span class="line" id="L1354">                .add_unsafe,</span>
<span class="line" id="L1355">                .alloc,</span>
<span class="line" id="L1356">                .alloc_mut,</span>
<span class="line" id="L1357">                .alloc_comptime_mut,</span>
<span class="line" id="L1358">                .alloc_inferred,</span>
<span class="line" id="L1359">                .alloc_inferred_mut,</span>
<span class="line" id="L1360">                .alloc_inferred_comptime,</span>
<span class="line" id="L1361">                .alloc_inferred_comptime_mut,</span>
<span class="line" id="L1362">                .make_ptr_const,</span>
<span class="line" id="L1363">                .array_cat,</span>
<span class="line" id="L1364">                .array_mul,</span>
<span class="line" id="L1365">                .array_type,</span>
<span class="line" id="L1366">                .array_type_sentinel,</span>
<span class="line" id="L1367">                .vector_type,</span>
<span class="line" id="L1368">                .elem_type,</span>
<span class="line" id="L1369">                .indexable_ptr_elem_type,</span>
<span class="line" id="L1370">                .vector_elem_type,</span>
<span class="line" id="L1371">                .indexable_ptr_len,</span>
<span class="line" id="L1372">                .anyframe_type,</span>
<span class="line" id="L1373">                .as_node,</span>
<span class="line" id="L1374">                .as_shift_operand,</span>
<span class="line" id="L1375">                .bit_and,</span>
<span class="line" id="L1376">                .bitcast,</span>
<span class="line" id="L1377">                .bit_or,</span>
<span class="line" id="L1378">                .block,</span>
<span class="line" id="L1379">                .block_comptime,</span>
<span class="line" id="L1380">                .block_inline,</span>
<span class="line" id="L1381">                .declaration,</span>
<span class="line" id="L1382">                .suspend_block,</span>
<span class="line" id="L1383">                .loop,</span>
<span class="line" id="L1384">                .bool_br_and,</span>
<span class="line" id="L1385">                .bool_br_or,</span>
<span class="line" id="L1386">                .bool_not,</span>
<span class="line" id="L1387">                .call,</span>
<span class="line" id="L1388">                .field_call,</span>
<span class="line" id="L1389">                .cmp_lt,</span>
<span class="line" id="L1390">                .cmp_lte,</span>
<span class="line" id="L1391">                .cmp_eq,</span>
<span class="line" id="L1392">                .cmp_gte,</span>
<span class="line" id="L1393">                .cmp_gt,</span>
<span class="line" id="L1394">                .cmp_neq,</span>
<span class="line" id="L1395">                .error_set_decl,</span>
<span class="line" id="L1396">                .error_set_decl_anon,</span>
<span class="line" id="L1397">                .error_set_decl_func,</span>
<span class="line" id="L1398">                .decl_ref,</span>
<span class="line" id="L1399">                .decl_val,</span>
<span class="line" id="L1400">                .load,</span>
<span class="line" id="L1401">                .div,</span>
<span class="line" id="L1402">                .elem_ptr,</span>
<span class="line" id="L1403">                .elem_val,</span>
<span class="line" id="L1404">                .elem_ptr_node,</span>
<span class="line" id="L1405">                .elem_val_node,</span>
<span class="line" id="L1406">                .elem_val_imm,</span>
<span class="line" id="L1407">                .field_ptr,</span>
<span class="line" id="L1408">                .field_val,</span>
<span class="line" id="L1409">                .field_ptr_named,</span>
<span class="line" id="L1410">                .field_val_named,</span>
<span class="line" id="L1411">                .func,</span>
<span class="line" id="L1412">                .func_inferred,</span>
<span class="line" id="L1413">                .func_fancy,</span>
<span class="line" id="L1414">                .has_decl,</span>
<span class="line" id="L1415">                .int,</span>
<span class="line" id="L1416">                .int_big,</span>
<span class="line" id="L1417">                .float,</span>
<span class="line" id="L1418">                .float128,</span>
<span class="line" id="L1419">                .int_type,</span>
<span class="line" id="L1420">                .is_non_null,</span>
<span class="line" id="L1421">                .is_non_null_ptr,</span>
<span class="line" id="L1422">                .is_non_err,</span>
<span class="line" id="L1423">                .is_non_err_ptr,</span>
<span class="line" id="L1424">                .ret_is_non_err,</span>
<span class="line" id="L1425">                .mod_rem,</span>
<span class="line" id="L1426">                .mul,</span>
<span class="line" id="L1427">                .mulwrap,</span>
<span class="line" id="L1428">                .mul_sat,</span>
<span class="line" id="L1429">                .ref,</span>
<span class="line" id="L1430">                .shl,</span>
<span class="line" id="L1431">                .shl_sat,</span>
<span class="line" id="L1432">                .shr,</span>
<span class="line" id="L1433">                .str,</span>
<span class="line" id="L1434">                .sub,</span>
<span class="line" id="L1435">                .subwrap,</span>
<span class="line" id="L1436">                .sub_sat,</span>
<span class="line" id="L1437">                .negate,</span>
<span class="line" id="L1438">                .negate_wrap,</span>
<span class="line" id="L1439">                .typeof,</span>
<span class="line" id="L1440">                .typeof_builtin,</span>
<span class="line" id="L1441">                .xor,</span>
<span class="line" id="L1442">                .optional_type,</span>
<span class="line" id="L1443">                .optional_payload_safe,</span>
<span class="line" id="L1444">                .optional_payload_unsafe,</span>
<span class="line" id="L1445">                .optional_payload_safe_ptr,</span>
<span class="line" id="L1446">                .optional_payload_unsafe_ptr,</span>
<span class="line" id="L1447">                .err_union_payload_unsafe,</span>
<span class="line" id="L1448">                .err_union_payload_unsafe_ptr,</span>
<span class="line" id="L1449">                .err_union_code,</span>
<span class="line" id="L1450">                .err_union_code_ptr,</span>
<span class="line" id="L1451">                .ptr_type,</span>
<span class="line" id="L1452">                .enum_literal,</span>
<span class="line" id="L1453">                .merge_error_sets,</span>
<span class="line" id="L1454">                .error_union_type,</span>
<span class="line" id="L1455">                .bit_not,</span>
<span class="line" id="L1456">                .error_value,</span>
<span class="line" id="L1457">                .slice_start,</span>
<span class="line" id="L1458">                .slice_end,</span>
<span class="line" id="L1459">                .slice_sentinel,</span>
<span class="line" id="L1460">                .slice_length,</span>
<span class="line" id="L1461">                .import,</span>
<span class="line" id="L1462">                .typeof_log2_int_type,</span>
<span class="line" id="L1463">                .switch_block,</span>
<span class="line" id="L1464">                .switch_block_ref,</span>
<span class="line" id="L1465">                .switch_block_err_union,</span>
<span class="line" id="L1466">                .union_init,</span>
<span class="line" id="L1467">                .field_type_ref,</span>
<span class="line" id="L1468">                .enum_from_int,</span>
<span class="line" id="L1469">                .int_from_enum,</span>
<span class="line" id="L1470">                .type_info,</span>
<span class="line" id="L1471">                .size_of,</span>
<span class="line" id="L1472">                .bit_size_of,</span>
<span class="line" id="L1473">                .int_from_ptr,</span>
<span class="line" id="L1474">                .align_of,</span>
<span class="line" id="L1475">                .int_from_bool,</span>
<span class="line" id="L1476">                .embed_file,</span>
<span class="line" id="L1477">                .error_name,</span>
<span class="line" id="L1478">                .sqrt,</span>
<span class="line" id="L1479">                .sin,</span>
<span class="line" id="L1480">                .cos,</span>
<span class="line" id="L1481">                .tan,</span>
<span class="line" id="L1482">                .exp,</span>
<span class="line" id="L1483">                .exp2,</span>
<span class="line" id="L1484">                .log,</span>
<span class="line" id="L1485">                .log2,</span>
<span class="line" id="L1486">                .log10,</span>
<span class="line" id="L1487">                .abs,</span>
<span class="line" id="L1488">                .floor,</span>
<span class="line" id="L1489">                .ceil,</span>
<span class="line" id="L1490">                .trunc,</span>
<span class="line" id="L1491">                .round,</span>
<span class="line" id="L1492">                .tag_name,</span>
<span class="line" id="L1493">                .type_name,</span>
<span class="line" id="L1494">                .frame_type,</span>
<span class="line" id="L1495">                .frame_size,</span>
<span class="line" id="L1496">                .int_from_float,</span>
<span class="line" id="L1497">                .float_from_int,</span>
<span class="line" id="L1498">                .ptr_from_int,</span>
<span class="line" id="L1499">                .float_cast,</span>
<span class="line" id="L1500">                .int_cast,</span>
<span class="line" id="L1501">                .ptr_cast,</span>
<span class="line" id="L1502">                .truncate,</span>
<span class="line" id="L1503">                .has_field,</span>
<span class="line" id="L1504">                .clz,</span>
<span class="line" id="L1505">                .ctz,</span>
<span class="line" id="L1506">                .pop_count,</span>
<span class="line" id="L1507">                .byte_swap,</span>
<span class="line" id="L1508">                .bit_reverse,</span>
<span class="line" id="L1509">                .div_exact,</span>
<span class="line" id="L1510">                .div_floor,</span>
<span class="line" id="L1511">                .div_trunc,</span>
<span class="line" id="L1512">                .mod,</span>
<span class="line" id="L1513">                .rem,</span>
<span class="line" id="L1514">                .shl_exact,</span>
<span class="line" id="L1515">                .shr_exact,</span>
<span class="line" id="L1516">                .bit_offset_of,</span>
<span class="line" id="L1517">                .offset_of,</span>
<span class="line" id="L1518">                .splat,</span>
<span class="line" id="L1519">                .reduce,</span>
<span class="line" id="L1520">                .shuffle,</span>
<span class="line" id="L1521">                .atomic_load,</span>
<span class="line" id="L1522">                .atomic_rmw,</span>
<span class="line" id="L1523">                .mul_add,</span>
<span class="line" id="L1524">                .builtin_call,</span>
<span class="line" id="L1525">                .field_parent_ptr,</span>
<span class="line" id="L1526">                .max,</span>
<span class="line" id="L1527">                .min,</span>
<span class="line" id="L1528">                .c_import,</span>
<span class="line" id="L1529">                .@&quot;resume&quot;,</span>
<span class="line" id="L1530">                .@&quot;await&quot;,</span>
<span class="line" id="L1531">                .ret_err_value_code,</span>
<span class="line" id="L1532">                .@&quot;break&quot;,</span>
<span class="line" id="L1533">                .break_inline,</span>
<span class="line" id="L1534">                .condbr,</span>
<span class="line" id="L1535">                .condbr_inline,</span>
<span class="line" id="L1536">                .compile_error,</span>
<span class="line" id="L1537">                .ret_node,</span>
<span class="line" id="L1538">                .ret_load,</span>
<span class="line" id="L1539">                .ret_implicit,</span>
<span class="line" id="L1540">                .ret_err_value,</span>
<span class="line" id="L1541">                .ret_ptr,</span>
<span class="line" id="L1542">                .ret_type,</span>
<span class="line" id="L1543">                .@&quot;unreachable&quot;,</span>
<span class="line" id="L1544">                .repeat,</span>
<span class="line" id="L1545">                .repeat_inline,</span>
<span class="line" id="L1546">                .panic,</span>
<span class="line" id="L1547">                .trap,</span>
<span class="line" id="L1548">                .for_len,</span>
<span class="line" id="L1549">                .@&quot;try&quot;,</span>
<span class="line" id="L1550">                .try_ptr,</span>
<span class="line" id="L1551">                .opt_eu_base_ptr_init,</span>
<span class="line" id="L1552">                .coerce_ptr_elem_ty,</span>
<span class="line" id="L1553">                .struct_init_empty,</span>
<span class="line" id="L1554">                .struct_init_empty_result,</span>
<span class="line" id="L1555">                .struct_init_empty_ref_result,</span>
<span class="line" id="L1556">                .struct_init_anon,</span>
<span class="line" id="L1557">                .struct_init,</span>
<span class="line" id="L1558">                .struct_init_ref,</span>
<span class="line" id="L1559">                .struct_init_field_type,</span>
<span class="line" id="L1560">                .struct_init_field_ptr,</span>
<span class="line" id="L1561">                .array_init_anon,</span>
<span class="line" id="L1562">                .array_init,</span>
<span class="line" id="L1563">                .array_init_ref,</span>
<span class="line" id="L1564">                .validate_array_init_ref_ty,</span>
<span class="line" id="L1565">                .array_init_elem_type,</span>
<span class="line" id="L1566">                .array_init_elem_ptr,</span>
<span class="line" id="L1567">                =&gt; <span class="tok-null">false</span>,</span>
<span class="line" id="L1568"></span>
<span class="line" id="L1569">                .extended =&gt; <span class="tok-kw">switch</span> (data.extended.opcode) {</span>
<span class="line" id="L1570">                    .fence, .set_cold, .breakpoint =&gt; <span class="tok-null">true</span>,</span>
<span class="line" id="L1571">                    <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,</span>
<span class="line" id="L1572">                },</span>
<span class="line" id="L1573">            };</span>
<span class="line" id="L1574">        }</span>
<span class="line" id="L1575"></span>
<span class="line" id="L1576">        <span class="tok-comment">/// Used by debug safety-checking code.</span></span>
<span class="line" id="L1577">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> data_tags = list: {</span>
<span class="line" id="L1578">            <span class="tok-builtin">@setEvalBranchQuota</span>(<span class="tok-number">2000</span>);</span>
<span class="line" id="L1579">            <span class="tok-kw">break</span> :list std.enums.directEnumArray(Tag, Data.FieldEnum, <span class="tok-number">0</span>, .{</span>
<span class="line" id="L1580">                .add = .pl_node,</span>
<span class="line" id="L1581">                .addwrap = .pl_node,</span>
<span class="line" id="L1582">                .add_sat = .pl_node,</span>
<span class="line" id="L1583">                .add_unsafe = .pl_node,</span>
<span class="line" id="L1584">                .sub = .pl_node,</span>
<span class="line" id="L1585">                .subwrap = .pl_node,</span>
<span class="line" id="L1586">                .sub_sat = .pl_node,</span>
<span class="line" id="L1587">                .mul = .pl_node,</span>
<span class="line" id="L1588">                .mulwrap = .pl_node,</span>
<span class="line" id="L1589">                .mul_sat = .pl_node,</span>
<span class="line" id="L1590"></span>
<span class="line" id="L1591">                .param = .pl_tok,</span>
<span class="line" id="L1592">                .param_comptime = .pl_tok,</span>
<span class="line" id="L1593">                .param_anytype = .str_tok,</span>
<span class="line" id="L1594">                .param_anytype_comptime = .str_tok,</span>
<span class="line" id="L1595">                .array_cat = .pl_node,</span>
<span class="line" id="L1596">                .array_mul = .pl_node,</span>
<span class="line" id="L1597">                .array_type = .pl_node,</span>
<span class="line" id="L1598">                .array_type_sentinel = .pl_node,</span>
<span class="line" id="L1599">                .vector_type = .pl_node,</span>
<span class="line" id="L1600">                .elem_type = .un_node,</span>
<span class="line" id="L1601">                .indexable_ptr_elem_type = .un_node,</span>
<span class="line" id="L1602">                .vector_elem_type = .un_node,</span>
<span class="line" id="L1603">                .indexable_ptr_len = .un_node,</span>
<span class="line" id="L1604">                .anyframe_type = .un_node,</span>
<span class="line" id="L1605">                .as_node = .pl_node,</span>
<span class="line" id="L1606">                .as_shift_operand = .pl_node,</span>
<span class="line" id="L1607">                .bit_and = .pl_node,</span>
<span class="line" id="L1608">                .bitcast = .pl_node,</span>
<span class="line" id="L1609">                .bit_not = .un_node,</span>
<span class="line" id="L1610">                .bit_or = .pl_node,</span>
<span class="line" id="L1611">                .block = .pl_node,</span>
<span class="line" id="L1612">                .block_comptime = .pl_node,</span>
<span class="line" id="L1613">                .block_inline = .pl_node,</span>
<span class="line" id="L1614">                .declaration = .pl_node,</span>
<span class="line" id="L1615">                .suspend_block = .pl_node,</span>
<span class="line" id="L1616">                .bool_not = .un_node,</span>
<span class="line" id="L1617">                .bool_br_and = .pl_node,</span>
<span class="line" id="L1618">                .bool_br_or = .pl_node,</span>
<span class="line" id="L1619">                .@&quot;break&quot; = .@&quot;break&quot;,</span>
<span class="line" id="L1620">                .break_inline = .@&quot;break&quot;,</span>
<span class="line" id="L1621">                .check_comptime_control_flow = .un_node,</span>
<span class="line" id="L1622">                .for_len = .pl_node,</span>
<span class="line" id="L1623">                .call = .pl_node,</span>
<span class="line" id="L1624">                .field_call = .pl_node,</span>
<span class="line" id="L1625">                .cmp_lt = .pl_node,</span>
<span class="line" id="L1626">                .cmp_lte = .pl_node,</span>
<span class="line" id="L1627">                .cmp_eq = .pl_node,</span>
<span class="line" id="L1628">                .cmp_gte = .pl_node,</span>
<span class="line" id="L1629">                .cmp_gt = .pl_node,</span>
<span class="line" id="L1630">                .cmp_neq = .pl_node,</span>
<span class="line" id="L1631">                .condbr = .pl_node,</span>
<span class="line" id="L1632">                .condbr_inline = .pl_node,</span>
<span class="line" id="L1633">                .@&quot;try&quot; = .pl_node,</span>
<span class="line" id="L1634">                .try_ptr = .pl_node,</span>
<span class="line" id="L1635">                .error_set_decl = .pl_node,</span>
<span class="line" id="L1636">                .error_set_decl_anon = .pl_node,</span>
<span class="line" id="L1637">                .error_set_decl_func = .pl_node,</span>
<span class="line" id="L1638">                .dbg_stmt = .dbg_stmt,</span>
<span class="line" id="L1639">                .dbg_var_ptr = .str_op,</span>
<span class="line" id="L1640">                .dbg_var_val = .str_op,</span>
<span class="line" id="L1641">                .decl_ref = .str_tok,</span>
<span class="line" id="L1642">                .decl_val = .str_tok,</span>
<span class="line" id="L1643">                .load = .un_node,</span>
<span class="line" id="L1644">                .div = .pl_node,</span>
<span class="line" id="L1645">                .elem_ptr = .pl_node,</span>
<span class="line" id="L1646">                .elem_ptr_node = .pl_node,</span>
<span class="line" id="L1647">                .elem_val = .pl_node,</span>
<span class="line" id="L1648">                .elem_val_node = .pl_node,</span>
<span class="line" id="L1649">                .elem_val_imm = .elem_val_imm,</span>
<span class="line" id="L1650">                .ensure_result_used = .un_node,</span>
<span class="line" id="L1651">                .ensure_result_non_error = .un_node,</span>
<span class="line" id="L1652">                .ensure_err_union_payload_void = .un_node,</span>
<span class="line" id="L1653">                .error_union_type = .pl_node,</span>
<span class="line" id="L1654">                .error_value = .str_tok,</span>
<span class="line" id="L1655">                .@&quot;export&quot; = .pl_node,</span>
<span class="line" id="L1656">                .export_value = .pl_node,</span>
<span class="line" id="L1657">                .field_ptr = .pl_node,</span>
<span class="line" id="L1658">                .field_val = .pl_node,</span>
<span class="line" id="L1659">                .field_ptr_named = .pl_node,</span>
<span class="line" id="L1660">                .field_val_named = .pl_node,</span>
<span class="line" id="L1661">                .func = .pl_node,</span>
<span class="line" id="L1662">                .func_inferred = .pl_node,</span>
<span class="line" id="L1663">                .func_fancy = .pl_node,</span>
<span class="line" id="L1664">                .import = .str_tok,</span>
<span class="line" id="L1665">                .int = .int,</span>
<span class="line" id="L1666">                .int_big = .str,</span>
<span class="line" id="L1667">                .float = .float,</span>
<span class="line" id="L1668">                .float128 = .pl_node,</span>
<span class="line" id="L1669">                .int_type = .int_type,</span>
<span class="line" id="L1670">                .is_non_null = .un_node,</span>
<span class="line" id="L1671">                .is_non_null_ptr = .un_node,</span>
<span class="line" id="L1672">                .is_non_err = .un_node,</span>
<span class="line" id="L1673">                .is_non_err_ptr = .un_node,</span>
<span class="line" id="L1674">                .ret_is_non_err = .un_node,</span>
<span class="line" id="L1675">                .loop = .pl_node,</span>
<span class="line" id="L1676">                .repeat = .node,</span>
<span class="line" id="L1677">                .repeat_inline = .node,</span>
<span class="line" id="L1678">                .merge_error_sets = .pl_node,</span>
<span class="line" id="L1679">                .mod_rem = .pl_node,</span>
<span class="line" id="L1680">                .ref = .un_tok,</span>
<span class="line" id="L1681">                .ret_node = .un_node,</span>
<span class="line" id="L1682">                .ret_load = .un_node,</span>
<span class="line" id="L1683">                .ret_implicit = .un_tok,</span>
<span class="line" id="L1684">                .ret_err_value = .str_tok,</span>
<span class="line" id="L1685">                .ret_err_value_code = .str_tok,</span>
<span class="line" id="L1686">                .ret_ptr = .node,</span>
<span class="line" id="L1687">                .ret_type = .node,</span>
<span class="line" id="L1688">                .ptr_type = .ptr_type,</span>
<span class="line" id="L1689">                .slice_start = .pl_node,</span>
<span class="line" id="L1690">                .slice_end = .pl_node,</span>
<span class="line" id="L1691">                .slice_sentinel = .pl_node,</span>
<span class="line" id="L1692">                .slice_length = .pl_node,</span>
<span class="line" id="L1693">                .store_node = .pl_node,</span>
<span class="line" id="L1694">                .store_to_inferred_ptr = .pl_node,</span>
<span class="line" id="L1695">                .str = .str,</span>
<span class="line" id="L1696">                .negate = .un_node,</span>
<span class="line" id="L1697">                .negate_wrap = .un_node,</span>
<span class="line" id="L1698">                .typeof = .un_node,</span>
<span class="line" id="L1699">                .typeof_log2_int_type = .un_node,</span>
<span class="line" id="L1700">                .@&quot;unreachable&quot; = .@&quot;unreachable&quot;,</span>
<span class="line" id="L1701">                .xor = .pl_node,</span>
<span class="line" id="L1702">                .optional_type = .un_node,</span>
<span class="line" id="L1703">                .optional_payload_safe = .un_node,</span>
<span class="line" id="L1704">                .optional_payload_unsafe = .un_node,</span>
<span class="line" id="L1705">                .optional_payload_safe_ptr = .un_node,</span>
<span class="line" id="L1706">                .optional_payload_unsafe_ptr = .un_node,</span>
<span class="line" id="L1707">                .err_union_payload_unsafe = .un_node,</span>
<span class="line" id="L1708">                .err_union_payload_unsafe_ptr = .un_node,</span>
<span class="line" id="L1709">                .err_union_code = .un_node,</span>
<span class="line" id="L1710">                .err_union_code_ptr = .un_node,</span>
<span class="line" id="L1711">                .enum_literal = .str_tok,</span>
<span class="line" id="L1712">                .switch_block = .pl_node,</span>
<span class="line" id="L1713">                .switch_block_ref = .pl_node,</span>
<span class="line" id="L1714">                .switch_block_err_union = .pl_node,</span>
<span class="line" id="L1715">                .validate_deref = .un_node,</span>
<span class="line" id="L1716">                .validate_destructure = .pl_node,</span>
<span class="line" id="L1717">                .field_type_ref = .pl_node,</span>
<span class="line" id="L1718">                .union_init = .pl_node,</span>
<span class="line" id="L1719">                .type_info = .un_node,</span>
<span class="line" id="L1720">                .size_of = .un_node,</span>
<span class="line" id="L1721">                .bit_size_of = .un_node,</span>
<span class="line" id="L1722">                .opt_eu_base_ptr_init = .un_node,</span>
<span class="line" id="L1723">                .coerce_ptr_elem_ty = .pl_node,</span>
<span class="line" id="L1724">                .validate_ref_ty = .un_tok,</span>
<span class="line" id="L1725"></span>
<span class="line" id="L1726">                .int_from_ptr = .un_node,</span>
<span class="line" id="L1727">                .compile_error = .un_node,</span>
<span class="line" id="L1728">                .set_eval_branch_quota = .un_node,</span>
<span class="line" id="L1729">                .int_from_enum = .un_node,</span>
<span class="line" id="L1730">                .align_of = .un_node,</span>
<span class="line" id="L1731">                .int_from_bool = .un_node,</span>
<span class="line" id="L1732">                .embed_file = .un_node,</span>
<span class="line" id="L1733">                .error_name = .un_node,</span>
<span class="line" id="L1734">                .panic = .un_node,</span>
<span class="line" id="L1735">                .trap = .node,</span>
<span class="line" id="L1736">                .set_runtime_safety = .un_node,</span>
<span class="line" id="L1737">                .sqrt = .un_node,</span>
<span class="line" id="L1738">                .sin = .un_node,</span>
<span class="line" id="L1739">                .cos = .un_node,</span>
<span class="line" id="L1740">                .tan = .un_node,</span>
<span class="line" id="L1741">                .exp = .un_node,</span>
<span class="line" id="L1742">                .exp2 = .un_node,</span>
<span class="line" id="L1743">                .log = .un_node,</span>
<span class="line" id="L1744">                .log2 = .un_node,</span>
<span class="line" id="L1745">                .log10 = .un_node,</span>
<span class="line" id="L1746">                .abs = .un_node,</span>
<span class="line" id="L1747">                .floor = .un_node,</span>
<span class="line" id="L1748">                .ceil = .un_node,</span>
<span class="line" id="L1749">                .trunc = .un_node,</span>
<span class="line" id="L1750">                .round = .un_node,</span>
<span class="line" id="L1751">                .tag_name = .un_node,</span>
<span class="line" id="L1752">                .type_name = .un_node,</span>
<span class="line" id="L1753">                .frame_type = .un_node,</span>
<span class="line" id="L1754">                .frame_size = .un_node,</span>
<span class="line" id="L1755"></span>
<span class="line" id="L1756">                .int_from_float = .pl_node,</span>
<span class="line" id="L1757">                .float_from_int = .pl_node,</span>
<span class="line" id="L1758">                .ptr_from_int = .pl_node,</span>
<span class="line" id="L1759">                .enum_from_int = .pl_node,</span>
<span class="line" id="L1760">                .float_cast = .pl_node,</span>
<span class="line" id="L1761">                .int_cast = .pl_node,</span>
<span class="line" id="L1762">                .ptr_cast = .pl_node,</span>
<span class="line" id="L1763">                .truncate = .pl_node,</span>
<span class="line" id="L1764">                .typeof_builtin = .pl_node,</span>
<span class="line" id="L1765"></span>
<span class="line" id="L1766">                .has_decl = .pl_node,</span>
<span class="line" id="L1767">                .has_field = .pl_node,</span>
<span class="line" id="L1768"></span>
<span class="line" id="L1769">                .clz = .un_node,</span>
<span class="line" id="L1770">                .ctz = .un_node,</span>
<span class="line" id="L1771">                .pop_count = .un_node,</span>
<span class="line" id="L1772">                .byte_swap = .un_node,</span>
<span class="line" id="L1773">                .bit_reverse = .un_node,</span>
<span class="line" id="L1774"></span>
<span class="line" id="L1775">                .div_exact = .pl_node,</span>
<span class="line" id="L1776">                .div_floor = .pl_node,</span>
<span class="line" id="L1777">                .div_trunc = .pl_node,</span>
<span class="line" id="L1778">                .mod = .pl_node,</span>
<span class="line" id="L1779">                .rem = .pl_node,</span>
<span class="line" id="L1780"></span>
<span class="line" id="L1781">                .shl = .pl_node,</span>
<span class="line" id="L1782">                .shl_exact = .pl_node,</span>
<span class="line" id="L1783">                .shl_sat = .pl_node,</span>
<span class="line" id="L1784">                .shr = .pl_node,</span>
<span class="line" id="L1785">                .shr_exact = .pl_node,</span>
<span class="line" id="L1786"></span>
<span class="line" id="L1787">                .bit_offset_of = .pl_node,</span>
<span class="line" id="L1788">                .offset_of = .pl_node,</span>
<span class="line" id="L1789">                .splat = .pl_node,</span>
<span class="line" id="L1790">                .reduce = .pl_node,</span>
<span class="line" id="L1791">                .shuffle = .pl_node,</span>
<span class="line" id="L1792">                .atomic_load = .pl_node,</span>
<span class="line" id="L1793">                .atomic_rmw = .pl_node,</span>
<span class="line" id="L1794">                .atomic_store = .pl_node,</span>
<span class="line" id="L1795">                .mul_add = .pl_node,</span>
<span class="line" id="L1796">                .builtin_call = .pl_node,</span>
<span class="line" id="L1797">                .field_parent_ptr = .pl_node,</span>
<span class="line" id="L1798">                .max = .pl_node,</span>
<span class="line" id="L1799">                .memcpy = .pl_node,</span>
<span class="line" id="L1800">                .memset = .pl_node,</span>
<span class="line" id="L1801">                .min = .pl_node,</span>
<span class="line" id="L1802">                .c_import = .pl_node,</span>
<span class="line" id="L1803"></span>
<span class="line" id="L1804">                .alloc = .un_node,</span>
<span class="line" id="L1805">                .alloc_mut = .un_node,</span>
<span class="line" id="L1806">                .alloc_comptime_mut = .un_node,</span>
<span class="line" id="L1807">                .alloc_inferred = .node,</span>
<span class="line" id="L1808">                .alloc_inferred_mut = .node,</span>
<span class="line" id="L1809">                .alloc_inferred_comptime = .node,</span>
<span class="line" id="L1810">                .alloc_inferred_comptime_mut = .node,</span>
<span class="line" id="L1811">                .resolve_inferred_alloc = .un_node,</span>
<span class="line" id="L1812">                .make_ptr_const = .un_node,</span>
<span class="line" id="L1813"></span>
<span class="line" id="L1814">                .@&quot;resume&quot; = .un_node,</span>
<span class="line" id="L1815">                .@&quot;await&quot; = .un_node,</span>
<span class="line" id="L1816"></span>
<span class="line" id="L1817">                .@&quot;defer&quot; = .@&quot;defer&quot;,</span>
<span class="line" id="L1818">                .defer_err_code = .defer_err_code,</span>
<span class="line" id="L1819"></span>
<span class="line" id="L1820">                .save_err_ret_index = .save_err_ret_index,</span>
<span class="line" id="L1821">                .restore_err_ret_index_unconditional = .un_node,</span>
<span class="line" id="L1822">                .restore_err_ret_index_fn_entry = .un_node,</span>
<span class="line" id="L1823"></span>
<span class="line" id="L1824">                .struct_init_empty = .un_node,</span>
<span class="line" id="L1825">                .struct_init_empty_result = .un_node,</span>
<span class="line" id="L1826">                .struct_init_empty_ref_result = .un_node,</span>
<span class="line" id="L1827">                .struct_init_anon = .pl_node,</span>
<span class="line" id="L1828">                .struct_init = .pl_node,</span>
<span class="line" id="L1829">                .struct_init_ref = .pl_node,</span>
<span class="line" id="L1830">                .validate_struct_init_ty = .un_node,</span>
<span class="line" id="L1831">                .validate_struct_init_result_ty = .un_node,</span>
<span class="line" id="L1832">                .validate_ptr_struct_init = .pl_node,</span>
<span class="line" id="L1833">                .struct_init_field_type = .pl_node,</span>
<span class="line" id="L1834">                .struct_init_field_ptr = .pl_node,</span>
<span class="line" id="L1835">                .array_init_anon = .pl_node,</span>
<span class="line" id="L1836">                .array_init = .pl_node,</span>
<span class="line" id="L1837">                .array_init_ref = .pl_node,</span>
<span class="line" id="L1838">                .validate_array_init_ty = .pl_node,</span>
<span class="line" id="L1839">                .validate_array_init_result_ty = .pl_node,</span>
<span class="line" id="L1840">                .validate_array_init_ref_ty = .pl_node,</span>
<span class="line" id="L1841">                .validate_ptr_array_init = .pl_node,</span>
<span class="line" id="L1842">                .array_init_elem_type = .bin,</span>
<span class="line" id="L1843">                .array_init_elem_ptr = .pl_node,</span>
<span class="line" id="L1844"></span>
<span class="line" id="L1845">                .extended = .extended,</span>
<span class="line" id="L1846">            });</span>
<span class="line" id="L1847">        };</span>
<span class="line" id="L1848"></span>
<span class="line" id="L1849">        <span class="tok-comment">// Uncomment to view how many tag slots are available.</span>
</span>
<span class="line" id="L1850">        <span class="tok-comment">//comptime {</span>
</span>
<span class="line" id="L1851">        <span class="tok-comment">//    @compileLog(&quot;ZIR tags left: &quot;, 256 - @typeInfo(Tag).Enum.fields.len);</span>
</span>
<span class="line" id="L1852">        <span class="tok-comment">//}</span>
</span>
<span class="line" id="L1853">    };</span>
<span class="line" id="L1854"></span>
<span class="line" id="L1855">    <span class="tok-comment">/// Rarer instructions are here; ones that do not fit in the 8-bit `Tag` enum.</span></span>
<span class="line" id="L1856">    <span class="tok-comment">/// `noreturn` instructions may not go here; they must be part of the main `Tag` enum.</span></span>
<span class="line" id="L1857">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Extended = <span class="tok-kw">enum</span>(<span class="tok-type">u16</span>) {</span>
<span class="line" id="L1858">        <span class="tok-comment">/// Declares a global variable.</span></span>
<span class="line" id="L1859">        <span class="tok-comment">/// `operand` is payload index to `ExtendedVar`.</span></span>
<span class="line" id="L1860">        <span class="tok-comment">/// `small` is `ExtendedVar.Small`.</span></span>
<span class="line" id="L1861">        variable,</span>
<span class="line" id="L1862">        <span class="tok-comment">/// A struct type definition. Contains references to ZIR instructions for</span></span>
<span class="line" id="L1863">        <span class="tok-comment">/// the field types, defaults, and alignments.</span></span>
<span class="line" id="L1864">        <span class="tok-comment">/// `operand` is payload index to `StructDecl`.</span></span>
<span class="line" id="L1865">        <span class="tok-comment">/// `small` is `StructDecl.Small`.</span></span>
<span class="line" id="L1866">        struct_decl,</span>
<span class="line" id="L1867">        <span class="tok-comment">/// An enum type definition. Contains references to ZIR instructions for</span></span>
<span class="line" id="L1868">        <span class="tok-comment">/// the field value expressions and optional type tag expression.</span></span>
<span class="line" id="L1869">        <span class="tok-comment">/// `operand` is payload index to `EnumDecl`.</span></span>
<span class="line" id="L1870">        <span class="tok-comment">/// `small` is `EnumDecl.Small`.</span></span>
<span class="line" id="L1871">        enum_decl,</span>
<span class="line" id="L1872">        <span class="tok-comment">/// A union type definition. Contains references to ZIR instructions for</span></span>
<span class="line" id="L1873">        <span class="tok-comment">/// the field types and optional type tag expression.</span></span>
<span class="line" id="L1874">        <span class="tok-comment">/// `operand` is payload index to `UnionDecl`.</span></span>
<span class="line" id="L1875">        <span class="tok-comment">/// `small` is `UnionDecl.Small`.</span></span>
<span class="line" id="L1876">        union_decl,</span>
<span class="line" id="L1877">        <span class="tok-comment">/// An opaque type definition. Contains references to decls and captures.</span></span>
<span class="line" id="L1878">        <span class="tok-comment">/// `operand` is payload index to `OpaqueDecl`.</span></span>
<span class="line" id="L1879">        <span class="tok-comment">/// `small` is `OpaqueDecl.Small`.</span></span>
<span class="line" id="L1880">        opaque_decl,</span>
<span class="line" id="L1881">        <span class="tok-comment">/// Implements the `@This` builtin.</span></span>
<span class="line" id="L1882">        <span class="tok-comment">/// `operand` is `src_node: i32`.</span></span>
<span class="line" id="L1883">        this,</span>
<span class="line" id="L1884">        <span class="tok-comment">/// Implements the `@returnAddress` builtin.</span></span>
<span class="line" id="L1885">        <span class="tok-comment">/// `operand` is `src_node: i32`.</span></span>
<span class="line" id="L1886">        ret_addr,</span>
<span class="line" id="L1887">        <span class="tok-comment">/// Implements the `@src` builtin.</span></span>
<span class="line" id="L1888">        <span class="tok-comment">/// `operand` is payload index to `LineColumn`.</span></span>
<span class="line" id="L1889">        builtin_src,</span>
<span class="line" id="L1890">        <span class="tok-comment">/// Implements the `@errorReturnTrace` builtin.</span></span>
<span class="line" id="L1891">        <span class="tok-comment">/// `operand` is `src_node: i32`.</span></span>
<span class="line" id="L1892">        error_return_trace,</span>
<span class="line" id="L1893">        <span class="tok-comment">/// Implements the `@frame` builtin.</span></span>
<span class="line" id="L1894">        <span class="tok-comment">/// `operand` is `src_node: i32`.</span></span>
<span class="line" id="L1895">        frame,</span>
<span class="line" id="L1896">        <span class="tok-comment">/// Implements the `@frameAddress` builtin.</span></span>
<span class="line" id="L1897">        <span class="tok-comment">/// `operand` is `src_node: i32`.</span></span>
<span class="line" id="L1898">        frame_address,</span>
<span class="line" id="L1899">        <span class="tok-comment">/// Same as `alloc` from `Tag` but may contain an alignment instruction.</span></span>
<span class="line" id="L1900">        <span class="tok-comment">/// `operand` is payload index to `AllocExtended`.</span></span>
<span class="line" id="L1901">        <span class="tok-comment">/// `small`:</span></span>
<span class="line" id="L1902">        <span class="tok-comment">///  * 0b000X - has type</span></span>
<span class="line" id="L1903">        <span class="tok-comment">///  * 0b00X0 - has alignment</span></span>
<span class="line" id="L1904">        <span class="tok-comment">///  * 0b0X00 - 1=const, 0=var</span></span>
<span class="line" id="L1905">        <span class="tok-comment">///  * 0bX000 - is comptime</span></span>
<span class="line" id="L1906">        alloc,</span>
<span class="line" id="L1907">        <span class="tok-comment">/// The `@extern` builtin.</span></span>
<span class="line" id="L1908">        <span class="tok-comment">/// `operand` is payload index to `BinNode`.</span></span>
<span class="line" id="L1909">        builtin_extern,</span>
<span class="line" id="L1910">        <span class="tok-comment">/// Inline assembly.</span></span>
<span class="line" id="L1911">        <span class="tok-comment">/// `small`:</span></span>
<span class="line" id="L1912">        <span class="tok-comment">///  * 0b00000000_000XXXXX - `outputs_len`.</span></span>
<span class="line" id="L1913">        <span class="tok-comment">///  * 0b000000XX_XXX00000 - `inputs_len`.</span></span>
<span class="line" id="L1914">        <span class="tok-comment">///  * 0b0XXXXX00_00000000 - `clobbers_len`.</span></span>
<span class="line" id="L1915">        <span class="tok-comment">///  * 0bX0000000_00000000 - is volatile</span></span>
<span class="line" id="L1916">        <span class="tok-comment">/// `operand` is payload index to `Asm`.</span></span>
<span class="line" id="L1917">        @&quot;asm&quot;,</span>
<span class="line" id="L1918">        <span class="tok-comment">/// Same as `asm` except the assembly template is not a string literal but a comptime</span></span>
<span class="line" id="L1919">        <span class="tok-comment">/// expression.</span></span>
<span class="line" id="L1920">        <span class="tok-comment">/// The `asm_source` field of the Asm is not a null-terminated string</span></span>
<span class="line" id="L1921">        <span class="tok-comment">/// but instead a Ref.</span></span>
<span class="line" id="L1922">        asm_expr,</span>
<span class="line" id="L1923">        <span class="tok-comment">/// Log compile time variables and emit an error message.</span></span>
<span class="line" id="L1924">        <span class="tok-comment">/// `operand` is payload index to `NodeMultiOp`.</span></span>
<span class="line" id="L1925">        <span class="tok-comment">/// `small` is `operands_len`.</span></span>
<span class="line" id="L1926">        <span class="tok-comment">/// The AST node is the compile log builtin call.</span></span>
<span class="line" id="L1927">        compile_log,</span>
<span class="line" id="L1928">        <span class="tok-comment">/// The builtin `@TypeOf` which returns the type after Peer Type Resolution</span></span>
<span class="line" id="L1929">        <span class="tok-comment">/// of one or more params.</span></span>
<span class="line" id="L1930">        <span class="tok-comment">/// `operand` is payload index to `TypeOfPeer`.</span></span>
<span class="line" id="L1931">        <span class="tok-comment">/// `small` is `operands_len`.</span></span>
<span class="line" id="L1932">        <span class="tok-comment">/// The AST node is the builtin call.</span></span>
<span class="line" id="L1933">        typeof_peer,</span>
<span class="line" id="L1934">        <span class="tok-comment">/// Implements the `@min` builtin for more than 2 args.</span></span>
<span class="line" id="L1935">        <span class="tok-comment">/// `operand` is payload index to `NodeMultiOp`.</span></span>
<span class="line" id="L1936">        <span class="tok-comment">/// `small` is `operands_len`.</span></span>
<span class="line" id="L1937">        <span class="tok-comment">/// The AST node is the builtin call.</span></span>
<span class="line" id="L1938">        min_multi,</span>
<span class="line" id="L1939">        <span class="tok-comment">/// Implements the `@max` builtin for more than 2 args.</span></span>
<span class="line" id="L1940">        <span class="tok-comment">/// `operand` is payload index to `NodeMultiOp`.</span></span>
<span class="line" id="L1941">        <span class="tok-comment">/// `small` is `operands_len`.</span></span>
<span class="line" id="L1942">        <span class="tok-comment">/// The AST node is the builtin call.</span></span>
<span class="line" id="L1943">        max_multi,</span>
<span class="line" id="L1944">        <span class="tok-comment">/// Implements the `@addWithOverflow` builtin.</span></span>
<span class="line" id="L1945">        <span class="tok-comment">/// `operand` is payload index to `BinNode`.</span></span>
<span class="line" id="L1946">        <span class="tok-comment">/// `small` is unused.</span></span>
<span class="line" id="L1947">        add_with_overflow,</span>
<span class="line" id="L1948">        <span class="tok-comment">/// Implements the `@subWithOverflow` builtin.</span></span>
<span class="line" id="L1949">        <span class="tok-comment">/// `operand` is payload index to `BinNode`.</span></span>
<span class="line" id="L1950">        <span class="tok-comment">/// `small` is unused.</span></span>
<span class="line" id="L1951">        sub_with_overflow,</span>
<span class="line" id="L1952">        <span class="tok-comment">/// Implements the `@mulWithOverflow` builtin.</span></span>
<span class="line" id="L1953">        <span class="tok-comment">/// `operand` is payload index to `BinNode`.</span></span>
<span class="line" id="L1954">        <span class="tok-comment">/// `small` is unused.</span></span>
<span class="line" id="L1955">        mul_with_overflow,</span>
<span class="line" id="L1956">        <span class="tok-comment">/// Implements the `@shlWithOverflow` builtin.</span></span>
<span class="line" id="L1957">        <span class="tok-comment">/// `operand` is payload index to `BinNode`.</span></span>
<span class="line" id="L1958">        <span class="tok-comment">/// `small` is unused.</span></span>
<span class="line" id="L1959">        shl_with_overflow,</span>
<span class="line" id="L1960">        <span class="tok-comment">/// `operand` is payload index to `UnNode`.</span></span>
<span class="line" id="L1961">        c_undef,</span>
<span class="line" id="L1962">        <span class="tok-comment">/// `operand` is payload index to `UnNode`.</span></span>
<span class="line" id="L1963">        c_include,</span>
<span class="line" id="L1964">        <span class="tok-comment">/// `operand` is payload index to `BinNode`.</span></span>
<span class="line" id="L1965">        c_define,</span>
<span class="line" id="L1966">        <span class="tok-comment">/// `operand` is payload index to `UnNode`.</span></span>
<span class="line" id="L1967">        wasm_memory_size,</span>
<span class="line" id="L1968">        <span class="tok-comment">/// `operand` is payload index to `BinNode`.</span></span>
<span class="line" id="L1969">        wasm_memory_grow,</span>
<span class="line" id="L1970">        <span class="tok-comment">/// The `@prefetch` builtin.</span></span>
<span class="line" id="L1971">        <span class="tok-comment">/// `operand` is payload index to `BinNode`.</span></span>
<span class="line" id="L1972">        prefetch,</span>
<span class="line" id="L1973">        <span class="tok-comment">/// Implements the `@fence` builtin.</span></span>
<span class="line" id="L1974">        <span class="tok-comment">/// `operand` is payload index to `UnNode`.</span></span>
<span class="line" id="L1975">        fence,</span>
<span class="line" id="L1976">        <span class="tok-comment">/// Implement builtin `@setFloatMode`.</span></span>
<span class="line" id="L1977">        <span class="tok-comment">/// `operand` is payload index to `UnNode`.</span></span>
<span class="line" id="L1978">        set_float_mode,</span>
<span class="line" id="L1979">        <span class="tok-comment">/// Implement builtin `@setAlignStack`.</span></span>
<span class="line" id="L1980">        <span class="tok-comment">/// `operand` is payload index to `UnNode`.</span></span>
<span class="line" id="L1981">        set_align_stack,</span>
<span class="line" id="L1982">        <span class="tok-comment">/// Implements `@setCold`.</span></span>
<span class="line" id="L1983">        <span class="tok-comment">/// `operand` is payload index to `UnNode`.</span></span>
<span class="line" id="L1984">        set_cold,</span>
<span class="line" id="L1985">        <span class="tok-comment">/// Implements the `@errorCast` builtin.</span></span>
<span class="line" id="L1986">        <span class="tok-comment">/// `operand` is payload index to `BinNode`. `lhs` is dest type, `rhs` is operand.</span></span>
<span class="line" id="L1987">        error_cast,</span>
<span class="line" id="L1988">        <span class="tok-comment">/// `operand` is payload index to `UnNode`.</span></span>
<span class="line" id="L1989">        await_nosuspend,</span>
<span class="line" id="L1990">        <span class="tok-comment">/// Implements `@breakpoint`.</span></span>
<span class="line" id="L1991">        <span class="tok-comment">/// `operand` is `src_node: i32`.</span></span>
<span class="line" id="L1992">        breakpoint,</span>
<span class="line" id="L1993">        <span class="tok-comment">/// Implements the `@select` builtin.</span></span>
<span class="line" id="L1994">        <span class="tok-comment">/// `operand` is payload index to `Select`.</span></span>
<span class="line" id="L1995">        select,</span>
<span class="line" id="L1996">        <span class="tok-comment">/// Implement builtin `@errToInt`.</span></span>
<span class="line" id="L1997">        <span class="tok-comment">/// `operand` is payload index to `UnNode`.</span></span>
<span class="line" id="L1998">        int_from_error,</span>
<span class="line" id="L1999">        <span class="tok-comment">/// Implement builtin `@errorFromInt`.</span></span>
<span class="line" id="L2000">        <span class="tok-comment">/// `operand` is payload index to `UnNode`.</span></span>
<span class="line" id="L2001">        error_from_int,</span>
<span class="line" id="L2002">        <span class="tok-comment">/// Implement builtin `@Type`.</span></span>
<span class="line" id="L2003">        <span class="tok-comment">/// `operand` is payload index to `UnNode`.</span></span>
<span class="line" id="L2004">        <span class="tok-comment">/// `small` contains `NameStrategy`.</span></span>
<span class="line" id="L2005">        reify,</span>
<span class="line" id="L2006">        <span class="tok-comment">/// Implements the `@asyncCall` builtin.</span></span>
<span class="line" id="L2007">        <span class="tok-comment">/// `operand` is payload index to `AsyncCall`.</span></span>
<span class="line" id="L2008">        builtin_async_call,</span>
<span class="line" id="L2009">        <span class="tok-comment">/// Implements the `@cmpxchgStrong` and `@cmpxchgWeak` builtins.</span></span>
<span class="line" id="L2010">        <span class="tok-comment">/// `small` 0=&gt;weak 1=&gt;strong</span></span>
<span class="line" id="L2011">        <span class="tok-comment">/// `operand` is payload index to `Cmpxchg`.</span></span>
<span class="line" id="L2012">        cmpxchg,</span>
<span class="line" id="L2013">        <span class="tok-comment">/// Implement builtin `@cVaArg`.</span></span>
<span class="line" id="L2014">        <span class="tok-comment">/// `operand` is payload index to `BinNode`.</span></span>
<span class="line" id="L2015">        c_va_arg,</span>
<span class="line" id="L2016">        <span class="tok-comment">/// Implement builtin `@cVaCopy`.</span></span>
<span class="line" id="L2017">        <span class="tok-comment">/// `operand` is payload index to `UnNode`.</span></span>
<span class="line" id="L2018">        c_va_copy,</span>
<span class="line" id="L2019">        <span class="tok-comment">/// Implement builtin `@cVaEnd`.</span></span>
<span class="line" id="L2020">        <span class="tok-comment">/// `operand` is payload index to `UnNode`.</span></span>
<span class="line" id="L2021">        c_va_end,</span>
<span class="line" id="L2022">        <span class="tok-comment">/// Implement builtin `@cVaStart`.</span></span>
<span class="line" id="L2023">        <span class="tok-comment">/// `operand` is `src_node: i32`.</span></span>
<span class="line" id="L2024">        c_va_start,</span>
<span class="line" id="L2025">        <span class="tok-comment">/// Implements the following builtins:</span></span>
<span class="line" id="L2026">        <span class="tok-comment">/// `@ptrCast`, `@alignCast`, `@addrSpaceCast`, `@constCast`, `@volatileCast`.</span></span>
<span class="line" id="L2027">        <span class="tok-comment">/// Represents an arbitrary nesting of the above builtins. Such a nesting is treated as a</span></span>
<span class="line" id="L2028">        <span class="tok-comment">/// single operation which can modify multiple components of a pointer type.</span></span>
<span class="line" id="L2029">        <span class="tok-comment">/// `operand` is payload index to `BinNode`.</span></span>
<span class="line" id="L2030">        <span class="tok-comment">/// `small` contains `FullPtrCastFlags`.</span></span>
<span class="line" id="L2031">        <span class="tok-comment">/// AST node is the root of the nested casts.</span></span>
<span class="line" id="L2032">        <span class="tok-comment">/// `lhs` is dest type, `rhs` is operand.</span></span>
<span class="line" id="L2033">        ptr_cast_full,</span>
<span class="line" id="L2034">        <span class="tok-comment">/// `operand` is payload index to `UnNode`.</span></span>
<span class="line" id="L2035">        <span class="tok-comment">/// `small` contains `FullPtrCastFlags`.</span></span>
<span class="line" id="L2036">        <span class="tok-comment">/// Guaranteed to only have flags where no explicit destination type is</span></span>
<span class="line" id="L2037">        <span class="tok-comment">/// required (const_cast and volatile_cast).</span></span>
<span class="line" id="L2038">        <span class="tok-comment">/// AST node is the root of the nested casts.</span></span>
<span class="line" id="L2039">        ptr_cast_no_dest,</span>
<span class="line" id="L2040">        <span class="tok-comment">/// Implements the `@workItemId` builtin.</span></span>
<span class="line" id="L2041">        <span class="tok-comment">/// `operand` is payload index to `UnNode`.</span></span>
<span class="line" id="L2042">        work_item_id,</span>
<span class="line" id="L2043">        <span class="tok-comment">/// Implements the `@workGroupSize` builtin.</span></span>
<span class="line" id="L2044">        <span class="tok-comment">/// `operand` is payload index to `UnNode`.</span></span>
<span class="line" id="L2045">        work_group_size,</span>
<span class="line" id="L2046">        <span class="tok-comment">/// Implements the `@workGroupId` builtin.</span></span>
<span class="line" id="L2047">        <span class="tok-comment">/// `operand` is payload index to `UnNode`.</span></span>
<span class="line" id="L2048">        work_group_id,</span>
<span class="line" id="L2049">        <span class="tok-comment">/// Implements the `@inComptime` builtin.</span></span>
<span class="line" id="L2050">        <span class="tok-comment">/// `operand` is `src_node: i32`.</span></span>
<span class="line" id="L2051">        in_comptime,</span>
<span class="line" id="L2052">        <span class="tok-comment">/// Restores the error return index to its last saved state in a given</span></span>
<span class="line" id="L2053">        <span class="tok-comment">/// block. If the block is `.none`, restores to the state from the point</span></span>
<span class="line" id="L2054">        <span class="tok-comment">/// of function entry. If the operand is not `.none`, the restore is</span></span>
<span class="line" id="L2055">        <span class="tok-comment">/// conditional on the operand value not being an error.</span></span>
<span class="line" id="L2056">        <span class="tok-comment">/// `operand` is payload index to `RestoreErrRetIndex`.</span></span>
<span class="line" id="L2057">        <span class="tok-comment">/// `small` is undefined.</span></span>
<span class="line" id="L2058">        restore_err_ret_index,</span>
<span class="line" id="L2059">        <span class="tok-comment">/// Retrieves a value from the current type declaration scope's closure.</span></span>
<span class="line" id="L2060">        <span class="tok-comment">/// `operand` is `src_node: i32`.</span></span>
<span class="line" id="L2061">        <span class="tok-comment">/// `small` is closure index.</span></span>
<span class="line" id="L2062">        closure_get,</span>
<span class="line" id="L2063">        <span class="tok-comment">/// Used as a placeholder instruction which is just a dummy index for Sema to replace</span></span>
<span class="line" id="L2064">        <span class="tok-comment">/// with a specific value. For instance, this is used for the capture of an `errdefer`.</span></span>
<span class="line" id="L2065">        <span class="tok-comment">/// This should never appear in a body.</span></span>
<span class="line" id="L2066">        value_placeholder,</span>
<span class="line" id="L2067"></span>
<span class="line" id="L2068">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> InstData = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2069">            opcode: Extended,</span>
<span class="line" id="L2070">            small: <span class="tok-type">u16</span>,</span>
<span class="line" id="L2071">            operand: <span class="tok-type">u32</span>,</span>
<span class="line" id="L2072">        };</span>
<span class="line" id="L2073">    };</span>
<span class="line" id="L2074"></span>
<span class="line" id="L2075">    <span class="tok-comment">/// The position of a ZIR instruction within the `Zir` instructions array.</span></span>
<span class="line" id="L2076">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Index = <span class="tok-kw">enum</span>(<span class="tok-type">u32</span>) {</span>
<span class="line" id="L2077">        <span class="tok-comment">/// ZIR is structured so that the outermost &quot;main&quot; struct of any file</span></span>
<span class="line" id="L2078">        <span class="tok-comment">/// is always at index 0.</span></span>
<span class="line" id="L2079">        main_struct_inst = <span class="tok-number">0</span>,</span>
<span class="line" id="L2080">        ref_start_index = static_len,</span>
<span class="line" id="L2081">        _,</span>
<span class="line" id="L2082"></span>
<span class="line" id="L2083">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> static_len = <span class="tok-number">84</span>;</span>
<span class="line" id="L2084"></span>
<span class="line" id="L2085">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toRef</span>(i: Index) Inst.Ref {</span>
<span class="line" id="L2086">            <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@intFromEnum</span>(Index.ref_start_index) + <span class="tok-builtin">@intFromEnum</span>(i));</span>
<span class="line" id="L2087">        }</span>
<span class="line" id="L2088"></span>
<span class="line" id="L2089">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toOptional</span>(i: Index) OptionalIndex {</span>
<span class="line" id="L2090">            <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@intFromEnum</span>(i));</span>
<span class="line" id="L2091">        }</span>
<span class="line" id="L2092">    };</span>
<span class="line" id="L2093"></span>
<span class="line" id="L2094">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> OptionalIndex = <span class="tok-kw">enum</span>(<span class="tok-type">u32</span>) {</span>
<span class="line" id="L2095">        <span class="tok-comment">/// ZIR is structured so that the outermost &quot;main&quot; struct of any file</span></span>
<span class="line" id="L2096">        <span class="tok-comment">/// is always at index 0.</span></span>
<span class="line" id="L2097">        main_struct_inst = <span class="tok-number">0</span>,</span>
<span class="line" id="L2098">        ref_start_index = Index.static_len,</span>
<span class="line" id="L2099">        none = std.math.maxInt(<span class="tok-type">u32</span>),</span>
<span class="line" id="L2100">        _,</span>
<span class="line" id="L2101"></span>
<span class="line" id="L2102">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unwrap</span>(oi: OptionalIndex) ?Index {</span>
<span class="line" id="L2103">            <span class="tok-kw">return</span> <span class="tok-kw">if</span> (oi == .none) <span class="tok-null">null</span> <span class="tok-kw">else</span> <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@intFromEnum</span>(oi));</span>
<span class="line" id="L2104">        }</span>
<span class="line" id="L2105">    };</span>
<span class="line" id="L2106"></span>
<span class="line" id="L2107">    <span class="tok-comment">/// A reference to ZIR instruction, or to an InternPool index, or neither.</span></span>
<span class="line" id="L2108">    <span class="tok-comment">///</span></span>
<span class="line" id="L2109">    <span class="tok-comment">/// If the integer tag value is &lt; InternPool.static_len, then it</span></span>
<span class="line" id="L2110">    <span class="tok-comment">/// corresponds to an InternPool index. Otherwise, this refers to a ZIR</span></span>
<span class="line" id="L2111">    <span class="tok-comment">/// instruction.</span></span>
<span class="line" id="L2112">    <span class="tok-comment">///</span></span>
<span class="line" id="L2113">    <span class="tok-comment">/// The tag type is specified so that it is safe to bitcast between `[]u32`</span></span>
<span class="line" id="L2114">    <span class="tok-comment">/// and `[]Ref`.</span></span>
<span class="line" id="L2115">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Ref = <span class="tok-kw">enum</span>(<span class="tok-type">u32</span>) {</span>
<span class="line" id="L2116">        u0_type,</span>
<span class="line" id="L2117">        i0_type,</span>
<span class="line" id="L2118">        u1_type,</span>
<span class="line" id="L2119">        u8_type,</span>
<span class="line" id="L2120">        i8_type,</span>
<span class="line" id="L2121">        u16_type,</span>
<span class="line" id="L2122">        i16_type,</span>
<span class="line" id="L2123">        u29_type,</span>
<span class="line" id="L2124">        u32_type,</span>
<span class="line" id="L2125">        i32_type,</span>
<span class="line" id="L2126">        u64_type,</span>
<span class="line" id="L2127">        i64_type,</span>
<span class="line" id="L2128">        u80_type,</span>
<span class="line" id="L2129">        u128_type,</span>
<span class="line" id="L2130">        i128_type,</span>
<span class="line" id="L2131">        usize_type,</span>
<span class="line" id="L2132">        isize_type,</span>
<span class="line" id="L2133">        c_char_type,</span>
<span class="line" id="L2134">        c_short_type,</span>
<span class="line" id="L2135">        c_ushort_type,</span>
<span class="line" id="L2136">        c_int_type,</span>
<span class="line" id="L2137">        c_uint_type,</span>
<span class="line" id="L2138">        c_long_type,</span>
<span class="line" id="L2139">        c_ulong_type,</span>
<span class="line" id="L2140">        c_longlong_type,</span>
<span class="line" id="L2141">        c_ulonglong_type,</span>
<span class="line" id="L2142">        c_longdouble_type,</span>
<span class="line" id="L2143">        f16_type,</span>
<span class="line" id="L2144">        f32_type,</span>
<span class="line" id="L2145">        f64_type,</span>
<span class="line" id="L2146">        f80_type,</span>
<span class="line" id="L2147">        f128_type,</span>
<span class="line" id="L2148">        anyopaque_type,</span>
<span class="line" id="L2149">        bool_type,</span>
<span class="line" id="L2150">        void_type,</span>
<span class="line" id="L2151">        type_type,</span>
<span class="line" id="L2152">        anyerror_type,</span>
<span class="line" id="L2153">        comptime_int_type,</span>
<span class="line" id="L2154">        comptime_float_type,</span>
<span class="line" id="L2155">        noreturn_type,</span>
<span class="line" id="L2156">        anyframe_type,</span>
<span class="line" id="L2157">        null_type,</span>
<span class="line" id="L2158">        undefined_type,</span>
<span class="line" id="L2159">        enum_literal_type,</span>
<span class="line" id="L2160">        atomic_order_type,</span>
<span class="line" id="L2161">        atomic_rmw_op_type,</span>
<span class="line" id="L2162">        calling_convention_type,</span>
<span class="line" id="L2163">        address_space_type,</span>
<span class="line" id="L2164">        float_mode_type,</span>
<span class="line" id="L2165">        reduce_op_type,</span>
<span class="line" id="L2166">        call_modifier_type,</span>
<span class="line" id="L2167">        prefetch_options_type,</span>
<span class="line" id="L2168">        export_options_type,</span>
<span class="line" id="L2169">        extern_options_type,</span>
<span class="line" id="L2170">        type_info_type,</span>
<span class="line" id="L2171">        manyptr_u8_type,</span>
<span class="line" id="L2172">        manyptr_const_u8_type,</span>
<span class="line" id="L2173">        manyptr_const_u8_sentinel_0_type,</span>
<span class="line" id="L2174">        single_const_pointer_to_comptime_int_type,</span>
<span class="line" id="L2175">        slice_const_u8_type,</span>
<span class="line" id="L2176">        slice_const_u8_sentinel_0_type,</span>
<span class="line" id="L2177">        optional_noreturn_type,</span>
<span class="line" id="L2178">        anyerror_void_error_union_type,</span>
<span class="line" id="L2179">        adhoc_inferred_error_set_type,</span>
<span class="line" id="L2180">        generic_poison_type,</span>
<span class="line" id="L2181">        empty_struct_type,</span>
<span class="line" id="L2182">        undef,</span>
<span class="line" id="L2183">        zero,</span>
<span class="line" id="L2184">        zero_usize,</span>
<span class="line" id="L2185">        zero_u8,</span>
<span class="line" id="L2186">        one,</span>
<span class="line" id="L2187">        one_usize,</span>
<span class="line" id="L2188">        one_u8,</span>
<span class="line" id="L2189">        four_u8,</span>
<span class="line" id="L2190">        negative_one,</span>
<span class="line" id="L2191">        calling_convention_c,</span>
<span class="line" id="L2192">        calling_convention_inline,</span>
<span class="line" id="L2193">        void_value,</span>
<span class="line" id="L2194">        unreachable_value,</span>
<span class="line" id="L2195">        null_value,</span>
<span class="line" id="L2196">        bool_true,</span>
<span class="line" id="L2197">        bool_false,</span>
<span class="line" id="L2198">        empty_struct,</span>
<span class="line" id="L2199">        generic_poison,</span>
<span class="line" id="L2200"></span>
<span class="line" id="L2201">        <span class="tok-comment">/// This tag is here to match Air and InternPool, however it is unused</span></span>
<span class="line" id="L2202">        <span class="tok-comment">/// for ZIR purposes.</span></span>
<span class="line" id="L2203">        var_args_param_type = std.math.maxInt(<span class="tok-type">u32</span>) - <span class="tok-number">1</span>,</span>
<span class="line" id="L2204">        <span class="tok-comment">/// This Ref does not correspond to any ZIR instruction or constant</span></span>
<span class="line" id="L2205">        <span class="tok-comment">/// value and may instead be used as a sentinel to indicate null.</span></span>
<span class="line" id="L2206">        none = std.math.maxInt(<span class="tok-type">u32</span>),</span>
<span class="line" id="L2207"></span>
<span class="line" id="L2208">        _,</span>
<span class="line" id="L2209"></span>
<span class="line" id="L2210">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toIndex</span>(inst: Ref) ?Index {</span>
<span class="line" id="L2211">            assert(inst != .none);</span>
<span class="line" id="L2212">            <span class="tok-kw">const</span> ref_int = <span class="tok-builtin">@intFromEnum</span>(inst);</span>
<span class="line" id="L2213">            <span class="tok-kw">if</span> (ref_int &gt;= <span class="tok-builtin">@intFromEnum</span>(Index.ref_start_index)) {</span>
<span class="line" id="L2214">                <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(ref_int - <span class="tok-builtin">@intFromEnum</span>(Index.ref_start_index));</span>
<span class="line" id="L2215">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2216">                <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L2217">            }</span>
<span class="line" id="L2218">        }</span>
<span class="line" id="L2219"></span>
<span class="line" id="L2220">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toIndexAllowNone</span>(inst: Ref) ?Index {</span>
<span class="line" id="L2221">            <span class="tok-kw">if</span> (inst == .none) <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L2222">            <span class="tok-kw">return</span> toIndex(inst);</span>
<span class="line" id="L2223">        }</span>
<span class="line" id="L2224">    };</span>
<span class="line" id="L2225"></span>
<span class="line" id="L2226">    <span class="tok-comment">/// All instructions have an 8-byte payload, which is contained within</span></span>
<span class="line" id="L2227">    <span class="tok-comment">/// this union. `Tag` determines which union field is active, as well as</span></span>
<span class="line" id="L2228">    <span class="tok-comment">/// how to interpret the data within.</span></span>
<span class="line" id="L2229">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Data = <span class="tok-kw">union</span> {</span>
<span class="line" id="L2230">        <span class="tok-comment">/// Used for `Tag.extended`. The extended opcode determines the meaning</span></span>
<span class="line" id="L2231">        <span class="tok-comment">/// of the `small` and `operand` fields.</span></span>
<span class="line" id="L2232">        extended: Extended.InstData,</span>
<span class="line" id="L2233">        <span class="tok-comment">/// Used for unary operators, with an AST node source location.</span></span>
<span class="line" id="L2234">        un_node: <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2235">            <span class="tok-comment">/// Offset from Decl AST node index.</span></span>
<span class="line" id="L2236">            src_node: <span class="tok-type">i32</span>,</span>
<span class="line" id="L2237">            <span class="tok-comment">/// The meaning of this operand depends on the corresponding `Tag`.</span></span>
<span class="line" id="L2238">            operand: Ref,</span>
<span class="line" id="L2239"></span>
<span class="line" id="L2240">            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">src</span>(self: <span class="tok-builtin">@This</span>()) LazySrcLoc {</span>
<span class="line" id="L2241">                <span class="tok-kw">return</span> LazySrcLoc.nodeOffset(self.src_node);</span>
<span class="line" id="L2242">            }</span>
<span class="line" id="L2243">        },</span>
<span class="line" id="L2244">        <span class="tok-comment">/// Used for unary operators, with a token source location.</span></span>
<span class="line" id="L2245">        un_tok: <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2246">            <span class="tok-comment">/// Offset from Decl AST token index.</span></span>
<span class="line" id="L2247">            src_tok: Ast.TokenIndex,</span>
<span class="line" id="L2248">            <span class="tok-comment">/// The meaning of this operand depends on the corresponding `Tag`.</span></span>
<span class="line" id="L2249">            operand: Ref,</span>
<span class="line" id="L2250"></span>
<span class="line" id="L2251">            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">src</span>(self: <span class="tok-builtin">@This</span>()) LazySrcLoc {</span>
<span class="line" id="L2252">                <span class="tok-kw">return</span> .{ .token_offset = self.src_tok };</span>
<span class="line" id="L2253">            }</span>
<span class="line" id="L2254">        },</span>
<span class="line" id="L2255">        pl_node: <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2256">            <span class="tok-comment">/// Offset from Decl AST node index.</span></span>
<span class="line" id="L2257">            <span class="tok-comment">/// `Tag` determines which kind of AST node this points to.</span></span>
<span class="line" id="L2258">            src_node: <span class="tok-type">i32</span>,</span>
<span class="line" id="L2259">            <span class="tok-comment">/// index into extra.</span></span>
<span class="line" id="L2260">            <span class="tok-comment">/// `Tag` determines what lives there.</span></span>
<span class="line" id="L2261">            payload_index: <span class="tok-type">u32</span>,</span>
<span class="line" id="L2262"></span>
<span class="line" id="L2263">            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">src</span>(self: <span class="tok-builtin">@This</span>()) LazySrcLoc {</span>
<span class="line" id="L2264">                <span class="tok-kw">return</span> LazySrcLoc.nodeOffset(self.src_node);</span>
<span class="line" id="L2265">            }</span>
<span class="line" id="L2266">        },</span>
<span class="line" id="L2267">        pl_tok: <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2268">            <span class="tok-comment">/// Offset from Decl AST token index.</span></span>
<span class="line" id="L2269">            src_tok: Ast.TokenIndex,</span>
<span class="line" id="L2270">            <span class="tok-comment">/// index into extra.</span></span>
<span class="line" id="L2271">            <span class="tok-comment">/// `Tag` determines what lives there.</span></span>
<span class="line" id="L2272">            payload_index: <span class="tok-type">u32</span>,</span>
<span class="line" id="L2273"></span>
<span class="line" id="L2274">            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">src</span>(self: <span class="tok-builtin">@This</span>()) LazySrcLoc {</span>
<span class="line" id="L2275">                <span class="tok-kw">return</span> .{ .token_offset = self.src_tok };</span>
<span class="line" id="L2276">            }</span>
<span class="line" id="L2277">        },</span>
<span class="line" id="L2278">        bin: Bin,</span>
<span class="line" id="L2279">        <span class="tok-comment">/// For strings which may contain null bytes.</span></span>
<span class="line" id="L2280">        str: <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2281">            <span class="tok-comment">/// Offset into `string_bytes`.</span></span>
<span class="line" id="L2282">            start: NullTerminatedString,</span>
<span class="line" id="L2283">            <span class="tok-comment">/// Number of bytes in the string.</span></span>
<span class="line" id="L2284">            len: <span class="tok-type">u32</span>,</span>
<span class="line" id="L2285"></span>
<span class="line" id="L2286">            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <span class="tok-builtin">@This</span>(), code: Zir) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L2287">                <span class="tok-kw">return</span> code.string_bytes[<span class="tok-builtin">@intFromEnum</span>(self.start)..][<span class="tok-number">0</span>..self.len];</span>
<span class="line" id="L2288">            }</span>
<span class="line" id="L2289">        },</span>
<span class="line" id="L2290">        str_tok: <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2291">            <span class="tok-comment">/// Offset into `string_bytes`. Null-terminated.</span></span>
<span class="line" id="L2292">            start: NullTerminatedString,</span>
<span class="line" id="L2293">            <span class="tok-comment">/// Offset from Decl AST token index.</span></span>
<span class="line" id="L2294">            src_tok: <span class="tok-type">u32</span>,</span>
<span class="line" id="L2295"></span>
<span class="line" id="L2296">            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <span class="tok-builtin">@This</span>(), code: Zir) [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L2297">                <span class="tok-kw">return</span> code.nullTerminatedString(self.start);</span>
<span class="line" id="L2298">            }</span>
<span class="line" id="L2299"></span>
<span class="line" id="L2300">            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">src</span>(self: <span class="tok-builtin">@This</span>()) LazySrcLoc {</span>
<span class="line" id="L2301">                <span class="tok-kw">return</span> .{ .token_offset = self.src_tok };</span>
<span class="line" id="L2302">            }</span>
<span class="line" id="L2303">        },</span>
<span class="line" id="L2304">        <span class="tok-comment">/// Offset from Decl AST token index.</span></span>
<span class="line" id="L2305">        tok: Ast.TokenIndex,</span>
<span class="line" id="L2306">        <span class="tok-comment">/// Offset from Decl AST node index.</span></span>
<span class="line" id="L2307">        node: <span class="tok-type">i32</span>,</span>
<span class="line" id="L2308">        int: <span class="tok-type">u64</span>,</span>
<span class="line" id="L2309">        float: <span class="tok-type">f64</span>,</span>
<span class="line" id="L2310">        ptr_type: <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2311">            flags: <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2312">                is_allowzero: <span class="tok-type">bool</span>,</span>
<span class="line" id="L2313">                is_mutable: <span class="tok-type">bool</span>,</span>
<span class="line" id="L2314">                is_volatile: <span class="tok-type">bool</span>,</span>
<span class="line" id="L2315">                has_sentinel: <span class="tok-type">bool</span>,</span>
<span class="line" id="L2316">                has_align: <span class="tok-type">bool</span>,</span>
<span class="line" id="L2317">                has_addrspace: <span class="tok-type">bool</span>,</span>
<span class="line" id="L2318">                has_bit_range: <span class="tok-type">bool</span>,</span>
<span class="line" id="L2319">                _: <span class="tok-type">u1</span> = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L2320">            },</span>
<span class="line" id="L2321">            size: std.builtin.Type.Pointer.Size,</span>
<span class="line" id="L2322">            <span class="tok-comment">/// Index into extra. See `PtrType`.</span></span>
<span class="line" id="L2323">            payload_index: <span class="tok-type">u32</span>,</span>
<span class="line" id="L2324">        },</span>
<span class="line" id="L2325">        int_type: <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2326">            <span class="tok-comment">/// Offset from Decl AST node index.</span></span>
<span class="line" id="L2327">            <span class="tok-comment">/// `Tag` determines which kind of AST node this points to.</span></span>
<span class="line" id="L2328">            src_node: <span class="tok-type">i32</span>,</span>
<span class="line" id="L2329">            signedness: std.builtin.Signedness,</span>
<span class="line" id="L2330">            bit_count: <span class="tok-type">u16</span>,</span>
<span class="line" id="L2331"></span>
<span class="line" id="L2332">            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">src</span>(self: <span class="tok-builtin">@This</span>()) LazySrcLoc {</span>
<span class="line" id="L2333">                <span class="tok-kw">return</span> LazySrcLoc.nodeOffset(self.src_node);</span>
<span class="line" id="L2334">            }</span>
<span class="line" id="L2335">        },</span>
<span class="line" id="L2336">        @&quot;unreachable&quot;: <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2337">            <span class="tok-comment">/// Offset from Decl AST node index.</span></span>
<span class="line" id="L2338">            <span class="tok-comment">/// `Tag` determines which kind of AST node this points to.</span></span>
<span class="line" id="L2339">            src_node: <span class="tok-type">i32</span>,</span>
<span class="line" id="L2340"></span>
<span class="line" id="L2341">            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">src</span>(self: <span class="tok-builtin">@This</span>()) LazySrcLoc {</span>
<span class="line" id="L2342">                <span class="tok-kw">return</span> LazySrcLoc.nodeOffset(self.src_node);</span>
<span class="line" id="L2343">            }</span>
<span class="line" id="L2344">        },</span>
<span class="line" id="L2345">        @&quot;break&quot;: <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2346">            operand: Ref,</span>
<span class="line" id="L2347">            payload_index: <span class="tok-type">u32</span>,</span>
<span class="line" id="L2348">        },</span>
<span class="line" id="L2349">        dbg_stmt: LineColumn,</span>
<span class="line" id="L2350">        <span class="tok-comment">/// Used for unary operators which reference an inst,</span></span>
<span class="line" id="L2351">        <span class="tok-comment">/// with an AST node source location.</span></span>
<span class="line" id="L2352">        inst_node: <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2353">            <span class="tok-comment">/// Offset from Decl AST node index.</span></span>
<span class="line" id="L2354">            src_node: <span class="tok-type">i32</span>,</span>
<span class="line" id="L2355">            <span class="tok-comment">/// The meaning of this operand depends on the corresponding `Tag`.</span></span>
<span class="line" id="L2356">            inst: Index,</span>
<span class="line" id="L2357"></span>
<span class="line" id="L2358">            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">src</span>(self: <span class="tok-builtin">@This</span>()) LazySrcLoc {</span>
<span class="line" id="L2359">                <span class="tok-kw">return</span> LazySrcLoc.nodeOffset(self.src_node);</span>
<span class="line" id="L2360">            }</span>
<span class="line" id="L2361">        },</span>
<span class="line" id="L2362">        str_op: <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2363">            <span class="tok-comment">/// Offset into `string_bytes`. Null-terminated.</span></span>
<span class="line" id="L2364">            str: NullTerminatedString,</span>
<span class="line" id="L2365">            operand: Ref,</span>
<span class="line" id="L2366"></span>
<span class="line" id="L2367">            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getStr</span>(self: <span class="tok-builtin">@This</span>(), zir: Zir) [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L2368">                <span class="tok-kw">return</span> zir.nullTerminatedString(self.str);</span>
<span class="line" id="L2369">            }</span>
<span class="line" id="L2370">        },</span>
<span class="line" id="L2371">        @&quot;defer&quot;: <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2372">            index: <span class="tok-type">u32</span>,</span>
<span class="line" id="L2373">            len: <span class="tok-type">u32</span>,</span>
<span class="line" id="L2374">        },</span>
<span class="line" id="L2375">        defer_err_code: <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2376">            err_code: Ref,</span>
<span class="line" id="L2377">            payload_index: <span class="tok-type">u32</span>,</span>
<span class="line" id="L2378">        },</span>
<span class="line" id="L2379">        save_err_ret_index: <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2380">            operand: Ref, <span class="tok-comment">// If error type (or .none), save new trace index</span>
</span>
<span class="line" id="L2381">        },</span>
<span class="line" id="L2382">        elem_val_imm: <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2383">            <span class="tok-comment">/// The indexable value being accessed.</span></span>
<span class="line" id="L2384">            operand: Ref,</span>
<span class="line" id="L2385">            <span class="tok-comment">/// The index being accessed.</span></span>
<span class="line" id="L2386">            idx: <span class="tok-type">u32</span>,</span>
<span class="line" id="L2387">        },</span>
<span class="line" id="L2388"></span>
<span class="line" id="L2389">        <span class="tok-comment">// Make sure we don't accidentally add a field to make this union</span>
</span>
<span class="line" id="L2390">        <span class="tok-comment">// bigger than expected. Note that in Debug builds, Zig is allowed</span>
</span>
<span class="line" id="L2391">        <span class="tok-comment">// to insert a secret field for safety checks.</span>
</span>
<span class="line" id="L2392">        <span class="tok-kw">comptime</span> {</span>
<span class="line" id="L2393">            <span class="tok-kw">if</span> (builtin.mode != .Debug <span class="tok-kw">and</span> builtin.mode != .ReleaseSafe) {</span>
<span class="line" id="L2394">                assert(<span class="tok-builtin">@sizeOf</span>(Data) == <span class="tok-number">8</span>);</span>
<span class="line" id="L2395">            }</span>
<span class="line" id="L2396">        }</span>
<span class="line" id="L2397"></span>
<span class="line" id="L2398">        <span class="tok-comment">/// TODO this has to be kept in sync with `Data` which we want to be an untagged</span></span>
<span class="line" id="L2399">        <span class="tok-comment">/// union. There is some kind of language awkwardness here and it has to do with</span></span>
<span class="line" id="L2400">        <span class="tok-comment">/// deserializing an untagged union (in this case `Data`) from a file, and trying</span></span>
<span class="line" id="L2401">        <span class="tok-comment">/// to preserve the hidden safety field.</span></span>
<span class="line" id="L2402">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> FieldEnum = <span class="tok-kw">enum</span> {</span>
<span class="line" id="L2403">            extended,</span>
<span class="line" id="L2404">            un_node,</span>
<span class="line" id="L2405">            un_tok,</span>
<span class="line" id="L2406">            pl_node,</span>
<span class="line" id="L2407">            pl_tok,</span>
<span class="line" id="L2408">            bin,</span>
<span class="line" id="L2409">            str,</span>
<span class="line" id="L2410">            str_tok,</span>
<span class="line" id="L2411">            tok,</span>
<span class="line" id="L2412">            node,</span>
<span class="line" id="L2413">            int,</span>
<span class="line" id="L2414">            float,</span>
<span class="line" id="L2415">            ptr_type,</span>
<span class="line" id="L2416">            int_type,</span>
<span class="line" id="L2417">            @&quot;unreachable&quot;,</span>
<span class="line" id="L2418">            @&quot;break&quot;,</span>
<span class="line" id="L2419">            dbg_stmt,</span>
<span class="line" id="L2420">            inst_node,</span>
<span class="line" id="L2421">            str_op,</span>
<span class="line" id="L2422">            @&quot;defer&quot;,</span>
<span class="line" id="L2423">            defer_err_code,</span>
<span class="line" id="L2424">            save_err_ret_index,</span>
<span class="line" id="L2425">            elem_val_imm,</span>
<span class="line" id="L2426">        };</span>
<span class="line" id="L2427">    };</span>
<span class="line" id="L2428"></span>
<span class="line" id="L2429">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Break = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2430">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> no_src_node = std.math.maxInt(<span class="tok-type">i32</span>);</span>
<span class="line" id="L2431"></span>
<span class="line" id="L2432">        operand_src_node: <span class="tok-type">i32</span>,</span>
<span class="line" id="L2433">        block_inst: Index,</span>
<span class="line" id="L2434">    };</span>
<span class="line" id="L2435"></span>
<span class="line" id="L2436">    <span class="tok-comment">/// Trailing:</span></span>
<span class="line" id="L2437">    <span class="tok-comment">/// 0. Output for every outputs_len</span></span>
<span class="line" id="L2438">    <span class="tok-comment">/// 1. Input for every inputs_len</span></span>
<span class="line" id="L2439">    <span class="tok-comment">/// 2. clobber: NullTerminatedString // index into string_bytes (null terminated) for every clobbers_len.</span></span>
<span class="line" id="L2440">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Asm = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2441">        src_node: <span class="tok-type">i32</span>,</span>
<span class="line" id="L2442">        <span class="tok-comment">// null-terminated string index</span>
</span>
<span class="line" id="L2443">        asm_source: NullTerminatedString,</span>
<span class="line" id="L2444">        <span class="tok-comment">/// 1 bit for each outputs_len: whether it uses `-&gt; T` or not.</span></span>
<span class="line" id="L2445">        <span class="tok-comment">///   0b0 - operand is a pointer to where to store the output.</span></span>
<span class="line" id="L2446">        <span class="tok-comment">///   0b1 - operand is a type; asm expression has the output as the result.</span></span>
<span class="line" id="L2447">        <span class="tok-comment">/// 0b0X is the first output, 0bX0 is the second, etc.</span></span>
<span class="line" id="L2448">        output_type_bits: <span class="tok-type">u32</span>,</span>
<span class="line" id="L2449"></span>
<span class="line" id="L2450">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Output = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2451">            <span class="tok-comment">/// index into string_bytes (null terminated)</span></span>
<span class="line" id="L2452">            name: NullTerminatedString,</span>
<span class="line" id="L2453">            <span class="tok-comment">/// index into string_bytes (null terminated)</span></span>
<span class="line" id="L2454">            constraint: NullTerminatedString,</span>
<span class="line" id="L2455">            <span class="tok-comment">/// How to interpret this is determined by `output_type_bits`.</span></span>
<span class="line" id="L2456">            operand: Ref,</span>
<span class="line" id="L2457">        };</span>
<span class="line" id="L2458"></span>
<span class="line" id="L2459">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Input = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2460">            <span class="tok-comment">/// index into string_bytes (null terminated)</span></span>
<span class="line" id="L2461">            name: NullTerminatedString,</span>
<span class="line" id="L2462">            <span class="tok-comment">/// index into string_bytes (null terminated)</span></span>
<span class="line" id="L2463">            constraint: NullTerminatedString,</span>
<span class="line" id="L2464">            operand: Ref,</span>
<span class="line" id="L2465">        };</span>
<span class="line" id="L2466">    };</span>
<span class="line" id="L2467"></span>
<span class="line" id="L2468">    <span class="tok-comment">/// Trailing:</span></span>
<span class="line" id="L2469">    <span class="tok-comment">/// if (ret_body_len == 1) {</span></span>
<span class="line" id="L2470">    <span class="tok-comment">///   0. return_type: Ref</span></span>
<span class="line" id="L2471">    <span class="tok-comment">/// }</span></span>
<span class="line" id="L2472">    <span class="tok-comment">/// if (ret_body_len &gt; 1) {</span></span>
<span class="line" id="L2473">    <span class="tok-comment">///   1. return_type: Index // for each ret_body_len</span></span>
<span class="line" id="L2474">    <span class="tok-comment">/// }</span></span>
<span class="line" id="L2475">    <span class="tok-comment">/// 2. body: Index // for each body_len</span></span>
<span class="line" id="L2476">    <span class="tok-comment">/// 3. src_locs: SrcLocs // if body_len != 0</span></span>
<span class="line" id="L2477">    <span class="tok-comment">/// 4. proto_hash: std.zig.SrcHash // if body_len != 0; hash of function prototype</span></span>
<span class="line" id="L2478">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Func = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2479">        <span class="tok-comment">/// If this is 0 it means a void return type.</span></span>
<span class="line" id="L2480">        <span class="tok-comment">/// If this is 1 it means return_type is a simple Ref</span></span>
<span class="line" id="L2481">        ret_body_len: <span class="tok-type">u32</span>,</span>
<span class="line" id="L2482">        <span class="tok-comment">/// Points to the block that contains the param instructions for this function.</span></span>
<span class="line" id="L2483">        <span class="tok-comment">/// If this is a `declaration`, it refers to the declaration's value body.</span></span>
<span class="line" id="L2484">        param_block: Index,</span>
<span class="line" id="L2485">        body_len: <span class="tok-type">u32</span>,</span>
<span class="line" id="L2486"></span>
<span class="line" id="L2487">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> SrcLocs = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2488">            <span class="tok-comment">/// Line index in the source file relative to the parent decl.</span></span>
<span class="line" id="L2489">            lbrace_line: <span class="tok-type">u32</span>,</span>
<span class="line" id="L2490">            <span class="tok-comment">/// Line index in the source file relative to the parent decl.</span></span>
<span class="line" id="L2491">            rbrace_line: <span class="tok-type">u32</span>,</span>
<span class="line" id="L2492">            <span class="tok-comment">/// lbrace_column is least significant bits u16</span></span>
<span class="line" id="L2493">            <span class="tok-comment">/// rbrace_column is most significant bits u16</span></span>
<span class="line" id="L2494">            columns: <span class="tok-type">u32</span>,</span>
<span class="line" id="L2495">        };</span>
<span class="line" id="L2496">    };</span>
<span class="line" id="L2497"></span>
<span class="line" id="L2498">    <span class="tok-comment">/// Trailing:</span></span>
<span class="line" id="L2499">    <span class="tok-comment">/// 0. lib_name: NullTerminatedString, // null terminated string index, if has_lib_name is set</span></span>
<span class="line" id="L2500">    <span class="tok-comment">/// if (has_align_ref and !has_align_body) {</span></span>
<span class="line" id="L2501">    <span class="tok-comment">///   1. align: Ref,</span></span>
<span class="line" id="L2502">    <span class="tok-comment">/// }</span></span>
<span class="line" id="L2503">    <span class="tok-comment">/// if (has_align_body) {</span></span>
<span class="line" id="L2504">    <span class="tok-comment">///   2. align_body_len: u32</span></span>
<span class="line" id="L2505">    <span class="tok-comment">///   3. align_body: u32 // for each align_body_len</span></span>
<span class="line" id="L2506">    <span class="tok-comment">/// }</span></span>
<span class="line" id="L2507">    <span class="tok-comment">/// if (has_addrspace_ref and !has_addrspace_body) {</span></span>
<span class="line" id="L2508">    <span class="tok-comment">///   4. addrspace: Ref,</span></span>
<span class="line" id="L2509">    <span class="tok-comment">/// }</span></span>
<span class="line" id="L2510">    <span class="tok-comment">/// if (has_addrspace_body) {</span></span>
<span class="line" id="L2511">    <span class="tok-comment">///   5. addrspace_body_len: u32</span></span>
<span class="line" id="L2512">    <span class="tok-comment">///   6. addrspace_body: u32 // for each addrspace_body_len</span></span>
<span class="line" id="L2513">    <span class="tok-comment">/// }</span></span>
<span class="line" id="L2514">    <span class="tok-comment">/// if (has_section_ref and !has_section_body) {</span></span>
<span class="line" id="L2515">    <span class="tok-comment">///   7. section: Ref,</span></span>
<span class="line" id="L2516">    <span class="tok-comment">/// }</span></span>
<span class="line" id="L2517">    <span class="tok-comment">/// if (has_section_body) {</span></span>
<span class="line" id="L2518">    <span class="tok-comment">///   8. section_body_len: u32</span></span>
<span class="line" id="L2519">    <span class="tok-comment">///   9. section_body: u32 // for each section_body_len</span></span>
<span class="line" id="L2520">    <span class="tok-comment">/// }</span></span>
<span class="line" id="L2521">    <span class="tok-comment">/// if (has_cc_ref and !has_cc_body) {</span></span>
<span class="line" id="L2522">    <span class="tok-comment">///   10. cc: Ref,</span></span>
<span class="line" id="L2523">    <span class="tok-comment">/// }</span></span>
<span class="line" id="L2524">    <span class="tok-comment">/// if (has_cc_body) {</span></span>
<span class="line" id="L2525">    <span class="tok-comment">///   11. cc_body_len: u32</span></span>
<span class="line" id="L2526">    <span class="tok-comment">///   12. cc_body: u32 // for each cc_body_len</span></span>
<span class="line" id="L2527">    <span class="tok-comment">/// }</span></span>
<span class="line" id="L2528">    <span class="tok-comment">/// if (has_ret_ty_ref and !has_ret_ty_body) {</span></span>
<span class="line" id="L2529">    <span class="tok-comment">///   13. ret_ty: Ref,</span></span>
<span class="line" id="L2530">    <span class="tok-comment">/// }</span></span>
<span class="line" id="L2531">    <span class="tok-comment">/// if (has_ret_ty_body) {</span></span>
<span class="line" id="L2532">    <span class="tok-comment">///   14. ret_ty_body_len: u32</span></span>
<span class="line" id="L2533">    <span class="tok-comment">///   15. ret_ty_body: u32 // for each ret_ty_body_len</span></span>
<span class="line" id="L2534">    <span class="tok-comment">/// }</span></span>
<span class="line" id="L2535">    <span class="tok-comment">/// 16. noalias_bits: u32 // if has_any_noalias</span></span>
<span class="line" id="L2536">    <span class="tok-comment">///     - each bit starting with LSB corresponds to parameter indexes</span></span>
<span class="line" id="L2537">    <span class="tok-comment">/// 17. body: Index // for each body_len</span></span>
<span class="line" id="L2538">    <span class="tok-comment">/// 18. src_locs: Func.SrcLocs // if body_len != 0</span></span>
<span class="line" id="L2539">    <span class="tok-comment">/// 19. proto_hash: std.zig.SrcHash // if body_len != 0; hash of function prototype</span></span>
<span class="line" id="L2540">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> FuncFancy = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2541">        <span class="tok-comment">/// Points to the block that contains the param instructions for this function.</span></span>
<span class="line" id="L2542">        <span class="tok-comment">/// If this is a `declaration`, it refers to the declaration's value body.</span></span>
<span class="line" id="L2543">        param_block: Index,</span>
<span class="line" id="L2544">        body_len: <span class="tok-type">u32</span>,</span>
<span class="line" id="L2545">        bits: Bits,</span>
<span class="line" id="L2546"></span>
<span class="line" id="L2547">        <span class="tok-comment">/// If both has_cc_ref and has_cc_body are false, it means auto calling convention.</span></span>
<span class="line" id="L2548">        <span class="tok-comment">/// If both has_align_ref and has_align_body are false, it means default alignment.</span></span>
<span class="line" id="L2549">        <span class="tok-comment">/// If both has_ret_ty_ref and has_ret_ty_body are false, it means void return type.</span></span>
<span class="line" id="L2550">        <span class="tok-comment">/// If both has_section_ref and has_section_body are false, it means default section.</span></span>
<span class="line" id="L2551">        <span class="tok-comment">/// If both has_addrspace_ref and has_addrspace_body are false, it means default addrspace.</span></span>
<span class="line" id="L2552">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Bits = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2553">            is_var_args: <span class="tok-type">bool</span>,</span>
<span class="line" id="L2554">            is_inferred_error: <span class="tok-type">bool</span>,</span>
<span class="line" id="L2555">            is_test: <span class="tok-type">bool</span>,</span>
<span class="line" id="L2556">            is_extern: <span class="tok-type">bool</span>,</span>
<span class="line" id="L2557">            is_noinline: <span class="tok-type">bool</span>,</span>
<span class="line" id="L2558">            has_align_ref: <span class="tok-type">bool</span>,</span>
<span class="line" id="L2559">            has_align_body: <span class="tok-type">bool</span>,</span>
<span class="line" id="L2560">            has_addrspace_ref: <span class="tok-type">bool</span>,</span>
<span class="line" id="L2561">            has_addrspace_body: <span class="tok-type">bool</span>,</span>
<span class="line" id="L2562">            has_section_ref: <span class="tok-type">bool</span>,</span>
<span class="line" id="L2563">            has_section_body: <span class="tok-type">bool</span>,</span>
<span class="line" id="L2564">            has_cc_ref: <span class="tok-type">bool</span>,</span>
<span class="line" id="L2565">            has_cc_body: <span class="tok-type">bool</span>,</span>
<span class="line" id="L2566">            has_ret_ty_ref: <span class="tok-type">bool</span>,</span>
<span class="line" id="L2567">            has_ret_ty_body: <span class="tok-type">bool</span>,</span>
<span class="line" id="L2568">            has_lib_name: <span class="tok-type">bool</span>,</span>
<span class="line" id="L2569">            has_any_noalias: <span class="tok-type">bool</span>,</span>
<span class="line" id="L2570">            _: <span class="tok-type">u15</span> = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L2571">        };</span>
<span class="line" id="L2572">    };</span>
<span class="line" id="L2573"></span>
<span class="line" id="L2574">    <span class="tok-comment">/// Trailing:</span></span>
<span class="line" id="L2575">    <span class="tok-comment">/// 0. lib_name: NullTerminatedString, // null terminated string index, if has_lib_name is set</span></span>
<span class="line" id="L2576">    <span class="tok-comment">/// 1. align: Ref, // if has_align is set</span></span>
<span class="line" id="L2577">    <span class="tok-comment">/// 2. init: Ref // if has_init is set</span></span>
<span class="line" id="L2578">    <span class="tok-comment">/// The source node is obtained from the containing `block_inline`.</span></span>
<span class="line" id="L2579">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ExtendedVar = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2580">        var_type: Ref,</span>
<span class="line" id="L2581"></span>
<span class="line" id="L2582">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Small = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2583">            has_lib_name: <span class="tok-type">bool</span>,</span>
<span class="line" id="L2584">            has_align: <span class="tok-type">bool</span>,</span>
<span class="line" id="L2585">            has_init: <span class="tok-type">bool</span>,</span>
<span class="line" id="L2586">            is_extern: <span class="tok-type">bool</span>,</span>
<span class="line" id="L2587">            is_const: <span class="tok-type">bool</span>,</span>
<span class="line" id="L2588">            is_threadlocal: <span class="tok-type">bool</span>,</span>
<span class="line" id="L2589">            _: <span class="tok-type">u10</span> = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L2590">        };</span>
<span class="line" id="L2591">    };</span>
<span class="line" id="L2592"></span>
<span class="line" id="L2593">    <span class="tok-comment">/// This data is stored inside extra, with trailing operands according to `operands_len`.</span></span>
<span class="line" id="L2594">    <span class="tok-comment">/// Each operand is a `Ref`.</span></span>
<span class="line" id="L2595">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> MultiOp = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2596">        operands_len: <span class="tok-type">u32</span>,</span>
<span class="line" id="L2597">    };</span>
<span class="line" id="L2598"></span>
<span class="line" id="L2599">    <span class="tok-comment">/// Trailing: operand: Ref, // for each `operands_len` (stored in `small`).</span></span>
<span class="line" id="L2600">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> NodeMultiOp = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2601">        src_node: <span class="tok-type">i32</span>,</span>
<span class="line" id="L2602">    };</span>
<span class="line" id="L2603"></span>
<span class="line" id="L2604">    <span class="tok-comment">/// This data is stored inside extra, with trailing operands according to `body_len`.</span></span>
<span class="line" id="L2605">    <span class="tok-comment">/// Each operand is an `Index`.</span></span>
<span class="line" id="L2606">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Block = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2607">        body_len: <span class="tok-type">u32</span>,</span>
<span class="line" id="L2608">    };</span>
<span class="line" id="L2609"></span>
<span class="line" id="L2610">    <span class="tok-comment">/// Trailing:</span></span>
<span class="line" id="L2611">    <span class="tok-comment">/// * inst: Index // for each `body_len`</span></span>
<span class="line" id="L2612">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> BoolBr = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2613">        lhs: Ref,</span>
<span class="line" id="L2614">        body_len: <span class="tok-type">u32</span>,</span>
<span class="line" id="L2615">    };</span>
<span class="line" id="L2616"></span>
<span class="line" id="L2617">    <span class="tok-comment">/// Trailing:</span></span>
<span class="line" id="L2618">    <span class="tok-comment">/// 0. doc_comment: u32          // if `has_doc_comment`; null-terminated string index</span></span>
<span class="line" id="L2619">    <span class="tok-comment">/// 1. align_body_len: u32       // if `has_align_linksection_addrspace`; 0 means no `align`</span></span>
<span class="line" id="L2620">    <span class="tok-comment">/// 2. linksection_body_len: u32 // if `has_align_linksection_addrspace`; 0 means no `linksection`</span></span>
<span class="line" id="L2621">    <span class="tok-comment">/// 3. addrspace_body_len: u32   // if `has_align_linksection_addrspace`; 0 means no `addrspace`</span></span>
<span class="line" id="L2622">    <span class="tok-comment">/// 4. value_body_inst: Zir.Inst.Index</span></span>
<span class="line" id="L2623">    <span class="tok-comment">///    - for each `value_body_len`</span></span>
<span class="line" id="L2624">    <span class="tok-comment">///    - body to be exited via `break_inline` to this `declaration` instruction</span></span>
<span class="line" id="L2625">    <span class="tok-comment">/// 5. align_body_inst: Zir.Inst.Index</span></span>
<span class="line" id="L2626">    <span class="tok-comment">///    - for each `align_body_len`</span></span>
<span class="line" id="L2627">    <span class="tok-comment">///    - body to be exited via `break_inline` to this `declaration` instruction</span></span>
<span class="line" id="L2628">    <span class="tok-comment">/// 6. linksection_body_inst: Zir.Inst.Index</span></span>
<span class="line" id="L2629">    <span class="tok-comment">///    - for each `linksection_body_len`</span></span>
<span class="line" id="L2630">    <span class="tok-comment">///    - body to be exited via `break_inline` to this `declaration` instruction</span></span>
<span class="line" id="L2631">    <span class="tok-comment">/// 7. addrspace_body_inst: Zir.Inst.Index</span></span>
<span class="line" id="L2632">    <span class="tok-comment">///    - for each `addrspace_body_len`</span></span>
<span class="line" id="L2633">    <span class="tok-comment">///    - body to be exited via `break_inline` to this `declaration` instruction</span></span>
<span class="line" id="L2634">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Declaration = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2635">        <span class="tok-comment">// These fields should be concatenated and reinterpreted as a `std.zig.SrcHash`.</span>
</span>
<span class="line" id="L2636">        src_hash_0: <span class="tok-type">u32</span>,</span>
<span class="line" id="L2637">        src_hash_1: <span class="tok-type">u32</span>,</span>
<span class="line" id="L2638">        src_hash_2: <span class="tok-type">u32</span>,</span>
<span class="line" id="L2639">        src_hash_3: <span class="tok-type">u32</span>,</span>
<span class="line" id="L2640">        <span class="tok-comment">/// The name of this `Decl`. Also indicates whether it is a test, comptime block, etc.</span></span>
<span class="line" id="L2641">        name: Name,</span>
<span class="line" id="L2642">        <span class="tok-comment">/// This Decl's line number relative to that of its parent.</span></span>
<span class="line" id="L2643">        <span class="tok-comment">/// TODO: column must be encoded similarly to respect non-formatted code!</span></span>
<span class="line" id="L2644">        line_offset: <span class="tok-type">u32</span>,</span>
<span class="line" id="L2645">        flags: Flags,</span>
<span class="line" id="L2646"></span>
<span class="line" id="L2647">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Flags = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span>(<span class="tok-type">u32</span>) {</span>
<span class="line" id="L2648">            value_body_len: <span class="tok-type">u28</span>,</span>
<span class="line" id="L2649">            is_pub: <span class="tok-type">bool</span>,</span>
<span class="line" id="L2650">            is_export: <span class="tok-type">bool</span>,</span>
<span class="line" id="L2651">            has_doc_comment: <span class="tok-type">bool</span>,</span>
<span class="line" id="L2652">            has_align_linksection_addrspace: <span class="tok-type">bool</span>,</span>
<span class="line" id="L2653">        };</span>
<span class="line" id="L2654"></span>
<span class="line" id="L2655">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Name = <span class="tok-kw">enum</span>(<span class="tok-type">u32</span>) {</span>
<span class="line" id="L2656">            @&quot;comptime&quot; = std.math.maxInt(<span class="tok-type">u32</span>),</span>
<span class="line" id="L2657">            @&quot;usingnamespace&quot; = std.math.maxInt(<span class="tok-type">u32</span>) - <span class="tok-number">1</span>,</span>
<span class="line" id="L2658">            unnamed_test = std.math.maxInt(<span class="tok-type">u32</span>) - <span class="tok-number">2</span>,</span>
<span class="line" id="L2659">            <span class="tok-comment">/// In this case, `has_doc_comment` will be true, and the doc</span></span>
<span class="line" id="L2660">            <span class="tok-comment">/// comment body is the identifier name.</span></span>
<span class="line" id="L2661">            decltest = std.math.maxInt(<span class="tok-type">u32</span>) - <span class="tok-number">3</span>,</span>
<span class="line" id="L2662">            <span class="tok-comment">/// Other values are `NullTerminatedString` values, i.e. index into</span></span>
<span class="line" id="L2663">            <span class="tok-comment">/// `string_bytes`. If the byte referenced is 0, the decl is a named</span></span>
<span class="line" id="L2664">            <span class="tok-comment">/// test, and the actual name begins at the following byte.</span></span>
<span class="line" id="L2665">            _,</span>
<span class="line" id="L2666"></span>
<span class="line" id="L2667">            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isNamedTest</span>(name: Name, zir: Zir) <span class="tok-type">bool</span> {</span>
<span class="line" id="L2668">                <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (name) {</span>
<span class="line" id="L2669">                    .@&quot;comptime&quot;, .@&quot;usingnamespace&quot;, .unnamed_test, .decltest =&gt; <span class="tok-null">false</span>,</span>
<span class="line" id="L2670">                    _ =&gt; zir.string_bytes[<span class="tok-builtin">@intFromEnum</span>(name)] == <span class="tok-number">0</span>,</span>
<span class="line" id="L2671">                };</span>
<span class="line" id="L2672">            }</span>
<span class="line" id="L2673">            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toString</span>(name: Name, zir: Zir) ?NullTerminatedString {</span>
<span class="line" id="L2674">                <span class="tok-kw">switch</span> (name) {</span>
<span class="line" id="L2675">                    .@&quot;comptime&quot;, .@&quot;usingnamespace&quot;, .unnamed_test, .decltest =&gt; <span class="tok-kw">return</span> <span class="tok-null">null</span>,</span>
<span class="line" id="L2676">                    _ =&gt; {},</span>
<span class="line" id="L2677">                }</span>
<span class="line" id="L2678">                <span class="tok-kw">const</span> idx: <span class="tok-type">u32</span> = <span class="tok-builtin">@intFromEnum</span>(name);</span>
<span class="line" id="L2679">                <span class="tok-kw">if</span> (zir.string_bytes[idx] == <span class="tok-number">0</span>) {</span>
<span class="line" id="L2680">                    <span class="tok-comment">// Named test</span>
</span>
<span class="line" id="L2681">                    <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(idx + <span class="tok-number">1</span>);</span>
<span class="line" id="L2682">                }</span>
<span class="line" id="L2683">                <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(idx);</span>
<span class="line" id="L2684">            }</span>
<span class="line" id="L2685">        };</span>
<span class="line" id="L2686"></span>
<span class="line" id="L2687">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Bodies = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2688">            value_body: []<span class="tok-kw">const</span> Index,</span>
<span class="line" id="L2689">            align_body: ?[]<span class="tok-kw">const</span> Index,</span>
<span class="line" id="L2690">            linksection_body: ?[]<span class="tok-kw">const</span> Index,</span>
<span class="line" id="L2691">            addrspace_body: ?[]<span class="tok-kw">const</span> Index,</span>
<span class="line" id="L2692">        };</span>
<span class="line" id="L2693"></span>
<span class="line" id="L2694">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getBodies</span>(declaration: Declaration, extra_end: <span class="tok-type">u32</span>, zir: Zir) Bodies {</span>
<span class="line" id="L2695">            <span class="tok-kw">var</span> extra_index: <span class="tok-type">u32</span> = extra_end;</span>
<span class="line" id="L2696">            extra_index += <span class="tok-builtin">@intFromBool</span>(declaration.flags.has_doc_comment);</span>
<span class="line" id="L2697">            <span class="tok-kw">const</span> value_body_len = declaration.flags.value_body_len;</span>
<span class="line" id="L2698">            <span class="tok-kw">const</span> align_body_len, <span class="tok-kw">const</span> linksection_body_len, <span class="tok-kw">const</span> addrspace_body_len = lens: {</span>
<span class="line" id="L2699">                <span class="tok-kw">if</span> (!declaration.flags.has_align_linksection_addrspace) {</span>
<span class="line" id="L2700">                    <span class="tok-kw">break</span> :lens .{ <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span> };</span>
<span class="line" id="L2701">                }</span>
<span class="line" id="L2702">                <span class="tok-kw">const</span> lens = zir.extra[extra_index..][<span class="tok-number">0</span>..<span class="tok-number">3</span>].*;</span>
<span class="line" id="L2703">                extra_index += <span class="tok-number">3</span>;</span>
<span class="line" id="L2704">                <span class="tok-kw">break</span> :lens lens;</span>
<span class="line" id="L2705">            };</span>
<span class="line" id="L2706">            <span class="tok-kw">return</span> .{</span>
<span class="line" id="L2707">                .value_body = b: {</span>
<span class="line" id="L2708">                    <span class="tok-kw">defer</span> extra_index += value_body_len;</span>
<span class="line" id="L2709">                    <span class="tok-kw">break</span> :b zir.bodySlice(extra_index, value_body_len);</span>
<span class="line" id="L2710">                },</span>
<span class="line" id="L2711">                .align_body = <span class="tok-kw">if</span> (align_body_len == <span class="tok-number">0</span>) <span class="tok-null">null</span> <span class="tok-kw">else</span> b: {</span>
<span class="line" id="L2712">                    <span class="tok-kw">defer</span> extra_index += align_body_len;</span>
<span class="line" id="L2713">                    <span class="tok-kw">break</span> :b zir.bodySlice(extra_index, align_body_len);</span>
<span class="line" id="L2714">                },</span>
<span class="line" id="L2715">                .linksection_body = <span class="tok-kw">if</span> (linksection_body_len == <span class="tok-number">0</span>) <span class="tok-null">null</span> <span class="tok-kw">else</span> b: {</span>
<span class="line" id="L2716">                    <span class="tok-kw">defer</span> extra_index += linksection_body_len;</span>
<span class="line" id="L2717">                    <span class="tok-kw">break</span> :b zir.bodySlice(extra_index, linksection_body_len);</span>
<span class="line" id="L2718">                },</span>
<span class="line" id="L2719">                .addrspace_body = <span class="tok-kw">if</span> (addrspace_body_len == <span class="tok-number">0</span>) <span class="tok-null">null</span> <span class="tok-kw">else</span> b: {</span>
<span class="line" id="L2720">                    <span class="tok-kw">defer</span> extra_index += addrspace_body_len;</span>
<span class="line" id="L2721">                    <span class="tok-kw">break</span> :b zir.bodySlice(extra_index, addrspace_body_len);</span>
<span class="line" id="L2722">                },</span>
<span class="line" id="L2723">            };</span>
<span class="line" id="L2724">        }</span>
<span class="line" id="L2725">    };</span>
<span class="line" id="L2726"></span>
<span class="line" id="L2727">    <span class="tok-comment">/// Stored inside extra, with trailing arguments according to `args_len`.</span></span>
<span class="line" id="L2728">    <span class="tok-comment">/// Implicit 0. arg_0_start: u32, // always same as `args_len`</span></span>
<span class="line" id="L2729">    <span class="tok-comment">/// 1. arg_end: u32, // for each `args_len`</span></span>
<span class="line" id="L2730">    <span class="tok-comment">/// arg_N_start is the same as arg_N-1_end</span></span>
<span class="line" id="L2731">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Call = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2732">        <span class="tok-comment">// Note: Flags *must* come first so that unusedResultExpr</span>
</span>
<span class="line" id="L2733">        <span class="tok-comment">// can find it when it goes to modify them.</span>
</span>
<span class="line" id="L2734">        flags: Flags,</span>
<span class="line" id="L2735">        callee: Ref,</span>
<span class="line" id="L2736"></span>
<span class="line" id="L2737">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Flags = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2738">            <span class="tok-comment">/// std.builtin.CallModifier in packed form</span></span>
<span class="line" id="L2739">            <span class="tok-kw">pub</span> <span class="tok-kw">const</span> PackedModifier = <span class="tok-type">u3</span>;</span>
<span class="line" id="L2740">            <span class="tok-kw">pub</span> <span class="tok-kw">const</span> PackedArgsLen = <span class="tok-type">u27</span>;</span>
<span class="line" id="L2741"></span>
<span class="line" id="L2742">            packed_modifier: PackedModifier,</span>
<span class="line" id="L2743">            ensure_result_used: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,</span>
<span class="line" id="L2744">            pop_error_return_trace: <span class="tok-type">bool</span>,</span>
<span class="line" id="L2745">            args_len: PackedArgsLen,</span>
<span class="line" id="L2746"></span>
<span class="line" id="L2747">            <span class="tok-kw">comptime</span> {</span>
<span class="line" id="L2748">                <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Flags) != <span class="tok-number">4</span> <span class="tok-kw">or</span> <span class="tok-builtin">@bitSizeOf</span>(Flags) != <span class="tok-number">32</span>)</span>
<span class="line" id="L2749">                    <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Layout of Call.Flags needs to be updated!&quot;</span>);</span>
<span class="line" id="L2750">                <span class="tok-kw">if</span> (<span class="tok-builtin">@bitSizeOf</span>(std.builtin.CallModifier) != <span class="tok-builtin">@bitSizeOf</span>(PackedModifier))</span>
<span class="line" id="L2751">                    <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Call.Flags.PackedModifier needs to be updated!&quot;</span>);</span>
<span class="line" id="L2752">            }</span>
<span class="line" id="L2753">        };</span>
<span class="line" id="L2754">    };</span>
<span class="line" id="L2755"></span>
<span class="line" id="L2756">    <span class="tok-comment">/// Stored inside extra, with trailing arguments according to `args_len`.</span></span>
<span class="line" id="L2757">    <span class="tok-comment">/// Implicit 0. arg_0_start: u32, // always same as `args_len`</span></span>
<span class="line" id="L2758">    <span class="tok-comment">/// 1. arg_end: u32, // for each `args_len`</span></span>
<span class="line" id="L2759">    <span class="tok-comment">/// arg_N_start is the same as arg_N-1_end</span></span>
<span class="line" id="L2760">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> FieldCall = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2761">        <span class="tok-comment">// Note: Flags *must* come first so that unusedResultExpr</span>
</span>
<span class="line" id="L2762">        <span class="tok-comment">// can find it when it goes to modify them.</span>
</span>
<span class="line" id="L2763">        flags: Call.Flags,</span>
<span class="line" id="L2764">        obj_ptr: Ref,</span>
<span class="line" id="L2765">        <span class="tok-comment">/// Offset into `string_bytes`.</span></span>
<span class="line" id="L2766">        field_name_start: NullTerminatedString,</span>
<span class="line" id="L2767">    };</span>
<span class="line" id="L2768"></span>
<span class="line" id="L2769">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> TypeOfPeer = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2770">        src_node: <span class="tok-type">i32</span>,</span>
<span class="line" id="L2771">        body_len: <span class="tok-type">u32</span>,</span>
<span class="line" id="L2772">        body_index: <span class="tok-type">u32</span>,</span>
<span class="line" id="L2773">    };</span>
<span class="line" id="L2774"></span>
<span class="line" id="L2775">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> BuiltinCall = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2776">        <span class="tok-comment">// Note: Flags *must* come first so that unusedResultExpr</span>
</span>
<span class="line" id="L2777">        <span class="tok-comment">// can find it when it goes to modify them.</span>
</span>
<span class="line" id="L2778">        flags: Flags,</span>
<span class="line" id="L2779">        modifier: Ref,</span>
<span class="line" id="L2780">        callee: Ref,</span>
<span class="line" id="L2781">        args: Ref,</span>
<span class="line" id="L2782"></span>
<span class="line" id="L2783">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Flags = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2784">            is_nosuspend: <span class="tok-type">bool</span>,</span>
<span class="line" id="L2785">            ensure_result_used: <span class="tok-type">bool</span>,</span>
<span class="line" id="L2786">            _: <span class="tok-type">u30</span> = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L2787"></span>
<span class="line" id="L2788">            <span class="tok-kw">comptime</span> {</span>
<span class="line" id="L2789">                <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Flags) != <span class="tok-number">4</span> <span class="tok-kw">or</span> <span class="tok-builtin">@bitSizeOf</span>(Flags) != <span class="tok-number">32</span>)</span>
<span class="line" id="L2790">                    <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Layout of BuiltinCall.Flags needs to be updated!&quot;</span>);</span>
<span class="line" id="L2791">            }</span>
<span class="line" id="L2792">        };</span>
<span class="line" id="L2793">    };</span>
<span class="line" id="L2794"></span>
<span class="line" id="L2795">    <span class="tok-comment">/// This data is stored inside extra, with two sets of trailing `Ref`:</span></span>
<span class="line" id="L2796">    <span class="tok-comment">/// * 0. the then body, according to `then_body_len`.</span></span>
<span class="line" id="L2797">    <span class="tok-comment">/// * 1. the else body, according to `else_body_len`.</span></span>
<span class="line" id="L2798">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> CondBr = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2799">        condition: Ref,</span>
<span class="line" id="L2800">        then_body_len: <span class="tok-type">u32</span>,</span>
<span class="line" id="L2801">        else_body_len: <span class="tok-type">u32</span>,</span>
<span class="line" id="L2802">    };</span>
<span class="line" id="L2803"></span>
<span class="line" id="L2804">    <span class="tok-comment">/// This data is stored inside extra, trailed by:</span></span>
<span class="line" id="L2805">    <span class="tok-comment">/// * 0. body: Index //  for each `body_len`.</span></span>
<span class="line" id="L2806">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Try = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2807">        <span class="tok-comment">/// The error union to unwrap.</span></span>
<span class="line" id="L2808">        operand: Ref,</span>
<span class="line" id="L2809">        body_len: <span class="tok-type">u32</span>,</span>
<span class="line" id="L2810">    };</span>
<span class="line" id="L2811"></span>
<span class="line" id="L2812">    <span class="tok-comment">/// Stored in extra. Depending on the flags in Data, there will be up to 5</span></span>
<span class="line" id="L2813">    <span class="tok-comment">/// trailing Ref fields:</span></span>
<span class="line" id="L2814">    <span class="tok-comment">/// 0. sentinel: Ref // if `has_sentinel` flag is set</span></span>
<span class="line" id="L2815">    <span class="tok-comment">/// 1. align: Ref // if `has_align` flag is set</span></span>
<span class="line" id="L2816">    <span class="tok-comment">/// 2. address_space: Ref // if `has_addrspace` flag is set</span></span>
<span class="line" id="L2817">    <span class="tok-comment">/// 3. bit_start: Ref // if `has_bit_range` flag is set</span></span>
<span class="line" id="L2818">    <span class="tok-comment">/// 4. host_size: Ref // if `has_bit_range` flag is set</span></span>
<span class="line" id="L2819">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> PtrType = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2820">        elem_type: Ref,</span>
<span class="line" id="L2821">        src_node: <span class="tok-type">i32</span>,</span>
<span class="line" id="L2822">    };</span>
<span class="line" id="L2823"></span>
<span class="line" id="L2824">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ArrayTypeSentinel = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2825">        len: Ref,</span>
<span class="line" id="L2826">        sentinel: Ref,</span>
<span class="line" id="L2827">        elem_type: Ref,</span>
<span class="line" id="L2828">    };</span>
<span class="line" id="L2829"></span>
<span class="line" id="L2830">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> SliceStart = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2831">        lhs: Ref,</span>
<span class="line" id="L2832">        start: Ref,</span>
<span class="line" id="L2833">    };</span>
<span class="line" id="L2834"></span>
<span class="line" id="L2835">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> SliceEnd = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2836">        lhs: Ref,</span>
<span class="line" id="L2837">        start: Ref,</span>
<span class="line" id="L2838">        end: Ref,</span>
<span class="line" id="L2839">    };</span>
<span class="line" id="L2840"></span>
<span class="line" id="L2841">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> SliceSentinel = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2842">        lhs: Ref,</span>
<span class="line" id="L2843">        start: Ref,</span>
<span class="line" id="L2844">        end: Ref,</span>
<span class="line" id="L2845">        sentinel: Ref,</span>
<span class="line" id="L2846">    };</span>
<span class="line" id="L2847"></span>
<span class="line" id="L2848">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> SliceLength = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2849">        lhs: Ref,</span>
<span class="line" id="L2850">        start: Ref,</span>
<span class="line" id="L2851">        len: Ref,</span>
<span class="line" id="L2852">        sentinel: Ref,</span>
<span class="line" id="L2853">        start_src_node_offset: <span class="tok-type">i32</span>,</span>
<span class="line" id="L2854">    };</span>
<span class="line" id="L2855"></span>
<span class="line" id="L2856">    <span class="tok-comment">/// The meaning of these operands depends on the corresponding `Tag`.</span></span>
<span class="line" id="L2857">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Bin = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2858">        lhs: Ref,</span>
<span class="line" id="L2859">        rhs: Ref,</span>
<span class="line" id="L2860">    };</span>
<span class="line" id="L2861"></span>
<span class="line" id="L2862">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> BinNode = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2863">        node: <span class="tok-type">i32</span>,</span>
<span class="line" id="L2864">        lhs: Ref,</span>
<span class="line" id="L2865">        rhs: Ref,</span>
<span class="line" id="L2866">    };</span>
<span class="line" id="L2867"></span>
<span class="line" id="L2868">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> UnNode = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2869">        node: <span class="tok-type">i32</span>,</span>
<span class="line" id="L2870">        operand: Ref,</span>
<span class="line" id="L2871">    };</span>
<span class="line" id="L2872"></span>
<span class="line" id="L2873">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ElemPtrImm = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2874">        ptr: Ref,</span>
<span class="line" id="L2875">        index: <span class="tok-type">u32</span>,</span>
<span class="line" id="L2876">    };</span>
<span class="line" id="L2877"></span>
<span class="line" id="L2878">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> SwitchBlockErrUnion = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2879">        operand: Ref,</span>
<span class="line" id="L2880">        bits: Bits,</span>
<span class="line" id="L2881">        main_src_node_offset: <span class="tok-type">i32</span>,</span>
<span class="line" id="L2882"></span>
<span class="line" id="L2883">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Bits = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span>(<span class="tok-type">u32</span>) {</span>
<span class="line" id="L2884">            <span class="tok-comment">/// If true, one or more prongs have multiple items.</span></span>
<span class="line" id="L2885">            has_multi_cases: <span class="tok-type">bool</span>,</span>
<span class="line" id="L2886">            <span class="tok-comment">/// If true, there is an else prong. This is mutually exclusive with `has_under`.</span></span>
<span class="line" id="L2887">            has_else: <span class="tok-type">bool</span>,</span>
<span class="line" id="L2888">            any_uses_err_capture: <span class="tok-type">bool</span>,</span>
<span class="line" id="L2889">            payload_is_ref: <span class="tok-type">bool</span>,</span>
<span class="line" id="L2890">            scalar_cases_len: ScalarCasesLen,</span>
<span class="line" id="L2891"></span>
<span class="line" id="L2892">            <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ScalarCasesLen = <span class="tok-type">u28</span>;</span>
<span class="line" id="L2893">        };</span>
<span class="line" id="L2894"></span>
<span class="line" id="L2895">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> MultiProng = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2896">            items: []<span class="tok-kw">const</span> Ref,</span>
<span class="line" id="L2897">            body: []<span class="tok-kw">const</span> Index,</span>
<span class="line" id="L2898">        };</span>
<span class="line" id="L2899">    };</span>
<span class="line" id="L2900"></span>
<span class="line" id="L2901">    <span class="tok-comment">/// 0. multi_cases_len: u32 // If has_multi_cases is set.</span></span>
<span class="line" id="L2902">    <span class="tok-comment">/// 1. tag_capture_inst: u32 // If any_has_tag_capture is set. Index of instruction prongs use to refer to the inline tag capture.</span></span>
<span class="line" id="L2903">    <span class="tok-comment">/// 2. else_body { // If has_else or has_under is set.</span></span>
<span class="line" id="L2904">    <span class="tok-comment">///        info: ProngInfo,</span></span>
<span class="line" id="L2905">    <span class="tok-comment">///        body member Index for every info.body_len</span></span>
<span class="line" id="L2906">    <span class="tok-comment">///     }</span></span>
<span class="line" id="L2907">    <span class="tok-comment">/// 3. scalar_cases: { // for every scalar_cases_len</span></span>
<span class="line" id="L2908">    <span class="tok-comment">///        item: Ref,</span></span>
<span class="line" id="L2909">    <span class="tok-comment">///        info: ProngInfo,</span></span>
<span class="line" id="L2910">    <span class="tok-comment">///        body member Index for every info.body_len</span></span>
<span class="line" id="L2911">    <span class="tok-comment">///     }</span></span>
<span class="line" id="L2912">    <span class="tok-comment">/// 4. multi_cases: { // for every multi_cases_len</span></span>
<span class="line" id="L2913">    <span class="tok-comment">///        items_len: u32,</span></span>
<span class="line" id="L2914">    <span class="tok-comment">///        ranges_len: u32,</span></span>
<span class="line" id="L2915">    <span class="tok-comment">///        info: ProngInfo,</span></span>
<span class="line" id="L2916">    <span class="tok-comment">///        item: Ref // for every items_len</span></span>
<span class="line" id="L2917">    <span class="tok-comment">///        ranges: { // for every ranges_len</span></span>
<span class="line" id="L2918">    <span class="tok-comment">///            item_first: Ref,</span></span>
<span class="line" id="L2919">    <span class="tok-comment">///            item_last: Ref,</span></span>
<span class="line" id="L2920">    <span class="tok-comment">///        }</span></span>
<span class="line" id="L2921">    <span class="tok-comment">///        body member Index for every info.body_len</span></span>
<span class="line" id="L2922">    <span class="tok-comment">///    }</span></span>
<span class="line" id="L2923">    <span class="tok-comment">///</span></span>
<span class="line" id="L2924">    <span class="tok-comment">/// When analyzing a case body, the switch instruction itself refers to the</span></span>
<span class="line" id="L2925">    <span class="tok-comment">/// captured payload. Whether this is captured by reference or by value</span></span>
<span class="line" id="L2926">    <span class="tok-comment">/// depends on whether the `byref` bit is set for the corresponding body.</span></span>
<span class="line" id="L2927">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> SwitchBlock = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2928">        <span class="tok-comment">/// The operand passed to the `switch` expression. If this is a</span></span>
<span class="line" id="L2929">        <span class="tok-comment">/// `switch_block`, this is the operand value; if `switch_block_ref` it</span></span>
<span class="line" id="L2930">        <span class="tok-comment">/// is a pointer to the operand. `switch_block_ref` is always used if</span></span>
<span class="line" id="L2931">        <span class="tok-comment">/// any prong has a byref capture.</span></span>
<span class="line" id="L2932">        operand: Ref,</span>
<span class="line" id="L2933">        bits: Bits,</span>
<span class="line" id="L2934"></span>
<span class="line" id="L2935">        <span class="tok-comment">/// These are stored in trailing data in `extra` for each prong.</span></span>
<span class="line" id="L2936">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ProngInfo = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span>(<span class="tok-type">u32</span>) {</span>
<span class="line" id="L2937">            body_len: <span class="tok-type">u28</span>,</span>
<span class="line" id="L2938">            capture: ProngInfo.Capture,</span>
<span class="line" id="L2939">            is_inline: <span class="tok-type">bool</span>,</span>
<span class="line" id="L2940">            has_tag_capture: <span class="tok-type">bool</span>,</span>
<span class="line" id="L2941"></span>
<span class="line" id="L2942">            <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Capture = <span class="tok-kw">enum</span>(<span class="tok-type">u2</span>) {</span>
<span class="line" id="L2943">                none,</span>
<span class="line" id="L2944">                by_val,</span>
<span class="line" id="L2945">                by_ref,</span>
<span class="line" id="L2946">            };</span>
<span class="line" id="L2947">        };</span>
<span class="line" id="L2948"></span>
<span class="line" id="L2949">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Bits = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span>(<span class="tok-type">u32</span>) {</span>
<span class="line" id="L2950">            <span class="tok-comment">/// If true, one or more prongs have multiple items.</span></span>
<span class="line" id="L2951">            has_multi_cases: <span class="tok-type">bool</span>,</span>
<span class="line" id="L2952">            <span class="tok-comment">/// If true, there is an else prong. This is mutually exclusive with `has_under`.</span></span>
<span class="line" id="L2953">            has_else: <span class="tok-type">bool</span>,</span>
<span class="line" id="L2954">            <span class="tok-comment">/// If true, there is an underscore prong. This is mutually exclusive with `has_else`.</span></span>
<span class="line" id="L2955">            has_under: <span class="tok-type">bool</span>,</span>
<span class="line" id="L2956">            <span class="tok-comment">/// If true, at least one prong has an inline tag capture.</span></span>
<span class="line" id="L2957">            any_has_tag_capture: <span class="tok-type">bool</span>,</span>
<span class="line" id="L2958">            scalar_cases_len: ScalarCasesLen,</span>
<span class="line" id="L2959"></span>
<span class="line" id="L2960">            <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ScalarCasesLen = <span class="tok-type">u28</span>;</span>
<span class="line" id="L2961"></span>
<span class="line" id="L2962">            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">specialProng</span>(bits: Bits) SpecialProng {</span>
<span class="line" id="L2963">                <span class="tok-kw">const</span> has_else: <span class="tok-type">u2</span> = <span class="tok-builtin">@intFromBool</span>(bits.has_else);</span>
<span class="line" id="L2964">                <span class="tok-kw">const</span> has_under: <span class="tok-type">u2</span> = <span class="tok-builtin">@intFromBool</span>(bits.has_under);</span>
<span class="line" id="L2965">                <span class="tok-kw">return</span> <span class="tok-kw">switch</span> ((has_else &lt;&lt; <span class="tok-number">1</span>) | has_under) {</span>
<span class="line" id="L2966">                    <span class="tok-number">0b00</span> =&gt; .none,</span>
<span class="line" id="L2967">                    <span class="tok-number">0b01</span> =&gt; .under,</span>
<span class="line" id="L2968">                    <span class="tok-number">0b10</span> =&gt; .@&quot;else&quot;,</span>
<span class="line" id="L2969">                    <span class="tok-number">0b11</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L2970">                };</span>
<span class="line" id="L2971">            }</span>
<span class="line" id="L2972">        };</span>
<span class="line" id="L2973"></span>
<span class="line" id="L2974">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> MultiProng = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2975">            items: []<span class="tok-kw">const</span> Ref,</span>
<span class="line" id="L2976">            body: []<span class="tok-kw">const</span> Index,</span>
<span class="line" id="L2977">        };</span>
<span class="line" id="L2978">    };</span>
<span class="line" id="L2979"></span>
<span class="line" id="L2980">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ArrayInitRefTy = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2981">        ptr_ty: Ref,</span>
<span class="line" id="L2982">        elem_count: <span class="tok-type">u32</span>,</span>
<span class="line" id="L2983">    };</span>
<span class="line" id="L2984"></span>
<span class="line" id="L2985">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Field = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2986">        lhs: Ref,</span>
<span class="line" id="L2987">        <span class="tok-comment">/// Offset into `string_bytes`.</span></span>
<span class="line" id="L2988">        field_name_start: NullTerminatedString,</span>
<span class="line" id="L2989">    };</span>
<span class="line" id="L2990"></span>
<span class="line" id="L2991">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> FieldNamed = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2992">        lhs: Ref,</span>
<span class="line" id="L2993">        field_name: Ref,</span>
<span class="line" id="L2994">    };</span>
<span class="line" id="L2995"></span>
<span class="line" id="L2996">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> As = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2997">        dest_type: Ref,</span>
<span class="line" id="L2998">        operand: Ref,</span>
<span class="line" id="L2999">    };</span>
<span class="line" id="L3000"></span>
<span class="line" id="L3001">    <span class="tok-comment">/// Trailing:</span></span>
<span class="line" id="L3002">    <span class="tok-comment">/// 0. captures_len: u32 // if has_captures_len</span></span>
<span class="line" id="L3003">    <span class="tok-comment">/// 1. fields_len: u32, // if has_fields_len</span></span>
<span class="line" id="L3004">    <span class="tok-comment">/// 2. decls_len: u32, // if has_decls_len</span></span>
<span class="line" id="L3005">    <span class="tok-comment">/// 3. capture: Capture // for every captures_len</span></span>
<span class="line" id="L3006">    <span class="tok-comment">/// 4. backing_int_body_len: u32, // if has_backing_int</span></span>
<span class="line" id="L3007">    <span class="tok-comment">/// 5. backing_int_ref: Ref, // if has_backing_int and backing_int_body_len is 0</span></span>
<span class="line" id="L3008">    <span class="tok-comment">/// 6. backing_int_body_inst: Inst, // if has_backing_int and backing_int_body_len is &gt; 0</span></span>
<span class="line" id="L3009">    <span class="tok-comment">/// 7. decl: Index, // for every decls_len; points to a `declaration` instruction</span></span>
<span class="line" id="L3010">    <span class="tok-comment">/// 8. flags: u32 // for every 8 fields</span></span>
<span class="line" id="L3011">    <span class="tok-comment">///    - sets of 4 bits:</span></span>
<span class="line" id="L3012">    <span class="tok-comment">///      0b000X: whether corresponding field has an align expression</span></span>
<span class="line" id="L3013">    <span class="tok-comment">///      0b00X0: whether corresponding field has a default expression</span></span>
<span class="line" id="L3014">    <span class="tok-comment">///      0b0X00: whether corresponding field is comptime</span></span>
<span class="line" id="L3015">    <span class="tok-comment">///      0bX000: whether corresponding field has a type expression</span></span>
<span class="line" id="L3016">    <span class="tok-comment">/// 9. fields: { // for every fields_len</span></span>
<span class="line" id="L3017">    <span class="tok-comment">///        field_name: u32, // if !is_tuple</span></span>
<span class="line" id="L3018">    <span class="tok-comment">///        doc_comment: NullTerminatedString, // .empty if no doc comment</span></span>
<span class="line" id="L3019">    <span class="tok-comment">///        field_type: Ref, // if corresponding bit is not set. none means anytype.</span></span>
<span class="line" id="L3020">    <span class="tok-comment">///        field_type_body_len: u32, // if corresponding bit is set</span></span>
<span class="line" id="L3021">    <span class="tok-comment">///        align_body_len: u32, // if corresponding bit is set</span></span>
<span class="line" id="L3022">    <span class="tok-comment">///        init_body_len: u32, // if corresponding bit is set</span></span>
<span class="line" id="L3023">    <span class="tok-comment">///    }</span></span>
<span class="line" id="L3024">    <span class="tok-comment">/// 10. bodies: { // for every fields_len</span></span>
<span class="line" id="L3025">    <span class="tok-comment">///        field_type_body_inst: Inst, // for each field_type_body_len</span></span>
<span class="line" id="L3026">    <span class="tok-comment">///        align_body_inst: Inst, // for each align_body_len</span></span>
<span class="line" id="L3027">    <span class="tok-comment">///        init_body_inst: Inst, // for each init_body_len</span></span>
<span class="line" id="L3028">    <span class="tok-comment">///    }</span></span>
<span class="line" id="L3029">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> StructDecl = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L3030">        <span class="tok-comment">// These fields should be concatenated and reinterpreted as a `std.zig.SrcHash`.</span>
</span>
<span class="line" id="L3031">        <span class="tok-comment">// This hash contains the source of all fields, and any specified attributes (`extern`, backing type, etc).</span>
</span>
<span class="line" id="L3032">        fields_hash_0: <span class="tok-type">u32</span>,</span>
<span class="line" id="L3033">        fields_hash_1: <span class="tok-type">u32</span>,</span>
<span class="line" id="L3034">        fields_hash_2: <span class="tok-type">u32</span>,</span>
<span class="line" id="L3035">        fields_hash_3: <span class="tok-type">u32</span>,</span>
<span class="line" id="L3036">        src_node: <span class="tok-type">i32</span>,</span>
<span class="line" id="L3037"></span>
<span class="line" id="L3038">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">src</span>(self: StructDecl) LazySrcLoc {</span>
<span class="line" id="L3039">            <span class="tok-kw">return</span> LazySrcLoc.nodeOffset(self.src_node);</span>
<span class="line" id="L3040">        }</span>
<span class="line" id="L3041"></span>
<span class="line" id="L3042">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Small = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {</span>
<span class="line" id="L3043">            has_captures_len: <span class="tok-type">bool</span>,</span>
<span class="line" id="L3044">            has_fields_len: <span class="tok-type">bool</span>,</span>
<span class="line" id="L3045">            has_decls_len: <span class="tok-type">bool</span>,</span>
<span class="line" id="L3046">            has_backing_int: <span class="tok-type">bool</span>,</span>
<span class="line" id="L3047">            known_non_opv: <span class="tok-type">bool</span>,</span>
<span class="line" id="L3048">            known_comptime_only: <span class="tok-type">bool</span>,</span>
<span class="line" id="L3049">            is_tuple: <span class="tok-type">bool</span>,</span>
<span class="line" id="L3050">            name_strategy: NameStrategy,</span>
<span class="line" id="L3051">            layout: std.builtin.Type.ContainerLayout,</span>
<span class="line" id="L3052">            any_default_inits: <span class="tok-type">bool</span>,</span>
<span class="line" id="L3053">            any_comptime_fields: <span class="tok-type">bool</span>,</span>
<span class="line" id="L3054">            any_aligned_fields: <span class="tok-type">bool</span>,</span>
<span class="line" id="L3055">            _: <span class="tok-type">u2</span> = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L3056">        };</span>
<span class="line" id="L3057">    };</span>
<span class="line" id="L3058"></span>
<span class="line" id="L3059">    <span class="tok-comment">/// Represents a single value being captured in a type declaration's closure.</span></span>
<span class="line" id="L3060">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Capture = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span>(<span class="tok-type">u32</span>) {</span>
<span class="line" id="L3061">        tag: <span class="tok-kw">enum</span>(<span class="tok-type">u2</span>) {</span>
<span class="line" id="L3062">            <span class="tok-comment">/// `data` is a `u16` index into the parent closure.</span></span>
<span class="line" id="L3063">            nested,</span>
<span class="line" id="L3064">            <span class="tok-comment">/// `data` is a `Zir.Inst.Index` to an instruction whose value is being captured.</span></span>
<span class="line" id="L3065">            instruction,</span>
<span class="line" id="L3066">            <span class="tok-comment">/// `data` is a `NullTerminatedString` to a decl name.</span></span>
<span class="line" id="L3067">            decl_val,</span>
<span class="line" id="L3068">            <span class="tok-comment">/// `data` is a `NullTerminatedString` to a decl name.</span></span>
<span class="line" id="L3069">            decl_ref,</span>
<span class="line" id="L3070">        },</span>
<span class="line" id="L3071">        data: <span class="tok-type">u30</span>,</span>
<span class="line" id="L3072">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Unwrapped = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {</span>
<span class="line" id="L3073">            nested: <span class="tok-type">u16</span>,</span>
<span class="line" id="L3074">            instruction: Zir.Inst.Index,</span>
<span class="line" id="L3075">            decl_val: NullTerminatedString,</span>
<span class="line" id="L3076">            decl_ref: NullTerminatedString,</span>
<span class="line" id="L3077">        };</span>
<span class="line" id="L3078">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">wrap</span>(cap: Unwrapped) Capture {</span>
<span class="line" id="L3079">            <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (cap) {</span>
<span class="line" id="L3080">                .nested =&gt; |idx| .{</span>
<span class="line" id="L3081">                    .tag = .nested,</span>
<span class="line" id="L3082">                    .data = idx,</span>
<span class="line" id="L3083">                },</span>
<span class="line" id="L3084">                .instruction =&gt; |inst| .{</span>
<span class="line" id="L3085">                    .tag = .instruction,</span>
<span class="line" id="L3086">                    .data = <span class="tok-builtin">@intCast</span>(<span class="tok-builtin">@intFromEnum</span>(inst)),</span>
<span class="line" id="L3087">                },</span>
<span class="line" id="L3088">                .decl_val =&gt; |str| .{</span>
<span class="line" id="L3089">                    .tag = .decl_val,</span>
<span class="line" id="L3090">                    .data = <span class="tok-builtin">@intCast</span>(<span class="tok-builtin">@intFromEnum</span>(str)),</span>
<span class="line" id="L3091">                },</span>
<span class="line" id="L3092">                .decl_ref =&gt; |str| .{</span>
<span class="line" id="L3093">                    .tag = .decl_ref,</span>
<span class="line" id="L3094">                    .data = <span class="tok-builtin">@intCast</span>(<span class="tok-builtin">@intFromEnum</span>(str)),</span>
<span class="line" id="L3095">                },</span>
<span class="line" id="L3096">            };</span>
<span class="line" id="L3097">        }</span>
<span class="line" id="L3098">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unwrap</span>(cap: Capture) Unwrapped {</span>
<span class="line" id="L3099">            <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (cap.tag) {</span>
<span class="line" id="L3100">                .nested =&gt; .{ .nested = <span class="tok-builtin">@intCast</span>(cap.data) },</span>
<span class="line" id="L3101">                .instruction =&gt; .{ .instruction = <span class="tok-builtin">@enumFromInt</span>(cap.data) },</span>
<span class="line" id="L3102">                .decl_val =&gt; .{ .decl_val = <span class="tok-builtin">@enumFromInt</span>(cap.data) },</span>
<span class="line" id="L3103">                .decl_ref =&gt; .{ .decl_ref = <span class="tok-builtin">@enumFromInt</span>(cap.data) },</span>
<span class="line" id="L3104">            };</span>
<span class="line" id="L3105">        }</span>
<span class="line" id="L3106">    };</span>
<span class="line" id="L3107"></span>
<span class="line" id="L3108">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> NameStrategy = <span class="tok-kw">enum</span>(<span class="tok-type">u2</span>) {</span>
<span class="line" id="L3109">        <span class="tok-comment">/// Use the same name as the parent declaration name.</span></span>
<span class="line" id="L3110">        <span class="tok-comment">/// e.g. `const Foo = struct {...};`.</span></span>
<span class="line" id="L3111">        parent,</span>
<span class="line" id="L3112">        <span class="tok-comment">/// Use the name of the currently executing comptime function call,</span></span>
<span class="line" id="L3113">        <span class="tok-comment">/// with the current parameters. e.g. `ArrayList(i32)`.</span></span>
<span class="line" id="L3114">        func,</span>
<span class="line" id="L3115">        <span class="tok-comment">/// Create an anonymous name for this declaration.</span></span>
<span class="line" id="L3116">        <span class="tok-comment">/// Like this: &quot;ParentDeclName_struct_69&quot;</span></span>
<span class="line" id="L3117">        anon,</span>
<span class="line" id="L3118">        <span class="tok-comment">/// Use the name specified in the next `dbg_var_{val,ptr}` instruction.</span></span>
<span class="line" id="L3119">        dbg_var,</span>
<span class="line" id="L3120">    };</span>
<span class="line" id="L3121"></span>
<span class="line" id="L3122">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> FullPtrCastFlags = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span>(<span class="tok-type">u5</span>) {</span>
<span class="line" id="L3123">        ptr_cast: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,</span>
<span class="line" id="L3124">        align_cast: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,</span>
<span class="line" id="L3125">        addrspace_cast: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,</span>
<span class="line" id="L3126">        const_cast: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,</span>
<span class="line" id="L3127">        volatile_cast: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,</span>
<span class="line" id="L3128"></span>
<span class="line" id="L3129">        <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">needResultTypeBuiltinName</span>(flags: FullPtrCastFlags) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L3130">            <span class="tok-kw">if</span> (flags.ptr_cast) <span class="tok-kw">return</span> <span class="tok-str">&quot;@ptrCast&quot;</span>;</span>
<span class="line" id="L3131">            <span class="tok-kw">if</span> (flags.align_cast) <span class="tok-kw">return</span> <span class="tok-str">&quot;@alignCast&quot;</span>;</span>
<span class="line" id="L3132">            <span class="tok-kw">if</span> (flags.addrspace_cast) <span class="tok-kw">return</span> <span class="tok-str">&quot;@addrSpaceCast&quot;</span>;</span>
<span class="line" id="L3133">            <span class="tok-kw">unreachable</span>;</span>
<span class="line" id="L3134">        }</span>
<span class="line" id="L3135">    };</span>
<span class="line" id="L3136"></span>
<span class="line" id="L3137">    <span class="tok-comment">/// Trailing:</span></span>
<span class="line" id="L3138">    <span class="tok-comment">/// 0. tag_type: Ref, // if has_tag_type</span></span>
<span class="line" id="L3139">    <span class="tok-comment">/// 1. captures_len: u32, // if has_captures_len</span></span>
<span class="line" id="L3140">    <span class="tok-comment">/// 2. body_len: u32, // if has_body_len</span></span>
<span class="line" id="L3141">    <span class="tok-comment">/// 3. fields_len: u32, // if has_fields_len</span></span>
<span class="line" id="L3142">    <span class="tok-comment">/// 4. decls_len: u32, // if has_decls_len</span></span>
<span class="line" id="L3143">    <span class="tok-comment">/// 5. capture: Capture // for every captures_len</span></span>
<span class="line" id="L3144">    <span class="tok-comment">/// 6. decl: Index, // for every decls_len; points to a `declaration` instruction</span></span>
<span class="line" id="L3145">    <span class="tok-comment">/// 7. inst: Index // for every body_len</span></span>
<span class="line" id="L3146">    <span class="tok-comment">/// 8. has_bits: u32 // for every 32 fields</span></span>
<span class="line" id="L3147">    <span class="tok-comment">///    - the bit is whether corresponding field has an value expression</span></span>
<span class="line" id="L3148">    <span class="tok-comment">/// 9. fields: { // for every fields_len</span></span>
<span class="line" id="L3149">    <span class="tok-comment">///        field_name: u32,</span></span>
<span class="line" id="L3150">    <span class="tok-comment">///        doc_comment: u32, // .empty if no doc_comment</span></span>
<span class="line" id="L3151">    <span class="tok-comment">///        value: Ref, // if corresponding bit is set</span></span>
<span class="line" id="L3152">    <span class="tok-comment">///    }</span></span>
<span class="line" id="L3153">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> EnumDecl = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L3154">        <span class="tok-comment">// These fields should be concatenated and reinterpreted as a `std.zig.SrcHash`.</span>
</span>
<span class="line" id="L3155">        <span class="tok-comment">// This hash contains the source of all fields, and the backing type if specified.</span>
</span>
<span class="line" id="L3156">        fields_hash_0: <span class="tok-type">u32</span>,</span>
<span class="line" id="L3157">        fields_hash_1: <span class="tok-type">u32</span>,</span>
<span class="line" id="L3158">        fields_hash_2: <span class="tok-type">u32</span>,</span>
<span class="line" id="L3159">        fields_hash_3: <span class="tok-type">u32</span>,</span>
<span class="line" id="L3160">        src_node: <span class="tok-type">i32</span>,</span>
<span class="line" id="L3161"></span>
<span class="line" id="L3162">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">src</span>(self: EnumDecl) LazySrcLoc {</span>
<span class="line" id="L3163">            <span class="tok-kw">return</span> LazySrcLoc.nodeOffset(self.src_node);</span>
<span class="line" id="L3164">        }</span>
<span class="line" id="L3165"></span>
<span class="line" id="L3166">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Small = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {</span>
<span class="line" id="L3167">            has_tag_type: <span class="tok-type">bool</span>,</span>
<span class="line" id="L3168">            has_captures_len: <span class="tok-type">bool</span>,</span>
<span class="line" id="L3169">            has_body_len: <span class="tok-type">bool</span>,</span>
<span class="line" id="L3170">            has_fields_len: <span class="tok-type">bool</span>,</span>
<span class="line" id="L3171">            has_decls_len: <span class="tok-type">bool</span>,</span>
<span class="line" id="L3172">            name_strategy: NameStrategy,</span>
<span class="line" id="L3173">            nonexhaustive: <span class="tok-type">bool</span>,</span>
<span class="line" id="L3174">            _: <span class="tok-type">u8</span> = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L3175">        };</span>
<span class="line" id="L3176">    };</span>
<span class="line" id="L3177"></span>
<span class="line" id="L3178">    <span class="tok-comment">/// Trailing:</span></span>
<span class="line" id="L3179">    <span class="tok-comment">/// 0. tag_type: Ref, // if has_tag_type</span></span>
<span class="line" id="L3180">    <span class="tok-comment">/// 1. captures_len: u32 // if has_captures_len</span></span>
<span class="line" id="L3181">    <span class="tok-comment">/// 2. body_len: u32, // if has_body_len</span></span>
<span class="line" id="L3182">    <span class="tok-comment">/// 3. fields_len: u32, // if has_fields_len</span></span>
<span class="line" id="L3183">    <span class="tok-comment">/// 4. decls_len: u37, // if has_decls_len</span></span>
<span class="line" id="L3184">    <span class="tok-comment">/// 5. capture: Capture // for every captures_len</span></span>
<span class="line" id="L3185">    <span class="tok-comment">/// 6. decl: Index, // for every decls_len; points to a `declaration` instruction</span></span>
<span class="line" id="L3186">    <span class="tok-comment">/// 7. inst: Index // for every body_len</span></span>
<span class="line" id="L3187">    <span class="tok-comment">/// 8. has_bits: u32 // for every 8 fields</span></span>
<span class="line" id="L3188">    <span class="tok-comment">///    - sets of 4 bits:</span></span>
<span class="line" id="L3189">    <span class="tok-comment">///      0b000X: whether corresponding field has a type expression</span></span>
<span class="line" id="L3190">    <span class="tok-comment">///      0b00X0: whether corresponding field has a align expression</span></span>
<span class="line" id="L3191">    <span class="tok-comment">///      0b0X00: whether corresponding field has a tag value expression</span></span>
<span class="line" id="L3192">    <span class="tok-comment">///      0bX000: unused</span></span>
<span class="line" id="L3193">    <span class="tok-comment">/// 9. fields: { // for every fields_len</span></span>
<span class="line" id="L3194">    <span class="tok-comment">///        field_name: NullTerminatedString, // null terminated string index</span></span>
<span class="line" id="L3195">    <span class="tok-comment">///        doc_comment: NullTerminatedString, // .empty if no doc comment</span></span>
<span class="line" id="L3196">    <span class="tok-comment">///        field_type: Ref, // if corresponding bit is set</span></span>
<span class="line" id="L3197">    <span class="tok-comment">///        - if none, means `anytype`.</span></span>
<span class="line" id="L3198">    <span class="tok-comment">///        align: Ref, // if corresponding bit is set</span></span>
<span class="line" id="L3199">    <span class="tok-comment">///        tag_value: Ref, // if corresponding bit is set</span></span>
<span class="line" id="L3200">    <span class="tok-comment">///    }</span></span>
<span class="line" id="L3201">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> UnionDecl = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L3202">        <span class="tok-comment">// These fields should be concatenated and reinterpreted as a `std.zig.SrcHash`.</span>
</span>
<span class="line" id="L3203">        <span class="tok-comment">// This hash contains the source of all fields, and any specified attributes (`extern` etc).</span>
</span>
<span class="line" id="L3204">        fields_hash_0: <span class="tok-type">u32</span>,</span>
<span class="line" id="L3205">        fields_hash_1: <span class="tok-type">u32</span>,</span>
<span class="line" id="L3206">        fields_hash_2: <span class="tok-type">u32</span>,</span>
<span class="line" id="L3207">        fields_hash_3: <span class="tok-type">u32</span>,</span>
<span class="line" id="L3208">        src_node: <span class="tok-type">i32</span>,</span>
<span class="line" id="L3209"></span>
<span class="line" id="L3210">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">src</span>(self: UnionDecl) LazySrcLoc {</span>
<span class="line" id="L3211">            <span class="tok-kw">return</span> LazySrcLoc.nodeOffset(self.src_node);</span>
<span class="line" id="L3212">        }</span>
<span class="line" id="L3213"></span>
<span class="line" id="L3214">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Small = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {</span>
<span class="line" id="L3215">            has_tag_type: <span class="tok-type">bool</span>,</span>
<span class="line" id="L3216">            has_captures_len: <span class="tok-type">bool</span>,</span>
<span class="line" id="L3217">            has_body_len: <span class="tok-type">bool</span>,</span>
<span class="line" id="L3218">            has_fields_len: <span class="tok-type">bool</span>,</span>
<span class="line" id="L3219">            has_decls_len: <span class="tok-type">bool</span>,</span>
<span class="line" id="L3220">            name_strategy: NameStrategy,</span>
<span class="line" id="L3221">            layout: std.builtin.Type.ContainerLayout,</span>
<span class="line" id="L3222">            <span class="tok-comment">/// has_tag_type | auto_enum_tag | result</span></span>
<span class="line" id="L3223">            <span class="tok-comment">/// -------------------------------------</span></span>
<span class="line" id="L3224">            <span class="tok-comment">///    false     | false         |  union { }</span></span>
<span class="line" id="L3225">            <span class="tok-comment">///    false     | true          |  union(enum) { }</span></span>
<span class="line" id="L3226">            <span class="tok-comment">///    true      | true          |  union(enum(T)) { }</span></span>
<span class="line" id="L3227">            <span class="tok-comment">///    true      | false         |  union(T) { }</span></span>
<span class="line" id="L3228">            auto_enum_tag: <span class="tok-type">bool</span>,</span>
<span class="line" id="L3229">            any_aligned_fields: <span class="tok-type">bool</span>,</span>
<span class="line" id="L3230">            _: <span class="tok-type">u5</span> = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L3231">        };</span>
<span class="line" id="L3232">    };</span>
<span class="line" id="L3233"></span>
<span class="line" id="L3234">    <span class="tok-comment">/// Trailing:</span></span>
<span class="line" id="L3235">    <span class="tok-comment">/// 0. captures_len: u32, // if has_captures_len</span></span>
<span class="line" id="L3236">    <span class="tok-comment">/// 1. decls_len: u32, // if has_decls_len</span></span>
<span class="line" id="L3237">    <span class="tok-comment">/// 2. capture: Capture, // for every captures_len</span></span>
<span class="line" id="L3238">    <span class="tok-comment">/// 3. decl: Index, // for every decls_len; points to a `declaration` instruction</span></span>
<span class="line" id="L3239">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> OpaqueDecl = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L3240">        src_node: <span class="tok-type">i32</span>,</span>
<span class="line" id="L3241"></span>
<span class="line" id="L3242">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">src</span>(self: OpaqueDecl) LazySrcLoc {</span>
<span class="line" id="L3243">            <span class="tok-kw">return</span> LazySrcLoc.nodeOffset(self.src_node);</span>
<span class="line" id="L3244">        }</span>
<span class="line" id="L3245"></span>
<span class="line" id="L3246">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Small = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {</span>
<span class="line" id="L3247">            has_captures_len: <span class="tok-type">bool</span>,</span>
<span class="line" id="L3248">            has_decls_len: <span class="tok-type">bool</span>,</span>
<span class="line" id="L3249">            name_strategy: NameStrategy,</span>
<span class="line" id="L3250">            _: <span class="tok-type">u12</span> = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L3251">        };</span>
<span class="line" id="L3252">    };</span>
<span class="line" id="L3253"></span>
<span class="line" id="L3254">    <span class="tok-comment">/// Trailing:</span></span>
<span class="line" id="L3255">    <span class="tok-comment">/// { // for every fields_len</span></span>
<span class="line" id="L3256">    <span class="tok-comment">///      field_name: NullTerminatedString // null terminated string index</span></span>
<span class="line" id="L3257">    <span class="tok-comment">///     doc_comment: NullTerminatedString // null terminated string index</span></span>
<span class="line" id="L3258">    <span class="tok-comment">/// }</span></span>
<span class="line" id="L3259">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ErrorSetDecl = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L3260">        fields_len: <span class="tok-type">u32</span>,</span>
<span class="line" id="L3261">    };</span>
<span class="line" id="L3262"></span>
<span class="line" id="L3263">    <span class="tok-comment">/// A f128 value, broken up into 4 u32 parts.</span></span>
<span class="line" id="L3264">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Float128 = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L3265">        piece0: <span class="tok-type">u32</span>,</span>
<span class="line" id="L3266">        piece1: <span class="tok-type">u32</span>,</span>
<span class="line" id="L3267">        piece2: <span class="tok-type">u32</span>,</span>
<span class="line" id="L3268">        piece3: <span class="tok-type">u32</span>,</span>
<span class="line" id="L3269"></span>
<span class="line" id="L3270">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: Float128) <span class="tok-type">f128</span> {</span>
<span class="line" id="L3271">            <span class="tok-kw">const</span> int_bits = <span class="tok-builtin">@as</span>(<span class="tok-type">u128</span>, self.piece0) |</span>
<span class="line" id="L3272">                (<span class="tok-builtin">@as</span>(<span class="tok-type">u128</span>, self.piece1) &lt;&lt; <span class="tok-number">32</span>) |</span>
<span class="line" id="L3273">                (<span class="tok-builtin">@as</span>(<span class="tok-type">u128</span>, self.piece2) &lt;&lt; <span class="tok-number">64</span>) |</span>
<span class="line" id="L3274">                (<span class="tok-builtin">@as</span>(<span class="tok-type">u128</span>, self.piece3) &lt;&lt; <span class="tok-number">96</span>);</span>
<span class="line" id="L3275">            <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">f128</span>, <span class="tok-builtin">@bitCast</span>(int_bits));</span>
<span class="line" id="L3276">        }</span>
<span class="line" id="L3277">    };</span>
<span class="line" id="L3278"></span>
<span class="line" id="L3279">    <span class="tok-comment">/// Trailing is an item per field.</span></span>
<span class="line" id="L3280">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> StructInit = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L3281">        fields_len: <span class="tok-type">u32</span>,</span>
<span class="line" id="L3282"></span>
<span class="line" id="L3283">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Item = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L3284">            <span class="tok-comment">/// The `struct_init_field_type` ZIR instruction for this field init.</span></span>
<span class="line" id="L3285">            field_type: Index,</span>
<span class="line" id="L3286">            <span class="tok-comment">/// The field init expression to be used as the field value. This value will be coerced</span></span>
<span class="line" id="L3287">            <span class="tok-comment">/// to the field type if not already.</span></span>
<span class="line" id="L3288">            init: Ref,</span>
<span class="line" id="L3289">        };</span>
<span class="line" id="L3290">    };</span>
<span class="line" id="L3291"></span>
<span class="line" id="L3292">    <span class="tok-comment">/// Trailing is an Item per field.</span></span>
<span class="line" id="L3293">    <span class="tok-comment">/// TODO make this instead array of inits followed by array of names because</span></span>
<span class="line" id="L3294">    <span class="tok-comment">/// it will be simpler Sema code and better for CPU cache.</span></span>
<span class="line" id="L3295">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> StructInitAnon = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L3296">        fields_len: <span class="tok-type">u32</span>,</span>
<span class="line" id="L3297"></span>
<span class="line" id="L3298">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Item = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L3299">            <span class="tok-comment">/// Null-terminated string table index.</span></span>
<span class="line" id="L3300">            field_name: NullTerminatedString,</span>
<span class="line" id="L3301">            <span class="tok-comment">/// The field init expression to be used as the field value.</span></span>
<span class="line" id="L3302">            init: Ref,</span>
<span class="line" id="L3303">        };</span>
<span class="line" id="L3304">    };</span>
<span class="line" id="L3305"></span>
<span class="line" id="L3306">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> FieldType = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L3307">        container_type: Ref,</span>
<span class="line" id="L3308">        <span class="tok-comment">/// Offset into `string_bytes`, null terminated.</span></span>
<span class="line" id="L3309">        name_start: NullTerminatedString,</span>
<span class="line" id="L3310">    };</span>
<span class="line" id="L3311"></span>
<span class="line" id="L3312">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> FieldTypeRef = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L3313">        container_type: Ref,</span>
<span class="line" id="L3314">        field_name: Ref,</span>
<span class="line" id="L3315">    };</span>
<span class="line" id="L3316"></span>
<span class="line" id="L3317">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Cmpxchg = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L3318">        node: <span class="tok-type">i32</span>,</span>
<span class="line" id="L3319">        ptr: Ref,</span>
<span class="line" id="L3320">        expected_value: Ref,</span>
<span class="line" id="L3321">        new_value: Ref,</span>
<span class="line" id="L3322">        success_order: Ref,</span>
<span class="line" id="L3323">        failure_order: Ref,</span>
<span class="line" id="L3324">    };</span>
<span class="line" id="L3325"></span>
<span class="line" id="L3326">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> AtomicRmw = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L3327">        ptr: Ref,</span>
<span class="line" id="L3328">        operation: Ref,</span>
<span class="line" id="L3329">        operand: Ref,</span>
<span class="line" id="L3330">        ordering: Ref,</span>
<span class="line" id="L3331">    };</span>
<span class="line" id="L3332"></span>
<span class="line" id="L3333">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> UnionInit = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L3334">        union_type: Ref,</span>
<span class="line" id="L3335">        field_name: Ref,</span>
<span class="line" id="L3336">        init: Ref,</span>
<span class="line" id="L3337">    };</span>
<span class="line" id="L3338"></span>
<span class="line" id="L3339">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> AtomicStore = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L3340">        ptr: Ref,</span>
<span class="line" id="L3341">        operand: Ref,</span>
<span class="line" id="L3342">        ordering: Ref,</span>
<span class="line" id="L3343">    };</span>
<span class="line" id="L3344"></span>
<span class="line" id="L3345">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> AtomicLoad = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L3346">        elem_type: Ref,</span>
<span class="line" id="L3347">        ptr: Ref,</span>
<span class="line" id="L3348">        ordering: Ref,</span>
<span class="line" id="L3349">    };</span>
<span class="line" id="L3350"></span>
<span class="line" id="L3351">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> MulAdd = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L3352">        mulend1: Ref,</span>
<span class="line" id="L3353">        mulend2: Ref,</span>
<span class="line" id="L3354">        addend: Ref,</span>
<span class="line" id="L3355">    };</span>
<span class="line" id="L3356"></span>
<span class="line" id="L3357">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> FieldParentPtr = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L3358">        parent_type: Ref,</span>
<span class="line" id="L3359">        field_name: Ref,</span>
<span class="line" id="L3360">        field_ptr: Ref,</span>
<span class="line" id="L3361">    };</span>
<span class="line" id="L3362"></span>
<span class="line" id="L3363">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Shuffle = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L3364">        elem_type: Ref,</span>
<span class="line" id="L3365">        a: Ref,</span>
<span class="line" id="L3366">        b: Ref,</span>
<span class="line" id="L3367">        mask: Ref,</span>
<span class="line" id="L3368">    };</span>
<span class="line" id="L3369"></span>
<span class="line" id="L3370">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Select = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L3371">        node: <span class="tok-type">i32</span>,</span>
<span class="line" id="L3372">        elem_type: Ref,</span>
<span class="line" id="L3373">        pred: Ref,</span>
<span class="line" id="L3374">        a: Ref,</span>
<span class="line" id="L3375">        b: Ref,</span>
<span class="line" id="L3376">    };</span>
<span class="line" id="L3377"></span>
<span class="line" id="L3378">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> AsyncCall = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L3379">        node: <span class="tok-type">i32</span>,</span>
<span class="line" id="L3380">        frame_buffer: Ref,</span>
<span class="line" id="L3381">        result_ptr: Ref,</span>
<span class="line" id="L3382">        fn_ptr: Ref,</span>
<span class="line" id="L3383">        args: Ref,</span>
<span class="line" id="L3384">    };</span>
<span class="line" id="L3385"></span>
<span class="line" id="L3386">    <span class="tok-comment">/// Trailing: inst: Index // for every body_len</span></span>
<span class="line" id="L3387">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Param = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L3388">        <span class="tok-comment">/// Null-terminated string index.</span></span>
<span class="line" id="L3389">        name: NullTerminatedString,</span>
<span class="line" id="L3390">        <span class="tok-comment">/// Null-terminated string index.</span></span>
<span class="line" id="L3391">        doc_comment: NullTerminatedString,</span>
<span class="line" id="L3392">        <span class="tok-comment">/// The body contains the type of the parameter.</span></span>
<span class="line" id="L3393">        body_len: <span class="tok-type">u32</span>,</span>
<span class="line" id="L3394">    };</span>
<span class="line" id="L3395"></span>
<span class="line" id="L3396">    <span class="tok-comment">/// Trailing:</span></span>
<span class="line" id="L3397">    <span class="tok-comment">/// 0. type_inst: Ref,  // if small 0b000X is set</span></span>
<span class="line" id="L3398">    <span class="tok-comment">/// 1. align_inst: Ref, // if small 0b00X0 is set</span></span>
<span class="line" id="L3399">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> AllocExtended = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L3400">        src_node: <span class="tok-type">i32</span>,</span>
<span class="line" id="L3401"></span>
<span class="line" id="L3402">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Small = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {</span>
<span class="line" id="L3403">            has_type: <span class="tok-type">bool</span>,</span>
<span class="line" id="L3404">            has_align: <span class="tok-type">bool</span>,</span>
<span class="line" id="L3405">            is_const: <span class="tok-type">bool</span>,</span>
<span class="line" id="L3406">            is_comptime: <span class="tok-type">bool</span>,</span>
<span class="line" id="L3407">            _: <span class="tok-type">u12</span> = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L3408">        };</span>
<span class="line" id="L3409">    };</span>
<span class="line" id="L3410"></span>
<span class="line" id="L3411">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Export = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L3412">        <span class="tok-comment">/// If present, this is referring to a Decl via field access, e.g. `a.b`.</span></span>
<span class="line" id="L3413">        <span class="tok-comment">/// If omitted, this is referring to a Decl via identifier, e.g. `a`.</span></span>
<span class="line" id="L3414">        namespace: Ref,</span>
<span class="line" id="L3415">        <span class="tok-comment">/// Null-terminated string index.</span></span>
<span class="line" id="L3416">        decl_name: NullTerminatedString,</span>
<span class="line" id="L3417">        options: Ref,</span>
<span class="line" id="L3418">    };</span>
<span class="line" id="L3419"></span>
<span class="line" id="L3420">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ExportValue = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L3421">        <span class="tok-comment">/// The comptime value to export.</span></span>
<span class="line" id="L3422">        operand: Ref,</span>
<span class="line" id="L3423">        options: Ref,</span>
<span class="line" id="L3424">    };</span>
<span class="line" id="L3425"></span>
<span class="line" id="L3426">    <span class="tok-comment">/// Trailing: `CompileErrors.Item` for each `items_len`.</span></span>
<span class="line" id="L3427">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> CompileErrors = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L3428">        items_len: <span class="tok-type">u32</span>,</span>
<span class="line" id="L3429"></span>
<span class="line" id="L3430">        <span class="tok-comment">/// Trailing: `note_payload_index: u32` for each `notes_len`.</span></span>
<span class="line" id="L3431">        <span class="tok-comment">/// It's a payload index of another `Item`.</span></span>
<span class="line" id="L3432">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Item = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L3433">            <span class="tok-comment">/// null terminated string index</span></span>
<span class="line" id="L3434">            msg: NullTerminatedString,</span>
<span class="line" id="L3435">            node: Ast.Node.Index,</span>
<span class="line" id="L3436">            <span class="tok-comment">/// If node is 0 then this will be populated.</span></span>
<span class="line" id="L3437">            token: Ast.TokenIndex,</span>
<span class="line" id="L3438">            <span class="tok-comment">/// Can be used in combination with `token`.</span></span>
<span class="line" id="L3439">            byte_offset: <span class="tok-type">u32</span>,</span>
<span class="line" id="L3440">            <span class="tok-comment">/// 0 or a payload index of a `Block`, each is a payload</span></span>
<span class="line" id="L3441">            <span class="tok-comment">/// index of another `Item`.</span></span>
<span class="line" id="L3442">            notes: <span class="tok-type">u32</span>,</span>
<span class="line" id="L3443"></span>
<span class="line" id="L3444">            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">notesLen</span>(item: Item, zir: Zir) <span class="tok-type">u32</span> {</span>
<span class="line" id="L3445">                <span class="tok-kw">if</span> (item.notes == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-number">0</span>;</span>
<span class="line" id="L3446">                <span class="tok-kw">const</span> block = zir.extraData(Block, item.notes);</span>
<span class="line" id="L3447">                <span class="tok-kw">return</span> block.data.body_len;</span>
<span class="line" id="L3448">            }</span>
<span class="line" id="L3449">        };</span>
<span class="line" id="L3450">    };</span>
<span class="line" id="L3451"></span>
<span class="line" id="L3452">    <span class="tok-comment">/// Trailing: for each `imports_len` there is an Item</span></span>
<span class="line" id="L3453">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Imports = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L3454">        imports_len: <span class="tok-type">u32</span>,</span>
<span class="line" id="L3455"></span>
<span class="line" id="L3456">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Item = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L3457">            <span class="tok-comment">/// null terminated string index</span></span>
<span class="line" id="L3458">            name: NullTerminatedString,</span>
<span class="line" id="L3459">            <span class="tok-comment">/// points to the import name</span></span>
<span class="line" id="L3460">            token: Ast.TokenIndex,</span>
<span class="line" id="L3461">        };</span>
<span class="line" id="L3462">    };</span>
<span class="line" id="L3463"></span>
<span class="line" id="L3464">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> LineColumn = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L3465">        line: <span class="tok-type">u32</span>,</span>
<span class="line" id="L3466">        column: <span class="tok-type">u32</span>,</span>
<span class="line" id="L3467">    };</span>
<span class="line" id="L3468"></span>
<span class="line" id="L3469">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ArrayInit = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L3470">        ty: Ref,</span>
<span class="line" id="L3471">        init_count: <span class="tok-type">u32</span>,</span>
<span class="line" id="L3472">    };</span>
<span class="line" id="L3473"></span>
<span class="line" id="L3474">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Src = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L3475">        node: <span class="tok-type">i32</span>,</span>
<span class="line" id="L3476">        line: <span class="tok-type">u32</span>,</span>
<span class="line" id="L3477">        column: <span class="tok-type">u32</span>,</span>
<span class="line" id="L3478">    };</span>
<span class="line" id="L3479"></span>
<span class="line" id="L3480">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> DeferErrCode = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L3481">        remapped_err_code: Index,</span>
<span class="line" id="L3482">        index: <span class="tok-type">u32</span>,</span>
<span class="line" id="L3483">        len: <span class="tok-type">u32</span>,</span>
<span class="line" id="L3484">    };</span>
<span class="line" id="L3485"></span>
<span class="line" id="L3486">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ValidateDestructure = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L3487">        <span class="tok-comment">/// The value being destructured.</span></span>
<span class="line" id="L3488">        operand: Ref,</span>
<span class="line" id="L3489">        <span class="tok-comment">/// The `destructure_assign` node.</span></span>
<span class="line" id="L3490">        destructure_node: <span class="tok-type">i32</span>,</span>
<span class="line" id="L3491">        <span class="tok-comment">/// The expected field count.</span></span>
<span class="line" id="L3492">        expect_len: <span class="tok-type">u32</span>,</span>
<span class="line" id="L3493">    };</span>
<span class="line" id="L3494"></span>
<span class="line" id="L3495">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ArrayMul = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L3496">        <span class="tok-comment">/// The result type of the array multiplication operation, or `.none` if none was available.</span></span>
<span class="line" id="L3497">        res_ty: Ref,</span>
<span class="line" id="L3498">        <span class="tok-comment">/// The LHS of the array multiplication.</span></span>
<span class="line" id="L3499">        lhs: Ref,</span>
<span class="line" id="L3500">        <span class="tok-comment">/// The RHS of the array multiplication.</span></span>
<span class="line" id="L3501">        rhs: Ref,</span>
<span class="line" id="L3502">    };</span>
<span class="line" id="L3503"></span>
<span class="line" id="L3504">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> RestoreErrRetIndex = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L3505">        src_node: <span class="tok-type">i32</span>,</span>
<span class="line" id="L3506">        <span class="tok-comment">/// If `.none`, restore the trace to its state upon function entry.</span></span>
<span class="line" id="L3507">        block: Ref,</span>
<span class="line" id="L3508">        <span class="tok-comment">/// If `.none`, restore unconditionally.</span></span>
<span class="line" id="L3509">        operand: Ref,</span>
<span class="line" id="L3510"></span>
<span class="line" id="L3511">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">src</span>(self: RestoreErrRetIndex) LazySrcLoc {</span>
<span class="line" id="L3512">            <span class="tok-kw">return</span> LazySrcLoc.nodeOffset(self.src_node);</span>
<span class="line" id="L3513">        }</span>
<span class="line" id="L3514">    };</span>
<span class="line" id="L3515">};</span>
<span class="line" id="L3516"></span>
<span class="line" id="L3517"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> SpecialProng = <span class="tok-kw">enum</span> { none, @&quot;else&quot;, under };</span>
<span class="line" id="L3518"></span>
<span class="line" id="L3519"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> DeclIterator = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L3520">    extra_index: <span class="tok-type">u32</span>,</span>
<span class="line" id="L3521">    decls_remaining: <span class="tok-type">u32</span>,</span>
<span class="line" id="L3522">    zir: Zir,</span>
<span class="line" id="L3523"></span>
<span class="line" id="L3524">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(it: *DeclIterator) ?Inst.Index {</span>
<span class="line" id="L3525">        <span class="tok-kw">if</span> (it.decls_remaining == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L3526">        <span class="tok-kw">const</span> decl_inst: Zir.Inst.Index = <span class="tok-builtin">@enumFromInt</span>(it.zir.extra[it.extra_index]);</span>
<span class="line" id="L3527">        it.extra_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L3528">        it.decls_remaining -= <span class="tok-number">1</span>;</span>
<span class="line" id="L3529">        assert(it.zir.instructions.items(.tag)[<span class="tok-builtin">@intFromEnum</span>(decl_inst)] == .declaration);</span>
<span class="line" id="L3530">        <span class="tok-kw">return</span> decl_inst;</span>
<span class="line" id="L3531">    }</span>
<span class="line" id="L3532">};</span>
<span class="line" id="L3533"></span>
<span class="line" id="L3534"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">declIterator</span>(zir: Zir, decl_inst: Zir.Inst.Index) DeclIterator {</span>
<span class="line" id="L3535">    <span class="tok-kw">const</span> tags = zir.instructions.items(.tag);</span>
<span class="line" id="L3536">    <span class="tok-kw">const</span> datas = zir.instructions.items(.data);</span>
<span class="line" id="L3537">    <span class="tok-kw">switch</span> (tags[<span class="tok-builtin">@intFromEnum</span>(decl_inst)]) {</span>
<span class="line" id="L3538">        <span class="tok-comment">// Functions are allowed and yield no iterations.</span>
</span>
<span class="line" id="L3539">        <span class="tok-comment">// There is one case matching this in the extended instruction set below.</span>
</span>
<span class="line" id="L3540">        .func, .func_inferred, .func_fancy =&gt; <span class="tok-kw">return</span> .{</span>
<span class="line" id="L3541">            .extra_index = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L3542">            .decls_remaining = <span class="tok-number">0</span>,</span>
<span class="line" id="L3543">            .zir = zir,</span>
<span class="line" id="L3544">        },</span>
<span class="line" id="L3545"></span>
<span class="line" id="L3546">        .extended =&gt; {</span>
<span class="line" id="L3547">            <span class="tok-kw">const</span> extended = datas[<span class="tok-builtin">@intFromEnum</span>(decl_inst)].extended;</span>
<span class="line" id="L3548">            <span class="tok-kw">switch</span> (extended.opcode) {</span>
<span class="line" id="L3549">                .struct_decl =&gt; {</span>
<span class="line" id="L3550">                    <span class="tok-kw">const</span> small: Inst.StructDecl.Small = <span class="tok-builtin">@bitCast</span>(extended.small);</span>
<span class="line" id="L3551">                    <span class="tok-kw">var</span> extra_index: <span class="tok-type">u32</span> = <span class="tok-builtin">@intCast</span>(extended.operand + <span class="tok-builtin">@typeInfo</span>(Inst.StructDecl).Struct.fields.len);</span>
<span class="line" id="L3552">                    <span class="tok-kw">const</span> captures_len = <span class="tok-kw">if</span> (small.has_captures_len) captures_len: {</span>
<span class="line" id="L3553">                        <span class="tok-kw">const</span> captures_len = zir.extra[extra_index];</span>
<span class="line" id="L3554">                        extra_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L3555">                        <span class="tok-kw">break</span> :captures_len captures_len;</span>
<span class="line" id="L3556">                    } <span class="tok-kw">else</span> <span class="tok-number">0</span>;</span>
<span class="line" id="L3557">                    extra_index += <span class="tok-builtin">@intFromBool</span>(small.has_fields_len);</span>
<span class="line" id="L3558">                    <span class="tok-kw">const</span> decls_len = <span class="tok-kw">if</span> (small.has_decls_len) decls_len: {</span>
<span class="line" id="L3559">                        <span class="tok-kw">const</span> decls_len = zir.extra[extra_index];</span>
<span class="line" id="L3560">                        extra_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L3561">                        <span class="tok-kw">break</span> :decls_len decls_len;</span>
<span class="line" id="L3562">                    } <span class="tok-kw">else</span> <span class="tok-number">0</span>;</span>
<span class="line" id="L3563"></span>
<span class="line" id="L3564">                    extra_index += captures_len;</span>
<span class="line" id="L3565"></span>
<span class="line" id="L3566">                    <span class="tok-kw">if</span> (small.has_backing_int) {</span>
<span class="line" id="L3567">                        <span class="tok-kw">const</span> backing_int_body_len = zir.extra[extra_index];</span>
<span class="line" id="L3568">                        extra_index += <span class="tok-number">1</span>; <span class="tok-comment">// backing_int_body_len</span>
</span>
<span class="line" id="L3569">                        <span class="tok-kw">if</span> (backing_int_body_len == <span class="tok-number">0</span>) {</span>
<span class="line" id="L3570">                            extra_index += <span class="tok-number">1</span>; <span class="tok-comment">// backing_int_ref</span>
</span>
<span class="line" id="L3571">                        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L3572">                            extra_index += backing_int_body_len; <span class="tok-comment">// backing_int_body_inst</span>
</span>
<span class="line" id="L3573">                        }</span>
<span class="line" id="L3574">                    }</span>
<span class="line" id="L3575"></span>
<span class="line" id="L3576">                    <span class="tok-kw">return</span> .{</span>
<span class="line" id="L3577">                        .extra_index = extra_index,</span>
<span class="line" id="L3578">                        .decls_remaining = decls_len,</span>
<span class="line" id="L3579">                        .zir = zir,</span>
<span class="line" id="L3580">                    };</span>
<span class="line" id="L3581">                },</span>
<span class="line" id="L3582">                .enum_decl =&gt; {</span>
<span class="line" id="L3583">                    <span class="tok-kw">const</span> small: Inst.EnumDecl.Small = <span class="tok-builtin">@bitCast</span>(extended.small);</span>
<span class="line" id="L3584">                    <span class="tok-kw">var</span> extra_index: <span class="tok-type">u32</span> = <span class="tok-builtin">@intCast</span>(extended.operand + <span class="tok-builtin">@typeInfo</span>(Inst.EnumDecl).Struct.fields.len);</span>
<span class="line" id="L3585">                    extra_index += <span class="tok-builtin">@intFromBool</span>(small.has_tag_type);</span>
<span class="line" id="L3586">                    <span class="tok-kw">const</span> captures_len = <span class="tok-kw">if</span> (small.has_captures_len) captures_len: {</span>
<span class="line" id="L3587">                        <span class="tok-kw">const</span> captures_len = zir.extra[extra_index];</span>
<span class="line" id="L3588">                        extra_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L3589">                        <span class="tok-kw">break</span> :captures_len captures_len;</span>
<span class="line" id="L3590">                    } <span class="tok-kw">else</span> <span class="tok-number">0</span>;</span>
<span class="line" id="L3591">                    extra_index += <span class="tok-builtin">@intFromBool</span>(small.has_body_len);</span>
<span class="line" id="L3592">                    extra_index += <span class="tok-builtin">@intFromBool</span>(small.has_fields_len);</span>
<span class="line" id="L3593">                    <span class="tok-kw">const</span> decls_len = <span class="tok-kw">if</span> (small.has_decls_len) decls_len: {</span>
<span class="line" id="L3594">                        <span class="tok-kw">const</span> decls_len = zir.extra[extra_index];</span>
<span class="line" id="L3595">                        extra_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L3596">                        <span class="tok-kw">break</span> :decls_len decls_len;</span>
<span class="line" id="L3597">                    } <span class="tok-kw">else</span> <span class="tok-number">0</span>;</span>
<span class="line" id="L3598"></span>
<span class="line" id="L3599">                    extra_index += captures_len;</span>
<span class="line" id="L3600"></span>
<span class="line" id="L3601">                    <span class="tok-kw">return</span> .{</span>
<span class="line" id="L3602">                        .extra_index = extra_index,</span>
<span class="line" id="L3603">                        .decls_remaining = decls_len,</span>
<span class="line" id="L3604">                        .zir = zir,</span>
<span class="line" id="L3605">                    };</span>
<span class="line" id="L3606">                },</span>
<span class="line" id="L3607">                .union_decl =&gt; {</span>
<span class="line" id="L3608">                    <span class="tok-kw">const</span> small: Inst.UnionDecl.Small = <span class="tok-builtin">@bitCast</span>(extended.small);</span>
<span class="line" id="L3609">                    <span class="tok-kw">var</span> extra_index: <span class="tok-type">u32</span> = <span class="tok-builtin">@intCast</span>(extended.operand + <span class="tok-builtin">@typeInfo</span>(Inst.UnionDecl).Struct.fields.len);</span>
<span class="line" id="L3610">                    extra_index += <span class="tok-builtin">@intFromBool</span>(small.has_tag_type);</span>
<span class="line" id="L3611">                    <span class="tok-kw">const</span> captures_len = <span class="tok-kw">if</span> (small.has_captures_len) captures_len: {</span>
<span class="line" id="L3612">                        <span class="tok-kw">const</span> captures_len = zir.extra[extra_index];</span>
<span class="line" id="L3613">                        extra_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L3614">                        <span class="tok-kw">break</span> :captures_len captures_len;</span>
<span class="line" id="L3615">                    } <span class="tok-kw">else</span> <span class="tok-number">0</span>;</span>
<span class="line" id="L3616">                    extra_index += <span class="tok-builtin">@intFromBool</span>(small.has_body_len);</span>
<span class="line" id="L3617">                    extra_index += <span class="tok-builtin">@intFromBool</span>(small.has_fields_len);</span>
<span class="line" id="L3618">                    <span class="tok-kw">const</span> decls_len = <span class="tok-kw">if</span> (small.has_decls_len) decls_len: {</span>
<span class="line" id="L3619">                        <span class="tok-kw">const</span> decls_len = zir.extra[extra_index];</span>
<span class="line" id="L3620">                        extra_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L3621">                        <span class="tok-kw">break</span> :decls_len decls_len;</span>
<span class="line" id="L3622">                    } <span class="tok-kw">else</span> <span class="tok-number">0</span>;</span>
<span class="line" id="L3623"></span>
<span class="line" id="L3624">                    extra_index += captures_len;</span>
<span class="line" id="L3625"></span>
<span class="line" id="L3626">                    <span class="tok-kw">return</span> .{</span>
<span class="line" id="L3627">                        .extra_index = extra_index,</span>
<span class="line" id="L3628">                        .decls_remaining = decls_len,</span>
<span class="line" id="L3629">                        .zir = zir,</span>
<span class="line" id="L3630">                    };</span>
<span class="line" id="L3631">                },</span>
<span class="line" id="L3632">                .opaque_decl =&gt; {</span>
<span class="line" id="L3633">                    <span class="tok-kw">const</span> small: Inst.OpaqueDecl.Small = <span class="tok-builtin">@bitCast</span>(extended.small);</span>
<span class="line" id="L3634">                    <span class="tok-kw">var</span> extra_index: <span class="tok-type">u32</span> = <span class="tok-builtin">@intCast</span>(extended.operand + <span class="tok-builtin">@typeInfo</span>(Inst.OpaqueDecl).Struct.fields.len);</span>
<span class="line" id="L3635">                    <span class="tok-kw">const</span> decls_len = <span class="tok-kw">if</span> (small.has_decls_len) decls_len: {</span>
<span class="line" id="L3636">                        <span class="tok-kw">const</span> decls_len = zir.extra[extra_index];</span>
<span class="line" id="L3637">                        extra_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L3638">                        <span class="tok-kw">break</span> :decls_len decls_len;</span>
<span class="line" id="L3639">                    } <span class="tok-kw">else</span> <span class="tok-number">0</span>;</span>
<span class="line" id="L3640">                    <span class="tok-kw">const</span> captures_len = <span class="tok-kw">if</span> (small.has_captures_len) captures_len: {</span>
<span class="line" id="L3641">                        <span class="tok-kw">const</span> captures_len = zir.extra[extra_index];</span>
<span class="line" id="L3642">                        extra_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L3643">                        <span class="tok-kw">break</span> :captures_len captures_len;</span>
<span class="line" id="L3644">                    } <span class="tok-kw">else</span> <span class="tok-number">0</span>;</span>
<span class="line" id="L3645"></span>
<span class="line" id="L3646">                    extra_index += captures_len;</span>
<span class="line" id="L3647"></span>
<span class="line" id="L3648">                    <span class="tok-kw">return</span> .{</span>
<span class="line" id="L3649">                        .extra_index = extra_index,</span>
<span class="line" id="L3650">                        .decls_remaining = decls_len,</span>
<span class="line" id="L3651">                        .zir = zir,</span>
<span class="line" id="L3652">                    };</span>
<span class="line" id="L3653">                },</span>
<span class="line" id="L3654">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L3655">            }</span>
<span class="line" id="L3656">        },</span>
<span class="line" id="L3657">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L3658">    }</span>
<span class="line" id="L3659">}</span>
<span class="line" id="L3660"></span>
<span class="line" id="L3661"><span class="tok-comment">/// The iterator would have to allocate memory anyway to iterate. So here we populate</span></span>
<span class="line" id="L3662"><span class="tok-comment">/// an ArrayList as the result.</span></span>
<span class="line" id="L3663"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">findDecls</span>(zir: Zir, list: *std.ArrayList(Inst.Index), decl_inst: Zir.Inst.Index) !<span class="tok-type">void</span> {</span>
<span class="line" id="L3664">    list.clearRetainingCapacity();</span>
<span class="line" id="L3665">    <span class="tok-kw">const</span> declaration, <span class="tok-kw">const</span> extra_end = zir.getDeclaration(decl_inst);</span>
<span class="line" id="L3666">    <span class="tok-kw">const</span> bodies = declaration.getBodies(extra_end, zir);</span>
<span class="line" id="L3667"></span>
<span class="line" id="L3668">    <span class="tok-kw">try</span> zir.findDeclsBody(list, bodies.value_body);</span>
<span class="line" id="L3669">    <span class="tok-kw">if</span> (bodies.align_body) |b| <span class="tok-kw">try</span> zir.findDeclsBody(list, b);</span>
<span class="line" id="L3670">    <span class="tok-kw">if</span> (bodies.linksection_body) |b| <span class="tok-kw">try</span> zir.findDeclsBody(list, b);</span>
<span class="line" id="L3671">    <span class="tok-kw">if</span> (bodies.addrspace_body) |b| <span class="tok-kw">try</span> zir.findDeclsBody(list, b);</span>
<span class="line" id="L3672">}</span>
<span class="line" id="L3673"></span>
<span class="line" id="L3674"><span class="tok-kw">fn</span> <span class="tok-fn">findDeclsInner</span>(</span>
<span class="line" id="L3675">    zir: Zir,</span>
<span class="line" id="L3676">    list: *std.ArrayList(Inst.Index),</span>
<span class="line" id="L3677">    inst: Inst.Index,</span>
<span class="line" id="L3678">) Allocator.Error!<span class="tok-type">void</span> {</span>
<span class="line" id="L3679">    <span class="tok-kw">const</span> tags = zir.instructions.items(.tag);</span>
<span class="line" id="L3680">    <span class="tok-kw">const</span> datas = zir.instructions.items(.data);</span>
<span class="line" id="L3681"></span>
<span class="line" id="L3682">    <span class="tok-kw">switch</span> (tags[<span class="tok-builtin">@intFromEnum</span>(inst)]) {</span>
<span class="line" id="L3683">        <span class="tok-comment">// Functions instructions are interesting and have a body.</span>
</span>
<span class="line" id="L3684">        .func,</span>
<span class="line" id="L3685">        .func_inferred,</span>
<span class="line" id="L3686">        =&gt; {</span>
<span class="line" id="L3687">            <span class="tok-kw">try</span> list.append(inst);</span>
<span class="line" id="L3688"></span>
<span class="line" id="L3689">            <span class="tok-kw">const</span> inst_data = datas[<span class="tok-builtin">@intFromEnum</span>(inst)].pl_node;</span>
<span class="line" id="L3690">            <span class="tok-kw">const</span> extra = zir.extraData(Inst.Func, inst_data.payload_index);</span>
<span class="line" id="L3691">            <span class="tok-kw">var</span> extra_index: <span class="tok-type">usize</span> = extra.end;</span>
<span class="line" id="L3692">            <span class="tok-kw">switch</span> (extra.data.ret_body_len) {</span>
<span class="line" id="L3693">                <span class="tok-number">0</span> =&gt; {},</span>
<span class="line" id="L3694">                <span class="tok-number">1</span> =&gt; extra_index += <span class="tok-number">1</span>,</span>
<span class="line" id="L3695">                <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L3696">                    <span class="tok-kw">const</span> body = zir.bodySlice(extra_index, extra.data.ret_body_len);</span>
<span class="line" id="L3697">                    extra_index += body.len;</span>
<span class="line" id="L3698">                    <span class="tok-kw">try</span> zir.findDeclsBody(list, body);</span>
<span class="line" id="L3699">                },</span>
<span class="line" id="L3700">            }</span>
<span class="line" id="L3701">            <span class="tok-kw">const</span> body = zir.bodySlice(extra_index, extra.data.body_len);</span>
<span class="line" id="L3702">            <span class="tok-kw">return</span> zir.findDeclsBody(list, body);</span>
<span class="line" id="L3703">        },</span>
<span class="line" id="L3704">        .func_fancy =&gt; {</span>
<span class="line" id="L3705">            <span class="tok-kw">try</span> list.append(inst);</span>
<span class="line" id="L3706"></span>
<span class="line" id="L3707">            <span class="tok-kw">const</span> inst_data = datas[<span class="tok-builtin">@intFromEnum</span>(inst)].pl_node;</span>
<span class="line" id="L3708">            <span class="tok-kw">const</span> extra = zir.extraData(Inst.FuncFancy, inst_data.payload_index);</span>
<span class="line" id="L3709">            <span class="tok-kw">var</span> extra_index: <span class="tok-type">usize</span> = extra.end;</span>
<span class="line" id="L3710">            extra_index += <span class="tok-builtin">@intFromBool</span>(extra.data.bits.has_lib_name);</span>
<span class="line" id="L3711"></span>
<span class="line" id="L3712">            <span class="tok-kw">if</span> (extra.data.bits.has_align_body) {</span>
<span class="line" id="L3713">                <span class="tok-kw">const</span> body_len = zir.extra[extra_index];</span>
<span class="line" id="L3714">                extra_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L3715">                <span class="tok-kw">const</span> body = zir.bodySlice(extra_index, body_len);</span>
<span class="line" id="L3716">                <span class="tok-kw">try</span> zir.findDeclsBody(list, body);</span>
<span class="line" id="L3717">                extra_index += body.len;</span>
<span class="line" id="L3718">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (extra.data.bits.has_align_ref) {</span>
<span class="line" id="L3719">                extra_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L3720">            }</span>
<span class="line" id="L3721"></span>
<span class="line" id="L3722">            <span class="tok-kw">if</span> (extra.data.bits.has_addrspace_body) {</span>
<span class="line" id="L3723">                <span class="tok-kw">const</span> body_len = zir.extra[extra_index];</span>
<span class="line" id="L3724">                extra_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L3725">                <span class="tok-kw">const</span> body = zir.bodySlice(extra_index, body_len);</span>
<span class="line" id="L3726">                <span class="tok-kw">try</span> zir.findDeclsBody(list, body);</span>
<span class="line" id="L3727">                extra_index += body.len;</span>
<span class="line" id="L3728">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (extra.data.bits.has_addrspace_ref) {</span>
<span class="line" id="L3729">                extra_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L3730">            }</span>
<span class="line" id="L3731"></span>
<span class="line" id="L3732">            <span class="tok-kw">if</span> (extra.data.bits.has_section_body) {</span>
<span class="line" id="L3733">                <span class="tok-kw">const</span> body_len = zir.extra[extra_index];</span>
<span class="line" id="L3734">                extra_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L3735">                <span class="tok-kw">const</span> body = zir.bodySlice(extra_index, body_len);</span>
<span class="line" id="L3736">                <span class="tok-kw">try</span> zir.findDeclsBody(list, body);</span>
<span class="line" id="L3737">                extra_index += body.len;</span>
<span class="line" id="L3738">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (extra.data.bits.has_section_ref) {</span>
<span class="line" id="L3739">                extra_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L3740">            }</span>
<span class="line" id="L3741"></span>
<span class="line" id="L3742">            <span class="tok-kw">if</span> (extra.data.bits.has_cc_body) {</span>
<span class="line" id="L3743">                <span class="tok-kw">const</span> body_len = zir.extra[extra_index];</span>
<span class="line" id="L3744">                extra_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L3745">                <span class="tok-kw">const</span> body = zir.bodySlice(extra_index, body_len);</span>
<span class="line" id="L3746">                <span class="tok-kw">try</span> zir.findDeclsBody(list, body);</span>
<span class="line" id="L3747">                extra_index += body.len;</span>
<span class="line" id="L3748">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (extra.data.bits.has_cc_ref) {</span>
<span class="line" id="L3749">                extra_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L3750">            }</span>
<span class="line" id="L3751"></span>
<span class="line" id="L3752">            <span class="tok-kw">if</span> (extra.data.bits.has_ret_ty_body) {</span>
<span class="line" id="L3753">                <span class="tok-kw">const</span> body_len = zir.extra[extra_index];</span>
<span class="line" id="L3754">                extra_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L3755">                <span class="tok-kw">const</span> body = zir.bodySlice(extra_index, body_len);</span>
<span class="line" id="L3756">                <span class="tok-kw">try</span> zir.findDeclsBody(list, body);</span>
<span class="line" id="L3757">                extra_index += body.len;</span>
<span class="line" id="L3758">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (extra.data.bits.has_ret_ty_ref) {</span>
<span class="line" id="L3759">                extra_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L3760">            }</span>
<span class="line" id="L3761"></span>
<span class="line" id="L3762">            extra_index += <span class="tok-builtin">@intFromBool</span>(extra.data.bits.has_any_noalias);</span>
<span class="line" id="L3763"></span>
<span class="line" id="L3764">            <span class="tok-kw">const</span> body = zir.bodySlice(extra_index, extra.data.body_len);</span>
<span class="line" id="L3765">            <span class="tok-kw">return</span> zir.findDeclsBody(list, body);</span>
<span class="line" id="L3766">        },</span>
<span class="line" id="L3767">        .extended =&gt; {</span>
<span class="line" id="L3768">            <span class="tok-kw">const</span> extended = datas[<span class="tok-builtin">@intFromEnum</span>(inst)].extended;</span>
<span class="line" id="L3769">            <span class="tok-kw">switch</span> (extended.opcode) {</span>
<span class="line" id="L3770"></span>
<span class="line" id="L3771">                <span class="tok-comment">// Decl instructions are interesting but have no body.</span>
</span>
<span class="line" id="L3772">                <span class="tok-comment">// TODO yes they do have a body actually. recurse over them just like block instructions.</span>
</span>
<span class="line" id="L3773">                .struct_decl,</span>
<span class="line" id="L3774">                .union_decl,</span>
<span class="line" id="L3775">                .enum_decl,</span>
<span class="line" id="L3776">                .opaque_decl,</span>
<span class="line" id="L3777">                =&gt; <span class="tok-kw">return</span> list.append(inst),</span>
<span class="line" id="L3778"></span>
<span class="line" id="L3779">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span>,</span>
<span class="line" id="L3780">            }</span>
<span class="line" id="L3781">        },</span>
<span class="line" id="L3782"></span>
<span class="line" id="L3783">        <span class="tok-comment">// Block instructions, recurse over the bodies.</span>
</span>
<span class="line" id="L3784"></span>
<span class="line" id="L3785">        .block, .block_comptime, .block_inline =&gt; {</span>
<span class="line" id="L3786">            <span class="tok-kw">const</span> inst_data = datas[<span class="tok-builtin">@intFromEnum</span>(inst)].pl_node;</span>
<span class="line" id="L3787">            <span class="tok-kw">const</span> extra = zir.extraData(Inst.Block, inst_data.payload_index);</span>
<span class="line" id="L3788">            <span class="tok-kw">const</span> body = zir.bodySlice(extra.end, extra.data.body_len);</span>
<span class="line" id="L3789">            <span class="tok-kw">return</span> zir.findDeclsBody(list, body);</span>
<span class="line" id="L3790">        },</span>
<span class="line" id="L3791">        .condbr, .condbr_inline =&gt; {</span>
<span class="line" id="L3792">            <span class="tok-kw">const</span> inst_data = datas[<span class="tok-builtin">@intFromEnum</span>(inst)].pl_node;</span>
<span class="line" id="L3793">            <span class="tok-kw">const</span> extra = zir.extraData(Inst.CondBr, inst_data.payload_index);</span>
<span class="line" id="L3794">            <span class="tok-kw">const</span> then_body = zir.bodySlice(extra.end, extra.data.then_body_len);</span>
<span class="line" id="L3795">            <span class="tok-kw">const</span> else_body = zir.bodySlice(extra.end + then_body.len, extra.data.else_body_len);</span>
<span class="line" id="L3796">            <span class="tok-kw">try</span> zir.findDeclsBody(list, then_body);</span>
<span class="line" id="L3797">            <span class="tok-kw">try</span> zir.findDeclsBody(list, else_body);</span>
<span class="line" id="L3798">        },</span>
<span class="line" id="L3799">        .@&quot;try&quot;, .try_ptr =&gt; {</span>
<span class="line" id="L3800">            <span class="tok-kw">const</span> inst_data = datas[<span class="tok-builtin">@intFromEnum</span>(inst)].pl_node;</span>
<span class="line" id="L3801">            <span class="tok-kw">const</span> extra = zir.extraData(Inst.Try, inst_data.payload_index);</span>
<span class="line" id="L3802">            <span class="tok-kw">const</span> body = zir.bodySlice(extra.end, extra.data.body_len);</span>
<span class="line" id="L3803">            <span class="tok-kw">try</span> zir.findDeclsBody(list, body);</span>
<span class="line" id="L3804">        },</span>
<span class="line" id="L3805">        .switch_block =&gt; <span class="tok-kw">return</span> findDeclsSwitch(zir, list, inst),</span>
<span class="line" id="L3806"></span>
<span class="line" id="L3807">        .suspend_block =&gt; <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;TODO iterate suspend block&quot;</span>),</span>
<span class="line" id="L3808"></span>
<span class="line" id="L3809">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span>, <span class="tok-comment">// Regular instruction, not interesting.</span>
</span>
<span class="line" id="L3810">    }</span>
<span class="line" id="L3811">}</span>
<span class="line" id="L3812"></span>
<span class="line" id="L3813"><span class="tok-kw">fn</span> <span class="tok-fn">findDeclsSwitch</span>(</span>
<span class="line" id="L3814">    zir: Zir,</span>
<span class="line" id="L3815">    list: *std.ArrayList(Inst.Index),</span>
<span class="line" id="L3816">    inst: Inst.Index,</span>
<span class="line" id="L3817">) Allocator.Error!<span class="tok-type">void</span> {</span>
<span class="line" id="L3818">    <span class="tok-kw">const</span> inst_data = zir.instructions.items(.data)[<span class="tok-builtin">@intFromEnum</span>(inst)].pl_node;</span>
<span class="line" id="L3819">    <span class="tok-kw">const</span> extra = zir.extraData(Inst.SwitchBlock, inst_data.payload_index);</span>
<span class="line" id="L3820"></span>
<span class="line" id="L3821">    <span class="tok-kw">var</span> extra_index: <span class="tok-type">usize</span> = extra.end;</span>
<span class="line" id="L3822"></span>
<span class="line" id="L3823">    <span class="tok-kw">const</span> multi_cases_len = <span class="tok-kw">if</span> (extra.data.bits.has_multi_cases) blk: {</span>
<span class="line" id="L3824">        <span class="tok-kw">const</span> multi_cases_len = zir.extra[extra_index];</span>
<span class="line" id="L3825">        extra_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L3826">        <span class="tok-kw">break</span> :blk multi_cases_len;</span>
<span class="line" id="L3827">    } <span class="tok-kw">else</span> <span class="tok-number">0</span>;</span>
<span class="line" id="L3828"></span>
<span class="line" id="L3829">    <span class="tok-kw">const</span> special_prong = extra.data.bits.specialProng();</span>
<span class="line" id="L3830">    <span class="tok-kw">if</span> (special_prong != .none) {</span>
<span class="line" id="L3831">        <span class="tok-kw">const</span> body_len: <span class="tok-type">u31</span> = <span class="tok-builtin">@truncate</span>(zir.extra[extra_index]);</span>
<span class="line" id="L3832">        extra_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L3833">        <span class="tok-kw">const</span> body = zir.bodySlice(extra_index, body_len);</span>
<span class="line" id="L3834">        extra_index += body.len;</span>
<span class="line" id="L3835"></span>
<span class="line" id="L3836">        <span class="tok-kw">try</span> zir.findDeclsBody(list, body);</span>
<span class="line" id="L3837">    }</span>
<span class="line" id="L3838"></span>
<span class="line" id="L3839">    {</span>
<span class="line" id="L3840">        <span class="tok-kw">const</span> scalar_cases_len = extra.data.bits.scalar_cases_len;</span>
<span class="line" id="L3841">        <span class="tok-kw">for</span> (<span class="tok-number">0</span>..scalar_cases_len) |_| {</span>
<span class="line" id="L3842">            extra_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L3843">            <span class="tok-kw">const</span> body_len: <span class="tok-type">u31</span> = <span class="tok-builtin">@truncate</span>(zir.extra[extra_index]);</span>
<span class="line" id="L3844">            extra_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L3845">            <span class="tok-kw">const</span> body = zir.bodySlice(extra_index, body_len);</span>
<span class="line" id="L3846">            extra_index += body_len;</span>
<span class="line" id="L3847"></span>
<span class="line" id="L3848">            <span class="tok-kw">try</span> zir.findDeclsBody(list, body);</span>
<span class="line" id="L3849">        }</span>
<span class="line" id="L3850">    }</span>
<span class="line" id="L3851">    {</span>
<span class="line" id="L3852">        <span class="tok-kw">for</span> (<span class="tok-number">0</span>..multi_cases_len) |_| {</span>
<span class="line" id="L3853">            <span class="tok-kw">const</span> items_len = zir.extra[extra_index];</span>
<span class="line" id="L3854">            extra_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L3855">            <span class="tok-kw">const</span> ranges_len = zir.extra[extra_index];</span>
<span class="line" id="L3856">            extra_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L3857">            <span class="tok-kw">const</span> body_len: <span class="tok-type">u31</span> = <span class="tok-builtin">@truncate</span>(zir.extra[extra_index]);</span>
<span class="line" id="L3858">            extra_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L3859">            <span class="tok-kw">const</span> items = zir.refSlice(extra_index, items_len);</span>
<span class="line" id="L3860">            extra_index += items_len;</span>
<span class="line" id="L3861">            _ = items;</span>
<span class="line" id="L3862"></span>
<span class="line" id="L3863">            <span class="tok-kw">var</span> range_i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L3864">            <span class="tok-kw">while</span> (range_i &lt; ranges_len) : (range_i += <span class="tok-number">1</span>) {</span>
<span class="line" id="L3865">                extra_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L3866">                extra_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L3867">            }</span>
<span class="line" id="L3868"></span>
<span class="line" id="L3869">            <span class="tok-kw">const</span> body = zir.bodySlice(extra_index, body_len);</span>
<span class="line" id="L3870">            extra_index += body_len;</span>
<span class="line" id="L3871"></span>
<span class="line" id="L3872">            <span class="tok-kw">try</span> zir.findDeclsBody(list, body);</span>
<span class="line" id="L3873">        }</span>
<span class="line" id="L3874">    }</span>
<span class="line" id="L3875">}</span>
<span class="line" id="L3876"></span>
<span class="line" id="L3877"><span class="tok-kw">fn</span> <span class="tok-fn">findDeclsBody</span>(</span>
<span class="line" id="L3878">    zir: Zir,</span>
<span class="line" id="L3879">    list: *std.ArrayList(Inst.Index),</span>
<span class="line" id="L3880">    body: []<span class="tok-kw">const</span> Inst.Index,</span>
<span class="line" id="L3881">) Allocator.Error!<span class="tok-type">void</span> {</span>
<span class="line" id="L3882">    <span class="tok-kw">for</span> (body) |member| {</span>
<span class="line" id="L3883">        <span class="tok-kw">try</span> zir.findDeclsInner(list, member);</span>
<span class="line" id="L3884">    }</span>
<span class="line" id="L3885">}</span>
<span class="line" id="L3886"></span>
<span class="line" id="L3887"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> FnInfo = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L3888">    param_body: []<span class="tok-kw">const</span> Inst.Index,</span>
<span class="line" id="L3889">    param_body_inst: Inst.Index,</span>
<span class="line" id="L3890">    ret_ty_body: []<span class="tok-kw">const</span> Inst.Index,</span>
<span class="line" id="L3891">    body: []<span class="tok-kw">const</span> Inst.Index,</span>
<span class="line" id="L3892">    ret_ty_ref: Zir.Inst.Ref,</span>
<span class="line" id="L3893">    total_params_len: <span class="tok-type">u32</span>,</span>
<span class="line" id="L3894">};</span>
<span class="line" id="L3895"></span>
<span class="line" id="L3896"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getParamBody</span>(zir: Zir, fn_inst: Inst.Index) []<span class="tok-kw">const</span> Zir.Inst.Index {</span>
<span class="line" id="L3897">    <span class="tok-kw">const</span> tags = zir.instructions.items(.tag);</span>
<span class="line" id="L3898">    <span class="tok-kw">const</span> datas = zir.instructions.items(.data);</span>
<span class="line" id="L3899">    <span class="tok-kw">const</span> inst_data = datas[<span class="tok-builtin">@intFromEnum</span>(fn_inst)].pl_node;</span>
<span class="line" id="L3900"></span>
<span class="line" id="L3901">    <span class="tok-kw">const</span> param_block_index = <span class="tok-kw">switch</span> (tags[<span class="tok-builtin">@intFromEnum</span>(fn_inst)]) {</span>
<span class="line" id="L3902">        .func, .func_inferred =&gt; blk: {</span>
<span class="line" id="L3903">            <span class="tok-kw">const</span> extra = zir.extraData(Inst.Func, inst_data.payload_index);</span>
<span class="line" id="L3904">            <span class="tok-kw">break</span> :blk extra.data.param_block;</span>
<span class="line" id="L3905">        },</span>
<span class="line" id="L3906">        .func_fancy =&gt; blk: {</span>
<span class="line" id="L3907">            <span class="tok-kw">const</span> extra = zir.extraData(Inst.FuncFancy, inst_data.payload_index);</span>
<span class="line" id="L3908">            <span class="tok-kw">break</span> :blk extra.data.param_block;</span>
<span class="line" id="L3909">        },</span>
<span class="line" id="L3910">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L3911">    };</span>
<span class="line" id="L3912"></span>
<span class="line" id="L3913">    <span class="tok-kw">switch</span> (tags[<span class="tok-builtin">@intFromEnum</span>(param_block_index)]) {</span>
<span class="line" id="L3914">        .block, .block_comptime, .block_inline =&gt; {</span>
<span class="line" id="L3915">            <span class="tok-kw">const</span> param_block = zir.extraData(Inst.Block, datas[<span class="tok-builtin">@intFromEnum</span>(param_block_index)].pl_node.payload_index);</span>
<span class="line" id="L3916">            <span class="tok-kw">return</span> zir.bodySlice(param_block.end, param_block.data.body_len);</span>
<span class="line" id="L3917">        },</span>
<span class="line" id="L3918">        .declaration =&gt; {</span>
<span class="line" id="L3919">            <span class="tok-kw">const</span> decl, <span class="tok-kw">const</span> extra_end = zir.getDeclaration(param_block_index);</span>
<span class="line" id="L3920">            <span class="tok-kw">return</span> decl.getBodies(extra_end, zir).value_body;</span>
<span class="line" id="L3921">        },</span>
<span class="line" id="L3922">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L3923">    }</span>
<span class="line" id="L3924">}</span>
<span class="line" id="L3925"></span>
<span class="line" id="L3926"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getFnInfo</span>(zir: Zir, fn_inst: Inst.Index) FnInfo {</span>
<span class="line" id="L3927">    <span class="tok-kw">const</span> tags = zir.instructions.items(.tag);</span>
<span class="line" id="L3928">    <span class="tok-kw">const</span> datas = zir.instructions.items(.data);</span>
<span class="line" id="L3929">    <span class="tok-kw">const</span> info: <span class="tok-kw">struct</span> {</span>
<span class="line" id="L3930">        param_block: Inst.Index,</span>
<span class="line" id="L3931">        body: []<span class="tok-kw">const</span> Inst.Index,</span>
<span class="line" id="L3932">        ret_ty_ref: Inst.Ref,</span>
<span class="line" id="L3933">        ret_ty_body: []<span class="tok-kw">const</span> Inst.Index,</span>
<span class="line" id="L3934">    } = <span class="tok-kw">switch</span> (tags[<span class="tok-builtin">@intFromEnum</span>(fn_inst)]) {</span>
<span class="line" id="L3935">        .func, .func_inferred =&gt; blk: {</span>
<span class="line" id="L3936">            <span class="tok-kw">const</span> inst_data = datas[<span class="tok-builtin">@intFromEnum</span>(fn_inst)].pl_node;</span>
<span class="line" id="L3937">            <span class="tok-kw">const</span> extra = zir.extraData(Inst.Func, inst_data.payload_index);</span>
<span class="line" id="L3938"></span>
<span class="line" id="L3939">            <span class="tok-kw">var</span> extra_index: <span class="tok-type">usize</span> = extra.end;</span>
<span class="line" id="L3940">            <span class="tok-kw">var</span> ret_ty_ref: Inst.Ref = .none;</span>
<span class="line" id="L3941">            <span class="tok-kw">var</span> ret_ty_body: []<span class="tok-kw">const</span> Inst.Index = &amp;.{};</span>
<span class="line" id="L3942"></span>
<span class="line" id="L3943">            <span class="tok-kw">switch</span> (extra.data.ret_body_len) {</span>
<span class="line" id="L3944">                <span class="tok-number">0</span> =&gt; {</span>
<span class="line" id="L3945">                    ret_ty_ref = .void_type;</span>
<span class="line" id="L3946">                },</span>
<span class="line" id="L3947">                <span class="tok-number">1</span> =&gt; {</span>
<span class="line" id="L3948">                    ret_ty_ref = <span class="tok-builtin">@enumFromInt</span>(zir.extra[extra_index]);</span>
<span class="line" id="L3949">                    extra_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L3950">                },</span>
<span class="line" id="L3951">                <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L3952">                    ret_ty_body = zir.bodySlice(extra_index, extra.data.ret_body_len);</span>
<span class="line" id="L3953">                    extra_index += ret_ty_body.len;</span>
<span class="line" id="L3954">                },</span>
<span class="line" id="L3955">            }</span>
<span class="line" id="L3956"></span>
<span class="line" id="L3957">            <span class="tok-kw">const</span> body = zir.bodySlice(extra_index, extra.data.body_len);</span>
<span class="line" id="L3958">            extra_index += body.len;</span>
<span class="line" id="L3959"></span>
<span class="line" id="L3960">            <span class="tok-kw">break</span> :blk .{</span>
<span class="line" id="L3961">                .param_block = extra.data.param_block,</span>
<span class="line" id="L3962">                .ret_ty_ref = ret_ty_ref,</span>
<span class="line" id="L3963">                .ret_ty_body = ret_ty_body,</span>
<span class="line" id="L3964">                .body = body,</span>
<span class="line" id="L3965">            };</span>
<span class="line" id="L3966">        },</span>
<span class="line" id="L3967">        .func_fancy =&gt; blk: {</span>
<span class="line" id="L3968">            <span class="tok-kw">const</span> inst_data = datas[<span class="tok-builtin">@intFromEnum</span>(fn_inst)].pl_node;</span>
<span class="line" id="L3969">            <span class="tok-kw">const</span> extra = zir.extraData(Inst.FuncFancy, inst_data.payload_index);</span>
<span class="line" id="L3970"></span>
<span class="line" id="L3971">            <span class="tok-kw">var</span> extra_index: <span class="tok-type">usize</span> = extra.end;</span>
<span class="line" id="L3972">            <span class="tok-kw">var</span> ret_ty_ref: Inst.Ref = .void_type;</span>
<span class="line" id="L3973">            <span class="tok-kw">var</span> ret_ty_body: []<span class="tok-kw">const</span> Inst.Index = &amp;.{};</span>
<span class="line" id="L3974"></span>
<span class="line" id="L3975">            extra_index += <span class="tok-builtin">@intFromBool</span>(extra.data.bits.has_lib_name);</span>
<span class="line" id="L3976">            <span class="tok-kw">if</span> (extra.data.bits.has_align_body) {</span>
<span class="line" id="L3977">                extra_index += zir.extra[extra_index] + <span class="tok-number">1</span>;</span>
<span class="line" id="L3978">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (extra.data.bits.has_align_ref) {</span>
<span class="line" id="L3979">                extra_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L3980">            }</span>
<span class="line" id="L3981">            <span class="tok-kw">if</span> (extra.data.bits.has_addrspace_body) {</span>
<span class="line" id="L3982">                extra_index += zir.extra[extra_index] + <span class="tok-number">1</span>;</span>
<span class="line" id="L3983">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (extra.data.bits.has_addrspace_ref) {</span>
<span class="line" id="L3984">                extra_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L3985">            }</span>
<span class="line" id="L3986">            <span class="tok-kw">if</span> (extra.data.bits.has_section_body) {</span>
<span class="line" id="L3987">                extra_index += zir.extra[extra_index] + <span class="tok-number">1</span>;</span>
<span class="line" id="L3988">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (extra.data.bits.has_section_ref) {</span>
<span class="line" id="L3989">                extra_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L3990">            }</span>
<span class="line" id="L3991">            <span class="tok-kw">if</span> (extra.data.bits.has_cc_body) {</span>
<span class="line" id="L3992">                extra_index += zir.extra[extra_index] + <span class="tok-number">1</span>;</span>
<span class="line" id="L3993">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (extra.data.bits.has_cc_ref) {</span>
<span class="line" id="L3994">                extra_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L3995">            }</span>
<span class="line" id="L3996">            <span class="tok-kw">if</span> (extra.data.bits.has_ret_ty_body) {</span>
<span class="line" id="L3997">                <span class="tok-kw">const</span> body_len = zir.extra[extra_index];</span>
<span class="line" id="L3998">                extra_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L3999">                ret_ty_body = zir.bodySlice(extra_index, body_len);</span>
<span class="line" id="L4000">                extra_index += ret_ty_body.len;</span>
<span class="line" id="L4001">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (extra.data.bits.has_ret_ty_ref) {</span>
<span class="line" id="L4002">                ret_ty_ref = <span class="tok-builtin">@enumFromInt</span>(zir.extra[extra_index]);</span>
<span class="line" id="L4003">                extra_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L4004">            }</span>
<span class="line" id="L4005"></span>
<span class="line" id="L4006">            extra_index += <span class="tok-builtin">@intFromBool</span>(extra.data.bits.has_any_noalias);</span>
<span class="line" id="L4007"></span>
<span class="line" id="L4008">            <span class="tok-kw">const</span> body = zir.bodySlice(extra_index, extra.data.body_len);</span>
<span class="line" id="L4009">            extra_index += body.len;</span>
<span class="line" id="L4010">            <span class="tok-kw">break</span> :blk .{</span>
<span class="line" id="L4011">                .param_block = extra.data.param_block,</span>
<span class="line" id="L4012">                .ret_ty_ref = ret_ty_ref,</span>
<span class="line" id="L4013">                .ret_ty_body = ret_ty_body,</span>
<span class="line" id="L4014">                .body = body,</span>
<span class="line" id="L4015">            };</span>
<span class="line" id="L4016">        },</span>
<span class="line" id="L4017">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L4018">    };</span>
<span class="line" id="L4019">    <span class="tok-kw">const</span> param_body = <span class="tok-kw">switch</span> (tags[<span class="tok-builtin">@intFromEnum</span>(info.param_block)]) {</span>
<span class="line" id="L4020">        .block, .block_comptime, .block_inline =&gt; param_body: {</span>
<span class="line" id="L4021">            <span class="tok-kw">const</span> param_block = zir.extraData(Inst.Block, datas[<span class="tok-builtin">@intFromEnum</span>(info.param_block)].pl_node.payload_index);</span>
<span class="line" id="L4022">            <span class="tok-kw">break</span> :param_body zir.bodySlice(param_block.end, param_block.data.body_len);</span>
<span class="line" id="L4023">        },</span>
<span class="line" id="L4024">        .declaration =&gt; param_body: {</span>
<span class="line" id="L4025">            <span class="tok-kw">const</span> decl, <span class="tok-kw">const</span> extra_end = zir.getDeclaration(info.param_block);</span>
<span class="line" id="L4026">            <span class="tok-kw">break</span> :param_body decl.getBodies(extra_end, zir).value_body;</span>
<span class="line" id="L4027">        },</span>
<span class="line" id="L4028">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L4029">    };</span>
<span class="line" id="L4030">    <span class="tok-kw">var</span> total_params_len: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L4031">    <span class="tok-kw">for</span> (param_body) |inst| {</span>
<span class="line" id="L4032">        <span class="tok-kw">switch</span> (tags[<span class="tok-builtin">@intFromEnum</span>(inst)]) {</span>
<span class="line" id="L4033">            .param, .param_comptime, .param_anytype, .param_anytype_comptime =&gt; {</span>
<span class="line" id="L4034">                total_params_len += <span class="tok-number">1</span>;</span>
<span class="line" id="L4035">            },</span>
<span class="line" id="L4036">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">continue</span>,</span>
<span class="line" id="L4037">        }</span>
<span class="line" id="L4038">    }</span>
<span class="line" id="L4039">    <span class="tok-kw">return</span> .{</span>
<span class="line" id="L4040">        .param_body = param_body,</span>
<span class="line" id="L4041">        .param_body_inst = info.param_block,</span>
<span class="line" id="L4042">        .ret_ty_body = info.ret_ty_body,</span>
<span class="line" id="L4043">        .ret_ty_ref = info.ret_ty_ref,</span>
<span class="line" id="L4044">        .body = info.body,</span>
<span class="line" id="L4045">        .total_params_len = total_params_len,</span>
<span class="line" id="L4046">    };</span>
<span class="line" id="L4047">}</span>
<span class="line" id="L4048"></span>
<span class="line" id="L4049"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getDeclaration</span>(zir: Zir, inst: Zir.Inst.Index) <span class="tok-kw">struct</span> { Inst.Declaration, <span class="tok-type">u32</span> } {</span>
<span class="line" id="L4050">    assert(zir.instructions.items(.tag)[<span class="tok-builtin">@intFromEnum</span>(inst)] == .declaration);</span>
<span class="line" id="L4051">    <span class="tok-kw">const</span> pl_node = zir.instructions.items(.data)[<span class="tok-builtin">@intFromEnum</span>(inst)].pl_node;</span>
<span class="line" id="L4052">    <span class="tok-kw">const</span> extra = zir.extraData(Inst.Declaration, pl_node.payload_index);</span>
<span class="line" id="L4053">    <span class="tok-kw">return</span> .{</span>
<span class="line" id="L4054">        extra.data,</span>
<span class="line" id="L4055">        <span class="tok-builtin">@intCast</span>(extra.end),</span>
<span class="line" id="L4056">    };</span>
<span class="line" id="L4057">}</span>
<span class="line" id="L4058"></span>
<span class="line" id="L4059"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAssociatedSrcHash</span>(zir: Zir, inst: Zir.Inst.Index) ?std.zig.SrcHash {</span>
<span class="line" id="L4060">    <span class="tok-kw">const</span> tag = zir.instructions.items(.tag);</span>
<span class="line" id="L4061">    <span class="tok-kw">const</span> data = zir.instructions.items(.data);</span>
<span class="line" id="L4062">    <span class="tok-kw">switch</span> (tag[<span class="tok-builtin">@intFromEnum</span>(inst)]) {</span>
<span class="line" id="L4063">        .declaration =&gt; {</span>
<span class="line" id="L4064">            <span class="tok-kw">const</span> pl_node = data[<span class="tok-builtin">@intFromEnum</span>(inst)].pl_node;</span>
<span class="line" id="L4065">            <span class="tok-kw">const</span> extra = zir.extraData(Inst.Declaration, pl_node.payload_index);</span>
<span class="line" id="L4066">            <span class="tok-kw">return</span> <span class="tok-builtin">@bitCast</span>([<span class="tok-number">4</span>]<span class="tok-type">u32</span>{</span>
<span class="line" id="L4067">                extra.data.src_hash_0,</span>
<span class="line" id="L4068">                extra.data.src_hash_1,</span>
<span class="line" id="L4069">                extra.data.src_hash_2,</span>
<span class="line" id="L4070">                extra.data.src_hash_3,</span>
<span class="line" id="L4071">            });</span>
<span class="line" id="L4072">        },</span>
<span class="line" id="L4073">        .func, .func_inferred =&gt; {</span>
<span class="line" id="L4074">            <span class="tok-kw">const</span> pl_node = data[<span class="tok-builtin">@intFromEnum</span>(inst)].pl_node;</span>
<span class="line" id="L4075">            <span class="tok-kw">const</span> extra = zir.extraData(Inst.Func, pl_node.payload_index);</span>
<span class="line" id="L4076">            <span class="tok-kw">if</span> (extra.data.body_len == <span class="tok-number">0</span>) {</span>
<span class="line" id="L4077">                <span class="tok-comment">// Function type or extern fn - no associated hash</span>
</span>
<span class="line" id="L4078">                <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L4079">            }</span>
<span class="line" id="L4080">            <span class="tok-kw">const</span> extra_index = extra.end +</span>
<span class="line" id="L4081">                <span class="tok-number">1</span> +</span>
<span class="line" id="L4082">                extra.data.body_len +</span>
<span class="line" id="L4083">                <span class="tok-builtin">@typeInfo</span>(Inst.Func.SrcLocs).Struct.fields.len;</span>
<span class="line" id="L4084">            <span class="tok-kw">return</span> <span class="tok-builtin">@bitCast</span>([<span class="tok-number">4</span>]<span class="tok-type">u32</span>{</span>
<span class="line" id="L4085">                zir.extra[extra_index + <span class="tok-number">0</span>],</span>
<span class="line" id="L4086">                zir.extra[extra_index + <span class="tok-number">1</span>],</span>
<span class="line" id="L4087">                zir.extra[extra_index + <span class="tok-number">2</span>],</span>
<span class="line" id="L4088">                zir.extra[extra_index + <span class="tok-number">3</span>],</span>
<span class="line" id="L4089">            });</span>
<span class="line" id="L4090">        },</span>
<span class="line" id="L4091">        .func_fancy =&gt; {</span>
<span class="line" id="L4092">            <span class="tok-kw">const</span> pl_node = data[<span class="tok-builtin">@intFromEnum</span>(inst)].pl_node;</span>
<span class="line" id="L4093">            <span class="tok-kw">const</span> extra = zir.extraData(Inst.FuncFancy, pl_node.payload_index);</span>
<span class="line" id="L4094">            <span class="tok-kw">if</span> (extra.data.body_len == <span class="tok-number">0</span>) {</span>
<span class="line" id="L4095">                <span class="tok-comment">// Function type or extern fn - no associated hash</span>
</span>
<span class="line" id="L4096">                <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L4097">            }</span>
<span class="line" id="L4098">            <span class="tok-kw">const</span> bits = extra.data.bits;</span>
<span class="line" id="L4099">            <span class="tok-kw">var</span> extra_index = extra.end;</span>
<span class="line" id="L4100">            extra_index += <span class="tok-builtin">@intFromBool</span>(bits.has_lib_name);</span>
<span class="line" id="L4101">            <span class="tok-kw">if</span> (bits.has_align_body) {</span>
<span class="line" id="L4102">                <span class="tok-kw">const</span> body_len = zir.extra[extra_index];</span>
<span class="line" id="L4103">                extra_index += <span class="tok-number">1</span> + body_len;</span>
<span class="line" id="L4104">            } <span class="tok-kw">else</span> extra_index += <span class="tok-builtin">@intFromBool</span>(bits.has_align_ref);</span>
<span class="line" id="L4105">            <span class="tok-kw">if</span> (bits.has_addrspace_body) {</span>
<span class="line" id="L4106">                <span class="tok-kw">const</span> body_len = zir.extra[extra_index];</span>
<span class="line" id="L4107">                extra_index += <span class="tok-number">1</span> + body_len;</span>
<span class="line" id="L4108">            } <span class="tok-kw">else</span> extra_index += <span class="tok-builtin">@intFromBool</span>(bits.has_addrspace_ref);</span>
<span class="line" id="L4109">            <span class="tok-kw">if</span> (bits.has_section_body) {</span>
<span class="line" id="L4110">                <span class="tok-kw">const</span> body_len = zir.extra[extra_index];</span>
<span class="line" id="L4111">                extra_index += <span class="tok-number">1</span> + body_len;</span>
<span class="line" id="L4112">            } <span class="tok-kw">else</span> extra_index += <span class="tok-builtin">@intFromBool</span>(bits.has_section_ref);</span>
<span class="line" id="L4113">            <span class="tok-kw">if</span> (bits.has_cc_body) {</span>
<span class="line" id="L4114">                <span class="tok-kw">const</span> body_len = zir.extra[extra_index];</span>
<span class="line" id="L4115">                extra_index += <span class="tok-number">1</span> + body_len;</span>
<span class="line" id="L4116">            } <span class="tok-kw">else</span> extra_index += <span class="tok-builtin">@intFromBool</span>(bits.has_cc_ref);</span>
<span class="line" id="L4117">            <span class="tok-kw">if</span> (bits.has_ret_ty_body) {</span>
<span class="line" id="L4118">                <span class="tok-kw">const</span> body_len = zir.extra[extra_index];</span>
<span class="line" id="L4119">                extra_index += <span class="tok-number">1</span> + body_len;</span>
<span class="line" id="L4120">            } <span class="tok-kw">else</span> extra_index += <span class="tok-builtin">@intFromBool</span>(bits.has_ret_ty_ref);</span>
<span class="line" id="L4121">            extra_index += <span class="tok-builtin">@intFromBool</span>(bits.has_any_noalias);</span>
<span class="line" id="L4122">            extra_index += extra.data.body_len;</span>
<span class="line" id="L4123">            extra_index += <span class="tok-builtin">@typeInfo</span>(Zir.Inst.Func.SrcLocs).Struct.fields.len;</span>
<span class="line" id="L4124">            <span class="tok-kw">return</span> <span class="tok-builtin">@bitCast</span>([<span class="tok-number">4</span>]<span class="tok-type">u32</span>{</span>
<span class="line" id="L4125">                zir.extra[extra_index + <span class="tok-number">0</span>],</span>
<span class="line" id="L4126">                zir.extra[extra_index + <span class="tok-number">1</span>],</span>
<span class="line" id="L4127">                zir.extra[extra_index + <span class="tok-number">2</span>],</span>
<span class="line" id="L4128">                zir.extra[extra_index + <span class="tok-number">3</span>],</span>
<span class="line" id="L4129">            });</span>
<span class="line" id="L4130">        },</span>
<span class="line" id="L4131">        .extended =&gt; {},</span>
<span class="line" id="L4132">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-null">null</span>,</span>
<span class="line" id="L4133">    }</span>
<span class="line" id="L4134">    <span class="tok-kw">const</span> extended = data[<span class="tok-builtin">@intFromEnum</span>(inst)].extended;</span>
<span class="line" id="L4135">    <span class="tok-kw">switch</span> (extended.opcode) {</span>
<span class="line" id="L4136">        .struct_decl =&gt; {</span>
<span class="line" id="L4137">            <span class="tok-kw">const</span> extra = zir.extraData(Inst.StructDecl, extended.operand).data;</span>
<span class="line" id="L4138">            <span class="tok-kw">return</span> <span class="tok-builtin">@bitCast</span>([<span class="tok-number">4</span>]<span class="tok-type">u32</span>{</span>
<span class="line" id="L4139">                extra.fields_hash_0,</span>
<span class="line" id="L4140">                extra.fields_hash_1,</span>
<span class="line" id="L4141">                extra.fields_hash_2,</span>
<span class="line" id="L4142">                extra.fields_hash_3,</span>
<span class="line" id="L4143">            });</span>
<span class="line" id="L4144">        },</span>
<span class="line" id="L4145">        .union_decl =&gt; {</span>
<span class="line" id="L4146">            <span class="tok-kw">const</span> extra = zir.extraData(Inst.UnionDecl, extended.operand).data;</span>
<span class="line" id="L4147">            <span class="tok-kw">return</span> <span class="tok-builtin">@bitCast</span>([<span class="tok-number">4</span>]<span class="tok-type">u32</span>{</span>
<span class="line" id="L4148">                extra.fields_hash_0,</span>
<span class="line" id="L4149">                extra.fields_hash_1,</span>
<span class="line" id="L4150">                extra.fields_hash_2,</span>
<span class="line" id="L4151">                extra.fields_hash_3,</span>
<span class="line" id="L4152">            });</span>
<span class="line" id="L4153">        },</span>
<span class="line" id="L4154">        .enum_decl =&gt; {</span>
<span class="line" id="L4155">            <span class="tok-kw">const</span> extra = zir.extraData(Inst.EnumDecl, extended.operand).data;</span>
<span class="line" id="L4156">            <span class="tok-kw">return</span> <span class="tok-builtin">@bitCast</span>([<span class="tok-number">4</span>]<span class="tok-type">u32</span>{</span>
<span class="line" id="L4157">                extra.fields_hash_0,</span>
<span class="line" id="L4158">                extra.fields_hash_1,</span>
<span class="line" id="L4159">                extra.fields_hash_2,</span>
<span class="line" id="L4160">                extra.fields_hash_3,</span>
<span class="line" id="L4161">            });</span>
<span class="line" id="L4162">        },</span>
<span class="line" id="L4163">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-null">null</span>,</span>
<span class="line" id="L4164">    }</span>
<span class="line" id="L4165">}</span>
<span class="line" id="L4166"></span>
</code></pre></body>
</html>