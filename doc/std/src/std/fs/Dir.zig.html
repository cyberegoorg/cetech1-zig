<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>fs/Dir.zig - source view</title>
    <link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAgklEQVR4AWMYWuD7EllJIM4G4g4g5oIJ/odhOJ8wToOxSTXgNxDHoeiBMfA4+wGShjyYOCkG/IGqWQziEzYAoUAeiF9D5U+DxEg14DRU7jWIT5IBIOdCxf+A+CQZAAoopEB7QJwBCBwHiip8UYmRdrAlDpIMgApwQZNnNii5Dq0MBgCxxycBnwEd+wAAAABJRU5ErkJggg==">
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style>
      body{
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        margin: 0;
        line-height: 1.5;
      }

      pre > code {
        display: block;
        overflow: auto;
        line-height: normal;
        margin: 0em;
      }
      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #005C7A;
      }
      .tok-comment {
          color: #545454;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #005C5C;
      }
      .tok-number {
          color: #005C5C;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }
      pre {
        counter-reset: line;
      }
      pre .line:before {
        counter-increment: line;
        content: counter(line);
        display: inline-block;
        padding-right: 1em;
        width: 2em;
        text-align: right;
        color: #999;
      }
      
      .line {
        width: 100%;
        display: inline-block;
      }
      .line:target {
        border-top: 1px solid #ccc;
        border-bottom: 1px solid #ccc;
        background: #fafafa;
      }

      @media (prefers-color-scheme: dark) {
        body{
            background:#222;
            color: #ccc;
        }
        pre > code {
            color: #ccc;
            background: #222;
            border: unset;
        }
        .line:target {
            border-top: 1px solid #444;
            border-bottom: 1px solid #444;
            background: #333;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
</head>
<body>
<pre><code><span class="line" id="L1">fd: posix.fd_t,</span>
<span class="line" id="L2"></span>
<span class="line" id="L3"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> default_mode = <span class="tok-number">0o755</span>;</span>
<span class="line" id="L4"></span>
<span class="line" id="L5"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Entry = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L6">    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L7">    kind: Kind,</span>
<span class="line" id="L8"></span>
<span class="line" id="L9">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Kind = File.Kind;</span>
<span class="line" id="L10">};</span>
<span class="line" id="L11"></span>
<span class="line" id="L12"><span class="tok-kw">const</span> IteratorError = <span class="tok-kw">error</span>{</span>
<span class="line" id="L13">    AccessDenied,</span>
<span class="line" id="L14">    SystemResources,</span>
<span class="line" id="L15">    <span class="tok-comment">/// WASI-only. The path of an entry could not be encoded as valid UTF-8.</span></span>
<span class="line" id="L16">    <span class="tok-comment">/// WASI is unable to handle paths that cannot be encoded as well-formed UTF-8.</span></span>
<span class="line" id="L17">    <span class="tok-comment">/// https://github.com/WebAssembly/wasi-filesystem/issues/17#issuecomment-1430639353</span></span>
<span class="line" id="L18">    InvalidUtf8,</span>
<span class="line" id="L19">} || posix.UnexpectedError;</span>
<span class="line" id="L20"></span>
<span class="line" id="L21"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Iterator = <span class="tok-kw">switch</span> (builtin.os.tag) {</span>
<span class="line" id="L22">    .macos, .ios, .freebsd, .netbsd, .dragonfly, .openbsd, .solaris, .illumos =&gt; <span class="tok-kw">struct</span> {</span>
<span class="line" id="L23">        dir: Dir,</span>
<span class="line" id="L24">        seek: <span class="tok-type">i64</span>,</span>
<span class="line" id="L25">        buf: [<span class="tok-number">1024</span>]<span class="tok-type">u8</span>, <span class="tok-comment">// TODO align(@alignOf(posix.system.dirent)),</span>
</span>
<span class="line" id="L26">        index: <span class="tok-type">usize</span>,</span>
<span class="line" id="L27">        end_index: <span class="tok-type">usize</span>,</span>
<span class="line" id="L28">        first_iter: <span class="tok-type">bool</span>,</span>
<span class="line" id="L29"></span>
<span class="line" id="L30">        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();</span>
<span class="line" id="L31"></span>
<span class="line" id="L32">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Error = IteratorError;</span>
<span class="line" id="L33"></span>
<span class="line" id="L34">        <span class="tok-comment">/// Memory such as file names referenced in this returned entry becomes invalid</span></span>
<span class="line" id="L35">        <span class="tok-comment">/// with subsequent calls to `next`, as well as when this `Dir` is deinitialized.</span></span>
<span class="line" id="L36">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *Self) Error!?Entry {</span>
<span class="line" id="L37">            <span class="tok-kw">switch</span> (builtin.os.tag) {</span>
<span class="line" id="L38">                .macos, .ios =&gt; <span class="tok-kw">return</span> self.nextDarwin(),</span>
<span class="line" id="L39">                .freebsd, .netbsd, .dragonfly, .openbsd =&gt; <span class="tok-kw">return</span> self.nextBsd(),</span>
<span class="line" id="L40">                .solaris, .illumos =&gt; <span class="tok-kw">return</span> self.nextSolaris(),</span>
<span class="line" id="L41">                <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;unimplemented&quot;</span>),</span>
<span class="line" id="L42">            }</span>
<span class="line" id="L43">        }</span>
<span class="line" id="L44"></span>
<span class="line" id="L45">        <span class="tok-kw">fn</span> <span class="tok-fn">nextDarwin</span>(self: *Self) !?Entry {</span>
<span class="line" id="L46">            start_over: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L47">                <span class="tok-kw">if</span> (self.index &gt;= self.end_index) {</span>
<span class="line" id="L48">                    <span class="tok-kw">if</span> (self.first_iter) {</span>
<span class="line" id="L49">                        posix.lseek_SET(self.dir.fd, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>; <span class="tok-comment">// EBADF here likely means that the Dir was not opened with iteration permissions</span>
</span>
<span class="line" id="L50">                        self.first_iter = <span class="tok-null">false</span>;</span>
<span class="line" id="L51">                    }</span>
<span class="line" id="L52">                    <span class="tok-kw">const</span> rc = posix.system.__getdirentries64(</span>
<span class="line" id="L53">                        self.dir.fd,</span>
<span class="line" id="L54">                        &amp;self.buf,</span>
<span class="line" id="L55">                        self.buf.len,</span>
<span class="line" id="L56">                        &amp;self.seek,</span>
<span class="line" id="L57">                    );</span>
<span class="line" id="L58">                    <span class="tok-kw">if</span> (rc == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L59">                    <span class="tok-kw">if</span> (rc &lt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L60">                        <span class="tok-kw">switch</span> (posix.errno(rc)) {</span>
<span class="line" id="L61">                            .BADF =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Dir is invalid or was opened without iteration ability</span>
</span>
<span class="line" id="L62">                            .FAULT =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L63">                            .NOTDIR =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L64">                            .INVAL =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L65">                            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> posix.unexpectedErrno(err),</span>
<span class="line" id="L66">                        }</span>
<span class="line" id="L67">                    }</span>
<span class="line" id="L68">                    self.index = <span class="tok-number">0</span>;</span>
<span class="line" id="L69">                    self.end_index = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(rc));</span>
<span class="line" id="L70">                }</span>
<span class="line" id="L71">                <span class="tok-kw">const</span> darwin_entry = <span class="tok-builtin">@as</span>(*<span class="tok-kw">align</span>(<span class="tok-number">1</span>) posix.system.dirent, <span class="tok-builtin">@ptrCast</span>(&amp;self.buf[self.index]));</span>
<span class="line" id="L72">                <span class="tok-kw">const</span> next_index = self.index + darwin_entry.reclen;</span>
<span class="line" id="L73">                self.index = next_index;</span>
<span class="line" id="L74"></span>
<span class="line" id="L75">                <span class="tok-kw">const</span> name = <span class="tok-builtin">@as</span>([*]<span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(&amp;darwin_entry.name))[<span class="tok-number">0</span>..darwin_entry.namlen];</span>
<span class="line" id="L76"></span>
<span class="line" id="L77">                <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;.&quot;</span>) <span class="tok-kw">or</span> mem.eql(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;..&quot;</span>) <span class="tok-kw">or</span> (darwin_entry.ino == <span class="tok-number">0</span>)) {</span>
<span class="line" id="L78">                    <span class="tok-kw">continue</span> :start_over;</span>
<span class="line" id="L79">                }</span>
<span class="line" id="L80"></span>
<span class="line" id="L81">                <span class="tok-kw">const</span> entry_kind: Entry.Kind = <span class="tok-kw">switch</span> (darwin_entry.<span class="tok-type">type</span>) {</span>
<span class="line" id="L82">                    posix.DT.BLK =&gt; .block_device,</span>
<span class="line" id="L83">                    posix.DT.CHR =&gt; .character_device,</span>
<span class="line" id="L84">                    posix.DT.DIR =&gt; .directory,</span>
<span class="line" id="L85">                    posix.DT.FIFO =&gt; .named_pipe,</span>
<span class="line" id="L86">                    posix.DT.LNK =&gt; .sym_link,</span>
<span class="line" id="L87">                    posix.DT.REG =&gt; .file,</span>
<span class="line" id="L88">                    posix.DT.SOCK =&gt; .unix_domain_socket,</span>
<span class="line" id="L89">                    posix.DT.WHT =&gt; .whiteout,</span>
<span class="line" id="L90">                    <span class="tok-kw">else</span> =&gt; .unknown,</span>
<span class="line" id="L91">                };</span>
<span class="line" id="L92">                <span class="tok-kw">return</span> Entry{</span>
<span class="line" id="L93">                    .name = name,</span>
<span class="line" id="L94">                    .kind = entry_kind,</span>
<span class="line" id="L95">                };</span>
<span class="line" id="L96">            }</span>
<span class="line" id="L97">        }</span>
<span class="line" id="L98"></span>
<span class="line" id="L99">        <span class="tok-kw">fn</span> <span class="tok-fn">nextSolaris</span>(self: *Self) !?Entry {</span>
<span class="line" id="L100">            start_over: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L101">                <span class="tok-kw">if</span> (self.index &gt;= self.end_index) {</span>
<span class="line" id="L102">                    <span class="tok-kw">if</span> (self.first_iter) {</span>
<span class="line" id="L103">                        posix.lseek_SET(self.dir.fd, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>; <span class="tok-comment">// EBADF here likely means that the Dir was not opened with iteration permissions</span>
</span>
<span class="line" id="L104">                        self.first_iter = <span class="tok-null">false</span>;</span>
<span class="line" id="L105">                    }</span>
<span class="line" id="L106">                    <span class="tok-kw">const</span> rc = posix.system.getdents(self.dir.fd, &amp;self.buf, self.buf.len);</span>
<span class="line" id="L107">                    <span class="tok-kw">switch</span> (posix.errno(rc)) {</span>
<span class="line" id="L108">                        .SUCCESS =&gt; {},</span>
<span class="line" id="L109">                        .BADF =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Dir is invalid or was opened without iteration ability</span>
</span>
<span class="line" id="L110">                        .FAULT =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L111">                        .NOTDIR =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L112">                        .INVAL =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L113">                        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> posix.unexpectedErrno(err),</span>
<span class="line" id="L114">                    }</span>
<span class="line" id="L115">                    <span class="tok-kw">if</span> (rc == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L116">                    self.index = <span class="tok-number">0</span>;</span>
<span class="line" id="L117">                    self.end_index = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(rc));</span>
<span class="line" id="L118">                }</span>
<span class="line" id="L119">                <span class="tok-kw">const</span> entry = <span class="tok-builtin">@as</span>(*<span class="tok-kw">align</span>(<span class="tok-number">1</span>) posix.system.dirent, <span class="tok-builtin">@ptrCast</span>(&amp;self.buf[self.index]));</span>
<span class="line" id="L120">                <span class="tok-kw">const</span> next_index = self.index + entry.reclen;</span>
<span class="line" id="L121">                self.index = next_index;</span>
<span class="line" id="L122"></span>
<span class="line" id="L123">                <span class="tok-kw">const</span> name = mem.sliceTo(<span class="tok-builtin">@as</span>([*:<span class="tok-number">0</span>]<span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(&amp;entry.name)), <span class="tok-number">0</span>);</span>
<span class="line" id="L124">                <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;.&quot;</span>) <span class="tok-kw">or</span> mem.eql(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;..&quot;</span>))</span>
<span class="line" id="L125">                    <span class="tok-kw">continue</span> :start_over;</span>
<span class="line" id="L126"></span>
<span class="line" id="L127">                <span class="tok-comment">// Solaris dirent doesn't expose type, so we have to call stat to get it.</span>
</span>
<span class="line" id="L128">                <span class="tok-kw">const</span> stat_info = posix.fstatat(</span>
<span class="line" id="L129">                    self.dir.fd,</span>
<span class="line" id="L130">                    name,</span>
<span class="line" id="L131">                    posix.AT.SYMLINK_NOFOLLOW,</span>
<span class="line" id="L132">                ) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L133">                    <span class="tok-kw">error</span>.NameTooLong =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L134">                    <span class="tok-kw">error</span>.SymLinkLoop =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L135">                    <span class="tok-kw">error</span>.FileNotFound =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// lost the race</span>
</span>
<span class="line" id="L136">                    <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L137">                };</span>
<span class="line" id="L138">                <span class="tok-kw">const</span> entry_kind: Entry.Kind = <span class="tok-kw">switch</span> (stat_info.mode &amp; posix.S.IFMT) {</span>
<span class="line" id="L139">                    posix.S.IFIFO =&gt; .named_pipe,</span>
<span class="line" id="L140">                    posix.S.IFCHR =&gt; .character_device,</span>
<span class="line" id="L141">                    posix.S.IFDIR =&gt; .directory,</span>
<span class="line" id="L142">                    posix.S.IFBLK =&gt; .block_device,</span>
<span class="line" id="L143">                    posix.S.IFREG =&gt; .file,</span>
<span class="line" id="L144">                    posix.S.IFLNK =&gt; .sym_link,</span>
<span class="line" id="L145">                    posix.S.IFSOCK =&gt; .unix_domain_socket,</span>
<span class="line" id="L146">                    posix.S.IFDOOR =&gt; .door,</span>
<span class="line" id="L147">                    posix.S.IFPORT =&gt; .event_port,</span>
<span class="line" id="L148">                    <span class="tok-kw">else</span> =&gt; .unknown,</span>
<span class="line" id="L149">                };</span>
<span class="line" id="L150">                <span class="tok-kw">return</span> Entry{</span>
<span class="line" id="L151">                    .name = name,</span>
<span class="line" id="L152">                    .kind = entry_kind,</span>
<span class="line" id="L153">                };</span>
<span class="line" id="L154">            }</span>
<span class="line" id="L155">        }</span>
<span class="line" id="L156"></span>
<span class="line" id="L157">        <span class="tok-kw">fn</span> <span class="tok-fn">nextBsd</span>(self: *Self) !?Entry {</span>
<span class="line" id="L158">            start_over: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L159">                <span class="tok-kw">if</span> (self.index &gt;= self.end_index) {</span>
<span class="line" id="L160">                    <span class="tok-kw">if</span> (self.first_iter) {</span>
<span class="line" id="L161">                        posix.lseek_SET(self.dir.fd, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>; <span class="tok-comment">// EBADF here likely means that the Dir was not opened with iteration permissions</span>
</span>
<span class="line" id="L162">                        self.first_iter = <span class="tok-null">false</span>;</span>
<span class="line" id="L163">                    }</span>
<span class="line" id="L164">                    <span class="tok-kw">const</span> rc = <span class="tok-kw">if</span> (builtin.os.tag == .netbsd)</span>
<span class="line" id="L165">                        posix.system.__getdents30(self.dir.fd, &amp;self.buf, self.buf.len)</span>
<span class="line" id="L166">                    <span class="tok-kw">else</span></span>
<span class="line" id="L167">                        posix.system.getdents(self.dir.fd, &amp;self.buf, self.buf.len);</span>
<span class="line" id="L168">                    <span class="tok-kw">switch</span> (posix.errno(rc)) {</span>
<span class="line" id="L169">                        .SUCCESS =&gt; {},</span>
<span class="line" id="L170">                        .BADF =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Dir is invalid or was opened without iteration ability</span>
</span>
<span class="line" id="L171">                        .FAULT =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L172">                        .NOTDIR =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L173">                        .INVAL =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L174">                        <span class="tok-comment">// Introduced in freebsd 13.2: directory unlinked but still open.</span>
</span>
<span class="line" id="L175">                        <span class="tok-comment">// To be consistent, iteration ends if the directory being iterated is deleted during iteration.</span>
</span>
<span class="line" id="L176">                        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-null">null</span>,</span>
<span class="line" id="L177">                        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> posix.unexpectedErrno(err),</span>
<span class="line" id="L178">                    }</span>
<span class="line" id="L179">                    <span class="tok-kw">if</span> (rc == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L180">                    self.index = <span class="tok-number">0</span>;</span>
<span class="line" id="L181">                    self.end_index = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(rc));</span>
<span class="line" id="L182">                }</span>
<span class="line" id="L183">                <span class="tok-kw">const</span> bsd_entry = <span class="tok-builtin">@as</span>(*<span class="tok-kw">align</span>(<span class="tok-number">1</span>) posix.system.dirent, <span class="tok-builtin">@ptrCast</span>(&amp;self.buf[self.index]));</span>
<span class="line" id="L184">                <span class="tok-kw">const</span> next_index = self.index + <span class="tok-kw">if</span> (<span class="tok-builtin">@hasDecl</span>(posix.system.dirent, <span class="tok-str">&quot;reclen&quot;</span>)) bsd_entry.reclen() <span class="tok-kw">else</span> bsd_entry.reclen;</span>
<span class="line" id="L185">                self.index = next_index;</span>
<span class="line" id="L186"></span>
<span class="line" id="L187">                <span class="tok-kw">const</span> name = <span class="tok-builtin">@as</span>([*]<span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(&amp;bsd_entry.name))[<span class="tok-number">0</span>..bsd_entry.namlen];</span>
<span class="line" id="L188"></span>
<span class="line" id="L189">                <span class="tok-kw">const</span> skip_zero_fileno = <span class="tok-kw">switch</span> (builtin.os.tag) {</span>
<span class="line" id="L190">                    <span class="tok-comment">// fileno=0 is used to mark invalid entries or deleted files.</span>
</span>
<span class="line" id="L191">                    .openbsd, .netbsd =&gt; <span class="tok-null">true</span>,</span>
<span class="line" id="L192">                    <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,</span>
<span class="line" id="L193">                };</span>
<span class="line" id="L194">                <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;.&quot;</span>) <span class="tok-kw">or</span> mem.eql(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;..&quot;</span>) <span class="tok-kw">or</span></span>
<span class="line" id="L195">                    (skip_zero_fileno <span class="tok-kw">and</span> bsd_entry.fileno == <span class="tok-number">0</span>))</span>
<span class="line" id="L196">                {</span>
<span class="line" id="L197">                    <span class="tok-kw">continue</span> :start_over;</span>
<span class="line" id="L198">                }</span>
<span class="line" id="L199"></span>
<span class="line" id="L200">                <span class="tok-kw">const</span> entry_kind: Entry.Kind = <span class="tok-kw">switch</span> (bsd_entry.<span class="tok-type">type</span>) {</span>
<span class="line" id="L201">                    posix.DT.BLK =&gt; .block_device,</span>
<span class="line" id="L202">                    posix.DT.CHR =&gt; .character_device,</span>
<span class="line" id="L203">                    posix.DT.DIR =&gt; .directory,</span>
<span class="line" id="L204">                    posix.DT.FIFO =&gt; .named_pipe,</span>
<span class="line" id="L205">                    posix.DT.LNK =&gt; .sym_link,</span>
<span class="line" id="L206">                    posix.DT.REG =&gt; .file,</span>
<span class="line" id="L207">                    posix.DT.SOCK =&gt; .unix_domain_socket,</span>
<span class="line" id="L208">                    posix.DT.WHT =&gt; .whiteout,</span>
<span class="line" id="L209">                    <span class="tok-kw">else</span> =&gt; .unknown,</span>
<span class="line" id="L210">                };</span>
<span class="line" id="L211">                <span class="tok-kw">return</span> Entry{</span>
<span class="line" id="L212">                    .name = name,</span>
<span class="line" id="L213">                    .kind = entry_kind,</span>
<span class="line" id="L214">                };</span>
<span class="line" id="L215">            }</span>
<span class="line" id="L216">        }</span>
<span class="line" id="L217"></span>
<span class="line" id="L218">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *Self) <span class="tok-type">void</span> {</span>
<span class="line" id="L219">            self.index = <span class="tok-number">0</span>;</span>
<span class="line" id="L220">            self.end_index = <span class="tok-number">0</span>;</span>
<span class="line" id="L221">            self.first_iter = <span class="tok-null">true</span>;</span>
<span class="line" id="L222">        }</span>
<span class="line" id="L223">    },</span>
<span class="line" id="L224">    .haiku =&gt; <span class="tok-kw">struct</span> {</span>
<span class="line" id="L225">        dir: Dir,</span>
<span class="line" id="L226">        buf: [<span class="tok-number">1024</span>]<span class="tok-type">u8</span>, <span class="tok-comment">// TODO align(@alignOf(posix.dirent64)),</span>
</span>
<span class="line" id="L227">        index: <span class="tok-type">usize</span>,</span>
<span class="line" id="L228">        end_index: <span class="tok-type">usize</span>,</span>
<span class="line" id="L229">        first_iter: <span class="tok-type">bool</span>,</span>
<span class="line" id="L230"></span>
<span class="line" id="L231">        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();</span>
<span class="line" id="L232"></span>
<span class="line" id="L233">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Error = IteratorError;</span>
<span class="line" id="L234"></span>
<span class="line" id="L235">        <span class="tok-comment">/// Memory such as file names referenced in this returned entry becomes invalid</span></span>
<span class="line" id="L236">        <span class="tok-comment">/// with subsequent calls to `next`, as well as when this `Dir` is deinitialized.</span></span>
<span class="line" id="L237">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *Self) Error!?Entry {</span>
<span class="line" id="L238">            start_over: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L239">                <span class="tok-comment">// TODO: find a better max</span>
</span>
<span class="line" id="L240">                <span class="tok-kw">const</span> HAIKU_MAX_COUNT = <span class="tok-number">10000</span>;</span>
<span class="line" id="L241">                <span class="tok-kw">if</span> (self.index &gt;= self.end_index) {</span>
<span class="line" id="L242">                    <span class="tok-kw">if</span> (self.first_iter) {</span>
<span class="line" id="L243">                        posix.lseek_SET(self.dir.fd, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>; <span class="tok-comment">// EBADF here likely means that the Dir was not opened with iteration permissions</span>
</span>
<span class="line" id="L244">                        self.first_iter = <span class="tok-null">false</span>;</span>
<span class="line" id="L245">                    }</span>
<span class="line" id="L246">                    <span class="tok-kw">const</span> rc = posix.system._kern_read_dir(</span>
<span class="line" id="L247">                        self.dir.fd,</span>
<span class="line" id="L248">                        &amp;self.buf,</span>
<span class="line" id="L249">                        self.buf.len,</span>
<span class="line" id="L250">                        HAIKU_MAX_COUNT,</span>
<span class="line" id="L251">                    );</span>
<span class="line" id="L252">                    <span class="tok-kw">if</span> (rc == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L253">                    <span class="tok-kw">if</span> (rc &lt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L254">                        <span class="tok-kw">switch</span> (posix.errno(rc)) {</span>
<span class="line" id="L255">                            .BADF =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Dir is invalid or was opened without iteration ability</span>
</span>
<span class="line" id="L256">                            .FAULT =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L257">                            .NOTDIR =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L258">                            .INVAL =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L259">                            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> posix.unexpectedErrno(err),</span>
<span class="line" id="L260">                        }</span>
<span class="line" id="L261">                    }</span>
<span class="line" id="L262">                    self.index = <span class="tok-number">0</span>;</span>
<span class="line" id="L263">                    self.end_index = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(rc));</span>
<span class="line" id="L264">                }</span>
<span class="line" id="L265">                <span class="tok-kw">const</span> haiku_entry = <span class="tok-builtin">@as</span>(*<span class="tok-kw">align</span>(<span class="tok-number">1</span>) posix.system.dirent, <span class="tok-builtin">@ptrCast</span>(&amp;self.buf[self.index]));</span>
<span class="line" id="L266">                <span class="tok-kw">const</span> next_index = self.index + haiku_entry.reclen;</span>
<span class="line" id="L267">                self.index = next_index;</span>
<span class="line" id="L268">                <span class="tok-kw">const</span> name = mem.sliceTo(<span class="tok-builtin">@as</span>([*:<span class="tok-number">0</span>]<span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(&amp;haiku_entry.name)), <span class="tok-number">0</span>);</span>
<span class="line" id="L269"></span>
<span class="line" id="L270">                <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;.&quot;</span>) <span class="tok-kw">or</span> mem.eql(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;..&quot;</span>) <span class="tok-kw">or</span> (haiku_entry.ino == <span class="tok-number">0</span>)) {</span>
<span class="line" id="L271">                    <span class="tok-kw">continue</span> :start_over;</span>
<span class="line" id="L272">                }</span>
<span class="line" id="L273"></span>
<span class="line" id="L274">                <span class="tok-kw">var</span> stat_info: posix.Stat = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L275">                <span class="tok-kw">const</span> rc = posix.system._kern_read_stat(</span>
<span class="line" id="L276">                    self.dir.fd,</span>
<span class="line" id="L277">                    &amp;haiku_entry.name,</span>
<span class="line" id="L278">                    <span class="tok-null">false</span>,</span>
<span class="line" id="L279">                    &amp;stat_info,</span>
<span class="line" id="L280">                    <span class="tok-number">0</span>,</span>
<span class="line" id="L281">                );</span>
<span class="line" id="L282">                <span class="tok-kw">if</span> (rc != <span class="tok-number">0</span>) {</span>
<span class="line" id="L283">                    <span class="tok-kw">switch</span> (posix.errno(rc)) {</span>
<span class="line" id="L284">                        .SUCCESS =&gt; {},</span>
<span class="line" id="L285">                        .BADF =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Dir is invalid or was opened without iteration ability</span>
</span>
<span class="line" id="L286">                        .FAULT =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L287">                        .NOTDIR =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L288">                        .INVAL =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L289">                        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> posix.unexpectedErrno(err),</span>
<span class="line" id="L290">                    }</span>
<span class="line" id="L291">                }</span>
<span class="line" id="L292">                <span class="tok-kw">const</span> statmode = stat_info.mode &amp; posix.S.IFMT;</span>
<span class="line" id="L293"></span>
<span class="line" id="L294">                <span class="tok-kw">const</span> entry_kind: Entry.Kind = <span class="tok-kw">switch</span> (statmode) {</span>
<span class="line" id="L295">                    posix.S.IFDIR =&gt; .directory,</span>
<span class="line" id="L296">                    posix.S.IFBLK =&gt; .block_device,</span>
<span class="line" id="L297">                    posix.S.IFCHR =&gt; .character_device,</span>
<span class="line" id="L298">                    posix.S.IFLNK =&gt; .sym_link,</span>
<span class="line" id="L299">                    posix.S.IFREG =&gt; .file,</span>
<span class="line" id="L300">                    posix.S.IFIFO =&gt; .named_pipe,</span>
<span class="line" id="L301">                    <span class="tok-kw">else</span> =&gt; .unknown,</span>
<span class="line" id="L302">                };</span>
<span class="line" id="L303"></span>
<span class="line" id="L304">                <span class="tok-kw">return</span> Entry{</span>
<span class="line" id="L305">                    .name = name,</span>
<span class="line" id="L306">                    .kind = entry_kind,</span>
<span class="line" id="L307">                };</span>
<span class="line" id="L308">            }</span>
<span class="line" id="L309">        }</span>
<span class="line" id="L310"></span>
<span class="line" id="L311">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *Self) <span class="tok-type">void</span> {</span>
<span class="line" id="L312">            self.index = <span class="tok-number">0</span>;</span>
<span class="line" id="L313">            self.end_index = <span class="tok-number">0</span>;</span>
<span class="line" id="L314">            self.first_iter = <span class="tok-null">true</span>;</span>
<span class="line" id="L315">        }</span>
<span class="line" id="L316">    },</span>
<span class="line" id="L317">    .linux =&gt; <span class="tok-kw">struct</span> {</span>
<span class="line" id="L318">        dir: Dir,</span>
<span class="line" id="L319">        <span class="tok-comment">// The if guard is solely there to prevent compile errors from missing `linux.dirent64`</span>
</span>
<span class="line" id="L320">        <span class="tok-comment">// definition when compiling for other OSes. It doesn't do anything when compiling for Linux.</span>
</span>
<span class="line" id="L321">        buf: [<span class="tok-number">1024</span>]<span class="tok-type">u8</span> <span class="tok-kw">align</span>(<span class="tok-kw">if</span> (builtin.os.tag != .linux) <span class="tok-number">1</span> <span class="tok-kw">else</span> <span class="tok-builtin">@alignOf</span>(linux.dirent64)),</span>
<span class="line" id="L322">        index: <span class="tok-type">usize</span>,</span>
<span class="line" id="L323">        end_index: <span class="tok-type">usize</span>,</span>
<span class="line" id="L324">        first_iter: <span class="tok-type">bool</span>,</span>
<span class="line" id="L325"></span>
<span class="line" id="L326">        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();</span>
<span class="line" id="L327">        <span class="tok-kw">const</span> linux = std.os.linux;</span>
<span class="line" id="L328"></span>
<span class="line" id="L329">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Error = IteratorError;</span>
<span class="line" id="L330"></span>
<span class="line" id="L331">        <span class="tok-comment">/// Memory such as file names referenced in this returned entry becomes invalid</span></span>
<span class="line" id="L332">        <span class="tok-comment">/// with subsequent calls to `next`, as well as when this `Dir` is deinitialized.</span></span>
<span class="line" id="L333">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *Self) Error!?Entry {</span>
<span class="line" id="L334">            <span class="tok-kw">return</span> self.nextLinux() <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L335">                <span class="tok-comment">// To be consistent across platforms, iteration ends if the directory being iterated is deleted during iteration.</span>
</span>
<span class="line" id="L336">                <span class="tok-comment">// This matches the behavior of non-Linux UNIX platforms.</span>
</span>
<span class="line" id="L337">                <span class="tok-kw">error</span>.DirNotFound =&gt; <span class="tok-null">null</span>,</span>
<span class="line" id="L338">                <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L339">            };</span>
<span class="line" id="L340">        }</span>
<span class="line" id="L341"></span>
<span class="line" id="L342">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ErrorLinux = <span class="tok-kw">error</span>{DirNotFound} || IteratorError;</span>
<span class="line" id="L343"></span>
<span class="line" id="L344">        <span class="tok-comment">/// Implementation of `next` that can return `error.DirNotFound` if the directory being</span></span>
<span class="line" id="L345">        <span class="tok-comment">/// iterated was deleted during iteration (this error is Linux specific).</span></span>
<span class="line" id="L346">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nextLinux</span>(self: *Self) ErrorLinux!?Entry {</span>
<span class="line" id="L347">            start_over: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L348">                <span class="tok-kw">if</span> (self.index &gt;= self.end_index) {</span>
<span class="line" id="L349">                    <span class="tok-kw">if</span> (self.first_iter) {</span>
<span class="line" id="L350">                        posix.lseek_SET(self.dir.fd, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>; <span class="tok-comment">// EBADF here likely means that the Dir was not opened with iteration permissions</span>
</span>
<span class="line" id="L351">                        self.first_iter = <span class="tok-null">false</span>;</span>
<span class="line" id="L352">                    }</span>
<span class="line" id="L353">                    <span class="tok-kw">const</span> rc = linux.getdents64(self.dir.fd, &amp;self.buf, self.buf.len);</span>
<span class="line" id="L354">                    <span class="tok-kw">switch</span> (linux.getErrno(rc)) {</span>
<span class="line" id="L355">                        .SUCCESS =&gt; {},</span>
<span class="line" id="L356">                        .BADF =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Dir is invalid or was opened without iteration ability</span>
</span>
<span class="line" id="L357">                        .FAULT =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L358">                        .NOTDIR =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L359">                        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DirNotFound, <span class="tok-comment">// The directory being iterated was deleted during iteration.</span>
</span>
<span class="line" id="L360">                        .INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected, <span class="tok-comment">// Linux may in some cases return EINVAL when reading /proc/$PID/net.</span>
</span>
<span class="line" id="L361">                        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied, <span class="tok-comment">// Do not have permission to iterate this directory.</span>
</span>
<span class="line" id="L362">                        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> posix.unexpectedErrno(err),</span>
<span class="line" id="L363">                    }</span>
<span class="line" id="L364">                    <span class="tok-kw">if</span> (rc == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L365">                    self.index = <span class="tok-number">0</span>;</span>
<span class="line" id="L366">                    self.end_index = rc;</span>
<span class="line" id="L367">                }</span>
<span class="line" id="L368">                <span class="tok-kw">const</span> linux_entry = <span class="tok-builtin">@as</span>(*<span class="tok-kw">align</span>(<span class="tok-number">1</span>) linux.dirent64, <span class="tok-builtin">@ptrCast</span>(&amp;self.buf[self.index]));</span>
<span class="line" id="L369">                <span class="tok-kw">const</span> next_index = self.index + linux_entry.reclen;</span>
<span class="line" id="L370">                self.index = next_index;</span>
<span class="line" id="L371"></span>
<span class="line" id="L372">                <span class="tok-kw">const</span> name = mem.sliceTo(<span class="tok-builtin">@as</span>([*:<span class="tok-number">0</span>]<span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(&amp;linux_entry.name)), <span class="tok-number">0</span>);</span>
<span class="line" id="L373"></span>
<span class="line" id="L374">                <span class="tok-comment">// skip . and .. entries</span>
</span>
<span class="line" id="L375">                <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;.&quot;</span>) <span class="tok-kw">or</span> mem.eql(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;..&quot;</span>)) {</span>
<span class="line" id="L376">                    <span class="tok-kw">continue</span> :start_over;</span>
<span class="line" id="L377">                }</span>
<span class="line" id="L378"></span>
<span class="line" id="L379">                <span class="tok-kw">const</span> entry_kind: Entry.Kind = <span class="tok-kw">switch</span> (linux_entry.<span class="tok-type">type</span>) {</span>
<span class="line" id="L380">                    linux.DT.BLK =&gt; .block_device,</span>
<span class="line" id="L381">                    linux.DT.CHR =&gt; .character_device,</span>
<span class="line" id="L382">                    linux.DT.DIR =&gt; .directory,</span>
<span class="line" id="L383">                    linux.DT.FIFO =&gt; .named_pipe,</span>
<span class="line" id="L384">                    linux.DT.LNK =&gt; .sym_link,</span>
<span class="line" id="L385">                    linux.DT.REG =&gt; .file,</span>
<span class="line" id="L386">                    linux.DT.SOCK =&gt; .unix_domain_socket,</span>
<span class="line" id="L387">                    <span class="tok-kw">else</span> =&gt; .unknown,</span>
<span class="line" id="L388">                };</span>
<span class="line" id="L389">                <span class="tok-kw">return</span> Entry{</span>
<span class="line" id="L390">                    .name = name,</span>
<span class="line" id="L391">                    .kind = entry_kind,</span>
<span class="line" id="L392">                };</span>
<span class="line" id="L393">            }</span>
<span class="line" id="L394">        }</span>
<span class="line" id="L395"></span>
<span class="line" id="L396">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *Self) <span class="tok-type">void</span> {</span>
<span class="line" id="L397">            self.index = <span class="tok-number">0</span>;</span>
<span class="line" id="L398">            self.end_index = <span class="tok-number">0</span>;</span>
<span class="line" id="L399">            self.first_iter = <span class="tok-null">true</span>;</span>
<span class="line" id="L400">        }</span>
<span class="line" id="L401">    },</span>
<span class="line" id="L402">    .windows =&gt; <span class="tok-kw">struct</span> {</span>
<span class="line" id="L403">        dir: Dir,</span>
<span class="line" id="L404">        buf: [<span class="tok-number">1024</span>]<span class="tok-type">u8</span> <span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(std.os.windows.FILE_BOTH_DIR_INFORMATION)),</span>
<span class="line" id="L405">        index: <span class="tok-type">usize</span>,</span>
<span class="line" id="L406">        end_index: <span class="tok-type">usize</span>,</span>
<span class="line" id="L407">        first_iter: <span class="tok-type">bool</span>,</span>
<span class="line" id="L408">        name_data: [fs.MAX_NAME_BYTES]<span class="tok-type">u8</span>,</span>
<span class="line" id="L409"></span>
<span class="line" id="L410">        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();</span>
<span class="line" id="L411"></span>
<span class="line" id="L412">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Error = IteratorError;</span>
<span class="line" id="L413"></span>
<span class="line" id="L414">        <span class="tok-comment">/// Memory such as file names referenced in this returned entry becomes invalid</span></span>
<span class="line" id="L415">        <span class="tok-comment">/// with subsequent calls to `next`, as well as when this `Dir` is deinitialized.</span></span>
<span class="line" id="L416">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *Self) Error!?Entry {</span>
<span class="line" id="L417">            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L418">                <span class="tok-kw">const</span> w = std.os.windows;</span>
<span class="line" id="L419">                <span class="tok-kw">if</span> (self.index &gt;= self.end_index) {</span>
<span class="line" id="L420">                    <span class="tok-kw">var</span> io: w.IO_STATUS_BLOCK = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L421">                    <span class="tok-kw">const</span> rc = w.ntdll.NtQueryDirectoryFile(</span>
<span class="line" id="L422">                        self.dir.fd,</span>
<span class="line" id="L423">                        <span class="tok-null">null</span>,</span>
<span class="line" id="L424">                        <span class="tok-null">null</span>,</span>
<span class="line" id="L425">                        <span class="tok-null">null</span>,</span>
<span class="line" id="L426">                        &amp;io,</span>
<span class="line" id="L427">                        &amp;self.buf,</span>
<span class="line" id="L428">                        self.buf.len,</span>
<span class="line" id="L429">                        .FileBothDirectoryInformation,</span>
<span class="line" id="L430">                        w.FALSE,</span>
<span class="line" id="L431">                        <span class="tok-null">null</span>,</span>
<span class="line" id="L432">                        <span class="tok-kw">if</span> (self.first_iter) <span class="tok-builtin">@as</span>(w.BOOLEAN, w.TRUE) <span class="tok-kw">else</span> <span class="tok-builtin">@as</span>(w.BOOLEAN, w.FALSE),</span>
<span class="line" id="L433">                    );</span>
<span class="line" id="L434">                    self.first_iter = <span class="tok-null">false</span>;</span>
<span class="line" id="L435">                    <span class="tok-kw">if</span> (io.Information == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L436">                    self.index = <span class="tok-number">0</span>;</span>
<span class="line" id="L437">                    self.end_index = io.Information;</span>
<span class="line" id="L438">                    <span class="tok-kw">switch</span> (rc) {</span>
<span class="line" id="L439">                        .SUCCESS =&gt; {},</span>
<span class="line" id="L440">                        .ACCESS_DENIED =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied, <span class="tok-comment">// Double-check that the Dir was opened with iteration ability</span>
</span>
<span class="line" id="L441"></span>
<span class="line" id="L442">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> w.unexpectedStatus(rc),</span>
<span class="line" id="L443">                    }</span>
<span class="line" id="L444">                }</span>
<span class="line" id="L445"></span>
<span class="line" id="L446">                <span class="tok-comment">// While the official api docs guarantee FILE_BOTH_DIR_INFORMATION to be aligned properly</span>
</span>
<span class="line" id="L447">                <span class="tok-comment">// this may not always be the case (e.g. due to faulty VM/Sandboxing tools)</span>
</span>
<span class="line" id="L448">                <span class="tok-kw">const</span> dir_info: *<span class="tok-kw">align</span>(<span class="tok-number">2</span>) w.FILE_BOTH_DIR_INFORMATION = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;self.buf[self.index]));</span>
<span class="line" id="L449">                <span class="tok-kw">if</span> (dir_info.NextEntryOffset != <span class="tok-number">0</span>) {</span>
<span class="line" id="L450">                    self.index += dir_info.NextEntryOffset;</span>
<span class="line" id="L451">                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L452">                    self.index = self.buf.len;</span>
<span class="line" id="L453">                }</span>
<span class="line" id="L454"></span>
<span class="line" id="L455">                <span class="tok-kw">const</span> name_wtf16le = <span class="tok-builtin">@as</span>([*]<span class="tok-type">u16</span>, <span class="tok-builtin">@ptrCast</span>(&amp;dir_info.FileName))[<span class="tok-number">0</span> .. dir_info.FileNameLength / <span class="tok-number">2</span>];</span>
<span class="line" id="L456"></span>
<span class="line" id="L457">                <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u16</span>, name_wtf16le, &amp;[_]<span class="tok-type">u16</span>{<span class="tok-str">'.'</span>}) <span class="tok-kw">or</span> mem.eql(<span class="tok-type">u16</span>, name_wtf16le, &amp;[_]<span class="tok-type">u16</span>{ <span class="tok-str">'.'</span>, <span class="tok-str">'.'</span> }))</span>
<span class="line" id="L458">                    <span class="tok-kw">continue</span>;</span>
<span class="line" id="L459">                <span class="tok-kw">const</span> name_wtf8_len = std.unicode.wtf16LeToWtf8(self.name_data[<span class="tok-number">0</span>..], name_wtf16le);</span>
<span class="line" id="L460">                <span class="tok-kw">const</span> name_wtf8 = self.name_data[<span class="tok-number">0</span>..name_wtf8_len];</span>
<span class="line" id="L461">                <span class="tok-kw">const</span> kind: Entry.Kind = blk: {</span>
<span class="line" id="L462">                    <span class="tok-kw">const</span> attrs = dir_info.FileAttributes;</span>
<span class="line" id="L463">                    <span class="tok-kw">if</span> (attrs &amp; w.FILE_ATTRIBUTE_DIRECTORY != <span class="tok-number">0</span>) <span class="tok-kw">break</span> :blk .directory;</span>
<span class="line" id="L464">                    <span class="tok-kw">if</span> (attrs &amp; w.FILE_ATTRIBUTE_REPARSE_POINT != <span class="tok-number">0</span>) <span class="tok-kw">break</span> :blk .sym_link;</span>
<span class="line" id="L465">                    <span class="tok-kw">break</span> :blk .file;</span>
<span class="line" id="L466">                };</span>
<span class="line" id="L467">                <span class="tok-kw">return</span> Entry{</span>
<span class="line" id="L468">                    .name = name_wtf8,</span>
<span class="line" id="L469">                    .kind = kind,</span>
<span class="line" id="L470">                };</span>
<span class="line" id="L471">            }</span>
<span class="line" id="L472">        }</span>
<span class="line" id="L473"></span>
<span class="line" id="L474">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *Self) <span class="tok-type">void</span> {</span>
<span class="line" id="L475">            self.index = <span class="tok-number">0</span>;</span>
<span class="line" id="L476">            self.end_index = <span class="tok-number">0</span>;</span>
<span class="line" id="L477">            self.first_iter = <span class="tok-null">true</span>;</span>
<span class="line" id="L478">        }</span>
<span class="line" id="L479">    },</span>
<span class="line" id="L480">    .wasi =&gt; <span class="tok-kw">struct</span> {</span>
<span class="line" id="L481">        dir: Dir,</span>
<span class="line" id="L482">        buf: [<span class="tok-number">1024</span>]<span class="tok-type">u8</span>, <span class="tok-comment">// TODO align(@alignOf(posix.wasi.dirent_t)),</span>
</span>
<span class="line" id="L483">        cookie: <span class="tok-type">u64</span>,</span>
<span class="line" id="L484">        index: <span class="tok-type">usize</span>,</span>
<span class="line" id="L485">        end_index: <span class="tok-type">usize</span>,</span>
<span class="line" id="L486"></span>
<span class="line" id="L487">        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();</span>
<span class="line" id="L488"></span>
<span class="line" id="L489">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Error = IteratorError;</span>
<span class="line" id="L490"></span>
<span class="line" id="L491">        <span class="tok-comment">/// Memory such as file names referenced in this returned entry becomes invalid</span></span>
<span class="line" id="L492">        <span class="tok-comment">/// with subsequent calls to `next`, as well as when this `Dir` is deinitialized.</span></span>
<span class="line" id="L493">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *Self) Error!?Entry {</span>
<span class="line" id="L494">            <span class="tok-kw">return</span> self.nextWasi() <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L495">                <span class="tok-comment">// To be consistent across platforms, iteration ends if the directory being iterated is deleted during iteration.</span>
</span>
<span class="line" id="L496">                <span class="tok-comment">// This matches the behavior of non-Linux UNIX platforms.</span>
</span>
<span class="line" id="L497">                <span class="tok-kw">error</span>.DirNotFound =&gt; <span class="tok-null">null</span>,</span>
<span class="line" id="L498">                <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L499">            };</span>
<span class="line" id="L500">        }</span>
<span class="line" id="L501"></span>
<span class="line" id="L502">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ErrorWasi = <span class="tok-kw">error</span>{DirNotFound} || IteratorError;</span>
<span class="line" id="L503"></span>
<span class="line" id="L504">        <span class="tok-comment">/// Implementation of `next` that can return platform-dependent errors depending on the host platform.</span></span>
<span class="line" id="L505">        <span class="tok-comment">/// When the host platform is Linux, `error.DirNotFound` can be returned if the directory being</span></span>
<span class="line" id="L506">        <span class="tok-comment">/// iterated was deleted during iteration.</span></span>
<span class="line" id="L507">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nextWasi</span>(self: *Self) ErrorWasi!?Entry {</span>
<span class="line" id="L508">            <span class="tok-comment">// We intentinally use fd_readdir even when linked with libc,</span>
</span>
<span class="line" id="L509">            <span class="tok-comment">// since its implementation is exactly the same as below,</span>
</span>
<span class="line" id="L510">            <span class="tok-comment">// and we avoid the code complexity here.</span>
</span>
<span class="line" id="L511">            <span class="tok-kw">const</span> w = std.os.wasi;</span>
<span class="line" id="L512">            start_over: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L513">                <span class="tok-comment">// According to the WASI spec, the last entry might be truncated,</span>
</span>
<span class="line" id="L514">                <span class="tok-comment">// so we need to check if the left buffer contains the whole dirent.</span>
</span>
<span class="line" id="L515">                <span class="tok-kw">if</span> (self.end_index - self.index &lt; <span class="tok-builtin">@sizeOf</span>(w.dirent_t)) {</span>
<span class="line" id="L516">                    <span class="tok-kw">var</span> bufused: <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L517">                    <span class="tok-kw">switch</span> (w.fd_readdir(self.dir.fd, &amp;self.buf, self.buf.len, self.cookie, &amp;bufused)) {</span>
<span class="line" id="L518">                        .SUCCESS =&gt; {},</span>
<span class="line" id="L519">                        .BADF =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// Dir is invalid or was opened without iteration ability</span>
</span>
<span class="line" id="L520">                        .FAULT =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L521">                        .NOTDIR =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L522">                        .INVAL =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L523">                        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DirNotFound, <span class="tok-comment">// The directory being iterated was deleted during iteration.</span>
</span>
<span class="line" id="L524">                        .NOTCAPABLE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,</span>
<span class="line" id="L525">                        .ILSEQ =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUtf8, <span class="tok-comment">// An entry's name cannot be encoded as UTF-8.</span>
</span>
<span class="line" id="L526">                        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> posix.unexpectedErrno(err),</span>
<span class="line" id="L527">                    }</span>
<span class="line" id="L528">                    <span class="tok-kw">if</span> (bufused == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L529">                    self.index = <span class="tok-number">0</span>;</span>
<span class="line" id="L530">                    self.end_index = bufused;</span>
<span class="line" id="L531">                }</span>
<span class="line" id="L532">                <span class="tok-kw">const</span> entry = <span class="tok-builtin">@as</span>(*<span class="tok-kw">align</span>(<span class="tok-number">1</span>) w.dirent_t, <span class="tok-builtin">@ptrCast</span>(&amp;self.buf[self.index]));</span>
<span class="line" id="L533">                <span class="tok-kw">const</span> entry_size = <span class="tok-builtin">@sizeOf</span>(w.dirent_t);</span>
<span class="line" id="L534">                <span class="tok-kw">const</span> name_index = self.index + entry_size;</span>
<span class="line" id="L535">                <span class="tok-kw">if</span> (name_index + entry.namlen &gt; self.end_index) {</span>
<span class="line" id="L536">                    <span class="tok-comment">// This case, the name is truncated, so we need to call readdir to store the entire name.</span>
</span>
<span class="line" id="L537">                    self.end_index = self.index; <span class="tok-comment">// Force fd_readdir in the next loop.</span>
</span>
<span class="line" id="L538">                    <span class="tok-kw">continue</span> :start_over;</span>
<span class="line" id="L539">                }</span>
<span class="line" id="L540">                <span class="tok-kw">const</span> name = self.buf[name_index .. name_index + entry.namlen];</span>
<span class="line" id="L541"></span>
<span class="line" id="L542">                <span class="tok-kw">const</span> next_index = name_index + entry.namlen;</span>
<span class="line" id="L543">                self.index = next_index;</span>
<span class="line" id="L544">                self.cookie = entry.next;</span>
<span class="line" id="L545"></span>
<span class="line" id="L546">                <span class="tok-comment">// skip . and .. entries</span>
</span>
<span class="line" id="L547">                <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;.&quot;</span>) <span class="tok-kw">or</span> mem.eql(<span class="tok-type">u8</span>, name, <span class="tok-str">&quot;..&quot;</span>)) {</span>
<span class="line" id="L548">                    <span class="tok-kw">continue</span> :start_over;</span>
<span class="line" id="L549">                }</span>
<span class="line" id="L550"></span>
<span class="line" id="L551">                <span class="tok-kw">const</span> entry_kind: Entry.Kind = <span class="tok-kw">switch</span> (entry.<span class="tok-type">type</span>) {</span>
<span class="line" id="L552">                    .BLOCK_DEVICE =&gt; .block_device,</span>
<span class="line" id="L553">                    .CHARACTER_DEVICE =&gt; .character_device,</span>
<span class="line" id="L554">                    .DIRECTORY =&gt; .directory,</span>
<span class="line" id="L555">                    .SYMBOLIC_LINK =&gt; .sym_link,</span>
<span class="line" id="L556">                    .REGULAR_FILE =&gt; .file,</span>
<span class="line" id="L557">                    .SOCKET_STREAM, .SOCKET_DGRAM =&gt; .unix_domain_socket,</span>
<span class="line" id="L558">                    <span class="tok-kw">else</span> =&gt; .unknown,</span>
<span class="line" id="L559">                };</span>
<span class="line" id="L560">                <span class="tok-kw">return</span> Entry{</span>
<span class="line" id="L561">                    .name = name,</span>
<span class="line" id="L562">                    .kind = entry_kind,</span>
<span class="line" id="L563">                };</span>
<span class="line" id="L564">            }</span>
<span class="line" id="L565">        }</span>
<span class="line" id="L566"></span>
<span class="line" id="L567">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *Self) <span class="tok-type">void</span> {</span>
<span class="line" id="L568">            self.index = <span class="tok-number">0</span>;</span>
<span class="line" id="L569">            self.end_index = <span class="tok-number">0</span>;</span>
<span class="line" id="L570">            self.cookie = std.os.wasi.DIRCOOKIE_START;</span>
<span class="line" id="L571">        }</span>
<span class="line" id="L572">    },</span>
<span class="line" id="L573">    <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;unimplemented&quot;</span>),</span>
<span class="line" id="L574">};</span>
<span class="line" id="L575"></span>
<span class="line" id="L576"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterate</span>(self: Dir) Iterator {</span>
<span class="line" id="L577">    <span class="tok-kw">return</span> self.iterateImpl(<span class="tok-null">true</span>);</span>
<span class="line" id="L578">}</span>
<span class="line" id="L579"></span>
<span class="line" id="L580"><span class="tok-comment">/// Like `iterate`, but will not reset the directory cursor before the first</span></span>
<span class="line" id="L581"><span class="tok-comment">/// iteration. This should only be used in cases where it is known that the</span></span>
<span class="line" id="L582"><span class="tok-comment">/// `Dir` has not had its cursor modified yet (e.g. it was just opened).</span></span>
<span class="line" id="L583"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterateAssumeFirstIteration</span>(self: Dir) Iterator {</span>
<span class="line" id="L584">    <span class="tok-kw">return</span> self.iterateImpl(<span class="tok-null">false</span>);</span>
<span class="line" id="L585">}</span>
<span class="line" id="L586"></span>
<span class="line" id="L587"><span class="tok-kw">fn</span> <span class="tok-fn">iterateImpl</span>(self: Dir, first_iter_start_value: <span class="tok-type">bool</span>) Iterator {</span>
<span class="line" id="L588">    <span class="tok-kw">switch</span> (builtin.os.tag) {</span>
<span class="line" id="L589">        .macos,</span>
<span class="line" id="L590">        .ios,</span>
<span class="line" id="L591">        .freebsd,</span>
<span class="line" id="L592">        .netbsd,</span>
<span class="line" id="L593">        .dragonfly,</span>
<span class="line" id="L594">        .openbsd,</span>
<span class="line" id="L595">        .solaris,</span>
<span class="line" id="L596">        .illumos,</span>
<span class="line" id="L597">        =&gt; <span class="tok-kw">return</span> Iterator{</span>
<span class="line" id="L598">            .dir = self,</span>
<span class="line" id="L599">            .seek = <span class="tok-number">0</span>,</span>
<span class="line" id="L600">            .index = <span class="tok-number">0</span>,</span>
<span class="line" id="L601">            .end_index = <span class="tok-number">0</span>,</span>
<span class="line" id="L602">            .buf = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L603">            .first_iter = first_iter_start_value,</span>
<span class="line" id="L604">        },</span>
<span class="line" id="L605">        .linux, .haiku =&gt; <span class="tok-kw">return</span> Iterator{</span>
<span class="line" id="L606">            .dir = self,</span>
<span class="line" id="L607">            .index = <span class="tok-number">0</span>,</span>
<span class="line" id="L608">            .end_index = <span class="tok-number">0</span>,</span>
<span class="line" id="L609">            .buf = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L610">            .first_iter = first_iter_start_value,</span>
<span class="line" id="L611">        },</span>
<span class="line" id="L612">        .windows =&gt; <span class="tok-kw">return</span> Iterator{</span>
<span class="line" id="L613">            .dir = self,</span>
<span class="line" id="L614">            .index = <span class="tok-number">0</span>,</span>
<span class="line" id="L615">            .end_index = <span class="tok-number">0</span>,</span>
<span class="line" id="L616">            .first_iter = first_iter_start_value,</span>
<span class="line" id="L617">            .buf = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L618">            .name_data = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L619">        },</span>
<span class="line" id="L620">        .wasi =&gt; <span class="tok-kw">return</span> Iterator{</span>
<span class="line" id="L621">            .dir = self,</span>
<span class="line" id="L622">            .cookie = std.os.wasi.DIRCOOKIE_START,</span>
<span class="line" id="L623">            .index = <span class="tok-number">0</span>,</span>
<span class="line" id="L624">            .end_index = <span class="tok-number">0</span>,</span>
<span class="line" id="L625">            .buf = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L626">        },</span>
<span class="line" id="L627">        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;unimplemented&quot;</span>),</span>
<span class="line" id="L628">    }</span>
<span class="line" id="L629">}</span>
<span class="line" id="L630"></span>
<span class="line" id="L631"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Walker = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L632">    stack: std.ArrayList(StackItem),</span>
<span class="line" id="L633">    name_buffer: std.ArrayList(<span class="tok-type">u8</span>),</span>
<span class="line" id="L634"></span>
<span class="line" id="L635">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> WalkerEntry = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L636">        <span class="tok-comment">/// The containing directory. This can be used to operate directly on `basename`</span></span>
<span class="line" id="L637">        <span class="tok-comment">/// rather than `path`, avoiding `error.NameTooLong` for deeply nested paths.</span></span>
<span class="line" id="L638">        <span class="tok-comment">/// The directory remains open until `next` or `deinit` is called.</span></span>
<span class="line" id="L639">        dir: Dir,</span>
<span class="line" id="L640">        basename: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L641">        path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L642">        kind: Dir.Entry.Kind,</span>
<span class="line" id="L643">    };</span>
<span class="line" id="L644"></span>
<span class="line" id="L645">    <span class="tok-kw">const</span> StackItem = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L646">        iter: Dir.Iterator,</span>
<span class="line" id="L647">        dirname_len: <span class="tok-type">usize</span>,</span>
<span class="line" id="L648">    };</span>
<span class="line" id="L649"></span>
<span class="line" id="L650">    <span class="tok-comment">/// After each call to this function, and on deinit(), the memory returned</span></span>
<span class="line" id="L651">    <span class="tok-comment">/// from this function becomes invalid. A copy must be made in order to keep</span></span>
<span class="line" id="L652">    <span class="tok-comment">/// a reference to the path.</span></span>
<span class="line" id="L653">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *Walker) !?WalkerEntry {</span>
<span class="line" id="L654">        <span class="tok-kw">while</span> (self.stack.items.len != <span class="tok-number">0</span>) {</span>
<span class="line" id="L655">            <span class="tok-comment">// `top` and `containing` become invalid after appending to `self.stack`</span>
</span>
<span class="line" id="L656">            <span class="tok-kw">var</span> top = &amp;self.stack.items[self.stack.items.len - <span class="tok-number">1</span>];</span>
<span class="line" id="L657">            <span class="tok-kw">var</span> containing = top;</span>
<span class="line" id="L658">            <span class="tok-kw">var</span> dirname_len = top.dirname_len;</span>
<span class="line" id="L659">            <span class="tok-kw">if</span> (top.iter.next() <span class="tok-kw">catch</span> |err| {</span>
<span class="line" id="L660">                <span class="tok-comment">// If we get an error, then we want the user to be able to continue</span>
</span>
<span class="line" id="L661">                <span class="tok-comment">// walking if they want, which means that we need to pop the directory</span>
</span>
<span class="line" id="L662">                <span class="tok-comment">// that errored from the stack. Otherwise, all future `next` calls would</span>
</span>
<span class="line" id="L663">                <span class="tok-comment">// likely just fail with the same error.</span>
</span>
<span class="line" id="L664">                <span class="tok-kw">var</span> item = self.stack.pop();</span>
<span class="line" id="L665">                <span class="tok-kw">if</span> (self.stack.items.len != <span class="tok-number">0</span>) {</span>
<span class="line" id="L666">                    item.iter.dir.close();</span>
<span class="line" id="L667">                }</span>
<span class="line" id="L668">                <span class="tok-kw">return</span> err;</span>
<span class="line" id="L669">            }) |base| {</span>
<span class="line" id="L670">                self.name_buffer.shrinkRetainingCapacity(dirname_len);</span>
<span class="line" id="L671">                <span class="tok-kw">if</span> (self.name_buffer.items.len != <span class="tok-number">0</span>) {</span>
<span class="line" id="L672">                    <span class="tok-kw">try</span> self.name_buffer.append(fs.path.sep);</span>
<span class="line" id="L673">                    dirname_len += <span class="tok-number">1</span>;</span>
<span class="line" id="L674">                }</span>
<span class="line" id="L675">                <span class="tok-kw">try</span> self.name_buffer.appendSlice(base.name);</span>
<span class="line" id="L676">                <span class="tok-kw">if</span> (base.kind == .directory) {</span>
<span class="line" id="L677">                    <span class="tok-kw">var</span> new_dir = top.iter.dir.openDir(base.name, .{ .iterate = <span class="tok-null">true</span> }) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L678">                        <span class="tok-kw">error</span>.NameTooLong =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// no path sep in base.name</span>
</span>
<span class="line" id="L679">                        <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L680">                    };</span>
<span class="line" id="L681">                    {</span>
<span class="line" id="L682">                        <span class="tok-kw">errdefer</span> new_dir.close();</span>
<span class="line" id="L683">                        <span class="tok-kw">try</span> self.stack.append(StackItem{</span>
<span class="line" id="L684">                            .iter = new_dir.iterateAssumeFirstIteration(),</span>
<span class="line" id="L685">                            .dirname_len = self.name_buffer.items.len,</span>
<span class="line" id="L686">                        });</span>
<span class="line" id="L687">                        top = &amp;self.stack.items[self.stack.items.len - <span class="tok-number">1</span>];</span>
<span class="line" id="L688">                        containing = &amp;self.stack.items[self.stack.items.len - <span class="tok-number">2</span>];</span>
<span class="line" id="L689">                    }</span>
<span class="line" id="L690">                }</span>
<span class="line" id="L691">                <span class="tok-kw">return</span> WalkerEntry{</span>
<span class="line" id="L692">                    .dir = containing.iter.dir,</span>
<span class="line" id="L693">                    .basename = self.name_buffer.items[dirname_len..],</span>
<span class="line" id="L694">                    .path = self.name_buffer.items,</span>
<span class="line" id="L695">                    .kind = base.kind,</span>
<span class="line" id="L696">                };</span>
<span class="line" id="L697">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L698">                <span class="tok-kw">var</span> item = self.stack.pop();</span>
<span class="line" id="L699">                <span class="tok-kw">if</span> (self.stack.items.len != <span class="tok-number">0</span>) {</span>
<span class="line" id="L700">                    item.iter.dir.close();</span>
<span class="line" id="L701">                }</span>
<span class="line" id="L702">            }</span>
<span class="line" id="L703">        }</span>
<span class="line" id="L704">        <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L705">    }</span>
<span class="line" id="L706"></span>
<span class="line" id="L707">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *Walker) <span class="tok-type">void</span> {</span>
<span class="line" id="L708">        <span class="tok-comment">// Close any remaining directories except the initial one (which is always at index 0)</span>
</span>
<span class="line" id="L709">        <span class="tok-kw">if</span> (self.stack.items.len &gt; <span class="tok-number">1</span>) {</span>
<span class="line" id="L710">            <span class="tok-kw">for</span> (self.stack.items[<span class="tok-number">1</span>..]) |*item| {</span>
<span class="line" id="L711">                item.iter.dir.close();</span>
<span class="line" id="L712">            }</span>
<span class="line" id="L713">        }</span>
<span class="line" id="L714">        self.stack.deinit();</span>
<span class="line" id="L715">        self.name_buffer.deinit();</span>
<span class="line" id="L716">    }</span>
<span class="line" id="L717">};</span>
<span class="line" id="L718"></span>
<span class="line" id="L719"><span class="tok-comment">/// Recursively iterates over a directory.</span></span>
<span class="line" id="L720"><span class="tok-comment">/// `self` must have been opened with `OpenDirOptions{.iterate = true}`.</span></span>
<span class="line" id="L721"><span class="tok-comment">/// Must call `Walker.deinit` when done.</span></span>
<span class="line" id="L722"><span class="tok-comment">/// The order of returned file system entries is undefined.</span></span>
<span class="line" id="L723"><span class="tok-comment">/// `self` will not be closed after walking it.</span></span>
<span class="line" id="L724"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">walk</span>(self: Dir, allocator: Allocator) !Walker {</span>
<span class="line" id="L725">    <span class="tok-kw">var</span> name_buffer = std.ArrayList(<span class="tok-type">u8</span>).init(allocator);</span>
<span class="line" id="L726">    <span class="tok-kw">errdefer</span> name_buffer.deinit();</span>
<span class="line" id="L727"></span>
<span class="line" id="L728">    <span class="tok-kw">var</span> stack = std.ArrayList(Walker.StackItem).init(allocator);</span>
<span class="line" id="L729">    <span class="tok-kw">errdefer</span> stack.deinit();</span>
<span class="line" id="L730"></span>
<span class="line" id="L731">    <span class="tok-kw">try</span> stack.append(Walker.StackItem{</span>
<span class="line" id="L732">        .iter = self.iterate(),</span>
<span class="line" id="L733">        .dirname_len = <span class="tok-number">0</span>,</span>
<span class="line" id="L734">    });</span>
<span class="line" id="L735"></span>
<span class="line" id="L736">    <span class="tok-kw">return</span> Walker{</span>
<span class="line" id="L737">        .stack = stack,</span>
<span class="line" id="L738">        .name_buffer = name_buffer,</span>
<span class="line" id="L739">    };</span>
<span class="line" id="L740">}</span>
<span class="line" id="L741"></span>
<span class="line" id="L742"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> OpenError = <span class="tok-kw">error</span>{</span>
<span class="line" id="L743">    FileNotFound,</span>
<span class="line" id="L744">    NotDir,</span>
<span class="line" id="L745">    AccessDenied,</span>
<span class="line" id="L746">    SymLinkLoop,</span>
<span class="line" id="L747">    ProcessFdQuotaExceeded,</span>
<span class="line" id="L748">    NameTooLong,</span>
<span class="line" id="L749">    SystemFdQuotaExceeded,</span>
<span class="line" id="L750">    NoDevice,</span>
<span class="line" id="L751">    SystemResources,</span>
<span class="line" id="L752">    <span class="tok-comment">/// WASI-only; file paths must be valid UTF-8.</span></span>
<span class="line" id="L753">    InvalidUtf8,</span>
<span class="line" id="L754">    <span class="tok-comment">/// Windows-only; file paths provided by the user must be valid WTF-8.</span></span>
<span class="line" id="L755">    <span class="tok-comment">/// https://simonsapin.github.io/wtf-8/</span></span>
<span class="line" id="L756">    InvalidWtf8,</span>
<span class="line" id="L757">    BadPathName,</span>
<span class="line" id="L758">    DeviceBusy,</span>
<span class="line" id="L759">    <span class="tok-comment">/// On Windows, `\\server` or `\\server\share` was not found.</span></span>
<span class="line" id="L760">    NetworkNotFound,</span>
<span class="line" id="L761">} || posix.UnexpectedError;</span>
<span class="line" id="L762"></span>
<span class="line" id="L763"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">close</span>(self: *Dir) <span class="tok-type">void</span> {</span>
<span class="line" id="L764">    posix.close(self.fd);</span>
<span class="line" id="L765">    self.* = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L766">}</span>
<span class="line" id="L767"></span>
<span class="line" id="L768"><span class="tok-comment">/// Opens a file for reading or writing, without attempting to create a new file.</span></span>
<span class="line" id="L769"><span class="tok-comment">/// To create a new file, see `createFile`.</span></span>
<span class="line" id="L770"><span class="tok-comment">/// Call `File.close` to release the resource.</span></span>
<span class="line" id="L771"><span class="tok-comment">/// Asserts that the path parameter has no null bytes.</span></span>
<span class="line" id="L772"><span class="tok-comment">/// On Windows, `sub_path` should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span></span>
<span class="line" id="L773"><span class="tok-comment">/// On WASI, `sub_path` should be encoded as valid UTF-8.</span></span>
<span class="line" id="L774"><span class="tok-comment">/// On other platforms, `sub_path` is an opaque sequence of bytes with no particular encoding.</span></span>
<span class="line" id="L775"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openFile</span>(self: Dir, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: File.OpenFlags) File.OpenError!File {</span>
<span class="line" id="L776">    <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L777">        <span class="tok-kw">const</span> path_w = <span class="tok-kw">try</span> std.os.windows.sliceToPrefixedFileW(self.fd, sub_path);</span>
<span class="line" id="L778">        <span class="tok-kw">return</span> self.openFileW(path_w.span(), flags);</span>
<span class="line" id="L779">    }</span>
<span class="line" id="L780">    <span class="tok-kw">if</span> (builtin.os.tag == .wasi) {</span>
<span class="line" id="L781">        <span class="tok-kw">var</span> base: std.os.wasi.rights_t = .{};</span>
<span class="line" id="L782">        <span class="tok-kw">if</span> (flags.isRead()) {</span>
<span class="line" id="L783">            base.FD_READ = <span class="tok-null">true</span>;</span>
<span class="line" id="L784">            base.FD_TELL = <span class="tok-null">true</span>;</span>
<span class="line" id="L785">            base.FD_SEEK = <span class="tok-null">true</span>;</span>
<span class="line" id="L786">            base.FD_FILESTAT_GET = <span class="tok-null">true</span>;</span>
<span class="line" id="L787">        }</span>
<span class="line" id="L788">        <span class="tok-kw">if</span> (flags.isWrite()) {</span>
<span class="line" id="L789">            base.FD_WRITE = <span class="tok-null">true</span>;</span>
<span class="line" id="L790">            base.FD_TELL = <span class="tok-null">true</span>;</span>
<span class="line" id="L791">            base.FD_SEEK = <span class="tok-null">true</span>;</span>
<span class="line" id="L792">            base.FD_DATASYNC = <span class="tok-null">true</span>;</span>
<span class="line" id="L793">            base.FD_FDSTAT_SET_FLAGS = <span class="tok-null">true</span>;</span>
<span class="line" id="L794">            base.FD_SYNC = <span class="tok-null">true</span>;</span>
<span class="line" id="L795">            base.FD_ALLOCATE = <span class="tok-null">true</span>;</span>
<span class="line" id="L796">            base.FD_ADVISE = <span class="tok-null">true</span>;</span>
<span class="line" id="L797">            base.FD_FILESTAT_SET_TIMES = <span class="tok-null">true</span>;</span>
<span class="line" id="L798">            base.FD_FILESTAT_SET_SIZE = <span class="tok-null">true</span>;</span>
<span class="line" id="L799">        }</span>
<span class="line" id="L800">        <span class="tok-kw">const</span> fd = <span class="tok-kw">try</span> posix.openatWasi(self.fd, sub_path, .{}, .{}, .{}, base, .{});</span>
<span class="line" id="L801">        <span class="tok-kw">return</span> .{ .handle = fd };</span>
<span class="line" id="L802">    }</span>
<span class="line" id="L803">    <span class="tok-kw">const</span> path_c = <span class="tok-kw">try</span> posix.toPosixPath(sub_path);</span>
<span class="line" id="L804">    <span class="tok-kw">return</span> self.openFileZ(&amp;path_c, flags);</span>
<span class="line" id="L805">}</span>
<span class="line" id="L806"></span>
<span class="line" id="L807"><span class="tok-comment">/// Same as `openFile` but the path parameter is null-terminated.</span></span>
<span class="line" id="L808"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openFileZ</span>(self: Dir, sub_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: File.OpenFlags) File.OpenError!File {</span>
<span class="line" id="L809">    <span class="tok-kw">switch</span> (builtin.os.tag) {</span>
<span class="line" id="L810">        .windows =&gt; {</span>
<span class="line" id="L811">            <span class="tok-kw">const</span> path_w = <span class="tok-kw">try</span> std.os.windows.cStrToPrefixedFileW(self.fd, sub_path);</span>
<span class="line" id="L812">            <span class="tok-kw">return</span> self.openFileW(path_w.span(), flags);</span>
<span class="line" id="L813">        },</span>
<span class="line" id="L814">        .wasi =&gt; {</span>
<span class="line" id="L815">            <span class="tok-kw">return</span> openFile(self, mem.sliceTo(sub_path, <span class="tok-number">0</span>), flags);</span>
<span class="line" id="L816">        },</span>
<span class="line" id="L817">        <span class="tok-kw">else</span> =&gt; {},</span>
<span class="line" id="L818">    }</span>
<span class="line" id="L819"></span>
<span class="line" id="L820">    <span class="tok-kw">var</span> os_flags: posix.O = .{</span>
<span class="line" id="L821">        .ACCMODE = <span class="tok-kw">switch</span> (flags.mode) {</span>
<span class="line" id="L822">            .read_only =&gt; .RDONLY,</span>
<span class="line" id="L823">            .write_only =&gt; .WRONLY,</span>
<span class="line" id="L824">            .read_write =&gt; .RDWR,</span>
<span class="line" id="L825">        },</span>
<span class="line" id="L826">    };</span>
<span class="line" id="L827">    <span class="tok-kw">if</span> (<span class="tok-builtin">@hasField</span>(posix.O, <span class="tok-str">&quot;CLOEXEC&quot;</span>)) os_flags.CLOEXEC = <span class="tok-null">true</span>;</span>
<span class="line" id="L828">    <span class="tok-kw">if</span> (<span class="tok-builtin">@hasField</span>(posix.O, <span class="tok-str">&quot;LARGEFILE&quot;</span>)) os_flags.LARGEFILE = <span class="tok-null">true</span>;</span>
<span class="line" id="L829">    <span class="tok-kw">if</span> (<span class="tok-builtin">@hasField</span>(posix.O, <span class="tok-str">&quot;NOCTTY&quot;</span>)) os_flags.NOCTTY = !flags.allow_ctty;</span>
<span class="line" id="L830"></span>
<span class="line" id="L831">    <span class="tok-comment">// Use the O locking flags if the os supports them to acquire the lock</span>
</span>
<span class="line" id="L832">    <span class="tok-comment">// atomically.</span>
</span>
<span class="line" id="L833">    <span class="tok-kw">const</span> has_flock_open_flags = <span class="tok-builtin">@hasField</span>(posix.O, <span class="tok-str">&quot;EXLOCK&quot;</span>);</span>
<span class="line" id="L834">    <span class="tok-kw">if</span> (has_flock_open_flags) {</span>
<span class="line" id="L835">        <span class="tok-comment">// Note that the NONBLOCK flag is removed after the openat() call</span>
</span>
<span class="line" id="L836">        <span class="tok-comment">// is successful.</span>
</span>
<span class="line" id="L837">        <span class="tok-kw">switch</span> (flags.lock) {</span>
<span class="line" id="L838">            .none =&gt; {},</span>
<span class="line" id="L839">            .shared =&gt; {</span>
<span class="line" id="L840">                os_flags.SHLOCK = <span class="tok-null">true</span>;</span>
<span class="line" id="L841">                os_flags.NONBLOCK = flags.lock_nonblocking;</span>
<span class="line" id="L842">            },</span>
<span class="line" id="L843">            .exclusive =&gt; {</span>
<span class="line" id="L844">                os_flags.EXLOCK = <span class="tok-null">true</span>;</span>
<span class="line" id="L845">                os_flags.NONBLOCK = flags.lock_nonblocking;</span>
<span class="line" id="L846">            },</span>
<span class="line" id="L847">        }</span>
<span class="line" id="L848">    }</span>
<span class="line" id="L849">    <span class="tok-kw">const</span> fd = <span class="tok-kw">try</span> posix.openatZ(self.fd, sub_path, os_flags, <span class="tok-number">0</span>);</span>
<span class="line" id="L850">    <span class="tok-kw">errdefer</span> posix.close(fd);</span>
<span class="line" id="L851"></span>
<span class="line" id="L852">    <span class="tok-kw">if</span> (<span class="tok-builtin">@hasDecl</span>(posix.system, <span class="tok-str">&quot;LOCK&quot;</span>)) {</span>
<span class="line" id="L853">        <span class="tok-kw">if</span> (!has_flock_open_flags <span class="tok-kw">and</span> flags.lock != .none) {</span>
<span class="line" id="L854">            <span class="tok-comment">// TODO: integrate async I/O</span>
</span>
<span class="line" id="L855">            <span class="tok-kw">const</span> lock_nonblocking: <span class="tok-type">i32</span> = <span class="tok-kw">if</span> (flags.lock_nonblocking) posix.LOCK.NB <span class="tok-kw">else</span> <span class="tok-number">0</span>;</span>
<span class="line" id="L856">            <span class="tok-kw">try</span> posix.flock(fd, <span class="tok-kw">switch</span> (flags.lock) {</span>
<span class="line" id="L857">                .none =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L858">                .shared =&gt; posix.LOCK.SH | lock_nonblocking,</span>
<span class="line" id="L859">                .exclusive =&gt; posix.LOCK.EX | lock_nonblocking,</span>
<span class="line" id="L860">            });</span>
<span class="line" id="L861">        }</span>
<span class="line" id="L862">    }</span>
<span class="line" id="L863"></span>
<span class="line" id="L864">    <span class="tok-kw">if</span> (has_flock_open_flags <span class="tok-kw">and</span> flags.lock_nonblocking) {</span>
<span class="line" id="L865">        <span class="tok-kw">var</span> fl_flags = posix.fcntl(fd, posix.F.GETFL, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L866">            <span class="tok-kw">error</span>.FileBusy =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L867">            <span class="tok-kw">error</span>.Locked =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L868">            <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L869">            <span class="tok-kw">error</span>.DeadLock =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L870">            <span class="tok-kw">error</span>.LockedRegionLimitExceeded =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L871">            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L872">        };</span>
<span class="line" id="L873">        fl_flags &amp;= ~<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">1</span> &lt;&lt; <span class="tok-builtin">@bitOffsetOf</span>(posix.O, <span class="tok-str">&quot;NONBLOCK&quot;</span>));</span>
<span class="line" id="L874">        _ = posix.fcntl(fd, posix.F.SETFL, fl_flags) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L875">            <span class="tok-kw">error</span>.FileBusy =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L876">            <span class="tok-kw">error</span>.Locked =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L877">            <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L878">            <span class="tok-kw">error</span>.DeadLock =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L879">            <span class="tok-kw">error</span>.LockedRegionLimitExceeded =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L880">            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L881">        };</span>
<span class="line" id="L882">    }</span>
<span class="line" id="L883"></span>
<span class="line" id="L884">    <span class="tok-kw">return</span> .{ .handle = fd };</span>
<span class="line" id="L885">}</span>
<span class="line" id="L886"></span>
<span class="line" id="L887"><span class="tok-comment">/// Same as `openFile` but Windows-only and the path parameter is</span></span>
<span class="line" id="L888"><span class="tok-comment">/// [WTF-16](https://simonsapin.github.io/wtf-8/#potentially-ill-formed-utf-16) encoded.</span></span>
<span class="line" id="L889"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openFileW</span>(self: Dir, sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>, flags: File.OpenFlags) File.OpenError!File {</span>
<span class="line" id="L890">    <span class="tok-kw">const</span> w = std.os.windows;</span>
<span class="line" id="L891">    <span class="tok-kw">const</span> file: File = .{</span>
<span class="line" id="L892">        .handle = <span class="tok-kw">try</span> w.OpenFile(sub_path_w, .{</span>
<span class="line" id="L893">            .dir = self.fd,</span>
<span class="line" id="L894">            .access_mask = w.SYNCHRONIZE |</span>
<span class="line" id="L895">                (<span class="tok-kw">if</span> (flags.isRead()) <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, w.GENERIC_READ) <span class="tok-kw">else</span> <span class="tok-number">0</span>) |</span>
<span class="line" id="L896">                (<span class="tok-kw">if</span> (flags.isWrite()) <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, w.GENERIC_WRITE) <span class="tok-kw">else</span> <span class="tok-number">0</span>),</span>
<span class="line" id="L897">            .creation = w.FILE_OPEN,</span>
<span class="line" id="L898">        }),</span>
<span class="line" id="L899">    };</span>
<span class="line" id="L900">    <span class="tok-kw">errdefer</span> file.close();</span>
<span class="line" id="L901">    <span class="tok-kw">var</span> io: w.IO_STATUS_BLOCK = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L902">    <span class="tok-kw">const</span> range_off: w.LARGE_INTEGER = <span class="tok-number">0</span>;</span>
<span class="line" id="L903">    <span class="tok-kw">const</span> range_len: w.LARGE_INTEGER = <span class="tok-number">1</span>;</span>
<span class="line" id="L904">    <span class="tok-kw">const</span> exclusive = <span class="tok-kw">switch</span> (flags.lock) {</span>
<span class="line" id="L905">        .none =&gt; <span class="tok-kw">return</span> file,</span>
<span class="line" id="L906">        .shared =&gt; <span class="tok-null">false</span>,</span>
<span class="line" id="L907">        .exclusive =&gt; <span class="tok-null">true</span>,</span>
<span class="line" id="L908">    };</span>
<span class="line" id="L909">    <span class="tok-kw">try</span> w.LockFile(</span>
<span class="line" id="L910">        file.handle,</span>
<span class="line" id="L911">        <span class="tok-null">null</span>,</span>
<span class="line" id="L912">        <span class="tok-null">null</span>,</span>
<span class="line" id="L913">        <span class="tok-null">null</span>,</span>
<span class="line" id="L914">        &amp;io,</span>
<span class="line" id="L915">        &amp;range_off,</span>
<span class="line" id="L916">        &amp;range_len,</span>
<span class="line" id="L917">        <span class="tok-null">null</span>,</span>
<span class="line" id="L918">        <span class="tok-builtin">@intFromBool</span>(flags.lock_nonblocking),</span>
<span class="line" id="L919">        <span class="tok-builtin">@intFromBool</span>(exclusive),</span>
<span class="line" id="L920">    );</span>
<span class="line" id="L921">    <span class="tok-kw">return</span> file;</span>
<span class="line" id="L922">}</span>
<span class="line" id="L923"></span>
<span class="line" id="L924"><span class="tok-comment">/// Creates, opens, or overwrites a file with write access.</span></span>
<span class="line" id="L925"><span class="tok-comment">/// Call `File.close` on the result when done.</span></span>
<span class="line" id="L926"><span class="tok-comment">/// Asserts that the path parameter has no null bytes.</span></span>
<span class="line" id="L927"><span class="tok-comment">/// On Windows, `sub_path` should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span></span>
<span class="line" id="L928"><span class="tok-comment">/// On WASI, `sub_path` should be encoded as valid UTF-8.</span></span>
<span class="line" id="L929"><span class="tok-comment">/// On other platforms, `sub_path` is an opaque sequence of bytes with no particular encoding.</span></span>
<span class="line" id="L930"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">createFile</span>(self: Dir, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: File.CreateFlags) File.OpenError!File {</span>
<span class="line" id="L931">    <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L932">        <span class="tok-kw">const</span> path_w = <span class="tok-kw">try</span> std.os.windows.sliceToPrefixedFileW(self.fd, sub_path);</span>
<span class="line" id="L933">        <span class="tok-kw">return</span> self.createFileW(path_w.span(), flags);</span>
<span class="line" id="L934">    }</span>
<span class="line" id="L935">    <span class="tok-kw">if</span> (builtin.os.tag == .wasi) {</span>
<span class="line" id="L936">        <span class="tok-kw">return</span> .{</span>
<span class="line" id="L937">            .handle = <span class="tok-kw">try</span> posix.openatWasi(self.fd, sub_path, .{}, .{</span>
<span class="line" id="L938">                .CREAT = <span class="tok-null">true</span>,</span>
<span class="line" id="L939">                .TRUNC = flags.truncate,</span>
<span class="line" id="L940">                .EXCL = flags.exclusive,</span>
<span class="line" id="L941">            }, .{}, .{</span>
<span class="line" id="L942">                .FD_READ = flags.read,</span>
<span class="line" id="L943">                .FD_WRITE = <span class="tok-null">true</span>,</span>
<span class="line" id="L944">                .FD_DATASYNC = <span class="tok-null">true</span>,</span>
<span class="line" id="L945">                .FD_SEEK = <span class="tok-null">true</span>,</span>
<span class="line" id="L946">                .FD_TELL = <span class="tok-null">true</span>,</span>
<span class="line" id="L947">                .FD_FDSTAT_SET_FLAGS = <span class="tok-null">true</span>,</span>
<span class="line" id="L948">                .FD_SYNC = <span class="tok-null">true</span>,</span>
<span class="line" id="L949">                .FD_ALLOCATE = <span class="tok-null">true</span>,</span>
<span class="line" id="L950">                .FD_ADVISE = <span class="tok-null">true</span>,</span>
<span class="line" id="L951">                .FD_FILESTAT_SET_TIMES = <span class="tok-null">true</span>,</span>
<span class="line" id="L952">                .FD_FILESTAT_SET_SIZE = <span class="tok-null">true</span>,</span>
<span class="line" id="L953">                .FD_FILESTAT_GET = <span class="tok-null">true</span>,</span>
<span class="line" id="L954">            }, .{}),</span>
<span class="line" id="L955">        };</span>
<span class="line" id="L956">    }</span>
<span class="line" id="L957">    <span class="tok-kw">const</span> path_c = <span class="tok-kw">try</span> posix.toPosixPath(sub_path);</span>
<span class="line" id="L958">    <span class="tok-kw">return</span> self.createFileZ(&amp;path_c, flags);</span>
<span class="line" id="L959">}</span>
<span class="line" id="L960"></span>
<span class="line" id="L961"><span class="tok-comment">/// Same as `createFile` but the path parameter is null-terminated.</span></span>
<span class="line" id="L962"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">createFileZ</span>(self: Dir, sub_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: File.CreateFlags) File.OpenError!File {</span>
<span class="line" id="L963">    <span class="tok-kw">switch</span> (builtin.os.tag) {</span>
<span class="line" id="L964">        .windows =&gt; {</span>
<span class="line" id="L965">            <span class="tok-kw">const</span> path_w = <span class="tok-kw">try</span> std.os.windows.cStrToPrefixedFileW(self.fd, sub_path_c);</span>
<span class="line" id="L966">            <span class="tok-kw">return</span> self.createFileW(path_w.span(), flags);</span>
<span class="line" id="L967">        },</span>
<span class="line" id="L968">        .wasi =&gt; {</span>
<span class="line" id="L969">            <span class="tok-kw">return</span> createFile(self, mem.sliceTo(sub_path_c, <span class="tok-number">0</span>), flags);</span>
<span class="line" id="L970">        },</span>
<span class="line" id="L971">        <span class="tok-kw">else</span> =&gt; {},</span>
<span class="line" id="L972">    }</span>
<span class="line" id="L973"></span>
<span class="line" id="L974">    <span class="tok-kw">var</span> os_flags: std.os.O = .{</span>
<span class="line" id="L975">        .ACCMODE = <span class="tok-kw">if</span> (flags.read) .RDWR <span class="tok-kw">else</span> .WRONLY,</span>
<span class="line" id="L976">        .CREAT = <span class="tok-null">true</span>,</span>
<span class="line" id="L977">        .TRUNC = flags.truncate,</span>
<span class="line" id="L978">        .EXCL = flags.exclusive,</span>
<span class="line" id="L979">    };</span>
<span class="line" id="L980">    <span class="tok-kw">if</span> (<span class="tok-builtin">@hasField</span>(posix.O, <span class="tok-str">&quot;LARGEFILE&quot;</span>)) os_flags.LARGEFILE = <span class="tok-null">true</span>;</span>
<span class="line" id="L981">    <span class="tok-kw">if</span> (<span class="tok-builtin">@hasField</span>(posix.O, <span class="tok-str">&quot;CLOEXEC&quot;</span>)) os_flags.CLOEXEC = <span class="tok-null">true</span>;</span>
<span class="line" id="L982"></span>
<span class="line" id="L983">    <span class="tok-comment">// Use the O locking flags if the os supports them to acquire the lock</span>
</span>
<span class="line" id="L984">    <span class="tok-comment">// atomically. Note that the NONBLOCK flag is removed after the openat()</span>
</span>
<span class="line" id="L985">    <span class="tok-comment">// call is successful.</span>
</span>
<span class="line" id="L986">    <span class="tok-kw">const</span> has_flock_open_flags = <span class="tok-builtin">@hasField</span>(posix.O, <span class="tok-str">&quot;EXLOCK&quot;</span>);</span>
<span class="line" id="L987">    <span class="tok-kw">if</span> (has_flock_open_flags) <span class="tok-kw">switch</span> (flags.lock) {</span>
<span class="line" id="L988">        .none =&gt; {},</span>
<span class="line" id="L989">        .shared =&gt; {</span>
<span class="line" id="L990">            os_flags.SHLOCK = <span class="tok-null">true</span>;</span>
<span class="line" id="L991">            os_flags.NONBLOCK = flags.lock_nonblocking;</span>
<span class="line" id="L992">        },</span>
<span class="line" id="L993">        .exclusive =&gt; {</span>
<span class="line" id="L994">            os_flags.EXLOCK = <span class="tok-null">true</span>;</span>
<span class="line" id="L995">            os_flags.NONBLOCK = flags.lock_nonblocking;</span>
<span class="line" id="L996">        },</span>
<span class="line" id="L997">    };</span>
<span class="line" id="L998"></span>
<span class="line" id="L999">    <span class="tok-kw">const</span> fd = <span class="tok-kw">try</span> posix.openatZ(self.fd, sub_path_c, os_flags, flags.mode);</span>
<span class="line" id="L1000">    <span class="tok-kw">errdefer</span> posix.close(fd);</span>
<span class="line" id="L1001"></span>
<span class="line" id="L1002">    <span class="tok-kw">if</span> (!has_flock_open_flags <span class="tok-kw">and</span> flags.lock != .none) {</span>
<span class="line" id="L1003">        <span class="tok-comment">// TODO: integrate async I/O</span>
</span>
<span class="line" id="L1004">        <span class="tok-kw">const</span> lock_nonblocking: <span class="tok-type">i32</span> = <span class="tok-kw">if</span> (flags.lock_nonblocking) posix.LOCK.NB <span class="tok-kw">else</span> <span class="tok-number">0</span>;</span>
<span class="line" id="L1005">        <span class="tok-kw">try</span> posix.flock(fd, <span class="tok-kw">switch</span> (flags.lock) {</span>
<span class="line" id="L1006">            .none =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1007">            .shared =&gt; posix.LOCK.SH | lock_nonblocking,</span>
<span class="line" id="L1008">            .exclusive =&gt; posix.LOCK.EX | lock_nonblocking,</span>
<span class="line" id="L1009">        });</span>
<span class="line" id="L1010">    }</span>
<span class="line" id="L1011"></span>
<span class="line" id="L1012">    <span class="tok-kw">if</span> (has_flock_open_flags <span class="tok-kw">and</span> flags.lock_nonblocking) {</span>
<span class="line" id="L1013">        <span class="tok-kw">var</span> fl_flags = posix.fcntl(fd, posix.F.GETFL, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1014">            <span class="tok-kw">error</span>.FileBusy =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1015">            <span class="tok-kw">error</span>.Locked =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1016">            <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1017">            <span class="tok-kw">error</span>.DeadLock =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1018">            <span class="tok-kw">error</span>.LockedRegionLimitExceeded =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1019">            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L1020">        };</span>
<span class="line" id="L1021">        fl_flags &amp;= ~<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">1</span> &lt;&lt; <span class="tok-builtin">@bitOffsetOf</span>(posix.O, <span class="tok-str">&quot;NONBLOCK&quot;</span>));</span>
<span class="line" id="L1022">        _ = posix.fcntl(fd, posix.F.SETFL, fl_flags) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1023">            <span class="tok-kw">error</span>.FileBusy =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1024">            <span class="tok-kw">error</span>.Locked =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1025">            <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1026">            <span class="tok-kw">error</span>.DeadLock =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1027">            <span class="tok-kw">error</span>.LockedRegionLimitExceeded =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1028">            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L1029">        };</span>
<span class="line" id="L1030">    }</span>
<span class="line" id="L1031"></span>
<span class="line" id="L1032">    <span class="tok-kw">return</span> .{ .handle = fd };</span>
<span class="line" id="L1033">}</span>
<span class="line" id="L1034"></span>
<span class="line" id="L1035"><span class="tok-comment">/// Same as `createFile` but Windows-only and the path parameter is</span></span>
<span class="line" id="L1036"><span class="tok-comment">/// [WTF-16](https://simonsapin.github.io/wtf-8/#potentially-ill-formed-utf-16) encoded.</span></span>
<span class="line" id="L1037"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">createFileW</span>(self: Dir, sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>, flags: File.CreateFlags) File.OpenError!File {</span>
<span class="line" id="L1038">    <span class="tok-kw">const</span> w = std.os.windows;</span>
<span class="line" id="L1039">    <span class="tok-kw">const</span> read_flag = <span class="tok-kw">if</span> (flags.read) <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, w.GENERIC_READ) <span class="tok-kw">else</span> <span class="tok-number">0</span>;</span>
<span class="line" id="L1040">    <span class="tok-kw">const</span> file: File = .{</span>
<span class="line" id="L1041">        .handle = <span class="tok-kw">try</span> w.OpenFile(sub_path_w, .{</span>
<span class="line" id="L1042">            .dir = self.fd,</span>
<span class="line" id="L1043">            .access_mask = w.SYNCHRONIZE | w.GENERIC_WRITE | read_flag,</span>
<span class="line" id="L1044">            .creation = <span class="tok-kw">if</span> (flags.exclusive)</span>
<span class="line" id="L1045">                <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, w.FILE_CREATE)</span>
<span class="line" id="L1046">            <span class="tok-kw">else</span> <span class="tok-kw">if</span> (flags.truncate)</span>
<span class="line" id="L1047">                <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, w.FILE_OVERWRITE_IF)</span>
<span class="line" id="L1048">            <span class="tok-kw">else</span></span>
<span class="line" id="L1049">                <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, w.FILE_OPEN_IF),</span>
<span class="line" id="L1050">        }),</span>
<span class="line" id="L1051">    };</span>
<span class="line" id="L1052">    <span class="tok-kw">errdefer</span> file.close();</span>
<span class="line" id="L1053">    <span class="tok-kw">var</span> io: w.IO_STATUS_BLOCK = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1054">    <span class="tok-kw">const</span> range_off: w.LARGE_INTEGER = <span class="tok-number">0</span>;</span>
<span class="line" id="L1055">    <span class="tok-kw">const</span> range_len: w.LARGE_INTEGER = <span class="tok-number">1</span>;</span>
<span class="line" id="L1056">    <span class="tok-kw">const</span> exclusive = <span class="tok-kw">switch</span> (flags.lock) {</span>
<span class="line" id="L1057">        .none =&gt; <span class="tok-kw">return</span> file,</span>
<span class="line" id="L1058">        .shared =&gt; <span class="tok-null">false</span>,</span>
<span class="line" id="L1059">        .exclusive =&gt; <span class="tok-null">true</span>,</span>
<span class="line" id="L1060">    };</span>
<span class="line" id="L1061">    <span class="tok-kw">try</span> w.LockFile(</span>
<span class="line" id="L1062">        file.handle,</span>
<span class="line" id="L1063">        <span class="tok-null">null</span>,</span>
<span class="line" id="L1064">        <span class="tok-null">null</span>,</span>
<span class="line" id="L1065">        <span class="tok-null">null</span>,</span>
<span class="line" id="L1066">        &amp;io,</span>
<span class="line" id="L1067">        &amp;range_off,</span>
<span class="line" id="L1068">        &amp;range_len,</span>
<span class="line" id="L1069">        <span class="tok-null">null</span>,</span>
<span class="line" id="L1070">        <span class="tok-builtin">@intFromBool</span>(flags.lock_nonblocking),</span>
<span class="line" id="L1071">        <span class="tok-builtin">@intFromBool</span>(exclusive),</span>
<span class="line" id="L1072">    );</span>
<span class="line" id="L1073">    <span class="tok-kw">return</span> file;</span>
<span class="line" id="L1074">}</span>
<span class="line" id="L1075"></span>
<span class="line" id="L1076"><span class="tok-comment">/// Creates a single directory with a relative or absolute path.</span></span>
<span class="line" id="L1077"><span class="tok-comment">/// To create multiple directories to make an entire path, see `makePath`.</span></span>
<span class="line" id="L1078"><span class="tok-comment">/// To operate on only absolute paths, see `makeDirAbsolute`.</span></span>
<span class="line" id="L1079"><span class="tok-comment">/// On Windows, `sub_path` should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span></span>
<span class="line" id="L1080"><span class="tok-comment">/// On WASI, `sub_path` should be encoded as valid UTF-8.</span></span>
<span class="line" id="L1081"><span class="tok-comment">/// On other platforms, `sub_path` is an opaque sequence of bytes with no particular encoding.</span></span>
<span class="line" id="L1082"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">makeDir</span>(self: Dir, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1083">    <span class="tok-kw">try</span> posix.mkdirat(self.fd, sub_path, default_mode);</span>
<span class="line" id="L1084">}</span>
<span class="line" id="L1085"></span>
<span class="line" id="L1086"><span class="tok-comment">/// Same as `makeDir`, but `sub_path` is null-terminated.</span></span>
<span class="line" id="L1087"><span class="tok-comment">/// To create multiple directories to make an entire path, see `makePath`.</span></span>
<span class="line" id="L1088"><span class="tok-comment">/// To operate on only absolute paths, see `makeDirAbsoluteZ`.</span></span>
<span class="line" id="L1089"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">makeDirZ</span>(self: Dir, sub_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1090">    <span class="tok-kw">try</span> posix.mkdiratZ(self.fd, sub_path, default_mode);</span>
<span class="line" id="L1091">}</span>
<span class="line" id="L1092"></span>
<span class="line" id="L1093"><span class="tok-comment">/// Creates a single directory with a relative or absolute null-terminated WTF-16 LE-encoded path.</span></span>
<span class="line" id="L1094"><span class="tok-comment">/// To create multiple directories to make an entire path, see `makePath`.</span></span>
<span class="line" id="L1095"><span class="tok-comment">/// To operate on only absolute paths, see `makeDirAbsoluteW`.</span></span>
<span class="line" id="L1096"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">makeDirW</span>(self: Dir, sub_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1097">    <span class="tok-kw">try</span> posix.mkdiratW(self.fd, sub_path, default_mode);</span>
<span class="line" id="L1098">}</span>
<span class="line" id="L1099"></span>
<span class="line" id="L1100"><span class="tok-comment">/// Calls makeDir iteratively to make an entire path</span></span>
<span class="line" id="L1101"><span class="tok-comment">/// (i.e. creating any parent directories that do not exist).</span></span>
<span class="line" id="L1102"><span class="tok-comment">/// Returns success if the path already exists and is a directory.</span></span>
<span class="line" id="L1103"><span class="tok-comment">/// This function is not atomic, and if it returns an error, the file system may</span></span>
<span class="line" id="L1104"><span class="tok-comment">/// have been modified regardless.</span></span>
<span class="line" id="L1105"><span class="tok-comment">/// On Windows, `sub_path` should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span></span>
<span class="line" id="L1106"><span class="tok-comment">/// On WASI, `sub_path` should be encoded as valid UTF-8.</span></span>
<span class="line" id="L1107"><span class="tok-comment">/// On other platforms, `sub_path` is an opaque sequence of bytes with no particular encoding.</span></span>
<span class="line" id="L1108"><span class="tok-comment">///</span></span>
<span class="line" id="L1109"><span class="tok-comment">/// Paths containing `..` components are handled differently depending on the platform:</span></span>
<span class="line" id="L1110"><span class="tok-comment">/// - On Windows, `..` are resolved before the path is passed to NtCreateFile, meaning</span></span>
<span class="line" id="L1111"><span class="tok-comment">///   a `sub_path` like &quot;first/../second&quot; will resolve to &quot;second&quot; and only a</span></span>
<span class="line" id="L1112"><span class="tok-comment">///   `./second` directory will be created.</span></span>
<span class="line" id="L1113"><span class="tok-comment">/// - On other platforms, `..` are not resolved before the path is passed to `mkdirat`,</span></span>
<span class="line" id="L1114"><span class="tok-comment">///   meaning a `sub_path` like &quot;first/../second&quot; will create both a `./first`</span></span>
<span class="line" id="L1115"><span class="tok-comment">///   and a `./second` directory.</span></span>
<span class="line" id="L1116"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">makePath</span>(self: Dir, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1117">    <span class="tok-kw">var</span> it = <span class="tok-kw">try</span> fs.path.componentIterator(sub_path);</span>
<span class="line" id="L1118">    <span class="tok-kw">var</span> component = it.last() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L1119">    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L1120">        self.makeDir(component.path) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1121">            <span class="tok-kw">error</span>.PathAlreadyExists =&gt; {</span>
<span class="line" id="L1122">                <span class="tok-comment">// stat the file and return an error if it's not a directory</span>
</span>
<span class="line" id="L1123">                <span class="tok-comment">// this is important because otherwise a dangling symlink</span>
</span>
<span class="line" id="L1124">                <span class="tok-comment">// could cause an infinite loop</span>
</span>
<span class="line" id="L1125">                check_dir: {</span>
<span class="line" id="L1126">                    <span class="tok-comment">// workaround for windows, see https://github.com/ziglang/zig/issues/16738</span>
</span>
<span class="line" id="L1127">                    <span class="tok-kw">const</span> fstat = self.statFile(component.path) <span class="tok-kw">catch</span> |stat_err| <span class="tok-kw">switch</span> (stat_err) {</span>
<span class="line" id="L1128">                        <span class="tok-kw">error</span>.IsDir =&gt; <span class="tok-kw">break</span> :check_dir,</span>
<span class="line" id="L1129">                        <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L1130">                    };</span>
<span class="line" id="L1131">                    <span class="tok-kw">if</span> (fstat.kind != .directory) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir;</span>
<span class="line" id="L1132">                }</span>
<span class="line" id="L1133">            },</span>
<span class="line" id="L1134">            <span class="tok-kw">error</span>.FileNotFound =&gt; |e| {</span>
<span class="line" id="L1135">                component = it.previous() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> e;</span>
<span class="line" id="L1136">                <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1137">            },</span>
<span class="line" id="L1138">            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L1139">        };</span>
<span class="line" id="L1140">        component = it.next() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L1141">    }</span>
<span class="line" id="L1142">}</span>
<span class="line" id="L1143"></span>
<span class="line" id="L1144"><span class="tok-comment">/// Windows only. Calls makeOpenDirAccessMaskW iteratively to make an entire path</span></span>
<span class="line" id="L1145"><span class="tok-comment">/// (i.e. creating any parent directories that do not exist).</span></span>
<span class="line" id="L1146"><span class="tok-comment">/// Opens the dir if the path already exists and is a directory.</span></span>
<span class="line" id="L1147"><span class="tok-comment">/// This function is not atomic, and if it returns an error, the file system may</span></span>
<span class="line" id="L1148"><span class="tok-comment">/// have been modified regardless.</span></span>
<span class="line" id="L1149"><span class="tok-comment">/// `sub_path` should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span></span>
<span class="line" id="L1150"><span class="tok-kw">fn</span> <span class="tok-fn">makeOpenPathAccessMaskW</span>(self: Dir, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, access_mask: <span class="tok-type">u32</span>, no_follow: <span class="tok-type">bool</span>) OpenError!Dir {</span>
<span class="line" id="L1151">    <span class="tok-kw">const</span> w = std.os.windows;</span>
<span class="line" id="L1152">    <span class="tok-kw">var</span> it = <span class="tok-kw">try</span> fs.path.componentIterator(sub_path);</span>
<span class="line" id="L1153">    <span class="tok-comment">// If there are no components in the path, then create a dummy component with the full path.</span>
</span>
<span class="line" id="L1154">    <span class="tok-kw">var</span> component = it.last() <span class="tok-kw">orelse</span> fs.path.NativeComponentIterator.Component{</span>
<span class="line" id="L1155">        .name = <span class="tok-str">&quot;&quot;</span>,</span>
<span class="line" id="L1156">        .path = sub_path,</span>
<span class="line" id="L1157">    };</span>
<span class="line" id="L1158"></span>
<span class="line" id="L1159">    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L1160">        <span class="tok-kw">const</span> sub_path_w = <span class="tok-kw">try</span> w.sliceToPrefixedFileW(self.fd, component.path);</span>
<span class="line" id="L1161">        <span class="tok-kw">const</span> is_last = it.peekNext() == <span class="tok-null">null</span>;</span>
<span class="line" id="L1162">        <span class="tok-kw">var</span> result = self.makeOpenDirAccessMaskW(sub_path_w.span().ptr, access_mask, .{</span>
<span class="line" id="L1163">            .no_follow = no_follow,</span>
<span class="line" id="L1164">            .create_disposition = <span class="tok-kw">if</span> (is_last) w.FILE_OPEN_IF <span class="tok-kw">else</span> w.FILE_CREATE,</span>
<span class="line" id="L1165">        }) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1166">            <span class="tok-kw">error</span>.FileNotFound =&gt; |e| {</span>
<span class="line" id="L1167">                component = it.previous() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> e;</span>
<span class="line" id="L1168">                <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1169">            },</span>
<span class="line" id="L1170">            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L1171">        };</span>
<span class="line" id="L1172"></span>
<span class="line" id="L1173">        component = it.next() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> result;</span>
<span class="line" id="L1174">        <span class="tok-comment">// Don't leak the intermediate file handles</span>
</span>
<span class="line" id="L1175">        result.close();</span>
<span class="line" id="L1176">    }</span>
<span class="line" id="L1177">}</span>
<span class="line" id="L1178"></span>
<span class="line" id="L1179"><span class="tok-comment">/// This function performs `makePath`, followed by `openDir`.</span></span>
<span class="line" id="L1180"><span class="tok-comment">/// If supported by the OS, this operation is atomic. It is not atomic on</span></span>
<span class="line" id="L1181"><span class="tok-comment">/// all operating systems.</span></span>
<span class="line" id="L1182"><span class="tok-comment">/// On Windows, `sub_path` should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span></span>
<span class="line" id="L1183"><span class="tok-comment">/// On WASI, `sub_path` should be encoded as valid UTF-8.</span></span>
<span class="line" id="L1184"><span class="tok-comment">/// On other platforms, `sub_path` is an opaque sequence of bytes with no particular encoding.</span></span>
<span class="line" id="L1185"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">makeOpenPath</span>(self: Dir, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, open_dir_options: OpenDirOptions) !Dir {</span>
<span class="line" id="L1186">    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (builtin.os.tag) {</span>
<span class="line" id="L1187">        .windows =&gt; {</span>
<span class="line" id="L1188">            <span class="tok-kw">const</span> w = std.os.windows;</span>
<span class="line" id="L1189">            <span class="tok-kw">const</span> base_flags = w.STANDARD_RIGHTS_READ | w.FILE_READ_ATTRIBUTES | w.FILE_READ_EA |</span>
<span class="line" id="L1190">                w.SYNCHRONIZE | w.FILE_TRAVERSE |</span>
<span class="line" id="L1191">                (<span class="tok-kw">if</span> (open_dir_options.iterate) w.FILE_LIST_DIRECTORY <span class="tok-kw">else</span> <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0</span>));</span>
<span class="line" id="L1192"></span>
<span class="line" id="L1193">            <span class="tok-kw">return</span> self.makeOpenPathAccessMaskW(sub_path, base_flags, open_dir_options.no_follow);</span>
<span class="line" id="L1194">        },</span>
<span class="line" id="L1195">        <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L1196">            <span class="tok-kw">return</span> self.openDir(sub_path, open_dir_options) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1197">                <span class="tok-kw">error</span>.FileNotFound =&gt; {</span>
<span class="line" id="L1198">                    <span class="tok-kw">try</span> self.makePath(sub_path);</span>
<span class="line" id="L1199">                    <span class="tok-kw">return</span> self.openDir(sub_path, open_dir_options);</span>
<span class="line" id="L1200">                },</span>
<span class="line" id="L1201">                <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L1202">            };</span>
<span class="line" id="L1203">        },</span>
<span class="line" id="L1204">    };</span>
<span class="line" id="L1205">}</span>
<span class="line" id="L1206"></span>
<span class="line" id="L1207"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> RealPathError = posix.RealPathError;</span>
<span class="line" id="L1208"></span>
<span class="line" id="L1209"><span class="tok-comment">///  This function returns the canonicalized absolute pathname of</span></span>
<span class="line" id="L1210"><span class="tok-comment">/// `pathname` relative to this `Dir`. If `pathname` is absolute, ignores this</span></span>
<span class="line" id="L1211"><span class="tok-comment">/// `Dir` handle and returns the canonicalized absolute pathname of `pathname`</span></span>
<span class="line" id="L1212"><span class="tok-comment">/// argument.</span></span>
<span class="line" id="L1213"><span class="tok-comment">/// On Windows, `sub_path` should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span></span>
<span class="line" id="L1214"><span class="tok-comment">/// On other platforms, `sub_path` is an opaque sequence of bytes with no particular encoding.</span></span>
<span class="line" id="L1215"><span class="tok-comment">/// On Windows, the result is encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span></span>
<span class="line" id="L1216"><span class="tok-comment">/// On other platforms, the result is an opaque sequence of bytes with no particular encoding.</span></span>
<span class="line" id="L1217"><span class="tok-comment">/// This function is not universally supported by all platforms.</span></span>
<span class="line" id="L1218"><span class="tok-comment">/// Currently supported hosts are: Linux, macOS, and Windows.</span></span>
<span class="line" id="L1219"><span class="tok-comment">/// See also `Dir.realpathZ`, `Dir.realpathW`, and `Dir.realpathAlloc`.</span></span>
<span class="line" id="L1220"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">realpath</span>(self: Dir, pathname: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, out_buffer: []<span class="tok-type">u8</span>) RealPathError![]<span class="tok-type">u8</span> {</span>
<span class="line" id="L1221">    <span class="tok-kw">if</span> (builtin.os.tag == .wasi) {</span>
<span class="line" id="L1222">        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;realpath is not available on WASI&quot;</span>);</span>
<span class="line" id="L1223">    }</span>
<span class="line" id="L1224">    <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L1225">        <span class="tok-kw">const</span> pathname_w = <span class="tok-kw">try</span> std.os.windows.sliceToPrefixedFileW(self.fd, pathname);</span>
<span class="line" id="L1226">        <span class="tok-kw">return</span> self.realpathW(pathname_w.span(), out_buffer);</span>
<span class="line" id="L1227">    }</span>
<span class="line" id="L1228">    <span class="tok-kw">const</span> pathname_c = <span class="tok-kw">try</span> posix.toPosixPath(pathname);</span>
<span class="line" id="L1229">    <span class="tok-kw">return</span> self.realpathZ(&amp;pathname_c, out_buffer);</span>
<span class="line" id="L1230">}</span>
<span class="line" id="L1231"></span>
<span class="line" id="L1232"><span class="tok-comment">/// Same as `Dir.realpath` except `pathname` is null-terminated.</span></span>
<span class="line" id="L1233"><span class="tok-comment">/// See also `Dir.realpath`, `realpathZ`.</span></span>
<span class="line" id="L1234"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">realpathZ</span>(self: Dir, pathname: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, out_buffer: []<span class="tok-type">u8</span>) RealPathError![]<span class="tok-type">u8</span> {</span>
<span class="line" id="L1235">    <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L1236">        <span class="tok-kw">const</span> pathname_w = <span class="tok-kw">try</span> posix.windows.cStrToPrefixedFileW(self.fd, pathname);</span>
<span class="line" id="L1237">        <span class="tok-kw">return</span> self.realpathW(pathname_w.span(), out_buffer);</span>
<span class="line" id="L1238">    }</span>
<span class="line" id="L1239"></span>
<span class="line" id="L1240">    <span class="tok-kw">const</span> flags: posix.O = <span class="tok-kw">switch</span> (builtin.os.tag) {</span>
<span class="line" id="L1241">        .linux =&gt; .{</span>
<span class="line" id="L1242">            .NONBLOCK = <span class="tok-null">true</span>,</span>
<span class="line" id="L1243">            .CLOEXEC = <span class="tok-null">true</span>,</span>
<span class="line" id="L1244">            .PATH = <span class="tok-null">true</span>,</span>
<span class="line" id="L1245">        },</span>
<span class="line" id="L1246">        <span class="tok-kw">else</span> =&gt; .{</span>
<span class="line" id="L1247">            .NONBLOCK = <span class="tok-null">true</span>,</span>
<span class="line" id="L1248">            .CLOEXEC = <span class="tok-null">true</span>,</span>
<span class="line" id="L1249">        },</span>
<span class="line" id="L1250">    };</span>
<span class="line" id="L1251"></span>
<span class="line" id="L1252">    <span class="tok-kw">const</span> fd = posix.openatZ(self.fd, pathname, flags, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1253">        <span class="tok-kw">error</span>.FileLocksNotSupported =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected,</span>
<span class="line" id="L1254">        <span class="tok-kw">error</span>.FileBusy =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected,</span>
<span class="line" id="L1255">        <span class="tok-kw">error</span>.WouldBlock =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected,</span>
<span class="line" id="L1256">        <span class="tok-kw">error</span>.InvalidUtf8 =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// WASI-only</span>
</span>
<span class="line" id="L1257">        <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L1258">    };</span>
<span class="line" id="L1259">    <span class="tok-kw">defer</span> posix.close(fd);</span>
<span class="line" id="L1260"></span>
<span class="line" id="L1261">    <span class="tok-comment">// Use of MAX_PATH_BYTES here is valid as the realpath function does not</span>
</span>
<span class="line" id="L1262">    <span class="tok-comment">// have a variant that takes an arbitrary-size buffer.</span>
</span>
<span class="line" id="L1263">    <span class="tok-comment">// TODO(#4812): Consider reimplementing realpath or using the POSIX.1-2008</span>
</span>
<span class="line" id="L1264">    <span class="tok-comment">// NULL out parameter (GNU's canonicalize_file_name) to handle overelong</span>
</span>
<span class="line" id="L1265">    <span class="tok-comment">// paths. musl supports passing NULL but restricts the output to PATH_MAX</span>
</span>
<span class="line" id="L1266">    <span class="tok-comment">// anyway.</span>
</span>
<span class="line" id="L1267">    <span class="tok-kw">var</span> buffer: [fs.MAX_PATH_BYTES]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1268">    <span class="tok-kw">const</span> out_path = <span class="tok-kw">try</span> posix.getFdPath(fd, &amp;buffer);</span>
<span class="line" id="L1269"></span>
<span class="line" id="L1270">    <span class="tok-kw">if</span> (out_path.len &gt; out_buffer.len) {</span>
<span class="line" id="L1271">        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong;</span>
<span class="line" id="L1272">    }</span>
<span class="line" id="L1273"></span>
<span class="line" id="L1274">    <span class="tok-kw">const</span> result = out_buffer[<span class="tok-number">0</span>..out_path.len];</span>
<span class="line" id="L1275">    <span class="tok-builtin">@memcpy</span>(result, out_path);</span>
<span class="line" id="L1276">    <span class="tok-kw">return</span> result;</span>
<span class="line" id="L1277">}</span>
<span class="line" id="L1278"></span>
<span class="line" id="L1279"><span class="tok-comment">/// Windows-only. Same as `Dir.realpath` except `pathname` is WTF16 LE encoded.</span></span>
<span class="line" id="L1280"><span class="tok-comment">/// The result is encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span></span>
<span class="line" id="L1281"><span class="tok-comment">/// See also `Dir.realpath`, `realpathW`.</span></span>
<span class="line" id="L1282"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">realpathW</span>(self: Dir, pathname: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>, out_buffer: []<span class="tok-type">u8</span>) RealPathError![]<span class="tok-type">u8</span> {</span>
<span class="line" id="L1283">    <span class="tok-kw">const</span> w = std.os.windows;</span>
<span class="line" id="L1284"></span>
<span class="line" id="L1285">    <span class="tok-kw">const</span> access_mask = w.GENERIC_READ | w.SYNCHRONIZE;</span>
<span class="line" id="L1286">    <span class="tok-kw">const</span> share_access = w.FILE_SHARE_READ;</span>
<span class="line" id="L1287">    <span class="tok-kw">const</span> creation = w.FILE_OPEN;</span>
<span class="line" id="L1288">    <span class="tok-kw">const</span> h_file = blk: {</span>
<span class="line" id="L1289">        <span class="tok-kw">const</span> res = w.OpenFile(pathname, .{</span>
<span class="line" id="L1290">            .dir = self.fd,</span>
<span class="line" id="L1291">            .access_mask = access_mask,</span>
<span class="line" id="L1292">            .share_access = share_access,</span>
<span class="line" id="L1293">            .creation = creation,</span>
<span class="line" id="L1294">            .filter = .any,</span>
<span class="line" id="L1295">        }) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1296">            <span class="tok-kw">error</span>.WouldBlock =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1297">            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L1298">        };</span>
<span class="line" id="L1299">        <span class="tok-kw">break</span> :blk res;</span>
<span class="line" id="L1300">    };</span>
<span class="line" id="L1301">    <span class="tok-kw">defer</span> w.CloseHandle(h_file);</span>
<span class="line" id="L1302"></span>
<span class="line" id="L1303">    <span class="tok-kw">var</span> wide_buf: [w.PATH_MAX_WIDE]<span class="tok-type">u16</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1304">    <span class="tok-kw">const</span> wide_slice = <span class="tok-kw">try</span> w.GetFinalPathNameByHandle(h_file, .{}, &amp;wide_buf);</span>
<span class="line" id="L1305">    <span class="tok-kw">var</span> big_out_buf: [fs.MAX_PATH_BYTES]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1306">    <span class="tok-kw">const</span> end_index = std.unicode.wtf16LeToWtf8(&amp;big_out_buf, wide_slice);</span>
<span class="line" id="L1307">    <span class="tok-kw">if</span> (end_index &gt; out_buffer.len)</span>
<span class="line" id="L1308">        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong;</span>
<span class="line" id="L1309">    <span class="tok-kw">const</span> result = out_buffer[<span class="tok-number">0</span>..end_index];</span>
<span class="line" id="L1310">    <span class="tok-builtin">@memcpy</span>(result, big_out_buf[<span class="tok-number">0</span>..end_index]);</span>
<span class="line" id="L1311">    <span class="tok-kw">return</span> result;</span>
<span class="line" id="L1312">}</span>
<span class="line" id="L1313"></span>
<span class="line" id="L1314"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> RealPathAllocError = RealPathError || Allocator.Error;</span>
<span class="line" id="L1315"></span>
<span class="line" id="L1316"><span class="tok-comment">/// Same as `Dir.realpath` except caller must free the returned memory.</span></span>
<span class="line" id="L1317"><span class="tok-comment">/// See also `Dir.realpath`.</span></span>
<span class="line" id="L1318"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">realpathAlloc</span>(self: Dir, allocator: Allocator, pathname: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) RealPathAllocError![]<span class="tok-type">u8</span> {</span>
<span class="line" id="L1319">    <span class="tok-comment">// Use of MAX_PATH_BYTES here is valid as the realpath function does not</span>
</span>
<span class="line" id="L1320">    <span class="tok-comment">// have a variant that takes an arbitrary-size buffer.</span>
</span>
<span class="line" id="L1321">    <span class="tok-comment">// TODO(#4812): Consider reimplementing realpath or using the POSIX.1-2008</span>
</span>
<span class="line" id="L1322">    <span class="tok-comment">// NULL out parameter (GNU's canonicalize_file_name) to handle overelong</span>
</span>
<span class="line" id="L1323">    <span class="tok-comment">// paths. musl supports passing NULL but restricts the output to PATH_MAX</span>
</span>
<span class="line" id="L1324">    <span class="tok-comment">// anyway.</span>
</span>
<span class="line" id="L1325">    <span class="tok-kw">var</span> buf: [fs.MAX_PATH_BYTES]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1326">    <span class="tok-kw">return</span> allocator.dupe(<span class="tok-type">u8</span>, <span class="tok-kw">try</span> self.realpath(pathname, buf[<span class="tok-number">0</span>..]));</span>
<span class="line" id="L1327">}</span>
<span class="line" id="L1328"></span>
<span class="line" id="L1329"><span class="tok-comment">/// Changes the current working directory to the open directory handle.</span></span>
<span class="line" id="L1330"><span class="tok-comment">/// This modifies global state and can have surprising effects in multi-</span></span>
<span class="line" id="L1331"><span class="tok-comment">/// threaded applications. Most applications and especially libraries should</span></span>
<span class="line" id="L1332"><span class="tok-comment">/// not call this function as a general rule, however it can have use cases</span></span>
<span class="line" id="L1333"><span class="tok-comment">/// in, for example, implementing a shell, or child process execution.</span></span>
<span class="line" id="L1334"><span class="tok-comment">/// Not all targets support this. For example, WASI does not have the concept</span></span>
<span class="line" id="L1335"><span class="tok-comment">/// of a current working directory.</span></span>
<span class="line" id="L1336"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setAsCwd</span>(self: Dir) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1337">    <span class="tok-kw">if</span> (builtin.os.tag == .wasi) {</span>
<span class="line" id="L1338">        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;changing cwd is not currently possible in WASI&quot;</span>);</span>
<span class="line" id="L1339">    }</span>
<span class="line" id="L1340">    <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L1341">        <span class="tok-kw">var</span> dir_path_buffer: [std.os.windows.PATH_MAX_WIDE]<span class="tok-type">u16</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1342">        <span class="tok-kw">const</span> dir_path = <span class="tok-kw">try</span> std.os.windows.GetFinalPathNameByHandle(self.fd, .{}, &amp;dir_path_buffer);</span>
<span class="line" id="L1343">        <span class="tok-kw">if</span> (builtin.link_libc) {</span>
<span class="line" id="L1344">            <span class="tok-kw">return</span> posix.chdirW(dir_path);</span>
<span class="line" id="L1345">        }</span>
<span class="line" id="L1346">        <span class="tok-kw">return</span> std.os.windows.SetCurrentDirectory(dir_path);</span>
<span class="line" id="L1347">    }</span>
<span class="line" id="L1348">    <span class="tok-kw">try</span> posix.fchdir(self.fd);</span>
<span class="line" id="L1349">}</span>
<span class="line" id="L1350"></span>
<span class="line" id="L1351"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> OpenDirOptions = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1352">    <span class="tok-comment">/// `true` means the opened directory can be used as the `Dir` parameter</span></span>
<span class="line" id="L1353">    <span class="tok-comment">/// for functions which operate based on an open directory handle. When `false`,</span></span>
<span class="line" id="L1354">    <span class="tok-comment">/// such operations are Illegal Behavior.</span></span>
<span class="line" id="L1355">    access_sub_paths: <span class="tok-type">bool</span> = <span class="tok-null">true</span>,</span>
<span class="line" id="L1356"></span>
<span class="line" id="L1357">    <span class="tok-comment">/// `true` means the opened directory can be scanned for the files and sub-directories</span></span>
<span class="line" id="L1358">    <span class="tok-comment">/// of the result. It means the `iterate` function can be called.</span></span>
<span class="line" id="L1359">    iterate: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,</span>
<span class="line" id="L1360"></span>
<span class="line" id="L1361">    <span class="tok-comment">/// `true` means it won't dereference the symlinks.</span></span>
<span class="line" id="L1362">    no_follow: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,</span>
<span class="line" id="L1363">};</span>
<span class="line" id="L1364"></span>
<span class="line" id="L1365"><span class="tok-comment">/// Opens a directory at the given path. The directory is a system resource that remains</span></span>
<span class="line" id="L1366"><span class="tok-comment">/// open until `close` is called on the result.</span></span>
<span class="line" id="L1367"><span class="tok-comment">/// The directory cannot be iterated unless the `iterate` option is set to `true`.</span></span>
<span class="line" id="L1368"><span class="tok-comment">///</span></span>
<span class="line" id="L1369"><span class="tok-comment">/// On Windows, `sub_path` should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span></span>
<span class="line" id="L1370"><span class="tok-comment">/// On WASI, `sub_path` should be encoded as valid UTF-8.</span></span>
<span class="line" id="L1371"><span class="tok-comment">/// On other platforms, `sub_path` is an opaque sequence of bytes with no particular encoding.</span></span>
<span class="line" id="L1372"><span class="tok-comment">/// Asserts that the path parameter has no null bytes.</span></span>
<span class="line" id="L1373"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openDir</span>(self: Dir, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, args: OpenDirOptions) OpenError!Dir {</span>
<span class="line" id="L1374">    <span class="tok-kw">switch</span> (builtin.os.tag) {</span>
<span class="line" id="L1375">        .windows =&gt; {</span>
<span class="line" id="L1376">            <span class="tok-kw">const</span> sub_path_w = <span class="tok-kw">try</span> posix.windows.sliceToPrefixedFileW(self.fd, sub_path);</span>
<span class="line" id="L1377">            <span class="tok-kw">return</span> self.openDirW(sub_path_w.span().ptr, args);</span>
<span class="line" id="L1378">        },</span>
<span class="line" id="L1379">        .wasi =&gt; {</span>
<span class="line" id="L1380">            <span class="tok-kw">var</span> base: std.os.wasi.rights_t = .{</span>
<span class="line" id="L1381">                .FD_FILESTAT_GET = <span class="tok-null">true</span>,</span>
<span class="line" id="L1382">                .FD_FDSTAT_SET_FLAGS = <span class="tok-null">true</span>,</span>
<span class="line" id="L1383">                .FD_FILESTAT_SET_TIMES = <span class="tok-null">true</span>,</span>
<span class="line" id="L1384">            };</span>
<span class="line" id="L1385">            <span class="tok-kw">if</span> (args.access_sub_paths) {</span>
<span class="line" id="L1386">                base.FD_READDIR = <span class="tok-null">true</span>;</span>
<span class="line" id="L1387">                base.PATH_CREATE_DIRECTORY = <span class="tok-null">true</span>;</span>
<span class="line" id="L1388">                base.PATH_CREATE_FILE = <span class="tok-null">true</span>;</span>
<span class="line" id="L1389">                base.PATH_LINK_SOURCE = <span class="tok-null">true</span>;</span>
<span class="line" id="L1390">                base.PATH_LINK_TARGET = <span class="tok-null">true</span>;</span>
<span class="line" id="L1391">                base.PATH_OPEN = <span class="tok-null">true</span>;</span>
<span class="line" id="L1392">                base.PATH_READLINK = <span class="tok-null">true</span>;</span>
<span class="line" id="L1393">                base.PATH_RENAME_SOURCE = <span class="tok-null">true</span>;</span>
<span class="line" id="L1394">                base.PATH_RENAME_TARGET = <span class="tok-null">true</span>;</span>
<span class="line" id="L1395">                base.PATH_FILESTAT_GET = <span class="tok-null">true</span>;</span>
<span class="line" id="L1396">                base.PATH_FILESTAT_SET_SIZE = <span class="tok-null">true</span>;</span>
<span class="line" id="L1397">                base.PATH_FILESTAT_SET_TIMES = <span class="tok-null">true</span>;</span>
<span class="line" id="L1398">                base.PATH_SYMLINK = <span class="tok-null">true</span>;</span>
<span class="line" id="L1399">                base.PATH_REMOVE_DIRECTORY = <span class="tok-null">true</span>;</span>
<span class="line" id="L1400">                base.PATH_UNLINK_FILE = <span class="tok-null">true</span>;</span>
<span class="line" id="L1401">            }</span>
<span class="line" id="L1402"></span>
<span class="line" id="L1403">            <span class="tok-kw">const</span> result = posix.openatWasi(</span>
<span class="line" id="L1404">                self.fd,</span>
<span class="line" id="L1405">                sub_path,</span>
<span class="line" id="L1406">                .{ .SYMLINK_FOLLOW = !args.no_follow },</span>
<span class="line" id="L1407">                .{ .DIRECTORY = <span class="tok-null">true</span> },</span>
<span class="line" id="L1408">                .{},</span>
<span class="line" id="L1409">                base,</span>
<span class="line" id="L1410">                base,</span>
<span class="line" id="L1411">            );</span>
<span class="line" id="L1412">            <span class="tok-kw">const</span> fd = result <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1413">                <span class="tok-kw">error</span>.FileTooBig =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// can't happen for directories</span>
</span>
<span class="line" id="L1414">                <span class="tok-kw">error</span>.IsDir =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// we're setting DIRECTORY</span>
</span>
<span class="line" id="L1415">                <span class="tok-kw">error</span>.NoSpaceLeft =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// not setting CREAT</span>
</span>
<span class="line" id="L1416">                <span class="tok-kw">error</span>.PathAlreadyExists =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// not setting CREAT</span>
</span>
<span class="line" id="L1417">                <span class="tok-kw">error</span>.FileLocksNotSupported =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// locking folders is not supported</span>
</span>
<span class="line" id="L1418">                <span class="tok-kw">error</span>.WouldBlock =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// can't happen for directories</span>
</span>
<span class="line" id="L1419">                <span class="tok-kw">error</span>.FileBusy =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// can't happen for directories</span>
</span>
<span class="line" id="L1420">                <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L1421">            };</span>
<span class="line" id="L1422">            <span class="tok-kw">return</span> .{ .fd = fd };</span>
<span class="line" id="L1423">        },</span>
<span class="line" id="L1424">        <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L1425">            <span class="tok-kw">const</span> sub_path_c = <span class="tok-kw">try</span> posix.toPosixPath(sub_path);</span>
<span class="line" id="L1426">            <span class="tok-kw">return</span> self.openDirZ(&amp;sub_path_c, args);</span>
<span class="line" id="L1427">        },</span>
<span class="line" id="L1428">    }</span>
<span class="line" id="L1429">}</span>
<span class="line" id="L1430"></span>
<span class="line" id="L1431"><span class="tok-comment">/// Same as `openDir` except the parameter is null-terminated.</span></span>
<span class="line" id="L1432"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openDirZ</span>(self: Dir, sub_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, args: OpenDirOptions) OpenError!Dir {</span>
<span class="line" id="L1433">    <span class="tok-kw">switch</span> (builtin.os.tag) {</span>
<span class="line" id="L1434">        .windows =&gt; {</span>
<span class="line" id="L1435">            <span class="tok-kw">const</span> sub_path_w = <span class="tok-kw">try</span> std.os.windows.cStrToPrefixedFileW(self.fd, sub_path_c);</span>
<span class="line" id="L1436">            <span class="tok-kw">return</span> self.openDirW(sub_path_w.span().ptr, args);</span>
<span class="line" id="L1437">        },</span>
<span class="line" id="L1438">        .wasi =&gt; {</span>
<span class="line" id="L1439">            <span class="tok-kw">return</span> openDir(self, mem.sliceTo(sub_path_c, <span class="tok-number">0</span>), args);</span>
<span class="line" id="L1440">        },</span>
<span class="line" id="L1441">        <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L1442">            <span class="tok-kw">var</span> symlink_flags: posix.O = .{</span>
<span class="line" id="L1443">                .ACCMODE = .RDONLY,</span>
<span class="line" id="L1444">                .NOFOLLOW = args.no_follow,</span>
<span class="line" id="L1445">                .DIRECTORY = <span class="tok-null">true</span>,</span>
<span class="line" id="L1446">                .CLOEXEC = <span class="tok-null">true</span>,</span>
<span class="line" id="L1447">            };</span>
<span class="line" id="L1448">            <span class="tok-kw">if</span> (<span class="tok-builtin">@hasField</span>(posix.O, <span class="tok-str">&quot;PATH&quot;</span>) <span class="tok-kw">and</span> !args.iterate)</span>
<span class="line" id="L1449">                symlink_flags.PATH = <span class="tok-null">true</span>;</span>
<span class="line" id="L1450"></span>
<span class="line" id="L1451">            <span class="tok-kw">return</span> self.openDirFlagsZ(sub_path_c, symlink_flags);</span>
<span class="line" id="L1452">        },</span>
<span class="line" id="L1453">    }</span>
<span class="line" id="L1454">}</span>
<span class="line" id="L1455"></span>
<span class="line" id="L1456"><span class="tok-comment">/// Same as `openDir` except the path parameter is WTF-16 LE encoded, NT-prefixed.</span></span>
<span class="line" id="L1457"><span class="tok-comment">/// This function asserts the target OS is Windows.</span></span>
<span class="line" id="L1458"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openDirW</span>(self: Dir, sub_path_w: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>, args: OpenDirOptions) OpenError!Dir {</span>
<span class="line" id="L1459">    <span class="tok-kw">const</span> w = std.os.windows;</span>
<span class="line" id="L1460">    <span class="tok-comment">// TODO remove some of these flags if args.access_sub_paths is false</span>
</span>
<span class="line" id="L1461">    <span class="tok-kw">const</span> base_flags = w.STANDARD_RIGHTS_READ | w.FILE_READ_ATTRIBUTES | w.FILE_READ_EA |</span>
<span class="line" id="L1462">        w.SYNCHRONIZE | w.FILE_TRAVERSE;</span>
<span class="line" id="L1463">    <span class="tok-kw">const</span> flags: <span class="tok-type">u32</span> = <span class="tok-kw">if</span> (args.iterate) base_flags | w.FILE_LIST_DIRECTORY <span class="tok-kw">else</span> base_flags;</span>
<span class="line" id="L1464">    <span class="tok-kw">const</span> dir = <span class="tok-kw">try</span> self.makeOpenDirAccessMaskW(sub_path_w, flags, .{</span>
<span class="line" id="L1465">        .no_follow = args.no_follow,</span>
<span class="line" id="L1466">        .create_disposition = w.FILE_OPEN,</span>
<span class="line" id="L1467">    });</span>
<span class="line" id="L1468">    <span class="tok-kw">return</span> dir;</span>
<span class="line" id="L1469">}</span>
<span class="line" id="L1470"></span>
<span class="line" id="L1471"><span class="tok-comment">/// Asserts `flags` has `DIRECTORY` set.</span></span>
<span class="line" id="L1472"><span class="tok-kw">fn</span> <span class="tok-fn">openDirFlagsZ</span>(self: Dir, sub_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: posix.O) OpenError!Dir {</span>
<span class="line" id="L1473">    assert(flags.DIRECTORY);</span>
<span class="line" id="L1474">    <span class="tok-kw">const</span> fd = posix.openatZ(self.fd, sub_path_c, flags, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1475">        <span class="tok-kw">error</span>.FileTooBig =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// can't happen for directories</span>
</span>
<span class="line" id="L1476">        <span class="tok-kw">error</span>.IsDir =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// we're setting DIRECTORY</span>
</span>
<span class="line" id="L1477">        <span class="tok-kw">error</span>.NoSpaceLeft =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// not setting CREAT</span>
</span>
<span class="line" id="L1478">        <span class="tok-kw">error</span>.PathAlreadyExists =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// not setting CREAT</span>
</span>
<span class="line" id="L1479">        <span class="tok-kw">error</span>.FileLocksNotSupported =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// locking folders is not supported</span>
</span>
<span class="line" id="L1480">        <span class="tok-kw">error</span>.WouldBlock =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// can't happen for directories</span>
</span>
<span class="line" id="L1481">        <span class="tok-kw">error</span>.FileBusy =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// can't happen for directories</span>
</span>
<span class="line" id="L1482">        <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L1483">    };</span>
<span class="line" id="L1484">    <span class="tok-kw">return</span> Dir{ .fd = fd };</span>
<span class="line" id="L1485">}</span>
<span class="line" id="L1486"></span>
<span class="line" id="L1487"><span class="tok-kw">const</span> MakeOpenDirAccessMaskWOptions = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1488">    no_follow: <span class="tok-type">bool</span>,</span>
<span class="line" id="L1489">    create_disposition: <span class="tok-type">u32</span>,</span>
<span class="line" id="L1490">};</span>
<span class="line" id="L1491"></span>
<span class="line" id="L1492"><span class="tok-kw">fn</span> <span class="tok-fn">makeOpenDirAccessMaskW</span>(self: Dir, sub_path_w: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>, access_mask: <span class="tok-type">u32</span>, flags: MakeOpenDirAccessMaskWOptions) OpenError!Dir {</span>
<span class="line" id="L1493">    <span class="tok-kw">const</span> w = std.os.windows;</span>
<span class="line" id="L1494"></span>
<span class="line" id="L1495">    <span class="tok-kw">var</span> result = Dir{</span>
<span class="line" id="L1496">        .fd = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L1497">    };</span>
<span class="line" id="L1498"></span>
<span class="line" id="L1499">    <span class="tok-kw">const</span> path_len_bytes = <span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, <span class="tok-builtin">@intCast</span>(mem.sliceTo(sub_path_w, <span class="tok-number">0</span>).len * <span class="tok-number">2</span>));</span>
<span class="line" id="L1500">    <span class="tok-kw">var</span> nt_name = w.UNICODE_STRING{</span>
<span class="line" id="L1501">        .Length = path_len_bytes,</span>
<span class="line" id="L1502">        .MaximumLength = path_len_bytes,</span>
<span class="line" id="L1503">        .Buffer = <span class="tok-builtin">@constCast</span>(sub_path_w),</span>
<span class="line" id="L1504">    };</span>
<span class="line" id="L1505">    <span class="tok-kw">var</span> attr = w.OBJECT_ATTRIBUTES{</span>
<span class="line" id="L1506">        .Length = <span class="tok-builtin">@sizeOf</span>(w.OBJECT_ATTRIBUTES),</span>
<span class="line" id="L1507">        .RootDirectory = <span class="tok-kw">if</span> (fs.path.isAbsoluteWindowsW(sub_path_w)) <span class="tok-null">null</span> <span class="tok-kw">else</span> self.fd,</span>
<span class="line" id="L1508">        .Attributes = <span class="tok-number">0</span>, <span class="tok-comment">// Note we do not use OBJ_CASE_INSENSITIVE here.</span>
</span>
<span class="line" id="L1509">        .ObjectName = &amp;nt_name,</span>
<span class="line" id="L1510">        .SecurityDescriptor = <span class="tok-null">null</span>,</span>
<span class="line" id="L1511">        .SecurityQualityOfService = <span class="tok-null">null</span>,</span>
<span class="line" id="L1512">    };</span>
<span class="line" id="L1513">    <span class="tok-kw">const</span> open_reparse_point: w.DWORD = <span class="tok-kw">if</span> (flags.no_follow) w.FILE_OPEN_REPARSE_POINT <span class="tok-kw">else</span> <span class="tok-number">0x0</span>;</span>
<span class="line" id="L1514">    <span class="tok-kw">var</span> io: w.IO_STATUS_BLOCK = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1515">    <span class="tok-kw">const</span> rc = w.ntdll.NtCreateFile(</span>
<span class="line" id="L1516">        &amp;result.fd,</span>
<span class="line" id="L1517">        access_mask,</span>
<span class="line" id="L1518">        &amp;attr,</span>
<span class="line" id="L1519">        &amp;io,</span>
<span class="line" id="L1520">        <span class="tok-null">null</span>,</span>
<span class="line" id="L1521">        w.FILE_ATTRIBUTE_NORMAL,</span>
<span class="line" id="L1522">        w.FILE_SHARE_READ | w.FILE_SHARE_WRITE,</span>
<span class="line" id="L1523">        flags.create_disposition,</span>
<span class="line" id="L1524">        w.FILE_DIRECTORY_FILE | w.FILE_SYNCHRONOUS_IO_NONALERT | w.FILE_OPEN_FOR_BACKUP_INTENT | open_reparse_point,</span>
<span class="line" id="L1525">        <span class="tok-null">null</span>,</span>
<span class="line" id="L1526">        <span class="tok-number">0</span>,</span>
<span class="line" id="L1527">    );</span>
<span class="line" id="L1528"></span>
<span class="line" id="L1529">    <span class="tok-kw">switch</span> (rc) {</span>
<span class="line" id="L1530">        .SUCCESS =&gt; <span class="tok-kw">return</span> result,</span>
<span class="line" id="L1531">        .OBJECT_NAME_INVALID =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BadPathName,</span>
<span class="line" id="L1532">        .OBJECT_NAME_NOT_FOUND =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,</span>
<span class="line" id="L1533">        .OBJECT_PATH_NOT_FOUND =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,</span>
<span class="line" id="L1534">        .NOT_A_DIRECTORY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,</span>
<span class="line" id="L1535">        <span class="tok-comment">// This can happen if the directory has 'List folder contents' permission set to 'Deny'</span>
</span>
<span class="line" id="L1536">        <span class="tok-comment">// and the directory is trying to be opened for iteration.</span>
</span>
<span class="line" id="L1537">        .ACCESS_DENIED =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,</span>
<span class="line" id="L1538">        .INVALID_PARAMETER =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1539">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> w.unexpectedStatus(rc),</span>
<span class="line" id="L1540">    }</span>
<span class="line" id="L1541">}</span>
<span class="line" id="L1542"></span>
<span class="line" id="L1543"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> DeleteFileError = posix.UnlinkError;</span>
<span class="line" id="L1544"></span>
<span class="line" id="L1545"><span class="tok-comment">/// Delete a file name and possibly the file it refers to, based on an open directory handle.</span></span>
<span class="line" id="L1546"><span class="tok-comment">/// On Windows, `sub_path` should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span></span>
<span class="line" id="L1547"><span class="tok-comment">/// On WASI, `sub_path` should be encoded as valid UTF-8.</span></span>
<span class="line" id="L1548"><span class="tok-comment">/// On other platforms, `sub_path` is an opaque sequence of bytes with no particular encoding.</span></span>
<span class="line" id="L1549"><span class="tok-comment">/// Asserts that the path parameter has no null bytes.</span></span>
<span class="line" id="L1550"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteFile</span>(self: Dir, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) DeleteFileError!<span class="tok-type">void</span> {</span>
<span class="line" id="L1551">    <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L1552">        <span class="tok-kw">const</span> sub_path_w = <span class="tok-kw">try</span> std.os.windows.sliceToPrefixedFileW(self.fd, sub_path);</span>
<span class="line" id="L1553">        <span class="tok-kw">return</span> self.deleteFileW(sub_path_w.span());</span>
<span class="line" id="L1554">    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (builtin.os.tag == .wasi <span class="tok-kw">and</span> !builtin.link_libc) {</span>
<span class="line" id="L1555">        posix.unlinkat(self.fd, sub_path, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1556">            <span class="tok-kw">error</span>.DirNotEmpty =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// not passing AT.REMOVEDIR</span>
</span>
<span class="line" id="L1557">            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L1558">        };</span>
<span class="line" id="L1559">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1560">        <span class="tok-kw">const</span> sub_path_c = <span class="tok-kw">try</span> posix.toPosixPath(sub_path);</span>
<span class="line" id="L1561">        <span class="tok-kw">return</span> self.deleteFileZ(&amp;sub_path_c);</span>
<span class="line" id="L1562">    }</span>
<span class="line" id="L1563">}</span>
<span class="line" id="L1564"></span>
<span class="line" id="L1565"><span class="tok-comment">/// Same as `deleteFile` except the parameter is null-terminated.</span></span>
<span class="line" id="L1566"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteFileZ</span>(self: Dir, sub_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) DeleteFileError!<span class="tok-type">void</span> {</span>
<span class="line" id="L1567">    posix.unlinkatZ(self.fd, sub_path_c, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1568">        <span class="tok-kw">error</span>.DirNotEmpty =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// not passing AT.REMOVEDIR</span>
</span>
<span class="line" id="L1569">        <span class="tok-kw">error</span>.AccessDenied =&gt; |e| <span class="tok-kw">switch</span> (builtin.os.tag) {</span>
<span class="line" id="L1570">            <span class="tok-comment">// non-Linux POSIX systems return EPERM when trying to delete a directory, so</span>
</span>
<span class="line" id="L1571">            <span class="tok-comment">// we need to handle that case specifically and translate the error</span>
</span>
<span class="line" id="L1572">            .macos, .ios, .freebsd, .netbsd, .dragonfly, .openbsd, .solaris, .illumos =&gt; {</span>
<span class="line" id="L1573">                <span class="tok-comment">// Don't follow symlinks to match unlinkat (which acts on symlinks rather than follows them)</span>
</span>
<span class="line" id="L1574">                <span class="tok-kw">const</span> fstat = posix.fstatatZ(self.fd, sub_path_c, posix.AT.SYMLINK_NOFOLLOW) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> e;</span>
<span class="line" id="L1575">                <span class="tok-kw">const</span> is_dir = fstat.mode &amp; posix.S.IFMT == posix.S.IFDIR;</span>
<span class="line" id="L1576">                <span class="tok-kw">return</span> <span class="tok-kw">if</span> (is_dir) <span class="tok-kw">error</span>.IsDir <span class="tok-kw">else</span> e;</span>
<span class="line" id="L1577">            },</span>
<span class="line" id="L1578">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> e,</span>
<span class="line" id="L1579">        },</span>
<span class="line" id="L1580">        <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L1581">    };</span>
<span class="line" id="L1582">}</span>
<span class="line" id="L1583"></span>
<span class="line" id="L1584"><span class="tok-comment">/// Same as `deleteFile` except the parameter is WTF-16 LE encoded.</span></span>
<span class="line" id="L1585"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteFileW</span>(self: Dir, sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>) DeleteFileError!<span class="tok-type">void</span> {</span>
<span class="line" id="L1586">    posix.unlinkatW(self.fd, sub_path_w, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1587">        <span class="tok-kw">error</span>.DirNotEmpty =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// not passing AT.REMOVEDIR</span>
</span>
<span class="line" id="L1588">        <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L1589">    };</span>
<span class="line" id="L1590">}</span>
<span class="line" id="L1591"></span>
<span class="line" id="L1592"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> DeleteDirError = <span class="tok-kw">error</span>{</span>
<span class="line" id="L1593">    DirNotEmpty,</span>
<span class="line" id="L1594">    FileNotFound,</span>
<span class="line" id="L1595">    AccessDenied,</span>
<span class="line" id="L1596">    FileBusy,</span>
<span class="line" id="L1597">    FileSystem,</span>
<span class="line" id="L1598">    SymLinkLoop,</span>
<span class="line" id="L1599">    NameTooLong,</span>
<span class="line" id="L1600">    NotDir,</span>
<span class="line" id="L1601">    SystemResources,</span>
<span class="line" id="L1602">    ReadOnlyFileSystem,</span>
<span class="line" id="L1603">    <span class="tok-comment">/// WASI-only; file paths must be valid UTF-8.</span></span>
<span class="line" id="L1604">    InvalidUtf8,</span>
<span class="line" id="L1605">    <span class="tok-comment">/// Windows-only; file paths provided by the user must be valid WTF-8.</span></span>
<span class="line" id="L1606">    <span class="tok-comment">/// https://simonsapin.github.io/wtf-8/</span></span>
<span class="line" id="L1607">    InvalidWtf8,</span>
<span class="line" id="L1608">    BadPathName,</span>
<span class="line" id="L1609">    <span class="tok-comment">/// On Windows, `\\server` or `\\server\share` was not found.</span></span>
<span class="line" id="L1610">    NetworkNotFound,</span>
<span class="line" id="L1611">    Unexpected,</span>
<span class="line" id="L1612">};</span>
<span class="line" id="L1613"></span>
<span class="line" id="L1614"><span class="tok-comment">/// Returns `error.DirNotEmpty` if the directory is not empty.</span></span>
<span class="line" id="L1615"><span class="tok-comment">/// To delete a directory recursively, see `deleteTree`.</span></span>
<span class="line" id="L1616"><span class="tok-comment">/// On Windows, `sub_path` should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span></span>
<span class="line" id="L1617"><span class="tok-comment">/// On WASI, `sub_path` should be encoded as valid UTF-8.</span></span>
<span class="line" id="L1618"><span class="tok-comment">/// On other platforms, `sub_path` is an opaque sequence of bytes with no particular encoding.</span></span>
<span class="line" id="L1619"><span class="tok-comment">/// Asserts that the path parameter has no null bytes.</span></span>
<span class="line" id="L1620"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteDir</span>(self: Dir, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) DeleteDirError!<span class="tok-type">void</span> {</span>
<span class="line" id="L1621">    <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L1622">        <span class="tok-kw">const</span> sub_path_w = <span class="tok-kw">try</span> std.os.windows.sliceToPrefixedFileW(self.fd, sub_path);</span>
<span class="line" id="L1623">        <span class="tok-kw">return</span> self.deleteDirW(sub_path_w.span());</span>
<span class="line" id="L1624">    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (builtin.os.tag == .wasi <span class="tok-kw">and</span> !builtin.link_libc) {</span>
<span class="line" id="L1625">        posix.unlinkat(self.fd, sub_path, posix.AT.REMOVEDIR) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1626">            <span class="tok-kw">error</span>.IsDir =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// not possible since we pass AT.REMOVEDIR</span>
</span>
<span class="line" id="L1627">            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L1628">        };</span>
<span class="line" id="L1629">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1630">        <span class="tok-kw">const</span> sub_path_c = <span class="tok-kw">try</span> posix.toPosixPath(sub_path);</span>
<span class="line" id="L1631">        <span class="tok-kw">return</span> self.deleteDirZ(&amp;sub_path_c);</span>
<span class="line" id="L1632">    }</span>
<span class="line" id="L1633">}</span>
<span class="line" id="L1634"></span>
<span class="line" id="L1635"><span class="tok-comment">/// Same as `deleteDir` except the parameter is null-terminated.</span></span>
<span class="line" id="L1636"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteDirZ</span>(self: Dir, sub_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) DeleteDirError!<span class="tok-type">void</span> {</span>
<span class="line" id="L1637">    posix.unlinkatZ(self.fd, sub_path_c, posix.AT.REMOVEDIR) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1638">        <span class="tok-kw">error</span>.IsDir =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// not possible since we pass AT.REMOVEDIR</span>
</span>
<span class="line" id="L1639">        <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L1640">    };</span>
<span class="line" id="L1641">}</span>
<span class="line" id="L1642"></span>
<span class="line" id="L1643"><span class="tok-comment">/// Same as `deleteDir` except the parameter is WTF16LE, NT prefixed.</span></span>
<span class="line" id="L1644"><span class="tok-comment">/// This function is Windows-only.</span></span>
<span class="line" id="L1645"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteDirW</span>(self: Dir, sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>) DeleteDirError!<span class="tok-type">void</span> {</span>
<span class="line" id="L1646">    posix.unlinkatW(self.fd, sub_path_w, posix.AT.REMOVEDIR) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1647">        <span class="tok-kw">error</span>.IsDir =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// not possible since we pass AT.REMOVEDIR</span>
</span>
<span class="line" id="L1648">        <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L1649">    };</span>
<span class="line" id="L1650">}</span>
<span class="line" id="L1651"></span>
<span class="line" id="L1652"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> RenameError = posix.RenameError;</span>
<span class="line" id="L1653"></span>
<span class="line" id="L1654"><span class="tok-comment">/// Change the name or location of a file or directory.</span></span>
<span class="line" id="L1655"><span class="tok-comment">/// If new_sub_path already exists, it will be replaced.</span></span>
<span class="line" id="L1656"><span class="tok-comment">/// Renaming a file over an existing directory or a directory</span></span>
<span class="line" id="L1657"><span class="tok-comment">/// over an existing file will fail with `error.IsDir` or `error.NotDir`</span></span>
<span class="line" id="L1658"><span class="tok-comment">/// On Windows, both paths should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span></span>
<span class="line" id="L1659"><span class="tok-comment">/// On WASI, both paths should be encoded as valid UTF-8.</span></span>
<span class="line" id="L1660"><span class="tok-comment">/// On other platforms, both paths are an opaque sequence of bytes with no particular encoding.</span></span>
<span class="line" id="L1661"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rename</span>(self: Dir, old_sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, new_sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) RenameError!<span class="tok-type">void</span> {</span>
<span class="line" id="L1662">    <span class="tok-kw">return</span> posix.renameat(self.fd, old_sub_path, self.fd, new_sub_path);</span>
<span class="line" id="L1663">}</span>
<span class="line" id="L1664"></span>
<span class="line" id="L1665"><span class="tok-comment">/// Same as `rename` except the parameters are null-terminated.</span></span>
<span class="line" id="L1666"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">renameZ</span>(self: Dir, old_sub_path_z: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, new_sub_path_z: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) RenameError!<span class="tok-type">void</span> {</span>
<span class="line" id="L1667">    <span class="tok-kw">return</span> posix.renameatZ(self.fd, old_sub_path_z, self.fd, new_sub_path_z);</span>
<span class="line" id="L1668">}</span>
<span class="line" id="L1669"></span>
<span class="line" id="L1670"><span class="tok-comment">/// Same as `rename` except the parameters are WTF16LE, NT prefixed.</span></span>
<span class="line" id="L1671"><span class="tok-comment">/// This function is Windows-only.</span></span>
<span class="line" id="L1672"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">renameW</span>(self: Dir, old_sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>, new_sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>) RenameError!<span class="tok-type">void</span> {</span>
<span class="line" id="L1673">    <span class="tok-kw">return</span> posix.renameatW(self.fd, old_sub_path_w, self.fd, new_sub_path_w);</span>
<span class="line" id="L1674">}</span>
<span class="line" id="L1675"></span>
<span class="line" id="L1676"><span class="tok-comment">/// Use with `Dir.symLink` and `symLinkAbsolute` to specify whether the symlink</span></span>
<span class="line" id="L1677"><span class="tok-comment">/// will point to a file or a directory. This value is ignored on all hosts</span></span>
<span class="line" id="L1678"><span class="tok-comment">/// except Windows where creating symlinks to different resource types, requires</span></span>
<span class="line" id="L1679"><span class="tok-comment">/// different flags. By default, `symLinkAbsolute` is assumed to point to a file.</span></span>
<span class="line" id="L1680"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> SymLinkFlags = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1681">    is_directory: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,</span>
<span class="line" id="L1682">};</span>
<span class="line" id="L1683"></span>
<span class="line" id="L1684"><span class="tok-comment">/// Creates a symbolic link named `sym_link_path` which contains the string `target_path`.</span></span>
<span class="line" id="L1685"><span class="tok-comment">/// A symbolic link (also known as a soft link) may point to an existing file or to a nonexistent</span></span>
<span class="line" id="L1686"><span class="tok-comment">/// one; the latter case is known as a dangling link.</span></span>
<span class="line" id="L1687"><span class="tok-comment">/// If `sym_link_path` exists, it will not be overwritten.</span></span>
<span class="line" id="L1688"><span class="tok-comment">/// On Windows, both paths should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span></span>
<span class="line" id="L1689"><span class="tok-comment">/// On WASI, both paths should be encoded as valid UTF-8.</span></span>
<span class="line" id="L1690"><span class="tok-comment">/// On other platforms, both paths are an opaque sequence of bytes with no particular encoding.</span></span>
<span class="line" id="L1691"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">symLink</span>(</span>
<span class="line" id="L1692">    self: Dir,</span>
<span class="line" id="L1693">    target_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1694">    sym_link_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1695">    flags: SymLinkFlags,</span>
<span class="line" id="L1696">) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1697">    <span class="tok-kw">if</span> (builtin.os.tag == .wasi <span class="tok-kw">and</span> !builtin.link_libc) {</span>
<span class="line" id="L1698">        <span class="tok-kw">return</span> self.symLinkWasi(target_path, sym_link_path, flags);</span>
<span class="line" id="L1699">    }</span>
<span class="line" id="L1700">    <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L1701">        <span class="tok-comment">// Target path does not use sliceToPrefixedFileW because certain paths</span>
</span>
<span class="line" id="L1702">        <span class="tok-comment">// are handled differently when creating a symlink than they would be</span>
</span>
<span class="line" id="L1703">        <span class="tok-comment">// when converting to an NT namespaced path. CreateSymbolicLink in</span>
</span>
<span class="line" id="L1704">        <span class="tok-comment">// symLinkW will handle the necessary conversion.</span>
</span>
<span class="line" id="L1705">        <span class="tok-kw">var</span> target_path_w: std.os.windows.PathSpace = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1706">        target_path_w.len = <span class="tok-kw">try</span> std.unicode.wtf8ToWtf16Le(&amp;target_path_w.data, target_path);</span>
<span class="line" id="L1707">        target_path_w.data[target_path_w.len] = <span class="tok-number">0</span>;</span>
<span class="line" id="L1708">        <span class="tok-comment">// However, we need to canonicalize any path separators to `\`, since if</span>
</span>
<span class="line" id="L1709">        <span class="tok-comment">// the target path is relative, then it must use `\` as the path separator.</span>
</span>
<span class="line" id="L1710">        mem.replaceScalar(</span>
<span class="line" id="L1711">            <span class="tok-type">u16</span>,</span>
<span class="line" id="L1712">            target_path_w.data[<span class="tok-number">0</span>..target_path_w.len],</span>
<span class="line" id="L1713">            mem.nativeToLittle(<span class="tok-type">u16</span>, <span class="tok-str">'/'</span>),</span>
<span class="line" id="L1714">            mem.nativeToLittle(<span class="tok-type">u16</span>, <span class="tok-str">'\\'</span>),</span>
<span class="line" id="L1715">        );</span>
<span class="line" id="L1716"></span>
<span class="line" id="L1717">        <span class="tok-kw">const</span> sym_link_path_w = <span class="tok-kw">try</span> std.os.windows.sliceToPrefixedFileW(self.fd, sym_link_path);</span>
<span class="line" id="L1718">        <span class="tok-kw">return</span> self.symLinkW(target_path_w.span(), sym_link_path_w.span(), flags);</span>
<span class="line" id="L1719">    }</span>
<span class="line" id="L1720">    <span class="tok-kw">const</span> target_path_c = <span class="tok-kw">try</span> posix.toPosixPath(target_path);</span>
<span class="line" id="L1721">    <span class="tok-kw">const</span> sym_link_path_c = <span class="tok-kw">try</span> posix.toPosixPath(sym_link_path);</span>
<span class="line" id="L1722">    <span class="tok-kw">return</span> self.symLinkZ(&amp;target_path_c, &amp;sym_link_path_c, flags);</span>
<span class="line" id="L1723">}</span>
<span class="line" id="L1724"></span>
<span class="line" id="L1725"><span class="tok-comment">/// WASI-only. Same as `symLink` except targeting WASI.</span></span>
<span class="line" id="L1726"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">symLinkWasi</span>(</span>
<span class="line" id="L1727">    self: Dir,</span>
<span class="line" id="L1728">    target_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1729">    sym_link_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1730">    _: SymLinkFlags,</span>
<span class="line" id="L1731">) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1732">    <span class="tok-kw">return</span> posix.symlinkat(target_path, self.fd, sym_link_path);</span>
<span class="line" id="L1733">}</span>
<span class="line" id="L1734"></span>
<span class="line" id="L1735"><span class="tok-comment">/// Same as `symLink`, except the pathname parameters are null-terminated.</span></span>
<span class="line" id="L1736"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">symLinkZ</span>(</span>
<span class="line" id="L1737">    self: Dir,</span>
<span class="line" id="L1738">    target_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1739">    sym_link_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1740">    flags: SymLinkFlags,</span>
<span class="line" id="L1741">) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1742">    <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L1743">        <span class="tok-kw">const</span> target_path_w = <span class="tok-kw">try</span> std.os.windows.cStrToPrefixedFileW(self.fd, target_path_c);</span>
<span class="line" id="L1744">        <span class="tok-kw">const</span> sym_link_path_w = <span class="tok-kw">try</span> std.os.windows.cStrToPrefixedFileW(self.fd, sym_link_path_c);</span>
<span class="line" id="L1745">        <span class="tok-kw">return</span> self.symLinkW(target_path_w.span(), sym_link_path_w.span(), flags);</span>
<span class="line" id="L1746">    }</span>
<span class="line" id="L1747">    <span class="tok-kw">return</span> posix.symlinkatZ(target_path_c, self.fd, sym_link_path_c);</span>
<span class="line" id="L1748">}</span>
<span class="line" id="L1749"></span>
<span class="line" id="L1750"><span class="tok-comment">/// Windows-only. Same as `symLink` except the pathname parameters</span></span>
<span class="line" id="L1751"><span class="tok-comment">/// are WTF16 LE encoded.</span></span>
<span class="line" id="L1752"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">symLinkW</span>(</span>
<span class="line" id="L1753">    self: Dir,</span>
<span class="line" id="L1754">    <span class="tok-comment">/// WTF-16, does not need to be NT-prefixed. The NT-prefixing</span></span>
<span class="line" id="L1755">    <span class="tok-comment">/// of this path is handled by CreateSymbolicLink.</span></span>
<span class="line" id="L1756">    <span class="tok-comment">/// Any path separators must be `\`, not `/`.</span></span>
<span class="line" id="L1757">    target_path_w: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>,</span>
<span class="line" id="L1758">    <span class="tok-comment">/// WTF-16, must be NT-prefixed or relative</span></span>
<span class="line" id="L1759">    sym_link_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>,</span>
<span class="line" id="L1760">    flags: SymLinkFlags,</span>
<span class="line" id="L1761">) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1762">    <span class="tok-kw">return</span> std.os.windows.CreateSymbolicLink(self.fd, sym_link_path_w, target_path_w, flags.is_directory);</span>
<span class="line" id="L1763">}</span>
<span class="line" id="L1764"></span>
<span class="line" id="L1765"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ReadLinkError = posix.ReadLinkError;</span>
<span class="line" id="L1766"></span>
<span class="line" id="L1767"><span class="tok-comment">/// Read value of a symbolic link.</span></span>
<span class="line" id="L1768"><span class="tok-comment">/// The return value is a slice of `buffer`, from index `0`.</span></span>
<span class="line" id="L1769"><span class="tok-comment">/// Asserts that the path parameter has no null bytes.</span></span>
<span class="line" id="L1770"><span class="tok-comment">/// On Windows, `sub_path` should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span></span>
<span class="line" id="L1771"><span class="tok-comment">/// On WASI, `sub_path` should be encoded as valid UTF-8.</span></span>
<span class="line" id="L1772"><span class="tok-comment">/// On other platforms, `sub_path` is an opaque sequence of bytes with no particular encoding.</span></span>
<span class="line" id="L1773"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readLink</span>(self: Dir, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, buffer: []<span class="tok-type">u8</span>) ReadLinkError![]<span class="tok-type">u8</span> {</span>
<span class="line" id="L1774">    <span class="tok-kw">if</span> (builtin.os.tag == .wasi <span class="tok-kw">and</span> !builtin.link_libc) {</span>
<span class="line" id="L1775">        <span class="tok-kw">return</span> self.readLinkWasi(sub_path, buffer);</span>
<span class="line" id="L1776">    }</span>
<span class="line" id="L1777">    <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L1778">        <span class="tok-kw">const</span> sub_path_w = <span class="tok-kw">try</span> std.os.windows.sliceToPrefixedFileW(self.fd, sub_path);</span>
<span class="line" id="L1779">        <span class="tok-kw">return</span> self.readLinkW(sub_path_w.span(), buffer);</span>
<span class="line" id="L1780">    }</span>
<span class="line" id="L1781">    <span class="tok-kw">const</span> sub_path_c = <span class="tok-kw">try</span> posix.toPosixPath(sub_path);</span>
<span class="line" id="L1782">    <span class="tok-kw">return</span> self.readLinkZ(&amp;sub_path_c, buffer);</span>
<span class="line" id="L1783">}</span>
<span class="line" id="L1784"></span>
<span class="line" id="L1785"><span class="tok-comment">/// WASI-only. Same as `readLink` except targeting WASI.</span></span>
<span class="line" id="L1786"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readLinkWasi</span>(self: Dir, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, buffer: []<span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span> {</span>
<span class="line" id="L1787">    <span class="tok-kw">return</span> posix.readlinkat(self.fd, sub_path, buffer);</span>
<span class="line" id="L1788">}</span>
<span class="line" id="L1789"></span>
<span class="line" id="L1790"><span class="tok-comment">/// Same as `readLink`, except the `sub_path_c` parameter is null-terminated.</span></span>
<span class="line" id="L1791"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readLinkZ</span>(self: Dir, sub_path_c: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, buffer: []<span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span> {</span>
<span class="line" id="L1792">    <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L1793">        <span class="tok-kw">const</span> sub_path_w = <span class="tok-kw">try</span> std.os.windows.cStrToPrefixedFileW(self.fd, sub_path_c);</span>
<span class="line" id="L1794">        <span class="tok-kw">return</span> self.readLinkW(sub_path_w.span(), buffer);</span>
<span class="line" id="L1795">    }</span>
<span class="line" id="L1796">    <span class="tok-kw">return</span> posix.readlinkatZ(self.fd, sub_path_c, buffer);</span>
<span class="line" id="L1797">}</span>
<span class="line" id="L1798"></span>
<span class="line" id="L1799"><span class="tok-comment">/// Windows-only. Same as `readLink` except the pathname parameter</span></span>
<span class="line" id="L1800"><span class="tok-comment">/// is WTF16 LE encoded.</span></span>
<span class="line" id="L1801"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readLinkW</span>(self: Dir, sub_path_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>, buffer: []<span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span> {</span>
<span class="line" id="L1802">    <span class="tok-kw">return</span> std.os.windows.ReadLink(self.fd, sub_path_w, buffer);</span>
<span class="line" id="L1803">}</span>
<span class="line" id="L1804"></span>
<span class="line" id="L1805"><span class="tok-comment">/// Read all of file contents using a preallocated buffer.</span></span>
<span class="line" id="L1806"><span class="tok-comment">/// The returned slice has the same pointer as `buffer`. If the length matches `buffer.len`</span></span>
<span class="line" id="L1807"><span class="tok-comment">/// the situation is ambiguous. It could either mean that the entire file was read, and</span></span>
<span class="line" id="L1808"><span class="tok-comment">/// it exactly fits the buffer, or it could mean the buffer was not big enough for the</span></span>
<span class="line" id="L1809"><span class="tok-comment">/// entire file.</span></span>
<span class="line" id="L1810"><span class="tok-comment">/// On Windows, `file_path` should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span></span>
<span class="line" id="L1811"><span class="tok-comment">/// On WASI, `file_path` should be encoded as valid UTF-8.</span></span>
<span class="line" id="L1812"><span class="tok-comment">/// On other platforms, `file_path` is an opaque sequence of bytes with no particular encoding.</span></span>
<span class="line" id="L1813"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readFile</span>(self: Dir, file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, buffer: []<span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span> {</span>
<span class="line" id="L1814">    <span class="tok-kw">var</span> file = <span class="tok-kw">try</span> self.openFile(file_path, .{});</span>
<span class="line" id="L1815">    <span class="tok-kw">defer</span> file.close();</span>
<span class="line" id="L1816"></span>
<span class="line" id="L1817">    <span class="tok-kw">const</span> end_index = <span class="tok-kw">try</span> file.readAll(buffer);</span>
<span class="line" id="L1818">    <span class="tok-kw">return</span> buffer[<span class="tok-number">0</span>..end_index];</span>
<span class="line" id="L1819">}</span>
<span class="line" id="L1820"></span>
<span class="line" id="L1821"><span class="tok-comment">/// On success, caller owns returned buffer.</span></span>
<span class="line" id="L1822"><span class="tok-comment">/// If the file is larger than `max_bytes`, returns `error.FileTooBig`.</span></span>
<span class="line" id="L1823"><span class="tok-comment">/// On Windows, `file_path` should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span></span>
<span class="line" id="L1824"><span class="tok-comment">/// On WASI, `file_path` should be encoded as valid UTF-8.</span></span>
<span class="line" id="L1825"><span class="tok-comment">/// On other platforms, `file_path` is an opaque sequence of bytes with no particular encoding.</span></span>
<span class="line" id="L1826"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readFileAlloc</span>(self: Dir, allocator: mem.Allocator, file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, max_bytes: <span class="tok-type">usize</span>) ![]<span class="tok-type">u8</span> {</span>
<span class="line" id="L1827">    <span class="tok-kw">return</span> self.readFileAllocOptions(allocator, file_path, max_bytes, <span class="tok-null">null</span>, <span class="tok-builtin">@alignOf</span>(<span class="tok-type">u8</span>), <span class="tok-null">null</span>);</span>
<span class="line" id="L1828">}</span>
<span class="line" id="L1829"></span>
<span class="line" id="L1830"><span class="tok-comment">/// On success, caller owns returned buffer.</span></span>
<span class="line" id="L1831"><span class="tok-comment">/// If the file is larger than `max_bytes`, returns `error.FileTooBig`.</span></span>
<span class="line" id="L1832"><span class="tok-comment">/// If `size_hint` is specified the initial buffer size is calculated using</span></span>
<span class="line" id="L1833"><span class="tok-comment">/// that value, otherwise the effective file size is used instead.</span></span>
<span class="line" id="L1834"><span class="tok-comment">/// Allows specifying alignment and a sentinel value.</span></span>
<span class="line" id="L1835"><span class="tok-comment">/// On Windows, `file_path` should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span></span>
<span class="line" id="L1836"><span class="tok-comment">/// On WASI, `file_path` should be encoded as valid UTF-8.</span></span>
<span class="line" id="L1837"><span class="tok-comment">/// On other platforms, `file_path` is an opaque sequence of bytes with no particular encoding.</span></span>
<span class="line" id="L1838"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readFileAllocOptions</span>(</span>
<span class="line" id="L1839">    self: Dir,</span>
<span class="line" id="L1840">    allocator: mem.Allocator,</span>
<span class="line" id="L1841">    file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1842">    max_bytes: <span class="tok-type">usize</span>,</span>
<span class="line" id="L1843">    size_hint: ?<span class="tok-type">usize</span>,</span>
<span class="line" id="L1844">    <span class="tok-kw">comptime</span> alignment: <span class="tok-type">u29</span>,</span>
<span class="line" id="L1845">    <span class="tok-kw">comptime</span> optional_sentinel: ?<span class="tok-type">u8</span>,</span>
<span class="line" id="L1846">) !(<span class="tok-kw">if</span> (optional_sentinel) |s| [:s]<span class="tok-kw">align</span>(alignment) <span class="tok-type">u8</span> <span class="tok-kw">else</span> []<span class="tok-kw">align</span>(alignment) <span class="tok-type">u8</span>) {</span>
<span class="line" id="L1847">    <span class="tok-kw">var</span> file = <span class="tok-kw">try</span> self.openFile(file_path, .{});</span>
<span class="line" id="L1848">    <span class="tok-kw">defer</span> file.close();</span>
<span class="line" id="L1849"></span>
<span class="line" id="L1850">    <span class="tok-comment">// If the file size doesn't fit a usize it'll be certainly greater than</span>
</span>
<span class="line" id="L1851">    <span class="tok-comment">// `max_bytes`</span>
</span>
<span class="line" id="L1852">    <span class="tok-kw">const</span> stat_size = size_hint <span class="tok-kw">orelse</span> std.math.cast(<span class="tok-type">usize</span>, <span class="tok-kw">try</span> file.getEndPos()) <span class="tok-kw">orelse</span></span>
<span class="line" id="L1853">        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileTooBig;</span>
<span class="line" id="L1854"></span>
<span class="line" id="L1855">    <span class="tok-kw">return</span> file.readToEndAllocOptions(allocator, max_bytes, stat_size, alignment, optional_sentinel);</span>
<span class="line" id="L1856">}</span>
<span class="line" id="L1857"></span>
<span class="line" id="L1858"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> DeleteTreeError = <span class="tok-kw">error</span>{</span>
<span class="line" id="L1859">    AccessDenied,</span>
<span class="line" id="L1860">    FileTooBig,</span>
<span class="line" id="L1861">    SymLinkLoop,</span>
<span class="line" id="L1862">    ProcessFdQuotaExceeded,</span>
<span class="line" id="L1863">    NameTooLong,</span>
<span class="line" id="L1864">    SystemFdQuotaExceeded,</span>
<span class="line" id="L1865">    NoDevice,</span>
<span class="line" id="L1866">    SystemResources,</span>
<span class="line" id="L1867">    ReadOnlyFileSystem,</span>
<span class="line" id="L1868">    FileSystem,</span>
<span class="line" id="L1869">    FileBusy,</span>
<span class="line" id="L1870">    DeviceBusy,</span>
<span class="line" id="L1871"></span>
<span class="line" id="L1872">    <span class="tok-comment">/// One of the path components was not a directory.</span></span>
<span class="line" id="L1873">    <span class="tok-comment">/// This error is unreachable if `sub_path` does not contain a path separator.</span></span>
<span class="line" id="L1874">    NotDir,</span>
<span class="line" id="L1875"></span>
<span class="line" id="L1876">    <span class="tok-comment">/// WASI-only; file paths must be valid UTF-8.</span></span>
<span class="line" id="L1877">    InvalidUtf8,</span>
<span class="line" id="L1878"></span>
<span class="line" id="L1879">    <span class="tok-comment">/// Windows-only; file paths provided by the user must be valid WTF-8.</span></span>
<span class="line" id="L1880">    <span class="tok-comment">/// https://simonsapin.github.io/wtf-8/</span></span>
<span class="line" id="L1881">    InvalidWtf8,</span>
<span class="line" id="L1882"></span>
<span class="line" id="L1883">    <span class="tok-comment">/// On Windows, file paths cannot contain these characters:</span></span>
<span class="line" id="L1884">    <span class="tok-comment">/// '/', '*', '?', '&quot;', '&lt;', '&gt;', '|'</span></span>
<span class="line" id="L1885">    BadPathName,</span>
<span class="line" id="L1886"></span>
<span class="line" id="L1887">    <span class="tok-comment">/// On Windows, `\\server` or `\\server\share` was not found.</span></span>
<span class="line" id="L1888">    NetworkNotFound,</span>
<span class="line" id="L1889">} || posix.UnexpectedError;</span>
<span class="line" id="L1890"></span>
<span class="line" id="L1891"><span class="tok-comment">/// Whether `full_path` describes a symlink, file, or directory, this function</span></span>
<span class="line" id="L1892"><span class="tok-comment">/// removes it. If it cannot be removed because it is a non-empty directory,</span></span>
<span class="line" id="L1893"><span class="tok-comment">/// this function recursively removes its entries and then tries again.</span></span>
<span class="line" id="L1894"><span class="tok-comment">/// This operation is not atomic on most file systems.</span></span>
<span class="line" id="L1895"><span class="tok-comment">/// On Windows, `sub_path` should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span></span>
<span class="line" id="L1896"><span class="tok-comment">/// On WASI, `sub_path` should be encoded as valid UTF-8.</span></span>
<span class="line" id="L1897"><span class="tok-comment">/// On other platforms, `sub_path` is an opaque sequence of bytes with no particular encoding.</span></span>
<span class="line" id="L1898"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteTree</span>(self: Dir, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) DeleteTreeError!<span class="tok-type">void</span> {</span>
<span class="line" id="L1899">    <span class="tok-kw">var</span> initial_iterable_dir = (<span class="tok-kw">try</span> self.deleteTreeOpenInitialSubpath(sub_path, .file)) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L1900"></span>
<span class="line" id="L1901">    <span class="tok-kw">const</span> StackItem = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1902">        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1903">        parent_dir: Dir,</span>
<span class="line" id="L1904">        iter: Dir.Iterator,</span>
<span class="line" id="L1905"></span>
<span class="line" id="L1906">        <span class="tok-kw">fn</span> <span class="tok-fn">closeAll</span>(items: []<span class="tok-builtin">@This</span>()) <span class="tok-type">void</span> {</span>
<span class="line" id="L1907">            <span class="tok-kw">for</span> (items) |*item| item.iter.dir.close();</span>
<span class="line" id="L1908">        }</span>
<span class="line" id="L1909">    };</span>
<span class="line" id="L1910"></span>
<span class="line" id="L1911">    <span class="tok-kw">var</span> stack_buffer: [<span class="tok-number">16</span>]StackItem = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1912">    <span class="tok-kw">var</span> stack = std.ArrayListUnmanaged(StackItem).initBuffer(&amp;stack_buffer);</span>
<span class="line" id="L1913">    <span class="tok-kw">defer</span> StackItem.closeAll(stack.items);</span>
<span class="line" id="L1914"></span>
<span class="line" id="L1915">    stack.appendAssumeCapacity(.{</span>
<span class="line" id="L1916">        .name = sub_path,</span>
<span class="line" id="L1917">        .parent_dir = self,</span>
<span class="line" id="L1918">        .iter = initial_iterable_dir.iterateAssumeFirstIteration(),</span>
<span class="line" id="L1919">    });</span>
<span class="line" id="L1920"></span>
<span class="line" id="L1921">    process_stack: <span class="tok-kw">while</span> (stack.items.len != <span class="tok-number">0</span>) {</span>
<span class="line" id="L1922">        <span class="tok-kw">var</span> top = &amp;stack.items[stack.items.len - <span class="tok-number">1</span>];</span>
<span class="line" id="L1923">        <span class="tok-kw">while</span> (<span class="tok-kw">try</span> top.iter.next()) |entry| {</span>
<span class="line" id="L1924">            <span class="tok-kw">var</span> treat_as_dir = entry.kind == .directory;</span>
<span class="line" id="L1925">            handle_entry: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L1926">                <span class="tok-kw">if</span> (treat_as_dir) {</span>
<span class="line" id="L1927">                    <span class="tok-kw">if</span> (stack.unusedCapacitySlice().len &gt;= <span class="tok-number">1</span>) {</span>
<span class="line" id="L1928">                        <span class="tok-kw">var</span> iterable_dir = top.iter.dir.openDir(entry.name, .{</span>
<span class="line" id="L1929">                            .no_follow = <span class="tok-null">true</span>,</span>
<span class="line" id="L1930">                            .iterate = <span class="tok-null">true</span>,</span>
<span class="line" id="L1931">                        }) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1932">                            <span class="tok-kw">error</span>.NotDir =&gt; {</span>
<span class="line" id="L1933">                                treat_as_dir = <span class="tok-null">false</span>;</span>
<span class="line" id="L1934">                                <span class="tok-kw">continue</span> :handle_entry;</span>
<span class="line" id="L1935">                            },</span>
<span class="line" id="L1936">                            <span class="tok-kw">error</span>.FileNotFound =&gt; {</span>
<span class="line" id="L1937">                                <span class="tok-comment">// That's fine, we were trying to remove this directory anyway.</span>
</span>
<span class="line" id="L1938">                                <span class="tok-kw">break</span> :handle_entry;</span>
<span class="line" id="L1939">                            },</span>
<span class="line" id="L1940"></span>
<span class="line" id="L1941">                            <span class="tok-kw">error</span>.AccessDenied,</span>
<span class="line" id="L1942">                            <span class="tok-kw">error</span>.SymLinkLoop,</span>
<span class="line" id="L1943">                            <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,</span>
<span class="line" id="L1944">                            <span class="tok-kw">error</span>.NameTooLong,</span>
<span class="line" id="L1945">                            <span class="tok-kw">error</span>.SystemFdQuotaExceeded,</span>
<span class="line" id="L1946">                            <span class="tok-kw">error</span>.NoDevice,</span>
<span class="line" id="L1947">                            <span class="tok-kw">error</span>.SystemResources,</span>
<span class="line" id="L1948">                            <span class="tok-kw">error</span>.Unexpected,</span>
<span class="line" id="L1949">                            <span class="tok-kw">error</span>.InvalidUtf8,</span>
<span class="line" id="L1950">                            <span class="tok-kw">error</span>.InvalidWtf8,</span>
<span class="line" id="L1951">                            <span class="tok-kw">error</span>.BadPathName,</span>
<span class="line" id="L1952">                            <span class="tok-kw">error</span>.NetworkNotFound,</span>
<span class="line" id="L1953">                            <span class="tok-kw">error</span>.DeviceBusy,</span>
<span class="line" id="L1954">                            =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L1955">                        };</span>
<span class="line" id="L1956">                        stack.appendAssumeCapacity(.{</span>
<span class="line" id="L1957">                            .name = entry.name,</span>
<span class="line" id="L1958">                            .parent_dir = top.iter.dir,</span>
<span class="line" id="L1959">                            .iter = iterable_dir.iterateAssumeFirstIteration(),</span>
<span class="line" id="L1960">                        });</span>
<span class="line" id="L1961">                        <span class="tok-kw">continue</span> :process_stack;</span>
<span class="line" id="L1962">                    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1963">                        <span class="tok-kw">try</span> top.iter.dir.deleteTreeMinStackSizeWithKindHint(entry.name, entry.kind);</span>
<span class="line" id="L1964">                        <span class="tok-kw">break</span> :handle_entry;</span>
<span class="line" id="L1965">                    }</span>
<span class="line" id="L1966">                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1967">                    <span class="tok-kw">if</span> (top.iter.dir.deleteFile(entry.name)) {</span>
<span class="line" id="L1968">                        <span class="tok-kw">break</span> :handle_entry;</span>
<span class="line" id="L1969">                    } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1970">                        <span class="tok-kw">error</span>.FileNotFound =&gt; <span class="tok-kw">break</span> :handle_entry,</span>
<span class="line" id="L1971"></span>
<span class="line" id="L1972">                        <span class="tok-comment">// Impossible because we do not pass any path separators.</span>
</span>
<span class="line" id="L1973">                        <span class="tok-kw">error</span>.NotDir =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1974"></span>
<span class="line" id="L1975">                        <span class="tok-kw">error</span>.IsDir =&gt; {</span>
<span class="line" id="L1976">                            treat_as_dir = <span class="tok-null">true</span>;</span>
<span class="line" id="L1977">                            <span class="tok-kw">continue</span> :handle_entry;</span>
<span class="line" id="L1978">                        },</span>
<span class="line" id="L1979"></span>
<span class="line" id="L1980">                        <span class="tok-kw">error</span>.AccessDenied,</span>
<span class="line" id="L1981">                        <span class="tok-kw">error</span>.InvalidUtf8,</span>
<span class="line" id="L1982">                        <span class="tok-kw">error</span>.InvalidWtf8,</span>
<span class="line" id="L1983">                        <span class="tok-kw">error</span>.SymLinkLoop,</span>
<span class="line" id="L1984">                        <span class="tok-kw">error</span>.NameTooLong,</span>
<span class="line" id="L1985">                        <span class="tok-kw">error</span>.SystemResources,</span>
<span class="line" id="L1986">                        <span class="tok-kw">error</span>.ReadOnlyFileSystem,</span>
<span class="line" id="L1987">                        <span class="tok-kw">error</span>.FileSystem,</span>
<span class="line" id="L1988">                        <span class="tok-kw">error</span>.FileBusy,</span>
<span class="line" id="L1989">                        <span class="tok-kw">error</span>.BadPathName,</span>
<span class="line" id="L1990">                        <span class="tok-kw">error</span>.NetworkNotFound,</span>
<span class="line" id="L1991">                        <span class="tok-kw">error</span>.Unexpected,</span>
<span class="line" id="L1992">                        =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L1993">                    }</span>
<span class="line" id="L1994">                }</span>
<span class="line" id="L1995">            }</span>
<span class="line" id="L1996">        }</span>
<span class="line" id="L1997"></span>
<span class="line" id="L1998">        <span class="tok-comment">// On Windows, we can't delete until the dir's handle has been closed, so</span>
</span>
<span class="line" id="L1999">        <span class="tok-comment">// close it before we try to delete.</span>
</span>
<span class="line" id="L2000">        top.iter.dir.close();</span>
<span class="line" id="L2001"></span>
<span class="line" id="L2002">        <span class="tok-comment">// In order to avoid double-closing the directory when cleaning up</span>
</span>
<span class="line" id="L2003">        <span class="tok-comment">// the stack in the case of an error, we save the relevant portions and</span>
</span>
<span class="line" id="L2004">        <span class="tok-comment">// pop the value from the stack.</span>
</span>
<span class="line" id="L2005">        <span class="tok-kw">const</span> parent_dir = top.parent_dir;</span>
<span class="line" id="L2006">        <span class="tok-kw">const</span> name = top.name;</span>
<span class="line" id="L2007">        stack.items.len -= <span class="tok-number">1</span>;</span>
<span class="line" id="L2008"></span>
<span class="line" id="L2009">        <span class="tok-kw">var</span> need_to_retry: <span class="tok-type">bool</span> = <span class="tok-null">false</span>;</span>
<span class="line" id="L2010">        parent_dir.deleteDir(name) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L2011">            <span class="tok-kw">error</span>.FileNotFound =&gt; {},</span>
<span class="line" id="L2012">            <span class="tok-kw">error</span>.DirNotEmpty =&gt; need_to_retry = <span class="tok-null">true</span>,</span>
<span class="line" id="L2013">            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L2014">        };</span>
<span class="line" id="L2015"></span>
<span class="line" id="L2016">        <span class="tok-kw">if</span> (need_to_retry) {</span>
<span class="line" id="L2017">            <span class="tok-comment">// Since we closed the handle that the previous iterator used, we</span>
</span>
<span class="line" id="L2018">            <span class="tok-comment">// need to re-open the dir and re-create the iterator.</span>
</span>
<span class="line" id="L2019">            <span class="tok-kw">var</span> iterable_dir = iterable_dir: {</span>
<span class="line" id="L2020">                <span class="tok-kw">var</span> treat_as_dir = <span class="tok-null">true</span>;</span>
<span class="line" id="L2021">                handle_entry: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L2022">                    <span class="tok-kw">if</span> (treat_as_dir) {</span>
<span class="line" id="L2023">                        <span class="tok-kw">break</span> :iterable_dir parent_dir.openDir(name, .{</span>
<span class="line" id="L2024">                            .no_follow = <span class="tok-null">true</span>,</span>
<span class="line" id="L2025">                            .iterate = <span class="tok-null">true</span>,</span>
<span class="line" id="L2026">                        }) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L2027">                            <span class="tok-kw">error</span>.NotDir =&gt; {</span>
<span class="line" id="L2028">                                treat_as_dir = <span class="tok-null">false</span>;</span>
<span class="line" id="L2029">                                <span class="tok-kw">continue</span> :handle_entry;</span>
<span class="line" id="L2030">                            },</span>
<span class="line" id="L2031">                            <span class="tok-kw">error</span>.FileNotFound =&gt; {</span>
<span class="line" id="L2032">                                <span class="tok-comment">// That's fine, we were trying to remove this directory anyway.</span>
</span>
<span class="line" id="L2033">                                <span class="tok-kw">continue</span> :process_stack;</span>
<span class="line" id="L2034">                            },</span>
<span class="line" id="L2035"></span>
<span class="line" id="L2036">                            <span class="tok-kw">error</span>.AccessDenied,</span>
<span class="line" id="L2037">                            <span class="tok-kw">error</span>.SymLinkLoop,</span>
<span class="line" id="L2038">                            <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,</span>
<span class="line" id="L2039">                            <span class="tok-kw">error</span>.NameTooLong,</span>
<span class="line" id="L2040">                            <span class="tok-kw">error</span>.SystemFdQuotaExceeded,</span>
<span class="line" id="L2041">                            <span class="tok-kw">error</span>.NoDevice,</span>
<span class="line" id="L2042">                            <span class="tok-kw">error</span>.SystemResources,</span>
<span class="line" id="L2043">                            <span class="tok-kw">error</span>.Unexpected,</span>
<span class="line" id="L2044">                            <span class="tok-kw">error</span>.InvalidUtf8,</span>
<span class="line" id="L2045">                            <span class="tok-kw">error</span>.InvalidWtf8,</span>
<span class="line" id="L2046">                            <span class="tok-kw">error</span>.BadPathName,</span>
<span class="line" id="L2047">                            <span class="tok-kw">error</span>.NetworkNotFound,</span>
<span class="line" id="L2048">                            <span class="tok-kw">error</span>.DeviceBusy,</span>
<span class="line" id="L2049">                            =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L2050">                        };</span>
<span class="line" id="L2051">                    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2052">                        <span class="tok-kw">if</span> (parent_dir.deleteFile(name)) {</span>
<span class="line" id="L2053">                            <span class="tok-kw">continue</span> :process_stack;</span>
<span class="line" id="L2054">                        } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L2055">                            <span class="tok-kw">error</span>.FileNotFound =&gt; <span class="tok-kw">continue</span> :process_stack,</span>
<span class="line" id="L2056"></span>
<span class="line" id="L2057">                            <span class="tok-comment">// Impossible because we do not pass any path separators.</span>
</span>
<span class="line" id="L2058">                            <span class="tok-kw">error</span>.NotDir =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L2059"></span>
<span class="line" id="L2060">                            <span class="tok-kw">error</span>.IsDir =&gt; {</span>
<span class="line" id="L2061">                                treat_as_dir = <span class="tok-null">true</span>;</span>
<span class="line" id="L2062">                                <span class="tok-kw">continue</span> :handle_entry;</span>
<span class="line" id="L2063">                            },</span>
<span class="line" id="L2064"></span>
<span class="line" id="L2065">                            <span class="tok-kw">error</span>.AccessDenied,</span>
<span class="line" id="L2066">                            <span class="tok-kw">error</span>.InvalidUtf8,</span>
<span class="line" id="L2067">                            <span class="tok-kw">error</span>.InvalidWtf8,</span>
<span class="line" id="L2068">                            <span class="tok-kw">error</span>.SymLinkLoop,</span>
<span class="line" id="L2069">                            <span class="tok-kw">error</span>.NameTooLong,</span>
<span class="line" id="L2070">                            <span class="tok-kw">error</span>.SystemResources,</span>
<span class="line" id="L2071">                            <span class="tok-kw">error</span>.ReadOnlyFileSystem,</span>
<span class="line" id="L2072">                            <span class="tok-kw">error</span>.FileSystem,</span>
<span class="line" id="L2073">                            <span class="tok-kw">error</span>.FileBusy,</span>
<span class="line" id="L2074">                            <span class="tok-kw">error</span>.BadPathName,</span>
<span class="line" id="L2075">                            <span class="tok-kw">error</span>.NetworkNotFound,</span>
<span class="line" id="L2076">                            <span class="tok-kw">error</span>.Unexpected,</span>
<span class="line" id="L2077">                            =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L2078">                        }</span>
<span class="line" id="L2079">                    }</span>
<span class="line" id="L2080">                }</span>
<span class="line" id="L2081">            };</span>
<span class="line" id="L2082">            <span class="tok-comment">// We know there is room on the stack since we are just re-adding</span>
</span>
<span class="line" id="L2083">            <span class="tok-comment">// the StackItem that we previously popped.</span>
</span>
<span class="line" id="L2084">            stack.appendAssumeCapacity(.{</span>
<span class="line" id="L2085">                .name = name,</span>
<span class="line" id="L2086">                .parent_dir = parent_dir,</span>
<span class="line" id="L2087">                .iter = iterable_dir.iterateAssumeFirstIteration(),</span>
<span class="line" id="L2088">            });</span>
<span class="line" id="L2089">            <span class="tok-kw">continue</span> :process_stack;</span>
<span class="line" id="L2090">        }</span>
<span class="line" id="L2091">    }</span>
<span class="line" id="L2092">}</span>
<span class="line" id="L2093"></span>
<span class="line" id="L2094"><span class="tok-comment">/// Like `deleteTree`, but only keeps one `Iterator` active at a time to minimize the function's stack size.</span></span>
<span class="line" id="L2095"><span class="tok-comment">/// This is slower than `deleteTree` but uses less stack space.</span></span>
<span class="line" id="L2096"><span class="tok-comment">/// On Windows, `sub_path` should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span></span>
<span class="line" id="L2097"><span class="tok-comment">/// On WASI, `sub_path` should be encoded as valid UTF-8.</span></span>
<span class="line" id="L2098"><span class="tok-comment">/// On other platforms, `sub_path` is an opaque sequence of bytes with no particular encoding.</span></span>
<span class="line" id="L2099"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deleteTreeMinStackSize</span>(self: Dir, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) DeleteTreeError!<span class="tok-type">void</span> {</span>
<span class="line" id="L2100">    <span class="tok-kw">return</span> self.deleteTreeMinStackSizeWithKindHint(sub_path, .file);</span>
<span class="line" id="L2101">}</span>
<span class="line" id="L2102"></span>
<span class="line" id="L2103"><span class="tok-kw">fn</span> <span class="tok-fn">deleteTreeMinStackSizeWithKindHint</span>(self: Dir, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, kind_hint: File.Kind) DeleteTreeError!<span class="tok-type">void</span> {</span>
<span class="line" id="L2104">    start_over: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L2105">        <span class="tok-kw">var</span> dir = (<span class="tok-kw">try</span> self.deleteTreeOpenInitialSubpath(sub_path, kind_hint)) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L2106">        <span class="tok-kw">var</span> cleanup_dir_parent: ?Dir = <span class="tok-null">null</span>;</span>
<span class="line" id="L2107">        <span class="tok-kw">defer</span> <span class="tok-kw">if</span> (cleanup_dir_parent) |*d| d.close();</span>
<span class="line" id="L2108"></span>
<span class="line" id="L2109">        <span class="tok-kw">var</span> cleanup_dir = <span class="tok-null">true</span>;</span>
<span class="line" id="L2110">        <span class="tok-kw">defer</span> <span class="tok-kw">if</span> (cleanup_dir) dir.close();</span>
<span class="line" id="L2111"></span>
<span class="line" id="L2112">        <span class="tok-comment">// Valid use of MAX_PATH_BYTES because dir_name_buf will only</span>
</span>
<span class="line" id="L2113">        <span class="tok-comment">// ever store a single path component that was returned from the</span>
</span>
<span class="line" id="L2114">        <span class="tok-comment">// filesystem.</span>
</span>
<span class="line" id="L2115">        <span class="tok-kw">var</span> dir_name_buf: [fs.MAX_PATH_BYTES]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L2116">        <span class="tok-kw">var</span> dir_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = sub_path;</span>
<span class="line" id="L2117"></span>
<span class="line" id="L2118">        <span class="tok-comment">// Here we must avoid recursion, in order to provide O(1) memory guarantee of this function.</span>
</span>
<span class="line" id="L2119">        <span class="tok-comment">// Go through each entry and if it is not a directory, delete it. If it is a directory,</span>
</span>
<span class="line" id="L2120">        <span class="tok-comment">// open it, and close the original directory. Repeat. Then start the entire operation over.</span>
</span>
<span class="line" id="L2121"></span>
<span class="line" id="L2122">        scan_dir: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L2123">            <span class="tok-kw">var</span> dir_it = dir.iterateAssumeFirstIteration();</span>
<span class="line" id="L2124">            dir_it: <span class="tok-kw">while</span> (<span class="tok-kw">try</span> dir_it.next()) |entry| {</span>
<span class="line" id="L2125">                <span class="tok-kw">var</span> treat_as_dir = entry.kind == .directory;</span>
<span class="line" id="L2126">                handle_entry: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L2127">                    <span class="tok-kw">if</span> (treat_as_dir) {</span>
<span class="line" id="L2128">                        <span class="tok-kw">const</span> new_dir = dir.openDir(entry.name, .{</span>
<span class="line" id="L2129">                            .no_follow = <span class="tok-null">true</span>,</span>
<span class="line" id="L2130">                            .iterate = <span class="tok-null">true</span>,</span>
<span class="line" id="L2131">                        }) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L2132">                            <span class="tok-kw">error</span>.NotDir =&gt; {</span>
<span class="line" id="L2133">                                treat_as_dir = <span class="tok-null">false</span>;</span>
<span class="line" id="L2134">                                <span class="tok-kw">continue</span> :handle_entry;</span>
<span class="line" id="L2135">                            },</span>
<span class="line" id="L2136">                            <span class="tok-kw">error</span>.FileNotFound =&gt; {</span>
<span class="line" id="L2137">                                <span class="tok-comment">// That's fine, we were trying to remove this directory anyway.</span>
</span>
<span class="line" id="L2138">                                <span class="tok-kw">continue</span> :dir_it;</span>
<span class="line" id="L2139">                            },</span>
<span class="line" id="L2140"></span>
<span class="line" id="L2141">                            <span class="tok-kw">error</span>.AccessDenied,</span>
<span class="line" id="L2142">                            <span class="tok-kw">error</span>.SymLinkLoop,</span>
<span class="line" id="L2143">                            <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,</span>
<span class="line" id="L2144">                            <span class="tok-kw">error</span>.NameTooLong,</span>
<span class="line" id="L2145">                            <span class="tok-kw">error</span>.SystemFdQuotaExceeded,</span>
<span class="line" id="L2146">                            <span class="tok-kw">error</span>.NoDevice,</span>
<span class="line" id="L2147">                            <span class="tok-kw">error</span>.SystemResources,</span>
<span class="line" id="L2148">                            <span class="tok-kw">error</span>.Unexpected,</span>
<span class="line" id="L2149">                            <span class="tok-kw">error</span>.InvalidUtf8,</span>
<span class="line" id="L2150">                            <span class="tok-kw">error</span>.InvalidWtf8,</span>
<span class="line" id="L2151">                            <span class="tok-kw">error</span>.BadPathName,</span>
<span class="line" id="L2152">                            <span class="tok-kw">error</span>.NetworkNotFound,</span>
<span class="line" id="L2153">                            <span class="tok-kw">error</span>.DeviceBusy,</span>
<span class="line" id="L2154">                            =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L2155">                        };</span>
<span class="line" id="L2156">                        <span class="tok-kw">if</span> (cleanup_dir_parent) |*d| d.close();</span>
<span class="line" id="L2157">                        cleanup_dir_parent = dir;</span>
<span class="line" id="L2158">                        dir = new_dir;</span>
<span class="line" id="L2159">                        <span class="tok-kw">const</span> result = dir_name_buf[<span class="tok-number">0</span>..entry.name.len];</span>
<span class="line" id="L2160">                        <span class="tok-builtin">@memcpy</span>(result, entry.name);</span>
<span class="line" id="L2161">                        dir_name = result;</span>
<span class="line" id="L2162">                        <span class="tok-kw">continue</span> :scan_dir;</span>
<span class="line" id="L2163">                    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2164">                        <span class="tok-kw">if</span> (dir.deleteFile(entry.name)) {</span>
<span class="line" id="L2165">                            <span class="tok-kw">continue</span> :dir_it;</span>
<span class="line" id="L2166">                        } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L2167">                            <span class="tok-kw">error</span>.FileNotFound =&gt; <span class="tok-kw">continue</span> :dir_it,</span>
<span class="line" id="L2168"></span>
<span class="line" id="L2169">                            <span class="tok-comment">// Impossible because we do not pass any path separators.</span>
</span>
<span class="line" id="L2170">                            <span class="tok-kw">error</span>.NotDir =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L2171"></span>
<span class="line" id="L2172">                            <span class="tok-kw">error</span>.IsDir =&gt; {</span>
<span class="line" id="L2173">                                treat_as_dir = <span class="tok-null">true</span>;</span>
<span class="line" id="L2174">                                <span class="tok-kw">continue</span> :handle_entry;</span>
<span class="line" id="L2175">                            },</span>
<span class="line" id="L2176"></span>
<span class="line" id="L2177">                            <span class="tok-kw">error</span>.AccessDenied,</span>
<span class="line" id="L2178">                            <span class="tok-kw">error</span>.InvalidUtf8,</span>
<span class="line" id="L2179">                            <span class="tok-kw">error</span>.InvalidWtf8,</span>
<span class="line" id="L2180">                            <span class="tok-kw">error</span>.SymLinkLoop,</span>
<span class="line" id="L2181">                            <span class="tok-kw">error</span>.NameTooLong,</span>
<span class="line" id="L2182">                            <span class="tok-kw">error</span>.SystemResources,</span>
<span class="line" id="L2183">                            <span class="tok-kw">error</span>.ReadOnlyFileSystem,</span>
<span class="line" id="L2184">                            <span class="tok-kw">error</span>.FileSystem,</span>
<span class="line" id="L2185">                            <span class="tok-kw">error</span>.FileBusy,</span>
<span class="line" id="L2186">                            <span class="tok-kw">error</span>.BadPathName,</span>
<span class="line" id="L2187">                            <span class="tok-kw">error</span>.NetworkNotFound,</span>
<span class="line" id="L2188">                            <span class="tok-kw">error</span>.Unexpected,</span>
<span class="line" id="L2189">                            =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L2190">                        }</span>
<span class="line" id="L2191">                    }</span>
<span class="line" id="L2192">                }</span>
<span class="line" id="L2193">            }</span>
<span class="line" id="L2194">            <span class="tok-comment">// Reached the end of the directory entries, which means we successfully deleted all of them.</span>
</span>
<span class="line" id="L2195">            <span class="tok-comment">// Now to remove the directory itself.</span>
</span>
<span class="line" id="L2196">            dir.close();</span>
<span class="line" id="L2197">            cleanup_dir = <span class="tok-null">false</span>;</span>
<span class="line" id="L2198"></span>
<span class="line" id="L2199">            <span class="tok-kw">if</span> (cleanup_dir_parent) |d| {</span>
<span class="line" id="L2200">                d.deleteDir(dir_name) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L2201">                    <span class="tok-comment">// These two things can happen due to file system race conditions.</span>
</span>
<span class="line" id="L2202">                    <span class="tok-kw">error</span>.FileNotFound, <span class="tok-kw">error</span>.DirNotEmpty =&gt; <span class="tok-kw">continue</span> :start_over,</span>
<span class="line" id="L2203">                    <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L2204">                };</span>
<span class="line" id="L2205">                <span class="tok-kw">continue</span> :start_over;</span>
<span class="line" id="L2206">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2207">                self.deleteDir(sub_path) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L2208">                    <span class="tok-kw">error</span>.FileNotFound =&gt; <span class="tok-kw">return</span>,</span>
<span class="line" id="L2209">                    <span class="tok-kw">error</span>.DirNotEmpty =&gt; <span class="tok-kw">continue</span> :start_over,</span>
<span class="line" id="L2210">                    <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L2211">                };</span>
<span class="line" id="L2212">                <span class="tok-kw">return</span>;</span>
<span class="line" id="L2213">            }</span>
<span class="line" id="L2214">        }</span>
<span class="line" id="L2215">    }</span>
<span class="line" id="L2216">}</span>
<span class="line" id="L2217"></span>
<span class="line" id="L2218"><span class="tok-comment">/// On successful delete, returns null.</span></span>
<span class="line" id="L2219"><span class="tok-kw">fn</span> <span class="tok-fn">deleteTreeOpenInitialSubpath</span>(self: Dir, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, kind_hint: File.Kind) !?Dir {</span>
<span class="line" id="L2220">    <span class="tok-kw">return</span> iterable_dir: {</span>
<span class="line" id="L2221">        <span class="tok-comment">// Treat as a file by default</span>
</span>
<span class="line" id="L2222">        <span class="tok-kw">var</span> treat_as_dir = kind_hint == .directory;</span>
<span class="line" id="L2223"></span>
<span class="line" id="L2224">        handle_entry: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L2225">            <span class="tok-kw">if</span> (treat_as_dir) {</span>
<span class="line" id="L2226">                <span class="tok-kw">break</span> :iterable_dir self.openDir(sub_path, .{</span>
<span class="line" id="L2227">                    .no_follow = <span class="tok-null">true</span>,</span>
<span class="line" id="L2228">                    .iterate = <span class="tok-null">true</span>,</span>
<span class="line" id="L2229">                }) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L2230">                    <span class="tok-kw">error</span>.NotDir =&gt; {</span>
<span class="line" id="L2231">                        treat_as_dir = <span class="tok-null">false</span>;</span>
<span class="line" id="L2232">                        <span class="tok-kw">continue</span> :handle_entry;</span>
<span class="line" id="L2233">                    },</span>
<span class="line" id="L2234">                    <span class="tok-kw">error</span>.FileNotFound =&gt; {</span>
<span class="line" id="L2235">                        <span class="tok-comment">// That's fine, we were trying to remove this directory anyway.</span>
</span>
<span class="line" id="L2236">                        <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L2237">                    },</span>
<span class="line" id="L2238"></span>
<span class="line" id="L2239">                    <span class="tok-kw">error</span>.AccessDenied,</span>
<span class="line" id="L2240">                    <span class="tok-kw">error</span>.SymLinkLoop,</span>
<span class="line" id="L2241">                    <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,</span>
<span class="line" id="L2242">                    <span class="tok-kw">error</span>.NameTooLong,</span>
<span class="line" id="L2243">                    <span class="tok-kw">error</span>.SystemFdQuotaExceeded,</span>
<span class="line" id="L2244">                    <span class="tok-kw">error</span>.NoDevice,</span>
<span class="line" id="L2245">                    <span class="tok-kw">error</span>.SystemResources,</span>
<span class="line" id="L2246">                    <span class="tok-kw">error</span>.Unexpected,</span>
<span class="line" id="L2247">                    <span class="tok-kw">error</span>.InvalidUtf8,</span>
<span class="line" id="L2248">                    <span class="tok-kw">error</span>.InvalidWtf8,</span>
<span class="line" id="L2249">                    <span class="tok-kw">error</span>.BadPathName,</span>
<span class="line" id="L2250">                    <span class="tok-kw">error</span>.DeviceBusy,</span>
<span class="line" id="L2251">                    <span class="tok-kw">error</span>.NetworkNotFound,</span>
<span class="line" id="L2252">                    =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L2253">                };</span>
<span class="line" id="L2254">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2255">                <span class="tok-kw">if</span> (self.deleteFile(sub_path)) {</span>
<span class="line" id="L2256">                    <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L2257">                } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L2258">                    <span class="tok-kw">error</span>.FileNotFound =&gt; <span class="tok-kw">return</span> <span class="tok-null">null</span>,</span>
<span class="line" id="L2259"></span>
<span class="line" id="L2260">                    <span class="tok-kw">error</span>.IsDir =&gt; {</span>
<span class="line" id="L2261">                        treat_as_dir = <span class="tok-null">true</span>;</span>
<span class="line" id="L2262">                        <span class="tok-kw">continue</span> :handle_entry;</span>
<span class="line" id="L2263">                    },</span>
<span class="line" id="L2264"></span>
<span class="line" id="L2265">                    <span class="tok-kw">error</span>.AccessDenied,</span>
<span class="line" id="L2266">                    <span class="tok-kw">error</span>.InvalidUtf8,</span>
<span class="line" id="L2267">                    <span class="tok-kw">error</span>.InvalidWtf8,</span>
<span class="line" id="L2268">                    <span class="tok-kw">error</span>.SymLinkLoop,</span>
<span class="line" id="L2269">                    <span class="tok-kw">error</span>.NameTooLong,</span>
<span class="line" id="L2270">                    <span class="tok-kw">error</span>.SystemResources,</span>
<span class="line" id="L2271">                    <span class="tok-kw">error</span>.ReadOnlyFileSystem,</span>
<span class="line" id="L2272">                    <span class="tok-kw">error</span>.NotDir,</span>
<span class="line" id="L2273">                    <span class="tok-kw">error</span>.FileSystem,</span>
<span class="line" id="L2274">                    <span class="tok-kw">error</span>.FileBusy,</span>
<span class="line" id="L2275">                    <span class="tok-kw">error</span>.BadPathName,</span>
<span class="line" id="L2276">                    <span class="tok-kw">error</span>.NetworkNotFound,</span>
<span class="line" id="L2277">                    <span class="tok-kw">error</span>.Unexpected,</span>
<span class="line" id="L2278">                    =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L2279">                }</span>
<span class="line" id="L2280">            }</span>
<span class="line" id="L2281">        }</span>
<span class="line" id="L2282">    };</span>
<span class="line" id="L2283">}</span>
<span class="line" id="L2284"></span>
<span class="line" id="L2285"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> WriteFileError = File.WriteError || File.OpenError;</span>
<span class="line" id="L2286"></span>
<span class="line" id="L2287"><span class="tok-comment">/// Deprecated: use `writeFile2`.</span></span>
<span class="line" id="L2288"><span class="tok-comment">/// On Windows, `sub_path` should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span></span>
<span class="line" id="L2289"><span class="tok-comment">/// On WASI, `sub_path` should be encoded as valid UTF-8.</span></span>
<span class="line" id="L2290"><span class="tok-comment">/// On other platforms, `sub_path` is an opaque sequence of bytes with no particular encoding.</span></span>
<span class="line" id="L2291"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeFile</span>(self: Dir, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) WriteFileError!<span class="tok-type">void</span> {</span>
<span class="line" id="L2292">    <span class="tok-kw">return</span> writeFile2(self, .{</span>
<span class="line" id="L2293">        .sub_path = sub_path,</span>
<span class="line" id="L2294">        .data = data,</span>
<span class="line" id="L2295">        .flags = .{},</span>
<span class="line" id="L2296">    });</span>
<span class="line" id="L2297">}</span>
<span class="line" id="L2298"></span>
<span class="line" id="L2299"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> WriteFileOptions = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2300">    <span class="tok-comment">/// On Windows, `sub_path` should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span></span>
<span class="line" id="L2301">    <span class="tok-comment">/// On WASI, `sub_path` should be encoded as valid UTF-8.</span></span>
<span class="line" id="L2302">    <span class="tok-comment">/// On other platforms, `sub_path` is an opaque sequence of bytes with no particular encoding.</span></span>
<span class="line" id="L2303">    sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L2304">    data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L2305">    flags: File.CreateFlags = .{},</span>
<span class="line" id="L2306">};</span>
<span class="line" id="L2307"></span>
<span class="line" id="L2308"><span class="tok-comment">/// Writes content to the file system, using the file creation flags provided.</span></span>
<span class="line" id="L2309"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeFile2</span>(self: Dir, options: WriteFileOptions) WriteFileError!<span class="tok-type">void</span> {</span>
<span class="line" id="L2310">    <span class="tok-kw">var</span> file = <span class="tok-kw">try</span> self.createFile(options.sub_path, options.flags);</span>
<span class="line" id="L2311">    <span class="tok-kw">defer</span> file.close();</span>
<span class="line" id="L2312">    <span class="tok-kw">try</span> file.writeAll(options.data);</span>
<span class="line" id="L2313">}</span>
<span class="line" id="L2314"></span>
<span class="line" id="L2315"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> AccessError = posix.AccessError;</span>
<span class="line" id="L2316"></span>
<span class="line" id="L2317"><span class="tok-comment">/// Test accessing `sub_path`.</span></span>
<span class="line" id="L2318"><span class="tok-comment">/// On Windows, `sub_path` should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span></span>
<span class="line" id="L2319"><span class="tok-comment">/// On WASI, `sub_path` should be encoded as valid UTF-8.</span></span>
<span class="line" id="L2320"><span class="tok-comment">/// On other platforms, `sub_path` is an opaque sequence of bytes with no particular encoding.</span></span>
<span class="line" id="L2321"><span class="tok-comment">/// Be careful of Time-Of-Check-Time-Of-Use race conditions when using this function.</span></span>
<span class="line" id="L2322"><span class="tok-comment">/// For example, instead of testing if a file exists and then opening it, just</span></span>
<span class="line" id="L2323"><span class="tok-comment">/// open it and handle the error for file not found.</span></span>
<span class="line" id="L2324"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">access</span>(self: Dir, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: File.OpenFlags) AccessError!<span class="tok-type">void</span> {</span>
<span class="line" id="L2325">    <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L2326">        <span class="tok-kw">const</span> sub_path_w = std.os.windows.sliceToPrefixedFileW(self.fd, sub_path) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L2327">            <span class="tok-kw">error</span>.AccessDenied =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,</span>
<span class="line" id="L2328">            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L2329">        };</span>
<span class="line" id="L2330">        <span class="tok-kw">return</span> self.accessW(sub_path_w.span().ptr, flags);</span>
<span class="line" id="L2331">    }</span>
<span class="line" id="L2332">    <span class="tok-kw">const</span> path_c = <span class="tok-kw">try</span> posix.toPosixPath(sub_path);</span>
<span class="line" id="L2333">    <span class="tok-kw">return</span> self.accessZ(&amp;path_c, flags);</span>
<span class="line" id="L2334">}</span>
<span class="line" id="L2335"></span>
<span class="line" id="L2336"><span class="tok-comment">/// Same as `access` except the path parameter is null-terminated.</span></span>
<span class="line" id="L2337"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">accessZ</span>(self: Dir, sub_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: File.OpenFlags) AccessError!<span class="tok-type">void</span> {</span>
<span class="line" id="L2338">    <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L2339">        <span class="tok-kw">const</span> sub_path_w = std.os.windows.cStrToPrefixedFileW(self.fd, sub_path) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L2340">            <span class="tok-kw">error</span>.AccessDenied =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,</span>
<span class="line" id="L2341">            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L2342">        };</span>
<span class="line" id="L2343">        <span class="tok-kw">return</span> self.accessW(sub_path_w.span().ptr, flags);</span>
<span class="line" id="L2344">    }</span>
<span class="line" id="L2345">    <span class="tok-kw">const</span> os_mode = <span class="tok-kw">switch</span> (flags.mode) {</span>
<span class="line" id="L2346">        .read_only =&gt; <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, posix.F_OK),</span>
<span class="line" id="L2347">        .write_only =&gt; <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, posix.W_OK),</span>
<span class="line" id="L2348">        .read_write =&gt; <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, posix.R_OK | posix.W_OK),</span>
<span class="line" id="L2349">    };</span>
<span class="line" id="L2350">    <span class="tok-kw">const</span> result = posix.faccessatZ(self.fd, sub_path, os_mode, <span class="tok-number">0</span>);</span>
<span class="line" id="L2351">    <span class="tok-kw">return</span> result;</span>
<span class="line" id="L2352">}</span>
<span class="line" id="L2353"></span>
<span class="line" id="L2354"><span class="tok-comment">/// Same as `access` except asserts the target OS is Windows and the path parameter is</span></span>
<span class="line" id="L2355"><span class="tok-comment">/// * WTF-16 LE encoded</span></span>
<span class="line" id="L2356"><span class="tok-comment">/// * null-terminated</span></span>
<span class="line" id="L2357"><span class="tok-comment">/// * relative or has the NT namespace prefix</span></span>
<span class="line" id="L2358"><span class="tok-comment">/// TODO currently this ignores `flags`.</span></span>
<span class="line" id="L2359"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">accessW</span>(self: Dir, sub_path_w: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>, flags: File.OpenFlags) AccessError!<span class="tok-type">void</span> {</span>
<span class="line" id="L2360">    _ = flags;</span>
<span class="line" id="L2361">    <span class="tok-kw">return</span> posix.faccessatW(self.fd, sub_path_w, <span class="tok-number">0</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L2362">}</span>
<span class="line" id="L2363"></span>
<span class="line" id="L2364"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> CopyFileOptions = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2365">    <span class="tok-comment">/// When this is `null` the mode is copied from the source file.</span></span>
<span class="line" id="L2366">    override_mode: ?File.Mode = <span class="tok-null">null</span>,</span>
<span class="line" id="L2367">};</span>
<span class="line" id="L2368"></span>
<span class="line" id="L2369"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> PrevStatus = <span class="tok-kw">enum</span> {</span>
<span class="line" id="L2370">    stale,</span>
<span class="line" id="L2371">    fresh,</span>
<span class="line" id="L2372">};</span>
<span class="line" id="L2373"></span>
<span class="line" id="L2374"><span class="tok-comment">/// Check the file size, mtime, and mode of `source_path` and `dest_path`. If they are equal, does nothing.</span></span>
<span class="line" id="L2375"><span class="tok-comment">/// Otherwise, atomically copies `source_path` to `dest_path`. The destination file gains the mtime,</span></span>
<span class="line" id="L2376"><span class="tok-comment">/// atime, and mode of the source file so that the next call to `updateFile` will not need a copy.</span></span>
<span class="line" id="L2377"><span class="tok-comment">/// Returns the previous status of the file before updating.</span></span>
<span class="line" id="L2378"><span class="tok-comment">/// If any of the directories do not exist for dest_path, they are created.</span></span>
<span class="line" id="L2379"><span class="tok-comment">/// On Windows, both paths should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span></span>
<span class="line" id="L2380"><span class="tok-comment">/// On WASI, both paths should be encoded as valid UTF-8.</span></span>
<span class="line" id="L2381"><span class="tok-comment">/// On other platforms, both paths are an opaque sequence of bytes with no particular encoding.</span></span>
<span class="line" id="L2382"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">updateFile</span>(</span>
<span class="line" id="L2383">    source_dir: Dir,</span>
<span class="line" id="L2384">    source_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L2385">    dest_dir: Dir,</span>
<span class="line" id="L2386">    dest_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L2387">    options: CopyFileOptions,</span>
<span class="line" id="L2388">) !PrevStatus {</span>
<span class="line" id="L2389">    <span class="tok-kw">var</span> src_file = <span class="tok-kw">try</span> source_dir.openFile(source_path, .{});</span>
<span class="line" id="L2390">    <span class="tok-kw">defer</span> src_file.close();</span>
<span class="line" id="L2391"></span>
<span class="line" id="L2392">    <span class="tok-kw">const</span> src_stat = <span class="tok-kw">try</span> src_file.stat();</span>
<span class="line" id="L2393">    <span class="tok-kw">const</span> actual_mode = options.override_mode <span class="tok-kw">orelse</span> src_stat.mode;</span>
<span class="line" id="L2394">    check_dest_stat: {</span>
<span class="line" id="L2395">        <span class="tok-kw">const</span> dest_stat = blk: {</span>
<span class="line" id="L2396">            <span class="tok-kw">var</span> dest_file = dest_dir.openFile(dest_path, .{}) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L2397">                <span class="tok-kw">error</span>.FileNotFound =&gt; <span class="tok-kw">break</span> :check_dest_stat,</span>
<span class="line" id="L2398">                <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L2399">            };</span>
<span class="line" id="L2400">            <span class="tok-kw">defer</span> dest_file.close();</span>
<span class="line" id="L2401"></span>
<span class="line" id="L2402">            <span class="tok-kw">break</span> :blk <span class="tok-kw">try</span> dest_file.stat();</span>
<span class="line" id="L2403">        };</span>
<span class="line" id="L2404"></span>
<span class="line" id="L2405">        <span class="tok-kw">if</span> (src_stat.size == dest_stat.size <span class="tok-kw">and</span></span>
<span class="line" id="L2406">            src_stat.mtime == dest_stat.mtime <span class="tok-kw">and</span></span>
<span class="line" id="L2407">            actual_mode == dest_stat.mode)</span>
<span class="line" id="L2408">        {</span>
<span class="line" id="L2409">            <span class="tok-kw">return</span> PrevStatus.fresh;</span>
<span class="line" id="L2410">        }</span>
<span class="line" id="L2411">    }</span>
<span class="line" id="L2412"></span>
<span class="line" id="L2413">    <span class="tok-kw">if</span> (fs.path.dirname(dest_path)) |dirname| {</span>
<span class="line" id="L2414">        <span class="tok-kw">try</span> dest_dir.makePath(dirname);</span>
<span class="line" id="L2415">    }</span>
<span class="line" id="L2416"></span>
<span class="line" id="L2417">    <span class="tok-kw">var</span> atomic_file = <span class="tok-kw">try</span> dest_dir.atomicFile(dest_path, .{ .mode = actual_mode });</span>
<span class="line" id="L2418">    <span class="tok-kw">defer</span> atomic_file.deinit();</span>
<span class="line" id="L2419"></span>
<span class="line" id="L2420">    <span class="tok-kw">try</span> atomic_file.file.writeFileAll(src_file, .{ .in_len = src_stat.size });</span>
<span class="line" id="L2421">    <span class="tok-kw">try</span> atomic_file.file.updateTimes(src_stat.atime, src_stat.mtime);</span>
<span class="line" id="L2422">    <span class="tok-kw">try</span> atomic_file.finish();</span>
<span class="line" id="L2423">    <span class="tok-kw">return</span> PrevStatus.stale;</span>
<span class="line" id="L2424">}</span>
<span class="line" id="L2425"></span>
<span class="line" id="L2426"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> CopyFileError = File.OpenError || File.StatError ||</span>
<span class="line" id="L2427">    AtomicFile.InitError || CopyFileRawError || AtomicFile.FinishError;</span>
<span class="line" id="L2428"></span>
<span class="line" id="L2429"><span class="tok-comment">/// Guaranteed to be atomic.</span></span>
<span class="line" id="L2430"><span class="tok-comment">/// On Linux, until https://patchwork.kernel.org/patch/9636735/ is merged and readily available,</span></span>
<span class="line" id="L2431"><span class="tok-comment">/// there is a possibility of power loss or application termination leaving temporary files present</span></span>
<span class="line" id="L2432"><span class="tok-comment">/// in the same directory as dest_path.</span></span>
<span class="line" id="L2433"><span class="tok-comment">/// On Windows, both paths should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span></span>
<span class="line" id="L2434"><span class="tok-comment">/// On WASI, both paths should be encoded as valid UTF-8.</span></span>
<span class="line" id="L2435"><span class="tok-comment">/// On other platforms, both paths are an opaque sequence of bytes with no particular encoding.</span></span>
<span class="line" id="L2436"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">copyFile</span>(</span>
<span class="line" id="L2437">    source_dir: Dir,</span>
<span class="line" id="L2438">    source_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L2439">    dest_dir: Dir,</span>
<span class="line" id="L2440">    dest_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L2441">    options: CopyFileOptions,</span>
<span class="line" id="L2442">) CopyFileError!<span class="tok-type">void</span> {</span>
<span class="line" id="L2443">    <span class="tok-kw">var</span> in_file = <span class="tok-kw">try</span> source_dir.openFile(source_path, .{});</span>
<span class="line" id="L2444">    <span class="tok-kw">defer</span> in_file.close();</span>
<span class="line" id="L2445"></span>
<span class="line" id="L2446">    <span class="tok-kw">var</span> size: ?<span class="tok-type">u64</span> = <span class="tok-null">null</span>;</span>
<span class="line" id="L2447">    <span class="tok-kw">const</span> mode = options.override_mode <span class="tok-kw">orelse</span> blk: {</span>
<span class="line" id="L2448">        <span class="tok-kw">const</span> st = <span class="tok-kw">try</span> in_file.stat();</span>
<span class="line" id="L2449">        size = st.size;</span>
<span class="line" id="L2450">        <span class="tok-kw">break</span> :blk st.mode;</span>
<span class="line" id="L2451">    };</span>
<span class="line" id="L2452"></span>
<span class="line" id="L2453">    <span class="tok-kw">var</span> atomic_file = <span class="tok-kw">try</span> dest_dir.atomicFile(dest_path, .{ .mode = mode });</span>
<span class="line" id="L2454">    <span class="tok-kw">defer</span> atomic_file.deinit();</span>
<span class="line" id="L2455"></span>
<span class="line" id="L2456">    <span class="tok-kw">try</span> copy_file(in_file.handle, atomic_file.file.handle, size);</span>
<span class="line" id="L2457">    <span class="tok-kw">try</span> atomic_file.finish();</span>
<span class="line" id="L2458">}</span>
<span class="line" id="L2459"></span>
<span class="line" id="L2460"><span class="tok-kw">const</span> CopyFileRawError = <span class="tok-kw">error</span>{SystemResources} || posix.CopyFileRangeError || posix.SendFileError;</span>
<span class="line" id="L2461"></span>
<span class="line" id="L2462"><span class="tok-comment">// Transfer all the data between two file descriptors in the most efficient way.</span>
</span>
<span class="line" id="L2463"><span class="tok-comment">// The copy starts at offset 0, the initial offsets are preserved.</span>
</span>
<span class="line" id="L2464"><span class="tok-comment">// No metadata is transferred over.</span>
</span>
<span class="line" id="L2465"><span class="tok-kw">fn</span> <span class="tok-fn">copy_file</span>(fd_in: posix.fd_t, fd_out: posix.fd_t, maybe_size: ?<span class="tok-type">u64</span>) CopyFileRawError!<span class="tok-type">void</span> {</span>
<span class="line" id="L2466">    <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> builtin.target.isDarwin()) {</span>
<span class="line" id="L2467">        <span class="tok-kw">const</span> rc = posix.system.fcopyfile(fd_in, fd_out, <span class="tok-null">null</span>, posix.system.COPYFILE_DATA);</span>
<span class="line" id="L2468">        <span class="tok-kw">switch</span> (posix.errno(rc)) {</span>
<span class="line" id="L2469">            .SUCCESS =&gt; <span class="tok-kw">return</span>,</span>
<span class="line" id="L2470">            .INVAL =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L2471">            .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,</span>
<span class="line" id="L2472">            <span class="tok-comment">// The source file is not a directory, symbolic link, or regular file.</span>
</span>
<span class="line" id="L2473">            <span class="tok-comment">// Try with the fallback path before giving up.</span>
</span>
<span class="line" id="L2474">            .OPNOTSUPP =&gt; {},</span>
<span class="line" id="L2475">            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> posix.unexpectedErrno(err),</span>
<span class="line" id="L2476">        }</span>
<span class="line" id="L2477">    }</span>
<span class="line" id="L2478"></span>
<span class="line" id="L2479">    <span class="tok-kw">if</span> (builtin.os.tag == .linux) {</span>
<span class="line" id="L2480">        <span class="tok-comment">// Try copy_file_range first as that works at the FS level and is the</span>
</span>
<span class="line" id="L2481">        <span class="tok-comment">// most efficient method (if available).</span>
</span>
<span class="line" id="L2482">        <span class="tok-kw">var</span> offset: <span class="tok-type">u64</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L2483">        cfr_loop: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L2484">            <span class="tok-comment">// The kernel checks the u64 value `offset+count` for overflow, use</span>
</span>
<span class="line" id="L2485">            <span class="tok-comment">// a 32 bit value so that the syscall won't return EINVAL except for</span>
</span>
<span class="line" id="L2486">            <span class="tok-comment">// impossibly large files (&gt; 2^64-1 - 2^32-1).</span>
</span>
<span class="line" id="L2487">            <span class="tok-kw">const</span> amt = <span class="tok-kw">try</span> posix.copy_file_range(fd_in, offset, fd_out, offset, std.math.maxInt(<span class="tok-type">u32</span>), <span class="tok-number">0</span>);</span>
<span class="line" id="L2488">            <span class="tok-comment">// Terminate as soon as we have copied size bytes or no bytes</span>
</span>
<span class="line" id="L2489">            <span class="tok-kw">if</span> (maybe_size) |s| {</span>
<span class="line" id="L2490">                <span class="tok-kw">if</span> (s == amt) <span class="tok-kw">break</span> :cfr_loop;</span>
<span class="line" id="L2491">            }</span>
<span class="line" id="L2492">            <span class="tok-kw">if</span> (amt == <span class="tok-number">0</span>) <span class="tok-kw">break</span> :cfr_loop;</span>
<span class="line" id="L2493">            offset += amt;</span>
<span class="line" id="L2494">        }</span>
<span class="line" id="L2495">        <span class="tok-kw">return</span>;</span>
<span class="line" id="L2496">    }</span>
<span class="line" id="L2497"></span>
<span class="line" id="L2498">    <span class="tok-comment">// Sendfile is a zero-copy mechanism iff the OS supports it, otherwise the</span>
</span>
<span class="line" id="L2499">    <span class="tok-comment">// fallback code will copy the contents chunk by chunk.</span>
</span>
<span class="line" id="L2500">    <span class="tok-kw">const</span> empty_iovec = [<span class="tok-number">0</span>]posix.iovec_const{};</span>
<span class="line" id="L2501">    <span class="tok-kw">var</span> offset: <span class="tok-type">u64</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L2502">    sendfile_loop: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L2503">        <span class="tok-kw">const</span> amt = <span class="tok-kw">try</span> posix.sendfile(fd_out, fd_in, offset, <span class="tok-number">0</span>, &amp;empty_iovec, &amp;empty_iovec, <span class="tok-number">0</span>);</span>
<span class="line" id="L2504">        <span class="tok-comment">// Terminate as soon as we have copied size bytes or no bytes</span>
</span>
<span class="line" id="L2505">        <span class="tok-kw">if</span> (maybe_size) |s| {</span>
<span class="line" id="L2506">            <span class="tok-kw">if</span> (s == amt) <span class="tok-kw">break</span> :sendfile_loop;</span>
<span class="line" id="L2507">        }</span>
<span class="line" id="L2508">        <span class="tok-kw">if</span> (amt == <span class="tok-number">0</span>) <span class="tok-kw">break</span> :sendfile_loop;</span>
<span class="line" id="L2509">        offset += amt;</span>
<span class="line" id="L2510">    }</span>
<span class="line" id="L2511">}</span>
<span class="line" id="L2512"></span>
<span class="line" id="L2513"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> AtomicFileOptions = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2514">    mode: File.Mode = File.default_mode,</span>
<span class="line" id="L2515">    make_path: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,</span>
<span class="line" id="L2516">};</span>
<span class="line" id="L2517"></span>
<span class="line" id="L2518"><span class="tok-comment">/// Directly access the `.file` field, and then call `AtomicFile.finish` to</span></span>
<span class="line" id="L2519"><span class="tok-comment">/// atomically replace `dest_path` with contents.</span></span>
<span class="line" id="L2520"><span class="tok-comment">/// Always call `AtomicFile.deinit` to clean up, regardless of whether</span></span>
<span class="line" id="L2521"><span class="tok-comment">/// `AtomicFile.finish` succeeded. `dest_path` must remain valid until</span></span>
<span class="line" id="L2522"><span class="tok-comment">/// `AtomicFile.deinit` is called.</span></span>
<span class="line" id="L2523"><span class="tok-comment">/// On Windows, `dest_path` should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span></span>
<span class="line" id="L2524"><span class="tok-comment">/// On WASI, `dest_path` should be encoded as valid UTF-8.</span></span>
<span class="line" id="L2525"><span class="tok-comment">/// On other platforms, `dest_path` is an opaque sequence of bytes with no particular encoding.</span></span>
<span class="line" id="L2526"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">atomicFile</span>(self: Dir, dest_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, options: AtomicFileOptions) !AtomicFile {</span>
<span class="line" id="L2527">    <span class="tok-kw">if</span> (fs.path.dirname(dest_path)) |dirname| {</span>
<span class="line" id="L2528">        <span class="tok-kw">const</span> dir = <span class="tok-kw">if</span> (options.make_path)</span>
<span class="line" id="L2529">            <span class="tok-kw">try</span> self.makeOpenPath(dirname, .{})</span>
<span class="line" id="L2530">        <span class="tok-kw">else</span></span>
<span class="line" id="L2531">            <span class="tok-kw">try</span> self.openDir(dirname, .{});</span>
<span class="line" id="L2532"></span>
<span class="line" id="L2533">        <span class="tok-kw">return</span> AtomicFile.init(fs.path.basename(dest_path), options.mode, dir, <span class="tok-null">true</span>);</span>
<span class="line" id="L2534">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2535">        <span class="tok-kw">return</span> AtomicFile.init(dest_path, options.mode, self, <span class="tok-null">false</span>);</span>
<span class="line" id="L2536">    }</span>
<span class="line" id="L2537">}</span>
<span class="line" id="L2538"></span>
<span class="line" id="L2539"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Stat = File.Stat;</span>
<span class="line" id="L2540"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> StatError = File.StatError;</span>
<span class="line" id="L2541"></span>
<span class="line" id="L2542"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">stat</span>(self: Dir) StatError!Stat {</span>
<span class="line" id="L2543">    <span class="tok-kw">const</span> file: File = .{ .handle = self.fd };</span>
<span class="line" id="L2544">    <span class="tok-kw">return</span> file.stat();</span>
<span class="line" id="L2545">}</span>
<span class="line" id="L2546"></span>
<span class="line" id="L2547"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> StatFileError = File.OpenError || File.StatError || posix.FStatAtError;</span>
<span class="line" id="L2548"></span>
<span class="line" id="L2549"><span class="tok-comment">/// Returns metadata for a file inside the directory.</span></span>
<span class="line" id="L2550"><span class="tok-comment">///</span></span>
<span class="line" id="L2551"><span class="tok-comment">/// On Windows, this requires three syscalls. On other operating systems, it</span></span>
<span class="line" id="L2552"><span class="tok-comment">/// only takes one.</span></span>
<span class="line" id="L2553"><span class="tok-comment">///</span></span>
<span class="line" id="L2554"><span class="tok-comment">/// Symlinks are followed.</span></span>
<span class="line" id="L2555"><span class="tok-comment">///</span></span>
<span class="line" id="L2556"><span class="tok-comment">/// `sub_path` may be absolute, in which case `self` is ignored.</span></span>
<span class="line" id="L2557"><span class="tok-comment">/// On Windows, `sub_path` should be encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span></span>
<span class="line" id="L2558"><span class="tok-comment">/// On WASI, `sub_path` should be encoded as valid UTF-8.</span></span>
<span class="line" id="L2559"><span class="tok-comment">/// On other platforms, `sub_path` is an opaque sequence of bytes with no particular encoding.</span></span>
<span class="line" id="L2560"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">statFile</span>(self: Dir, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) StatFileError!Stat {</span>
<span class="line" id="L2561">    <span class="tok-kw">if</span> (builtin.os.tag == .windows) {</span>
<span class="line" id="L2562">        <span class="tok-kw">var</span> file = <span class="tok-kw">try</span> self.openFile(sub_path, .{});</span>
<span class="line" id="L2563">        <span class="tok-kw">defer</span> file.close();</span>
<span class="line" id="L2564">        <span class="tok-kw">return</span> file.stat();</span>
<span class="line" id="L2565">    }</span>
<span class="line" id="L2566">    <span class="tok-kw">if</span> (builtin.os.tag == .wasi <span class="tok-kw">and</span> !builtin.link_libc) {</span>
<span class="line" id="L2567">        <span class="tok-kw">const</span> st = <span class="tok-kw">try</span> posix.fstatat_wasi(self.fd, sub_path, .{ .SYMLINK_FOLLOW = <span class="tok-null">true</span> });</span>
<span class="line" id="L2568">        <span class="tok-kw">return</span> Stat.fromWasi(st);</span>
<span class="line" id="L2569">    }</span>
<span class="line" id="L2570">    <span class="tok-kw">const</span> st = <span class="tok-kw">try</span> posix.fstatat(self.fd, sub_path, <span class="tok-number">0</span>);</span>
<span class="line" id="L2571">    <span class="tok-kw">return</span> Stat.fromSystem(st);</span>
<span class="line" id="L2572">}</span>
<span class="line" id="L2573"></span>
<span class="line" id="L2574"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ChmodError = File.ChmodError;</span>
<span class="line" id="L2575"></span>
<span class="line" id="L2576"><span class="tok-comment">/// Changes the mode of the directory.</span></span>
<span class="line" id="L2577"><span class="tok-comment">/// The process must have the correct privileges in order to do this</span></span>
<span class="line" id="L2578"><span class="tok-comment">/// successfully, or must have the effective user ID matching the owner</span></span>
<span class="line" id="L2579"><span class="tok-comment">/// of the directory. Additionally, the directory must have been opened</span></span>
<span class="line" id="L2580"><span class="tok-comment">/// with `OpenDirOptions{ .iterate = true }`.</span></span>
<span class="line" id="L2581"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">chmod</span>(self: Dir, new_mode: File.Mode) ChmodError!<span class="tok-type">void</span> {</span>
<span class="line" id="L2582">    <span class="tok-kw">const</span> file: File = .{ .handle = self.fd };</span>
<span class="line" id="L2583">    <span class="tok-kw">try</span> file.chmod(new_mode);</span>
<span class="line" id="L2584">}</span>
<span class="line" id="L2585"></span>
<span class="line" id="L2586"><span class="tok-comment">/// Changes the owner and group of the directory.</span></span>
<span class="line" id="L2587"><span class="tok-comment">/// The process must have the correct privileges in order to do this</span></span>
<span class="line" id="L2588"><span class="tok-comment">/// successfully. The group may be changed by the owner of the directory to</span></span>
<span class="line" id="L2589"><span class="tok-comment">/// any group of which the owner is a member. Additionally, the directory</span></span>
<span class="line" id="L2590"><span class="tok-comment">/// must have been opened with `OpenDirOptions{ .iterate = true }`. If the</span></span>
<span class="line" id="L2591"><span class="tok-comment">/// owner or group is specified as `null`, the ID is not changed.</span></span>
<span class="line" id="L2592"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">chown</span>(self: Dir, owner: ?File.Uid, group: ?File.Gid) ChownError!<span class="tok-type">void</span> {</span>
<span class="line" id="L2593">    <span class="tok-kw">const</span> file: File = .{ .handle = self.fd };</span>
<span class="line" id="L2594">    <span class="tok-kw">try</span> file.chown(owner, group);</span>
<span class="line" id="L2595">}</span>
<span class="line" id="L2596"></span>
<span class="line" id="L2597"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ChownError = File.ChownError;</span>
<span class="line" id="L2598"></span>
<span class="line" id="L2599"><span class="tok-kw">const</span> Permissions = File.Permissions;</span>
<span class="line" id="L2600"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> SetPermissionsError = File.SetPermissionsError;</span>
<span class="line" id="L2601"></span>
<span class="line" id="L2602"><span class="tok-comment">/// Sets permissions according to the provided `Permissions` struct.</span></span>
<span class="line" id="L2603"><span class="tok-comment">/// This method is *NOT* available on WASI</span></span>
<span class="line" id="L2604"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setPermissions</span>(self: Dir, permissions: Permissions) SetPermissionsError!<span class="tok-type">void</span> {</span>
<span class="line" id="L2605">    <span class="tok-kw">const</span> file: File = .{ .handle = self.fd };</span>
<span class="line" id="L2606">    <span class="tok-kw">try</span> file.setPermissions(permissions);</span>
<span class="line" id="L2607">}</span>
<span class="line" id="L2608"></span>
<span class="line" id="L2609"><span class="tok-kw">const</span> Metadata = File.Metadata;</span>
<span class="line" id="L2610"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> MetadataError = File.MetadataError;</span>
<span class="line" id="L2611"></span>
<span class="line" id="L2612"><span class="tok-comment">/// Returns a `Metadata` struct, representing the permissions on the directory</span></span>
<span class="line" id="L2613"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">metadata</span>(self: Dir) MetadataError!Metadata {</span>
<span class="line" id="L2614">    <span class="tok-kw">const</span> file: File = .{ .handle = self.fd };</span>
<span class="line" id="L2615">    <span class="tok-kw">return</span> <span class="tok-kw">try</span> file.metadata();</span>
<span class="line" id="L2616">}</span>
<span class="line" id="L2617"></span>
<span class="line" id="L2618"><span class="tok-kw">const</span> Dir = <span class="tok-builtin">@This</span>();</span>
<span class="line" id="L2619"><span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);</span>
<span class="line" id="L2620"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;../std.zig&quot;</span>);</span>
<span class="line" id="L2621"><span class="tok-kw">const</span> File = std.fs.File;</span>
<span class="line" id="L2622"><span class="tok-kw">const</span> AtomicFile = std.fs.AtomicFile;</span>
<span class="line" id="L2623"><span class="tok-comment">// https://github.com/ziglang/zig/issues/5019</span>
</span>
<span class="line" id="L2624"><span class="tok-kw">const</span> posix = std.os;</span>
<span class="line" id="L2625"><span class="tok-kw">const</span> mem = std.mem;</span>
<span class="line" id="L2626"><span class="tok-kw">const</span> fs = std.fs;</span>
<span class="line" id="L2627"><span class="tok-kw">const</span> Allocator = std.mem.Allocator;</span>
<span class="line" id="L2628"><span class="tok-kw">const</span> assert = std.debug.assert;</span>
<span class="line" id="L2629"></span>
</code></pre></body>
</html>