<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>Build.zig - source view</title>
    <link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAgklEQVR4AWMYWuD7EllJIM4G4g4g5oIJ/odhOJ8wToOxSTXgNxDHoeiBMfA4+wGShjyYOCkG/IGqWQziEzYAoUAeiF9D5U+DxEg14DRU7jWIT5IBIOdCxf+A+CQZAAoopEB7QJwBCBwHiip8UYmRdrAlDpIMgApwQZNnNii5Dq0MBgCxxycBnwEd+wAAAABJRU5ErkJggg==">
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style>
      body{
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        margin: 0;
        line-height: 1.5;
      }

      pre > code {
        display: block;
        overflow: auto;
        line-height: normal;
        margin: 0em;
      }
      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #005C7A;
      }
      .tok-comment {
          color: #545454;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #005C5C;
      }
      .tok-number {
          color: #005C5C;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }
      pre {
        counter-reset: line;
      }
      pre .line:before {
        counter-increment: line;
        content: counter(line);
        display: inline-block;
        padding-right: 1em;
        width: 2em;
        text-align: right;
        color: #999;
      }
      
      .line {
        width: 100%;
        display: inline-block;
      }
      .line:target {
        border-top: 1px solid #ccc;
        border-bottom: 1px solid #ccc;
        background: #fafafa;
      }

      @media (prefers-color-scheme: dark) {
        body{
            background:#222;
            color: #ccc;
        }
        pre > code {
            color: #ccc;
            background: #222;
            border: unset;
        }
        .line:target {
            border-top: 1px solid #444;
            border-bottom: 1px solid #444;
            background: #333;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
</head>
<body>
<pre><code><span class="line" id="L1"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std.zig&quot;</span>);</span>
<span class="line" id="L2"><span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);</span>
<span class="line" id="L3"><span class="tok-kw">const</span> io = std.io;</span>
<span class="line" id="L4"><span class="tok-kw">const</span> fs = std.fs;</span>
<span class="line" id="L5"><span class="tok-kw">const</span> mem = std.mem;</span>
<span class="line" id="L6"><span class="tok-kw">const</span> debug = std.debug;</span>
<span class="line" id="L7"><span class="tok-kw">const</span> panic = std.debug.panic;</span>
<span class="line" id="L8"><span class="tok-kw">const</span> assert = debug.assert;</span>
<span class="line" id="L9"><span class="tok-kw">const</span> log = std.log;</span>
<span class="line" id="L10"><span class="tok-kw">const</span> ArrayList = std.ArrayList;</span>
<span class="line" id="L11"><span class="tok-kw">const</span> StringHashMap = std.StringHashMap;</span>
<span class="line" id="L12"><span class="tok-kw">const</span> Allocator = mem.Allocator;</span>
<span class="line" id="L13"><span class="tok-kw">const</span> Target = std.Target;</span>
<span class="line" id="L14"><span class="tok-kw">const</span> process = std.process;</span>
<span class="line" id="L15"><span class="tok-kw">const</span> EnvMap = std.process.EnvMap;</span>
<span class="line" id="L16"><span class="tok-kw">const</span> fmt_lib = std.fmt;</span>
<span class="line" id="L17"><span class="tok-kw">const</span> File = std.fs.File;</span>
<span class="line" id="L18"><span class="tok-kw">const</span> Sha256 = std.crypto.hash.sha2.Sha256;</span>
<span class="line" id="L19"><span class="tok-kw">const</span> Build = <span class="tok-builtin">@This</span>();</span>
<span class="line" id="L20"></span>
<span class="line" id="L21"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Cache = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;Build/Cache.zig&quot;</span>);</span>
<span class="line" id="L22"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Step = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;Build/Step.zig&quot;</span>);</span>
<span class="line" id="L23"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Module = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;Build/Module.zig&quot;</span>);</span>
<span class="line" id="L24"></span>
<span class="line" id="L25"><span class="tok-comment">/// Shared state among all Build instances.</span></span>
<span class="line" id="L26">graph: *Graph,</span>
<span class="line" id="L27">install_tls: TopLevelStep,</span>
<span class="line" id="L28">uninstall_tls: TopLevelStep,</span>
<span class="line" id="L29">allocator: Allocator,</span>
<span class="line" id="L30">user_input_options: UserInputOptionsMap,</span>
<span class="line" id="L31">available_options_map: AvailableOptionsMap,</span>
<span class="line" id="L32">available_options_list: ArrayList(AvailableOption),</span>
<span class="line" id="L33">verbose: <span class="tok-type">bool</span>,</span>
<span class="line" id="L34">verbose_link: <span class="tok-type">bool</span>,</span>
<span class="line" id="L35">verbose_cc: <span class="tok-type">bool</span>,</span>
<span class="line" id="L36">verbose_air: <span class="tok-type">bool</span>,</span>
<span class="line" id="L37">verbose_llvm_ir: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L38">verbose_llvm_bc: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L39">verbose_cimport: <span class="tok-type">bool</span>,</span>
<span class="line" id="L40">verbose_llvm_cpu_features: <span class="tok-type">bool</span>,</span>
<span class="line" id="L41">reference_trace: ?<span class="tok-type">u32</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L42">invalid_user_input: <span class="tok-type">bool</span>,</span>
<span class="line" id="L43">default_step: *Step,</span>
<span class="line" id="L44">top_level_steps: std.StringArrayHashMapUnmanaged(*TopLevelStep),</span>
<span class="line" id="L45">install_prefix: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L46">dest_dir: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L47">lib_dir: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L48">exe_dir: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L49">h_dir: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L50">install_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L51">sysroot: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L52">search_prefixes: std.ArrayListUnmanaged([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>),</span>
<span class="line" id="L53">libc_file: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L54">installed_files: ArrayList(InstalledFile),</span>
<span class="line" id="L55"><span class="tok-comment">/// Path to the directory containing build.zig.</span></span>
<span class="line" id="L56">build_root: Cache.Directory,</span>
<span class="line" id="L57">cache_root: Cache.Directory,</span>
<span class="line" id="L58">zig_lib_dir: ?LazyPath,</span>
<span class="line" id="L59">pkg_config_pkg_list: ?(PkgConfigError![]<span class="tok-kw">const</span> PkgConfigPkg) = <span class="tok-null">null</span>,</span>
<span class="line" id="L60">args: ?[][]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L61">debug_log_scopes: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = &amp;.{},</span>
<span class="line" id="L62">debug_compile_errors: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,</span>
<span class="line" id="L63">debug_pkg_config: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,</span>
<span class="line" id="L64"><span class="tok-comment">/// Number of stack frames captured when a `StackTrace` is recorded for debug purposes,</span></span>
<span class="line" id="L65"><span class="tok-comment">/// in particular at `Step` creation.</span></span>
<span class="line" id="L66"><span class="tok-comment">/// Set to 0 to disable stack collection.</span></span>
<span class="line" id="L67">debug_stack_frames_count: <span class="tok-type">u8</span> = <span class="tok-number">8</span>,</span>
<span class="line" id="L68"></span>
<span class="line" id="L69"><span class="tok-comment">/// Experimental. Use system Darling installation to run cross compiled macOS build artifacts.</span></span>
<span class="line" id="L70">enable_darling: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,</span>
<span class="line" id="L71"><span class="tok-comment">/// Use system QEMU installation to run cross compiled foreign architecture build artifacts.</span></span>
<span class="line" id="L72">enable_qemu: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,</span>
<span class="line" id="L73"><span class="tok-comment">/// Darwin. Use Rosetta to run x86_64 macOS build artifacts on arm64 macOS.</span></span>
<span class="line" id="L74">enable_rosetta: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,</span>
<span class="line" id="L75"><span class="tok-comment">/// Use system Wasmtime installation to run cross compiled wasm/wasi build artifacts.</span></span>
<span class="line" id="L76">enable_wasmtime: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,</span>
<span class="line" id="L77"><span class="tok-comment">/// Use system Wine installation to run cross compiled Windows build artifacts.</span></span>
<span class="line" id="L78">enable_wine: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,</span>
<span class="line" id="L79"><span class="tok-comment">/// After following the steps in https://github.com/ziglang/zig/wiki/Updating-libc#glibc,</span></span>
<span class="line" id="L80"><span class="tok-comment">/// this will be the directory $glibc-build-dir/install/glibcs</span></span>
<span class="line" id="L81"><span class="tok-comment">/// Given the example of the aarch64 target, this is the directory</span></span>
<span class="line" id="L82"><span class="tok-comment">/// that contains the path `aarch64-linux-gnu/lib/ld-linux-aarch64.so.1`.</span></span>
<span class="line" id="L83">glibc_runtimes_dir: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L84"></span>
<span class="line" id="L85"><span class="tok-comment">/// Information about the native target. Computed before build() is invoked.</span></span>
<span class="line" id="L86">host: ResolvedTarget,</span>
<span class="line" id="L87"></span>
<span class="line" id="L88">dep_prefix: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">&quot;&quot;</span>,</span>
<span class="line" id="L89"></span>
<span class="line" id="L90">modules: std.StringArrayHashMap(*Module),</span>
<span class="line" id="L91"></span>
<span class="line" id="L92">named_writefiles: std.StringArrayHashMap(*Step.WriteFile),</span>
<span class="line" id="L93"><span class="tok-comment">/// A map from build root dirs to the corresponding `*Dependency`. This is shared with all child</span></span>
<span class="line" id="L94"><span class="tok-comment">/// `Build`s.</span></span>
<span class="line" id="L95">initialized_deps: *InitializedDepMap,</span>
<span class="line" id="L96"><span class="tok-comment">/// A mapping from dependency names to package hashes.</span></span>
<span class="line" id="L97">available_deps: AvailableDeps,</span>
<span class="line" id="L98"></span>
<span class="line" id="L99">release_mode: ReleaseMode,</span>
<span class="line" id="L100"></span>
<span class="line" id="L101"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ReleaseMode = <span class="tok-kw">enum</span> {</span>
<span class="line" id="L102">    off,</span>
<span class="line" id="L103">    any,</span>
<span class="line" id="L104">    fast,</span>
<span class="line" id="L105">    safe,</span>
<span class="line" id="L106">    small,</span>
<span class="line" id="L107">};</span>
<span class="line" id="L108"></span>
<span class="line" id="L109"><span class="tok-comment">/// Shared state among all Build instances.</span></span>
<span class="line" id="L110"><span class="tok-comment">/// Settings that are here rather than in Build are not configurable per-package.</span></span>
<span class="line" id="L111"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Graph = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L112">    arena: Allocator,</span>
<span class="line" id="L113">    system_library_options: std.StringArrayHashMapUnmanaged(SystemLibraryMode) = .{},</span>
<span class="line" id="L114">    system_package_mode: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,</span>
<span class="line" id="L115">    cache: Cache,</span>
<span class="line" id="L116">    zig_exe: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L117">    env_map: EnvMap,</span>
<span class="line" id="L118">    global_cache_root: Cache.Directory,</span>
<span class="line" id="L119">    host_query_options: std.Target.Query.ParseOptions = .{},</span>
<span class="line" id="L120">    needed_lazy_dependencies: std.StringArrayHashMapUnmanaged(<span class="tok-type">void</span>) = .{},</span>
<span class="line" id="L121">};</span>
<span class="line" id="L122"></span>
<span class="line" id="L123"><span class="tok-kw">const</span> AvailableDeps = []<span class="tok-kw">const</span> <span class="tok-kw">struct</span> { []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, []<span class="tok-kw">const</span> <span class="tok-type">u8</span> };</span>
<span class="line" id="L124"></span>
<span class="line" id="L125"><span class="tok-kw">const</span> SystemLibraryMode = <span class="tok-kw">enum</span> {</span>
<span class="line" id="L126">    <span class="tok-comment">/// User asked for the library to be disabled.</span></span>
<span class="line" id="L127">    <span class="tok-comment">/// The build runner has not confirmed whether the setting is recognized yet.</span></span>
<span class="line" id="L128">    user_disabled,</span>
<span class="line" id="L129">    <span class="tok-comment">/// User asked for the library to be enabled.</span></span>
<span class="line" id="L130">    <span class="tok-comment">/// The build runner has not confirmed whether the setting is recognized yet.</span></span>
<span class="line" id="L131">    user_enabled,</span>
<span class="line" id="L132">    <span class="tok-comment">/// The build runner has confirmed that this setting is recognized.</span></span>
<span class="line" id="L133">    <span class="tok-comment">/// System integration with this library has been resolved to off.</span></span>
<span class="line" id="L134">    declared_disabled,</span>
<span class="line" id="L135">    <span class="tok-comment">/// The build runner has confirmed that this setting is recognized.</span></span>
<span class="line" id="L136">    <span class="tok-comment">/// System integration with this library has been resolved to on.</span></span>
<span class="line" id="L137">    declared_enabled,</span>
<span class="line" id="L138">};</span>
<span class="line" id="L139"></span>
<span class="line" id="L140"><span class="tok-kw">const</span> InitializedDepMap = std.HashMap(InitializedDepKey, *Dependency, InitializedDepContext, std.hash_map.default_max_load_percentage);</span>
<span class="line" id="L141"><span class="tok-kw">const</span> InitializedDepKey = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L142">    build_root_string: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L143">    user_input_options: UserInputOptionsMap,</span>
<span class="line" id="L144">};</span>
<span class="line" id="L145"></span>
<span class="line" id="L146"><span class="tok-kw">const</span> InitializedDepContext = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L147">    allocator: Allocator,</span>
<span class="line" id="L148"></span>
<span class="line" id="L149">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(self: <span class="tok-builtin">@This</span>(), k: InitializedDepKey) <span class="tok-type">u64</span> {</span>
<span class="line" id="L150">        <span class="tok-kw">var</span> hasher = std.hash.Wyhash.init(<span class="tok-number">0</span>);</span>
<span class="line" id="L151">        hasher.update(k.build_root_string);</span>
<span class="line" id="L152">        hashUserInputOptionsMap(self.allocator, k.user_input_options, &amp;hasher);</span>
<span class="line" id="L153">        <span class="tok-kw">return</span> hasher.final();</span>
<span class="line" id="L154">    }</span>
<span class="line" id="L155"></span>
<span class="line" id="L156">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(self: <span class="tok-builtin">@This</span>(), lhs: InitializedDepKey, rhs: InitializedDepKey) <span class="tok-type">bool</span> {</span>
<span class="line" id="L157">        _ = self;</span>
<span class="line" id="L158">        <span class="tok-kw">if</span> (!std.mem.eql(<span class="tok-type">u8</span>, lhs.build_root_string, rhs.build_root_string))</span>
<span class="line" id="L159">            <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L160"></span>
<span class="line" id="L161">        <span class="tok-kw">if</span> (lhs.user_input_options.count() != rhs.user_input_options.count())</span>
<span class="line" id="L162">            <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L163"></span>
<span class="line" id="L164">        <span class="tok-kw">var</span> it = lhs.user_input_options.iterator();</span>
<span class="line" id="L165">        <span class="tok-kw">while</span> (it.next()) |lhs_entry| {</span>
<span class="line" id="L166">            <span class="tok-kw">const</span> rhs_value = rhs.user_input_options.get(lhs_entry.key_ptr.*) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L167">            <span class="tok-kw">if</span> (!userValuesAreSame(lhs_entry.value_ptr.*.value, rhs_value.value))</span>
<span class="line" id="L168">                <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L169">        }</span>
<span class="line" id="L170"></span>
<span class="line" id="L171">        <span class="tok-kw">return</span> <span class="tok-null">true</span>;</span>
<span class="line" id="L172">    }</span>
<span class="line" id="L173">};</span>
<span class="line" id="L174"></span>
<span class="line" id="L175"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> RunError = <span class="tok-kw">error</span>{</span>
<span class="line" id="L176">    ReadFailure,</span>
<span class="line" id="L177">    ExitCodeFailure,</span>
<span class="line" id="L178">    ProcessTerminated,</span>
<span class="line" id="L179">    ExecNotSupported,</span>
<span class="line" id="L180">} || std.ChildProcess.SpawnError;</span>
<span class="line" id="L181"></span>
<span class="line" id="L182"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> PkgConfigError = <span class="tok-kw">error</span>{</span>
<span class="line" id="L183">    PkgConfigCrashed,</span>
<span class="line" id="L184">    PkgConfigFailed,</span>
<span class="line" id="L185">    PkgConfigNotInstalled,</span>
<span class="line" id="L186">    PkgConfigInvalidOutput,</span>
<span class="line" id="L187">};</span>
<span class="line" id="L188"></span>
<span class="line" id="L189"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> PkgConfigPkg = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L190">    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L191">    desc: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L192">};</span>
<span class="line" id="L193"></span>
<span class="line" id="L194"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> CStd = <span class="tok-kw">enum</span> {</span>
<span class="line" id="L195">    C89,</span>
<span class="line" id="L196">    C99,</span>
<span class="line" id="L197">    C11,</span>
<span class="line" id="L198">};</span>
<span class="line" id="L199"></span>
<span class="line" id="L200"><span class="tok-kw">const</span> UserInputOptionsMap = StringHashMap(UserInputOption);</span>
<span class="line" id="L201"><span class="tok-kw">const</span> AvailableOptionsMap = StringHashMap(AvailableOption);</span>
<span class="line" id="L202"></span>
<span class="line" id="L203"><span class="tok-kw">const</span> AvailableOption = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L204">    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L205">    type_id: TypeId,</span>
<span class="line" id="L206">    description: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L207">    <span class="tok-comment">/// If the `type_id` is `enum` this provides the list of enum options</span></span>
<span class="line" id="L208">    enum_options: ?[]<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L209">};</span>
<span class="line" id="L210"></span>
<span class="line" id="L211"><span class="tok-kw">const</span> UserInputOption = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L212">    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L213">    value: UserValue,</span>
<span class="line" id="L214">    used: <span class="tok-type">bool</span>,</span>
<span class="line" id="L215">};</span>
<span class="line" id="L216"></span>
<span class="line" id="L217"><span class="tok-kw">const</span> UserValue = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {</span>
<span class="line" id="L218">    flag: <span class="tok-type">void</span>,</span>
<span class="line" id="L219">    scalar: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L220">    list: ArrayList([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>),</span>
<span class="line" id="L221">    map: StringHashMap(*<span class="tok-kw">const</span> UserValue),</span>
<span class="line" id="L222">};</span>
<span class="line" id="L223"></span>
<span class="line" id="L224"><span class="tok-kw">const</span> TypeId = <span class="tok-kw">enum</span> {</span>
<span class="line" id="L225">    <span class="tok-type">bool</span>,</span>
<span class="line" id="L226">    int,</span>
<span class="line" id="L227">    float,</span>
<span class="line" id="L228">    @&quot;enum&quot;,</span>
<span class="line" id="L229">    string,</span>
<span class="line" id="L230">    list,</span>
<span class="line" id="L231">    build_id,</span>
<span class="line" id="L232">};</span>
<span class="line" id="L233"></span>
<span class="line" id="L234"><span class="tok-kw">const</span> TopLevelStep = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L235">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> base_id = .top_level;</span>
<span class="line" id="L236"></span>
<span class="line" id="L237">    step: Step,</span>
<span class="line" id="L238">    description: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L239">};</span>
<span class="line" id="L240"></span>
<span class="line" id="L241"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> DirList = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L242">    lib_dir: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L243">    exe_dir: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L244">    include_dir: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L245">};</span>
<span class="line" id="L246"></span>
<span class="line" id="L247"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">create</span>(</span>
<span class="line" id="L248">    graph: *Graph,</span>
<span class="line" id="L249">    build_root: Cache.Directory,</span>
<span class="line" id="L250">    cache_root: Cache.Directory,</span>
<span class="line" id="L251">    available_deps: AvailableDeps,</span>
<span class="line" id="L252">) !*Build {</span>
<span class="line" id="L253">    <span class="tok-kw">const</span> arena = graph.arena;</span>
<span class="line" id="L254">    <span class="tok-kw">const</span> initialized_deps = <span class="tok-kw">try</span> arena.create(InitializedDepMap);</span>
<span class="line" id="L255">    initialized_deps.* = InitializedDepMap.initContext(arena, .{ .allocator = arena });</span>
<span class="line" id="L256"></span>
<span class="line" id="L257">    <span class="tok-kw">const</span> self = <span class="tok-kw">try</span> arena.create(Build);</span>
<span class="line" id="L258">    self.* = .{</span>
<span class="line" id="L259">        .graph = graph,</span>
<span class="line" id="L260">        .build_root = build_root,</span>
<span class="line" id="L261">        .cache_root = cache_root,</span>
<span class="line" id="L262">        .verbose = <span class="tok-null">false</span>,</span>
<span class="line" id="L263">        .verbose_link = <span class="tok-null">false</span>,</span>
<span class="line" id="L264">        .verbose_cc = <span class="tok-null">false</span>,</span>
<span class="line" id="L265">        .verbose_air = <span class="tok-null">false</span>,</span>
<span class="line" id="L266">        .verbose_llvm_ir = <span class="tok-null">null</span>,</span>
<span class="line" id="L267">        .verbose_llvm_bc = <span class="tok-null">null</span>,</span>
<span class="line" id="L268">        .verbose_cimport = <span class="tok-null">false</span>,</span>
<span class="line" id="L269">        .verbose_llvm_cpu_features = <span class="tok-null">false</span>,</span>
<span class="line" id="L270">        .invalid_user_input = <span class="tok-null">false</span>,</span>
<span class="line" id="L271">        .allocator = arena,</span>
<span class="line" id="L272">        .user_input_options = UserInputOptionsMap.init(arena),</span>
<span class="line" id="L273">        .available_options_map = AvailableOptionsMap.init(arena),</span>
<span class="line" id="L274">        .available_options_list = ArrayList(AvailableOption).init(arena),</span>
<span class="line" id="L275">        .top_level_steps = .{},</span>
<span class="line" id="L276">        .default_step = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L277">        .search_prefixes = .{},</span>
<span class="line" id="L278">        .install_prefix = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L279">        .lib_dir = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L280">        .exe_dir = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L281">        .h_dir = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L282">        .dest_dir = graph.env_map.get(<span class="tok-str">&quot;DESTDIR&quot;</span>),</span>
<span class="line" id="L283">        .installed_files = ArrayList(InstalledFile).init(arena),</span>
<span class="line" id="L284">        .install_tls = .{</span>
<span class="line" id="L285">            .step = Step.init(.{</span>
<span class="line" id="L286">                .id = .top_level,</span>
<span class="line" id="L287">                .name = <span class="tok-str">&quot;install&quot;</span>,</span>
<span class="line" id="L288">                .owner = self,</span>
<span class="line" id="L289">            }),</span>
<span class="line" id="L290">            .description = <span class="tok-str">&quot;Copy build artifacts to prefix path&quot;</span>,</span>
<span class="line" id="L291">        },</span>
<span class="line" id="L292">        .uninstall_tls = .{</span>
<span class="line" id="L293">            .step = Step.init(.{</span>
<span class="line" id="L294">                .id = .top_level,</span>
<span class="line" id="L295">                .name = <span class="tok-str">&quot;uninstall&quot;</span>,</span>
<span class="line" id="L296">                .owner = self,</span>
<span class="line" id="L297">                .makeFn = makeUninstall,</span>
<span class="line" id="L298">            }),</span>
<span class="line" id="L299">            .description = <span class="tok-str">&quot;Remove build artifacts from prefix path&quot;</span>,</span>
<span class="line" id="L300">        },</span>
<span class="line" id="L301">        .zig_lib_dir = <span class="tok-null">null</span>,</span>
<span class="line" id="L302">        .install_path = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L303">        .args = <span class="tok-null">null</span>,</span>
<span class="line" id="L304">        .host = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L305">        .modules = std.StringArrayHashMap(*Module).init(arena),</span>
<span class="line" id="L306">        .named_writefiles = std.StringArrayHashMap(*Step.WriteFile).init(arena),</span>
<span class="line" id="L307">        .initialized_deps = initialized_deps,</span>
<span class="line" id="L308">        .available_deps = available_deps,</span>
<span class="line" id="L309">        .release_mode = .off,</span>
<span class="line" id="L310">    };</span>
<span class="line" id="L311">    <span class="tok-kw">try</span> self.top_level_steps.put(arena, self.install_tls.step.name, &amp;self.install_tls);</span>
<span class="line" id="L312">    <span class="tok-kw">try</span> self.top_level_steps.put(arena, self.uninstall_tls.step.name, &amp;self.uninstall_tls);</span>
<span class="line" id="L313">    self.default_step = &amp;self.install_tls.step;</span>
<span class="line" id="L314">    <span class="tok-kw">return</span> self;</span>
<span class="line" id="L315">}</span>
<span class="line" id="L316"></span>
<span class="line" id="L317"><span class="tok-kw">fn</span> <span class="tok-fn">createChild</span>(</span>
<span class="line" id="L318">    parent: *Build,</span>
<span class="line" id="L319">    dep_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L320">    build_root: Cache.Directory,</span>
<span class="line" id="L321">    pkg_deps: AvailableDeps,</span>
<span class="line" id="L322">    user_input_options: UserInputOptionsMap,</span>
<span class="line" id="L323">) !*Build {</span>
<span class="line" id="L324">    <span class="tok-kw">const</span> child = <span class="tok-kw">try</span> createChildOnly(parent, dep_name, build_root, pkg_deps, user_input_options);</span>
<span class="line" id="L325">    <span class="tok-kw">try</span> determineAndApplyInstallPrefix(child);</span>
<span class="line" id="L326">    <span class="tok-kw">return</span> child;</span>
<span class="line" id="L327">}</span>
<span class="line" id="L328"></span>
<span class="line" id="L329"><span class="tok-kw">fn</span> <span class="tok-fn">createChildOnly</span>(</span>
<span class="line" id="L330">    parent: *Build,</span>
<span class="line" id="L331">    dep_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L332">    build_root: Cache.Directory,</span>
<span class="line" id="L333">    pkg_deps: AvailableDeps,</span>
<span class="line" id="L334">    user_input_options: UserInputOptionsMap,</span>
<span class="line" id="L335">) !*Build {</span>
<span class="line" id="L336">    <span class="tok-kw">const</span> allocator = parent.allocator;</span>
<span class="line" id="L337">    <span class="tok-kw">const</span> child = <span class="tok-kw">try</span> allocator.create(Build);</span>
<span class="line" id="L338">    child.* = .{</span>
<span class="line" id="L339">        .graph = parent.graph,</span>
<span class="line" id="L340">        .allocator = allocator,</span>
<span class="line" id="L341">        .install_tls = .{</span>
<span class="line" id="L342">            .step = Step.init(.{</span>
<span class="line" id="L343">                .id = .top_level,</span>
<span class="line" id="L344">                .name = <span class="tok-str">&quot;install&quot;</span>,</span>
<span class="line" id="L345">                .owner = child,</span>
<span class="line" id="L346">            }),</span>
<span class="line" id="L347">            .description = <span class="tok-str">&quot;Copy build artifacts to prefix path&quot;</span>,</span>
<span class="line" id="L348">        },</span>
<span class="line" id="L349">        .uninstall_tls = .{</span>
<span class="line" id="L350">            .step = Step.init(.{</span>
<span class="line" id="L351">                .id = .top_level,</span>
<span class="line" id="L352">                .name = <span class="tok-str">&quot;uninstall&quot;</span>,</span>
<span class="line" id="L353">                .owner = child,</span>
<span class="line" id="L354">                .makeFn = makeUninstall,</span>
<span class="line" id="L355">            }),</span>
<span class="line" id="L356">            .description = <span class="tok-str">&quot;Remove build artifacts from prefix path&quot;</span>,</span>
<span class="line" id="L357">        },</span>
<span class="line" id="L358">        .user_input_options = user_input_options,</span>
<span class="line" id="L359">        .available_options_map = AvailableOptionsMap.init(allocator),</span>
<span class="line" id="L360">        .available_options_list = ArrayList(AvailableOption).init(allocator),</span>
<span class="line" id="L361">        .verbose = parent.verbose,</span>
<span class="line" id="L362">        .verbose_link = parent.verbose_link,</span>
<span class="line" id="L363">        .verbose_cc = parent.verbose_cc,</span>
<span class="line" id="L364">        .verbose_air = parent.verbose_air,</span>
<span class="line" id="L365">        .verbose_llvm_ir = parent.verbose_llvm_ir,</span>
<span class="line" id="L366">        .verbose_llvm_bc = parent.verbose_llvm_bc,</span>
<span class="line" id="L367">        .verbose_cimport = parent.verbose_cimport,</span>
<span class="line" id="L368">        .verbose_llvm_cpu_features = parent.verbose_llvm_cpu_features,</span>
<span class="line" id="L369">        .reference_trace = parent.reference_trace,</span>
<span class="line" id="L370">        .invalid_user_input = <span class="tok-null">false</span>,</span>
<span class="line" id="L371">        .default_step = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L372">        .top_level_steps = .{},</span>
<span class="line" id="L373">        .install_prefix = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L374">        .dest_dir = parent.dest_dir,</span>
<span class="line" id="L375">        .lib_dir = parent.lib_dir,</span>
<span class="line" id="L376">        .exe_dir = parent.exe_dir,</span>
<span class="line" id="L377">        .h_dir = parent.h_dir,</span>
<span class="line" id="L378">        .install_path = parent.install_path,</span>
<span class="line" id="L379">        .sysroot = parent.sysroot,</span>
<span class="line" id="L380">        .search_prefixes = parent.search_prefixes,</span>
<span class="line" id="L381">        .libc_file = parent.libc_file,</span>
<span class="line" id="L382">        .installed_files = ArrayList(InstalledFile).init(allocator),</span>
<span class="line" id="L383">        .build_root = build_root,</span>
<span class="line" id="L384">        .cache_root = parent.cache_root,</span>
<span class="line" id="L385">        .zig_lib_dir = parent.zig_lib_dir,</span>
<span class="line" id="L386">        .debug_log_scopes = parent.debug_log_scopes,</span>
<span class="line" id="L387">        .debug_compile_errors = parent.debug_compile_errors,</span>
<span class="line" id="L388">        .debug_pkg_config = parent.debug_pkg_config,</span>
<span class="line" id="L389">        .enable_darling = parent.enable_darling,</span>
<span class="line" id="L390">        .enable_qemu = parent.enable_qemu,</span>
<span class="line" id="L391">        .enable_rosetta = parent.enable_rosetta,</span>
<span class="line" id="L392">        .enable_wasmtime = parent.enable_wasmtime,</span>
<span class="line" id="L393">        .enable_wine = parent.enable_wine,</span>
<span class="line" id="L394">        .glibc_runtimes_dir = parent.glibc_runtimes_dir,</span>
<span class="line" id="L395">        .host = parent.host,</span>
<span class="line" id="L396">        .dep_prefix = parent.fmt(<span class="tok-str">&quot;{s}{s}.&quot;</span>, .{ parent.dep_prefix, dep_name }),</span>
<span class="line" id="L397">        .modules = std.StringArrayHashMap(*Module).init(allocator),</span>
<span class="line" id="L398">        .named_writefiles = std.StringArrayHashMap(*Step.WriteFile).init(allocator),</span>
<span class="line" id="L399">        .initialized_deps = parent.initialized_deps,</span>
<span class="line" id="L400">        .available_deps = pkg_deps,</span>
<span class="line" id="L401">        .release_mode = parent.release_mode,</span>
<span class="line" id="L402">    };</span>
<span class="line" id="L403">    <span class="tok-kw">try</span> child.top_level_steps.put(allocator, child.install_tls.step.name, &amp;child.install_tls);</span>
<span class="line" id="L404">    <span class="tok-kw">try</span> child.top_level_steps.put(allocator, child.uninstall_tls.step.name, &amp;child.uninstall_tls);</span>
<span class="line" id="L405">    child.default_step = &amp;child.install_tls.step;</span>
<span class="line" id="L406">    <span class="tok-kw">return</span> child;</span>
<span class="line" id="L407">}</span>
<span class="line" id="L408"></span>
<span class="line" id="L409"><span class="tok-kw">fn</span> <span class="tok-fn">userInputOptionsFromArgs</span>(allocator: Allocator, args: <span class="tok-kw">anytype</span>) UserInputOptionsMap {</span>
<span class="line" id="L410">    <span class="tok-kw">var</span> user_input_options = UserInputOptionsMap.init(allocator);</span>
<span class="line" id="L411">    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(args)).Struct.fields) |field| {</span>
<span class="line" id="L412">        <span class="tok-kw">const</span> v = <span class="tok-builtin">@field</span>(args, field.name);</span>
<span class="line" id="L413">        <span class="tok-kw">const</span> T = <span class="tok-builtin">@TypeOf</span>(v);</span>
<span class="line" id="L414">        <span class="tok-kw">switch</span> (T) {</span>
<span class="line" id="L415">            Target.Query =&gt; {</span>
<span class="line" id="L416">                user_input_options.put(field.name, .{</span>
<span class="line" id="L417">                    .name = field.name,</span>
<span class="line" id="L418">                    .value = .{ .scalar = v.zigTriple(allocator) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>) },</span>
<span class="line" id="L419">                    .used = <span class="tok-null">false</span>,</span>
<span class="line" id="L420">                }) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L421">                user_input_options.put(<span class="tok-str">&quot;cpu&quot;</span>, .{</span>
<span class="line" id="L422">                    .name = <span class="tok-str">&quot;cpu&quot;</span>,</span>
<span class="line" id="L423">                    .value = .{ .scalar = v.serializeCpuAlloc(allocator) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>) },</span>
<span class="line" id="L424">                    .used = <span class="tok-null">false</span>,</span>
<span class="line" id="L425">                }) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L426">            },</span>
<span class="line" id="L427">            ResolvedTarget =&gt; {</span>
<span class="line" id="L428">                user_input_options.put(field.name, .{</span>
<span class="line" id="L429">                    .name = field.name,</span>
<span class="line" id="L430">                    .value = .{ .scalar = v.query.zigTriple(allocator) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>) },</span>
<span class="line" id="L431">                    .used = <span class="tok-null">false</span>,</span>
<span class="line" id="L432">                }) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L433">                user_input_options.put(<span class="tok-str">&quot;cpu&quot;</span>, .{</span>
<span class="line" id="L434">                    .name = <span class="tok-str">&quot;cpu&quot;</span>,</span>
<span class="line" id="L435">                    .value = .{ .scalar = v.query.serializeCpuAlloc(allocator) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>) },</span>
<span class="line" id="L436">                    .used = <span class="tok-null">false</span>,</span>
<span class="line" id="L437">                }) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L438">            },</span>
<span class="line" id="L439">            []<span class="tok-kw">const</span> <span class="tok-type">u8</span> =&gt; {</span>
<span class="line" id="L440">                user_input_options.put(field.name, .{</span>
<span class="line" id="L441">                    .name = field.name,</span>
<span class="line" id="L442">                    .value = .{ .scalar = v },</span>
<span class="line" id="L443">                    .used = <span class="tok-null">false</span>,</span>
<span class="line" id="L444">                }) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L445">            },</span>
<span class="line" id="L446">            []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span> =&gt; {</span>
<span class="line" id="L447">                <span class="tok-kw">var</span> list = ArrayList([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>).initCapacity(allocator, v.len) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L448">                list.appendSliceAssumeCapacity(v);</span>
<span class="line" id="L449"></span>
<span class="line" id="L450">                user_input_options.put(field.name, .{</span>
<span class="line" id="L451">                    .name = field.name,</span>
<span class="line" id="L452">                    .value = .{ .list = list },</span>
<span class="line" id="L453">                    .used = <span class="tok-null">false</span>,</span>
<span class="line" id="L454">                }) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L455">            },</span>
<span class="line" id="L456">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {</span>
<span class="line" id="L457">                .Bool =&gt; {</span>
<span class="line" id="L458">                    user_input_options.put(field.name, .{</span>
<span class="line" id="L459">                        .name = field.name,</span>
<span class="line" id="L460">                        .value = .{ .scalar = <span class="tok-kw">if</span> (v) <span class="tok-str">&quot;true&quot;</span> <span class="tok-kw">else</span> <span class="tok-str">&quot;false&quot;</span> },</span>
<span class="line" id="L461">                        .used = <span class="tok-null">false</span>,</span>
<span class="line" id="L462">                    }) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L463">                },</span>
<span class="line" id="L464">                .Enum, .EnumLiteral =&gt; {</span>
<span class="line" id="L465">                    user_input_options.put(field.name, .{</span>
<span class="line" id="L466">                        .name = field.name,</span>
<span class="line" id="L467">                        .value = .{ .scalar = <span class="tok-builtin">@tagName</span>(v) },</span>
<span class="line" id="L468">                        .used = <span class="tok-null">false</span>,</span>
<span class="line" id="L469">                    }) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L470">                },</span>
<span class="line" id="L471">                .Int =&gt; {</span>
<span class="line" id="L472">                    user_input_options.put(field.name, .{</span>
<span class="line" id="L473">                        .name = field.name,</span>
<span class="line" id="L474">                        .value = .{ .scalar = std.fmt.allocPrint(allocator, <span class="tok-str">&quot;{d}&quot;</span>, .{v}) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>) },</span>
<span class="line" id="L475">                        .used = <span class="tok-null">false</span>,</span>
<span class="line" id="L476">                    }) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L477">                },</span>
<span class="line" id="L478">                <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;option '&quot;</span> ++ field.name ++ <span class="tok-str">&quot;' has unsupported type: &quot;</span> ++ <span class="tok-builtin">@typeName</span>(T)),</span>
<span class="line" id="L479">            },</span>
<span class="line" id="L480">        }</span>
<span class="line" id="L481">    }</span>
<span class="line" id="L482"></span>
<span class="line" id="L483">    <span class="tok-kw">return</span> user_input_options;</span>
<span class="line" id="L484">}</span>
<span class="line" id="L485"></span>
<span class="line" id="L486"><span class="tok-kw">const</span> OrderedUserValue = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {</span>
<span class="line" id="L487">    flag: <span class="tok-type">void</span>,</span>
<span class="line" id="L488">    scalar: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L489">    list: ArrayList([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>),</span>
<span class="line" id="L490">    map: ArrayList(Pair),</span>
<span class="line" id="L491"></span>
<span class="line" id="L492">    <span class="tok-kw">const</span> Pair = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L493">        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L494">        value: OrderedUserValue,</span>
<span class="line" id="L495">        <span class="tok-kw">fn</span> <span class="tok-fn">lessThan</span>(_: <span class="tok-type">void</span>, lhs: Pair, rhs: Pair) <span class="tok-type">bool</span> {</span>
<span class="line" id="L496">            <span class="tok-kw">return</span> std.ascii.lessThanIgnoreCase(lhs.name, rhs.name);</span>
<span class="line" id="L497">        }</span>
<span class="line" id="L498">    };</span>
<span class="line" id="L499"></span>
<span class="line" id="L500">    <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(self: OrderedUserValue, hasher: *std.hash.Wyhash) <span class="tok-type">void</span> {</span>
<span class="line" id="L501">        <span class="tok-kw">switch</span> (self) {</span>
<span class="line" id="L502">            .flag =&gt; {},</span>
<span class="line" id="L503">            .scalar =&gt; |scalar| hasher.update(scalar),</span>
<span class="line" id="L504">            <span class="tok-comment">// lists are already ordered</span>
</span>
<span class="line" id="L505">            .list =&gt; |list| <span class="tok-kw">for</span> (list.items) |list_entry|</span>
<span class="line" id="L506">                hasher.update(list_entry),</span>
<span class="line" id="L507">            .map =&gt; |map| <span class="tok-kw">for</span> (map.items) |map_entry| {</span>
<span class="line" id="L508">                hasher.update(map_entry.name);</span>
<span class="line" id="L509">                map_entry.value.hash(hasher);</span>
<span class="line" id="L510">            },</span>
<span class="line" id="L511">        }</span>
<span class="line" id="L512">    }</span>
<span class="line" id="L513"></span>
<span class="line" id="L514">    <span class="tok-kw">fn</span> <span class="tok-fn">mapFromUnordered</span>(allocator: Allocator, unordered: std.StringHashMap(*<span class="tok-kw">const</span> UserValue)) ArrayList(Pair) {</span>
<span class="line" id="L515">        <span class="tok-kw">var</span> ordered = ArrayList(Pair).init(allocator);</span>
<span class="line" id="L516">        <span class="tok-kw">var</span> it = unordered.iterator();</span>
<span class="line" id="L517">        <span class="tok-kw">while</span> (it.next()) |entry| {</span>
<span class="line" id="L518">            ordered.append(.{</span>
<span class="line" id="L519">                .name = entry.key_ptr.*,</span>
<span class="line" id="L520">                .value = OrderedUserValue.fromUnordered(allocator, entry.value_ptr.*.*),</span>
<span class="line" id="L521">            }) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L522">        }</span>
<span class="line" id="L523"></span>
<span class="line" id="L524">        std.mem.sortUnstable(Pair, ordered.items, {}, Pair.lessThan);</span>
<span class="line" id="L525">        <span class="tok-kw">return</span> ordered;</span>
<span class="line" id="L526">    }</span>
<span class="line" id="L527"></span>
<span class="line" id="L528">    <span class="tok-kw">fn</span> <span class="tok-fn">fromUnordered</span>(allocator: Allocator, unordered: UserValue) OrderedUserValue {</span>
<span class="line" id="L529">        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (unordered) {</span>
<span class="line" id="L530">            .flag =&gt; .{ .flag = {} },</span>
<span class="line" id="L531">            .scalar =&gt; |scalar| .{ .scalar = scalar },</span>
<span class="line" id="L532">            .list =&gt; |list| .{ .list = list },</span>
<span class="line" id="L533">            .map =&gt; |map| .{ .map = OrderedUserValue.mapFromUnordered(allocator, map) },</span>
<span class="line" id="L534">        };</span>
<span class="line" id="L535">    }</span>
<span class="line" id="L536">};</span>
<span class="line" id="L537"></span>
<span class="line" id="L538"><span class="tok-kw">const</span> OrderedUserInputOption = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L539">    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L540">    value: OrderedUserValue,</span>
<span class="line" id="L541">    used: <span class="tok-type">bool</span>,</span>
<span class="line" id="L542"></span>
<span class="line" id="L543">    <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(self: OrderedUserInputOption, hasher: *std.hash.Wyhash) <span class="tok-type">void</span> {</span>
<span class="line" id="L544">        hasher.update(self.name);</span>
<span class="line" id="L545">        self.value.hash(hasher);</span>
<span class="line" id="L546">    }</span>
<span class="line" id="L547"></span>
<span class="line" id="L548">    <span class="tok-kw">fn</span> <span class="tok-fn">fromUnordered</span>(allocator: Allocator, user_input_option: UserInputOption) OrderedUserInputOption {</span>
<span class="line" id="L549">        <span class="tok-kw">return</span> OrderedUserInputOption{</span>
<span class="line" id="L550">            .name = user_input_option.name,</span>
<span class="line" id="L551">            .used = user_input_option.used,</span>
<span class="line" id="L552">            .value = OrderedUserValue.fromUnordered(allocator, user_input_option.value),</span>
<span class="line" id="L553">        };</span>
<span class="line" id="L554">    }</span>
<span class="line" id="L555"></span>
<span class="line" id="L556">    <span class="tok-kw">fn</span> <span class="tok-fn">lessThan</span>(_: <span class="tok-type">void</span>, lhs: OrderedUserInputOption, rhs: OrderedUserInputOption) <span class="tok-type">bool</span> {</span>
<span class="line" id="L557">        <span class="tok-kw">return</span> std.ascii.lessThanIgnoreCase(lhs.name, rhs.name);</span>
<span class="line" id="L558">    }</span>
<span class="line" id="L559">};</span>
<span class="line" id="L560"></span>
<span class="line" id="L561"><span class="tok-comment">// The hash should be consistent with the same values given a different order.</span>
</span>
<span class="line" id="L562"><span class="tok-comment">// This function takes a user input map, orders it, then hashes the contents.</span>
</span>
<span class="line" id="L563"><span class="tok-kw">fn</span> <span class="tok-fn">hashUserInputOptionsMap</span>(allocator: Allocator, user_input_options: UserInputOptionsMap, hasher: *std.hash.Wyhash) <span class="tok-type">void</span> {</span>
<span class="line" id="L564">    <span class="tok-kw">var</span> ordered = ArrayList(OrderedUserInputOption).init(allocator);</span>
<span class="line" id="L565">    <span class="tok-kw">var</span> it = user_input_options.iterator();</span>
<span class="line" id="L566">    <span class="tok-kw">while</span> (it.next()) |entry|</span>
<span class="line" id="L567">        ordered.append(OrderedUserInputOption.fromUnordered(allocator, entry.value_ptr.*)) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L568"></span>
<span class="line" id="L569">    std.mem.sortUnstable(OrderedUserInputOption, ordered.items, {}, OrderedUserInputOption.lessThan);</span>
<span class="line" id="L570"></span>
<span class="line" id="L571">    <span class="tok-comment">// juice it</span>
</span>
<span class="line" id="L572">    <span class="tok-kw">for</span> (ordered.items) |user_option|</span>
<span class="line" id="L573">        user_option.hash(hasher);</span>
<span class="line" id="L574">}</span>
<span class="line" id="L575"></span>
<span class="line" id="L576"><span class="tok-kw">fn</span> <span class="tok-fn">determineAndApplyInstallPrefix</span>(b: *Build) !<span class="tok-type">void</span> {</span>
<span class="line" id="L577">    <span class="tok-comment">// Create an installation directory local to this package. This will be used when</span>
</span>
<span class="line" id="L578">    <span class="tok-comment">// dependant packages require a standard prefix, such as include directories for C headers.</span>
</span>
<span class="line" id="L579">    <span class="tok-kw">var</span> hash = b.graph.cache.hash;</span>
<span class="line" id="L580">    <span class="tok-comment">// Random bytes to make unique. Refresh this with new random bytes when</span>
</span>
<span class="line" id="L581">    <span class="tok-comment">// implementation is modified in a non-backwards-compatible way.</span>
</span>
<span class="line" id="L582">    hash.add(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0xd8cb0055</span>));</span>
<span class="line" id="L583">    hash.addBytes(b.dep_prefix);</span>
<span class="line" id="L584"></span>
<span class="line" id="L585">    <span class="tok-kw">var</span> wyhash = std.hash.Wyhash.init(<span class="tok-number">0</span>);</span>
<span class="line" id="L586">    hashUserInputOptionsMap(b.allocator, b.user_input_options, &amp;wyhash);</span>
<span class="line" id="L587">    hash.add(wyhash.final());</span>
<span class="line" id="L588"></span>
<span class="line" id="L589">    <span class="tok-kw">const</span> digest = hash.final();</span>
<span class="line" id="L590">    <span class="tok-kw">const</span> install_prefix = <span class="tok-kw">try</span> b.cache_root.join(b.allocator, &amp;.{ <span class="tok-str">&quot;i&quot;</span>, &amp;digest });</span>
<span class="line" id="L591">    b.resolveInstallPrefix(install_prefix, .{});</span>
<span class="line" id="L592">}</span>
<span class="line" id="L593"></span>
<span class="line" id="L594"><span class="tok-comment">/// This function is intended to be called by lib/build_runner.zig, not a build.zig file.</span></span>
<span class="line" id="L595"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">resolveInstallPrefix</span>(self: *Build, install_prefix: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, dir_list: DirList) <span class="tok-type">void</span> {</span>
<span class="line" id="L596">    <span class="tok-kw">if</span> (self.dest_dir) |dest_dir| {</span>
<span class="line" id="L597">        self.install_prefix = install_prefix <span class="tok-kw">orelse</span> <span class="tok-str">&quot;/usr&quot;</span>;</span>
<span class="line" id="L598">        self.install_path = self.pathJoin(&amp;.{ dest_dir, self.install_prefix });</span>
<span class="line" id="L599">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L600">        self.install_prefix = install_prefix <span class="tok-kw">orelse</span></span>
<span class="line" id="L601">            (self.build_root.join(self.allocator, &amp;.{<span class="tok-str">&quot;zig-out&quot;</span>}) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;unhandled error&quot;</span>));</span>
<span class="line" id="L602">        self.install_path = self.install_prefix;</span>
<span class="line" id="L603">    }</span>
<span class="line" id="L604"></span>
<span class="line" id="L605">    <span class="tok-kw">var</span> lib_list = [_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ self.install_path, <span class="tok-str">&quot;lib&quot;</span> };</span>
<span class="line" id="L606">    <span class="tok-kw">var</span> exe_list = [_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ self.install_path, <span class="tok-str">&quot;bin&quot;</span> };</span>
<span class="line" id="L607">    <span class="tok-kw">var</span> h_list = [_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ self.install_path, <span class="tok-str">&quot;include&quot;</span> };</span>
<span class="line" id="L608"></span>
<span class="line" id="L609">    <span class="tok-kw">if</span> (dir_list.lib_dir) |dir| {</span>
<span class="line" id="L610">        <span class="tok-kw">if</span> (std.fs.path.isAbsolute(dir)) lib_list[<span class="tok-number">0</span>] = self.dest_dir <span class="tok-kw">orelse</span> <span class="tok-str">&quot;&quot;</span>;</span>
<span class="line" id="L611">        lib_list[<span class="tok-number">1</span>] = dir;</span>
<span class="line" id="L612">    }</span>
<span class="line" id="L613"></span>
<span class="line" id="L614">    <span class="tok-kw">if</span> (dir_list.exe_dir) |dir| {</span>
<span class="line" id="L615">        <span class="tok-kw">if</span> (std.fs.path.isAbsolute(dir)) exe_list[<span class="tok-number">0</span>] = self.dest_dir <span class="tok-kw">orelse</span> <span class="tok-str">&quot;&quot;</span>;</span>
<span class="line" id="L616">        exe_list[<span class="tok-number">1</span>] = dir;</span>
<span class="line" id="L617">    }</span>
<span class="line" id="L618"></span>
<span class="line" id="L619">    <span class="tok-kw">if</span> (dir_list.include_dir) |dir| {</span>
<span class="line" id="L620">        <span class="tok-kw">if</span> (std.fs.path.isAbsolute(dir)) h_list[<span class="tok-number">0</span>] = self.dest_dir <span class="tok-kw">orelse</span> <span class="tok-str">&quot;&quot;</span>;</span>
<span class="line" id="L621">        h_list[<span class="tok-number">1</span>] = dir;</span>
<span class="line" id="L622">    }</span>
<span class="line" id="L623"></span>
<span class="line" id="L624">    self.lib_dir = self.pathJoin(&amp;lib_list);</span>
<span class="line" id="L625">    self.exe_dir = self.pathJoin(&amp;exe_list);</span>
<span class="line" id="L626">    self.h_dir = self.pathJoin(&amp;h_list);</span>
<span class="line" id="L627">}</span>
<span class="line" id="L628"></span>
<span class="line" id="L629"><span class="tok-comment">/// Create a set of key-value pairs that can be converted into a Zig source</span></span>
<span class="line" id="L630"><span class="tok-comment">/// file and then inserted into a Zig compilation's module table for importing.</span></span>
<span class="line" id="L631"><span class="tok-comment">/// In other words, this provides a way to expose build.zig values to Zig</span></span>
<span class="line" id="L632"><span class="tok-comment">/// source code with `@import`.</span></span>
<span class="line" id="L633"><span class="tok-comment">/// Related: `Module.addOptions`.</span></span>
<span class="line" id="L634"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOptions</span>(self: *Build) *Step.Options {</span>
<span class="line" id="L635">    <span class="tok-kw">return</span> Step.Options.create(self);</span>
<span class="line" id="L636">}</span>
<span class="line" id="L637"></span>
<span class="line" id="L638"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ExecutableOptions = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L639">    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L640">    <span class="tok-comment">/// If you want the executable to run on the same computer as the one</span></span>
<span class="line" id="L641">    <span class="tok-comment">/// building the package, pass the `host` field of the package's `Build`</span></span>
<span class="line" id="L642">    <span class="tok-comment">/// instance.</span></span>
<span class="line" id="L643">    target: ResolvedTarget,</span>
<span class="line" id="L644">    root_source_file: ?LazyPath = <span class="tok-null">null</span>,</span>
<span class="line" id="L645">    version: ?std.SemanticVersion = <span class="tok-null">null</span>,</span>
<span class="line" id="L646">    optimize: std.builtin.OptimizeMode = .Debug,</span>
<span class="line" id="L647">    code_model: std.builtin.CodeModel = .default,</span>
<span class="line" id="L648">    linkage: ?Step.Compile.Linkage = <span class="tok-null">null</span>,</span>
<span class="line" id="L649">    max_rss: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,</span>
<span class="line" id="L650">    link_libc: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L651">    single_threaded: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L652">    pic: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L653">    strip: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L654">    unwind_tables: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L655">    omit_frame_pointer: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L656">    sanitize_thread: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L657">    error_tracing: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L658">    use_llvm: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L659">    use_lld: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L660">    zig_lib_dir: ?LazyPath = <span class="tok-null">null</span>,</span>
<span class="line" id="L661">    <span class="tok-comment">/// Embed a `.manifest` file in the compilation if the object format supports it.</span></span>
<span class="line" id="L662">    <span class="tok-comment">/// https://learn.microsoft.com/en-us/windows/win32/sbscs/manifest-files-reference</span></span>
<span class="line" id="L663">    <span class="tok-comment">/// Manifest files must have the extension `.manifest`.</span></span>
<span class="line" id="L664">    <span class="tok-comment">/// Can be set regardless of target. The `.manifest` file will be ignored</span></span>
<span class="line" id="L665">    <span class="tok-comment">/// if the target object format does not support embedded manifests.</span></span>
<span class="line" id="L666">    win32_manifest: ?LazyPath = <span class="tok-null">null</span>,</span>
<span class="line" id="L667">};</span>
<span class="line" id="L668"></span>
<span class="line" id="L669"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addExecutable</span>(b: *Build, options: ExecutableOptions) *Step.Compile {</span>
<span class="line" id="L670">    <span class="tok-kw">return</span> Step.Compile.create(b, .{</span>
<span class="line" id="L671">        .name = options.name,</span>
<span class="line" id="L672">        .root_module = .{</span>
<span class="line" id="L673">            .root_source_file = options.root_source_file,</span>
<span class="line" id="L674">            .target = options.target,</span>
<span class="line" id="L675">            .optimize = options.optimize,</span>
<span class="line" id="L676">            .link_libc = options.link_libc,</span>
<span class="line" id="L677">            .single_threaded = options.single_threaded,</span>
<span class="line" id="L678">            .pic = options.pic,</span>
<span class="line" id="L679">            .strip = options.strip,</span>
<span class="line" id="L680">            .unwind_tables = options.unwind_tables,</span>
<span class="line" id="L681">            .omit_frame_pointer = options.omit_frame_pointer,</span>
<span class="line" id="L682">            .sanitize_thread = options.sanitize_thread,</span>
<span class="line" id="L683">            .error_tracing = options.error_tracing,</span>
<span class="line" id="L684">            .code_model = options.code_model,</span>
<span class="line" id="L685">        },</span>
<span class="line" id="L686">        .version = options.version,</span>
<span class="line" id="L687">        .kind = .exe,</span>
<span class="line" id="L688">        .linkage = options.linkage,</span>
<span class="line" id="L689">        .max_rss = options.max_rss,</span>
<span class="line" id="L690">        .use_llvm = options.use_llvm,</span>
<span class="line" id="L691">        .use_lld = options.use_lld,</span>
<span class="line" id="L692">        .zig_lib_dir = options.zig_lib_dir <span class="tok-kw">orelse</span> b.zig_lib_dir,</span>
<span class="line" id="L693">        .win32_manifest = options.win32_manifest,</span>
<span class="line" id="L694">    });</span>
<span class="line" id="L695">}</span>
<span class="line" id="L696"></span>
<span class="line" id="L697"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ObjectOptions = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L698">    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L699">    root_source_file: ?LazyPath = <span class="tok-null">null</span>,</span>
<span class="line" id="L700">    <span class="tok-comment">/// To choose the same computer as the one building the package, pass the</span></span>
<span class="line" id="L701">    <span class="tok-comment">/// `host` field of the package's `Build` instance.</span></span>
<span class="line" id="L702">    target: ResolvedTarget,</span>
<span class="line" id="L703">    code_model: std.builtin.CodeModel = .default,</span>
<span class="line" id="L704">    optimize: std.builtin.OptimizeMode,</span>
<span class="line" id="L705">    max_rss: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,</span>
<span class="line" id="L706">    link_libc: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L707">    single_threaded: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L708">    pic: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L709">    strip: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L710">    unwind_tables: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L711">    omit_frame_pointer: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L712">    sanitize_thread: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L713">    error_tracing: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L714">    use_llvm: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L715">    use_lld: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L716">    zig_lib_dir: ?LazyPath = <span class="tok-null">null</span>,</span>
<span class="line" id="L717">};</span>
<span class="line" id="L718"></span>
<span class="line" id="L719"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addObject</span>(b: *Build, options: ObjectOptions) *Step.Compile {</span>
<span class="line" id="L720">    <span class="tok-kw">return</span> Step.Compile.create(b, .{</span>
<span class="line" id="L721">        .name = options.name,</span>
<span class="line" id="L722">        .root_module = .{</span>
<span class="line" id="L723">            .root_source_file = options.root_source_file,</span>
<span class="line" id="L724">            .target = options.target,</span>
<span class="line" id="L725">            .optimize = options.optimize,</span>
<span class="line" id="L726">            .link_libc = options.link_libc,</span>
<span class="line" id="L727">            .single_threaded = options.single_threaded,</span>
<span class="line" id="L728">            .pic = options.pic,</span>
<span class="line" id="L729">            .strip = options.strip,</span>
<span class="line" id="L730">            .unwind_tables = options.unwind_tables,</span>
<span class="line" id="L731">            .omit_frame_pointer = options.omit_frame_pointer,</span>
<span class="line" id="L732">            .sanitize_thread = options.sanitize_thread,</span>
<span class="line" id="L733">            .error_tracing = options.error_tracing,</span>
<span class="line" id="L734">            .code_model = options.code_model,</span>
<span class="line" id="L735">        },</span>
<span class="line" id="L736">        .kind = .obj,</span>
<span class="line" id="L737">        .max_rss = options.max_rss,</span>
<span class="line" id="L738">        .use_llvm = options.use_llvm,</span>
<span class="line" id="L739">        .use_lld = options.use_lld,</span>
<span class="line" id="L740">        .zig_lib_dir = options.zig_lib_dir <span class="tok-kw">orelse</span> b.zig_lib_dir,</span>
<span class="line" id="L741">    });</span>
<span class="line" id="L742">}</span>
<span class="line" id="L743"></span>
<span class="line" id="L744"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> SharedLibraryOptions = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L745">    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L746">    <span class="tok-comment">/// To choose the same computer as the one building the package, pass the</span></span>
<span class="line" id="L747">    <span class="tok-comment">/// `host` field of the package's `Build` instance.</span></span>
<span class="line" id="L748">    target: ResolvedTarget,</span>
<span class="line" id="L749">    optimize: std.builtin.OptimizeMode,</span>
<span class="line" id="L750">    code_model: std.builtin.CodeModel = .default,</span>
<span class="line" id="L751">    root_source_file: ?LazyPath = <span class="tok-null">null</span>,</span>
<span class="line" id="L752">    version: ?std.SemanticVersion = <span class="tok-null">null</span>,</span>
<span class="line" id="L753">    max_rss: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,</span>
<span class="line" id="L754">    link_libc: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L755">    single_threaded: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L756">    pic: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L757">    strip: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L758">    unwind_tables: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L759">    omit_frame_pointer: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L760">    sanitize_thread: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L761">    error_tracing: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L762">    use_llvm: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L763">    use_lld: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L764">    zig_lib_dir: ?LazyPath = <span class="tok-null">null</span>,</span>
<span class="line" id="L765">    <span class="tok-comment">/// Embed a `.manifest` file in the compilation if the object format supports it.</span></span>
<span class="line" id="L766">    <span class="tok-comment">/// https://learn.microsoft.com/en-us/windows/win32/sbscs/manifest-files-reference</span></span>
<span class="line" id="L767">    <span class="tok-comment">/// Manifest files must have the extension `.manifest`.</span></span>
<span class="line" id="L768">    <span class="tok-comment">/// Can be set regardless of target. The `.manifest` file will be ignored</span></span>
<span class="line" id="L769">    <span class="tok-comment">/// if the target object format does not support embedded manifests.</span></span>
<span class="line" id="L770">    win32_manifest: ?LazyPath = <span class="tok-null">null</span>,</span>
<span class="line" id="L771">};</span>
<span class="line" id="L772"></span>
<span class="line" id="L773"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addSharedLibrary</span>(b: *Build, options: SharedLibraryOptions) *Step.Compile {</span>
<span class="line" id="L774">    <span class="tok-kw">return</span> Step.Compile.create(b, .{</span>
<span class="line" id="L775">        .name = options.name,</span>
<span class="line" id="L776">        .root_module = .{</span>
<span class="line" id="L777">            .target = options.target,</span>
<span class="line" id="L778">            .optimize = options.optimize,</span>
<span class="line" id="L779">            .root_source_file = options.root_source_file,</span>
<span class="line" id="L780">            .link_libc = options.link_libc,</span>
<span class="line" id="L781">            .single_threaded = options.single_threaded,</span>
<span class="line" id="L782">            .pic = options.pic,</span>
<span class="line" id="L783">            .strip = options.strip,</span>
<span class="line" id="L784">            .unwind_tables = options.unwind_tables,</span>
<span class="line" id="L785">            .omit_frame_pointer = options.omit_frame_pointer,</span>
<span class="line" id="L786">            .sanitize_thread = options.sanitize_thread,</span>
<span class="line" id="L787">            .error_tracing = options.error_tracing,</span>
<span class="line" id="L788">            .code_model = options.code_model,</span>
<span class="line" id="L789">        },</span>
<span class="line" id="L790">        .kind = .lib,</span>
<span class="line" id="L791">        .linkage = .dynamic,</span>
<span class="line" id="L792">        .version = options.version,</span>
<span class="line" id="L793">        .max_rss = options.max_rss,</span>
<span class="line" id="L794">        .use_llvm = options.use_llvm,</span>
<span class="line" id="L795">        .use_lld = options.use_lld,</span>
<span class="line" id="L796">        .zig_lib_dir = options.zig_lib_dir <span class="tok-kw">orelse</span> b.zig_lib_dir,</span>
<span class="line" id="L797">        .win32_manifest = options.win32_manifest,</span>
<span class="line" id="L798">    });</span>
<span class="line" id="L799">}</span>
<span class="line" id="L800"></span>
<span class="line" id="L801"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> StaticLibraryOptions = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L802">    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L803">    root_source_file: ?LazyPath = <span class="tok-null">null</span>,</span>
<span class="line" id="L804">    <span class="tok-comment">/// To choose the same computer as the one building the package, pass the</span></span>
<span class="line" id="L805">    <span class="tok-comment">/// `host` field of the package's `Build` instance.</span></span>
<span class="line" id="L806">    target: ResolvedTarget,</span>
<span class="line" id="L807">    optimize: std.builtin.OptimizeMode,</span>
<span class="line" id="L808">    code_model: std.builtin.CodeModel = .default,</span>
<span class="line" id="L809">    version: ?std.SemanticVersion = <span class="tok-null">null</span>,</span>
<span class="line" id="L810">    max_rss: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,</span>
<span class="line" id="L811">    link_libc: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L812">    single_threaded: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L813">    pic: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L814">    strip: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L815">    unwind_tables: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L816">    omit_frame_pointer: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L817">    sanitize_thread: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L818">    error_tracing: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L819">    use_llvm: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L820">    use_lld: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L821">    zig_lib_dir: ?LazyPath = <span class="tok-null">null</span>,</span>
<span class="line" id="L822">};</span>
<span class="line" id="L823"></span>
<span class="line" id="L824"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addStaticLibrary</span>(b: *Build, options: StaticLibraryOptions) *Step.Compile {</span>
<span class="line" id="L825">    <span class="tok-kw">return</span> Step.Compile.create(b, .{</span>
<span class="line" id="L826">        .name = options.name,</span>
<span class="line" id="L827">        .root_module = .{</span>
<span class="line" id="L828">            .target = options.target,</span>
<span class="line" id="L829">            .optimize = options.optimize,</span>
<span class="line" id="L830">            .root_source_file = options.root_source_file,</span>
<span class="line" id="L831">            .link_libc = options.link_libc,</span>
<span class="line" id="L832">            .single_threaded = options.single_threaded,</span>
<span class="line" id="L833">            .pic = options.pic,</span>
<span class="line" id="L834">            .strip = options.strip,</span>
<span class="line" id="L835">            .unwind_tables = options.unwind_tables,</span>
<span class="line" id="L836">            .omit_frame_pointer = options.omit_frame_pointer,</span>
<span class="line" id="L837">            .sanitize_thread = options.sanitize_thread,</span>
<span class="line" id="L838">            .error_tracing = options.error_tracing,</span>
<span class="line" id="L839">            .code_model = options.code_model,</span>
<span class="line" id="L840">        },</span>
<span class="line" id="L841">        .kind = .lib,</span>
<span class="line" id="L842">        .linkage = .static,</span>
<span class="line" id="L843">        .version = options.version,</span>
<span class="line" id="L844">        .max_rss = options.max_rss,</span>
<span class="line" id="L845">        .use_llvm = options.use_llvm,</span>
<span class="line" id="L846">        .use_lld = options.use_lld,</span>
<span class="line" id="L847">        .zig_lib_dir = options.zig_lib_dir <span class="tok-kw">orelse</span> b.zig_lib_dir,</span>
<span class="line" id="L848">    });</span>
<span class="line" id="L849">}</span>
<span class="line" id="L850"></span>
<span class="line" id="L851"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> TestOptions = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L852">    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">&quot;test&quot;</span>,</span>
<span class="line" id="L853">    root_source_file: LazyPath,</span>
<span class="line" id="L854">    target: ?ResolvedTarget = <span class="tok-null">null</span>,</span>
<span class="line" id="L855">    optimize: std.builtin.OptimizeMode = .Debug,</span>
<span class="line" id="L856">    version: ?std.SemanticVersion = <span class="tok-null">null</span>,</span>
<span class="line" id="L857">    max_rss: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,</span>
<span class="line" id="L858">    <span class="tok-comment">/// deprecated: use `.filters = &amp;.{filter}` instead of `.filter = filter`.</span></span>
<span class="line" id="L859">    filter: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L860">    filters: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = &amp;.{},</span>
<span class="line" id="L861">    test_runner: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L862">    link_libc: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L863">    single_threaded: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L864">    pic: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L865">    strip: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L866">    unwind_tables: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L867">    omit_frame_pointer: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L868">    sanitize_thread: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L869">    error_tracing: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L870">    use_llvm: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L871">    use_lld: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L872">    zig_lib_dir: ?LazyPath = <span class="tok-null">null</span>,</span>
<span class="line" id="L873">};</span>
<span class="line" id="L874"></span>
<span class="line" id="L875"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addTest</span>(b: *Build, options: TestOptions) *Step.Compile {</span>
<span class="line" id="L876">    <span class="tok-kw">return</span> Step.Compile.create(b, .{</span>
<span class="line" id="L877">        .name = options.name,</span>
<span class="line" id="L878">        .kind = .@&quot;test&quot;,</span>
<span class="line" id="L879">        .root_module = .{</span>
<span class="line" id="L880">            .root_source_file = options.root_source_file,</span>
<span class="line" id="L881">            .target = options.target <span class="tok-kw">orelse</span> b.host,</span>
<span class="line" id="L882">            .optimize = options.optimize,</span>
<span class="line" id="L883">            .link_libc = options.link_libc,</span>
<span class="line" id="L884">            .single_threaded = options.single_threaded,</span>
<span class="line" id="L885">            .pic = options.pic,</span>
<span class="line" id="L886">            .strip = options.strip,</span>
<span class="line" id="L887">            .unwind_tables = options.unwind_tables,</span>
<span class="line" id="L888">            .omit_frame_pointer = options.omit_frame_pointer,</span>
<span class="line" id="L889">            .sanitize_thread = options.sanitize_thread,</span>
<span class="line" id="L890">            .error_tracing = options.error_tracing,</span>
<span class="line" id="L891">        },</span>
<span class="line" id="L892">        .max_rss = options.max_rss,</span>
<span class="line" id="L893">        .filters = <span class="tok-kw">if</span> (options.filter != <span class="tok-null">null</span> <span class="tok-kw">and</span> options.filters.len &gt; <span class="tok-number">0</span>) filters: {</span>
<span class="line" id="L894">            <span class="tok-kw">const</span> filters = b.allocator.alloc([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-number">1</span> + options.filters.len) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L895">            filters[<span class="tok-number">0</span>] = b.dupe(options.filter.?);</span>
<span class="line" id="L896">            <span class="tok-kw">for</span> (filters[<span class="tok-number">1</span>..], options.filters) |*dest, source| dest.* = b.dupe(source);</span>
<span class="line" id="L897">            <span class="tok-kw">break</span> :filters filters;</span>
<span class="line" id="L898">        } <span class="tok-kw">else</span> b.dupeStrings(<span class="tok-kw">if</span> (options.filter) |filter| &amp;.{filter} <span class="tok-kw">else</span> options.filters),</span>
<span class="line" id="L899">        .test_runner = options.test_runner,</span>
<span class="line" id="L900">        .use_llvm = options.use_llvm,</span>
<span class="line" id="L901">        .use_lld = options.use_lld,</span>
<span class="line" id="L902">        .zig_lib_dir = options.zig_lib_dir <span class="tok-kw">orelse</span> b.zig_lib_dir,</span>
<span class="line" id="L903">    });</span>
<span class="line" id="L904">}</span>
<span class="line" id="L905"></span>
<span class="line" id="L906"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> AssemblyOptions = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L907">    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L908">    source_file: LazyPath,</span>
<span class="line" id="L909">    <span class="tok-comment">/// To choose the same computer as the one building the package, pass the</span></span>
<span class="line" id="L910">    <span class="tok-comment">/// `host` field of the package's `Build` instance.</span></span>
<span class="line" id="L911">    target: ResolvedTarget,</span>
<span class="line" id="L912">    optimize: std.builtin.OptimizeMode,</span>
<span class="line" id="L913">    max_rss: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,</span>
<span class="line" id="L914">    zig_lib_dir: ?LazyPath = <span class="tok-null">null</span>,</span>
<span class="line" id="L915">};</span>
<span class="line" id="L916"></span>
<span class="line" id="L917"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addAssembly</span>(b: *Build, options: AssemblyOptions) *Step.Compile {</span>
<span class="line" id="L918">    <span class="tok-kw">const</span> obj_step = Step.Compile.create(b, .{</span>
<span class="line" id="L919">        .name = options.name,</span>
<span class="line" id="L920">        .kind = .obj,</span>
<span class="line" id="L921">        .root_module = .{</span>
<span class="line" id="L922">            .target = options.target,</span>
<span class="line" id="L923">            .optimize = options.optimize,</span>
<span class="line" id="L924">        },</span>
<span class="line" id="L925">        .max_rss = options.max_rss,</span>
<span class="line" id="L926">        .zig_lib_dir = options.zig_lib_dir <span class="tok-kw">orelse</span> b.zig_lib_dir,</span>
<span class="line" id="L927">    });</span>
<span class="line" id="L928">    obj_step.addAssemblyFile(options.source_file);</span>
<span class="line" id="L929">    <span class="tok-kw">return</span> obj_step;</span>
<span class="line" id="L930">}</span>
<span class="line" id="L931"></span>
<span class="line" id="L932"><span class="tok-comment">/// This function creates a module and adds it to the package's module set, making</span></span>
<span class="line" id="L933"><span class="tok-comment">/// it available to other packages which depend on this one.</span></span>
<span class="line" id="L934"><span class="tok-comment">/// `createModule` can be used instead to create a private module.</span></span>
<span class="line" id="L935"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addModule</span>(b: *Build, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, options: Module.CreateOptions) *Module {</span>
<span class="line" id="L936">    <span class="tok-kw">const</span> module = Module.create(b, options);</span>
<span class="line" id="L937">    b.modules.put(b.dupe(name), module) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L938">    <span class="tok-kw">return</span> module;</span>
<span class="line" id="L939">}</span>
<span class="line" id="L940"></span>
<span class="line" id="L941"><span class="tok-comment">/// This function creates a private module, to be used by the current package,</span></span>
<span class="line" id="L942"><span class="tok-comment">/// but not exposed to other packages depending on this one.</span></span>
<span class="line" id="L943"><span class="tok-comment">/// `addModule` can be used instead to create a public module.</span></span>
<span class="line" id="L944"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">createModule</span>(b: *Build, options: Module.CreateOptions) *Module {</span>
<span class="line" id="L945">    <span class="tok-kw">return</span> Module.create(b, options);</span>
<span class="line" id="L946">}</span>
<span class="line" id="L947"></span>
<span class="line" id="L948"><span class="tok-comment">/// Initializes a `Step.Run` with argv, which must at least have the path to the</span></span>
<span class="line" id="L949"><span class="tok-comment">/// executable. More command line arguments can be added with `addArg`,</span></span>
<span class="line" id="L950"><span class="tok-comment">/// `addArgs`, and `addArtifactArg`.</span></span>
<span class="line" id="L951"><span class="tok-comment">/// Be careful using this function, as it introduces a system dependency.</span></span>
<span class="line" id="L952"><span class="tok-comment">/// To run an executable built with zig build, see `Step.Compile.run`.</span></span>
<span class="line" id="L953"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addSystemCommand</span>(self: *Build, argv: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) *Step.Run {</span>
<span class="line" id="L954">    assert(argv.len &gt;= <span class="tok-number">1</span>);</span>
<span class="line" id="L955">    <span class="tok-kw">const</span> run_step = Step.Run.create(self, self.fmt(<span class="tok-str">&quot;run {s}&quot;</span>, .{argv[<span class="tok-number">0</span>]}));</span>
<span class="line" id="L956">    run_step.addArgs(argv);</span>
<span class="line" id="L957">    <span class="tok-kw">return</span> run_step;</span>
<span class="line" id="L958">}</span>
<span class="line" id="L959"></span>
<span class="line" id="L960"><span class="tok-comment">/// Creates a `Step.Run` with an executable built with `addExecutable`.</span></span>
<span class="line" id="L961"><span class="tok-comment">/// Add command line arguments with methods of `Step.Run`.</span></span>
<span class="line" id="L962"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addRunArtifact</span>(b: *Build, exe: *Step.Compile) *Step.Run {</span>
<span class="line" id="L963">    <span class="tok-comment">// It doesn't have to be native. We catch that if you actually try to run it.</span>
</span>
<span class="line" id="L964">    <span class="tok-comment">// Consider that this is declarative; the run step may not be run unless a user</span>
</span>
<span class="line" id="L965">    <span class="tok-comment">// option is supplied.</span>
</span>
<span class="line" id="L966">    <span class="tok-kw">const</span> run_step = Step.Run.create(b, b.fmt(<span class="tok-str">&quot;run {s}&quot;</span>, .{exe.name}));</span>
<span class="line" id="L967">    run_step.addArtifactArg(exe);</span>
<span class="line" id="L968"></span>
<span class="line" id="L969">    <span class="tok-kw">if</span> (exe.kind == .@&quot;test&quot; <span class="tok-kw">and</span> exe.test_server_mode) {</span>
<span class="line" id="L970">        run_step.enableTestRunnerMode();</span>
<span class="line" id="L971">    }</span>
<span class="line" id="L972"></span>
<span class="line" id="L973">    <span class="tok-kw">return</span> run_step;</span>
<span class="line" id="L974">}</span>
<span class="line" id="L975"></span>
<span class="line" id="L976"><span class="tok-comment">/// Using the `values` provided, produces a C header file, possibly based on a</span></span>
<span class="line" id="L977"><span class="tok-comment">/// template input file (e.g. config.h.in).</span></span>
<span class="line" id="L978"><span class="tok-comment">/// When an input template file is provided, this function will fail the build</span></span>
<span class="line" id="L979"><span class="tok-comment">/// when an option not found in the input file is provided in `values`, and</span></span>
<span class="line" id="L980"><span class="tok-comment">/// when an option found in the input file is missing from `values`.</span></span>
<span class="line" id="L981"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addConfigHeader</span>(</span>
<span class="line" id="L982">    b: *Build,</span>
<span class="line" id="L983">    options: Step.ConfigHeader.Options,</span>
<span class="line" id="L984">    values: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L985">) *Step.ConfigHeader {</span>
<span class="line" id="L986">    <span class="tok-kw">var</span> options_copy = options;</span>
<span class="line" id="L987">    <span class="tok-kw">if</span> (options_copy.first_ret_addr == <span class="tok-null">null</span>)</span>
<span class="line" id="L988">        options_copy.first_ret_addr = <span class="tok-builtin">@returnAddress</span>();</span>
<span class="line" id="L989"></span>
<span class="line" id="L990">    <span class="tok-kw">const</span> config_header_step = Step.ConfigHeader.create(b, options_copy);</span>
<span class="line" id="L991">    config_header_step.addValues(values);</span>
<span class="line" id="L992">    <span class="tok-kw">return</span> config_header_step;</span>
<span class="line" id="L993">}</span>
<span class="line" id="L994"></span>
<span class="line" id="L995"><span class="tok-comment">/// Allocator.dupe without the need to handle out of memory.</span></span>
<span class="line" id="L996"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dupe</span>(self: *Build, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) []<span class="tok-type">u8</span> {</span>
<span class="line" id="L997">    <span class="tok-kw">return</span> self.allocator.dupe(<span class="tok-type">u8</span>, bytes) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L998">}</span>
<span class="line" id="L999"></span>
<span class="line" id="L1000"><span class="tok-comment">/// Duplicates an array of strings without the need to handle out of memory.</span></span>
<span class="line" id="L1001"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dupeStrings</span>(self: *Build, strings: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) [][]<span class="tok-type">u8</span> {</span>
<span class="line" id="L1002">    <span class="tok-kw">const</span> array = self.allocator.alloc([]<span class="tok-type">u8</span>, strings.len) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L1003">    <span class="tok-kw">for</span> (array, strings) |*dest, source| dest.* = self.dupe(source);</span>
<span class="line" id="L1004">    <span class="tok-kw">return</span> array;</span>
<span class="line" id="L1005">}</span>
<span class="line" id="L1006"></span>
<span class="line" id="L1007"><span class="tok-comment">/// Duplicates a path and converts all slashes to the OS's canonical path separator.</span></span>
<span class="line" id="L1008"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dupePath</span>(self: *Build, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) []<span class="tok-type">u8</span> {</span>
<span class="line" id="L1009">    <span class="tok-kw">const</span> the_copy = self.dupe(bytes);</span>
<span class="line" id="L1010">    <span class="tok-kw">for</span> (the_copy) |*byte| {</span>
<span class="line" id="L1011">        <span class="tok-kw">switch</span> (byte.*) {</span>
<span class="line" id="L1012">            <span class="tok-str">'/'</span>, <span class="tok-str">'\\'</span> =&gt; byte.* = fs.path.sep,</span>
<span class="line" id="L1013">            <span class="tok-kw">else</span> =&gt; {},</span>
<span class="line" id="L1014">        }</span>
<span class="line" id="L1015">    }</span>
<span class="line" id="L1016">    <span class="tok-kw">return</span> the_copy;</span>
<span class="line" id="L1017">}</span>
<span class="line" id="L1018"></span>
<span class="line" id="L1019"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addWriteFile</span>(self: *Build, file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) *Step.WriteFile {</span>
<span class="line" id="L1020">    <span class="tok-kw">const</span> write_file_step = self.addWriteFiles();</span>
<span class="line" id="L1021">    _ = write_file_step.add(file_path, data);</span>
<span class="line" id="L1022">    <span class="tok-kw">return</span> write_file_step;</span>
<span class="line" id="L1023">}</span>
<span class="line" id="L1024"></span>
<span class="line" id="L1025"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addNamedWriteFiles</span>(b: *Build, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) *Step.WriteFile {</span>
<span class="line" id="L1026">    <span class="tok-kw">const</span> wf = Step.WriteFile.create(b);</span>
<span class="line" id="L1027">    b.named_writefiles.put(b.dupe(name), wf) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L1028">    <span class="tok-kw">return</span> wf;</span>
<span class="line" id="L1029">}</span>
<span class="line" id="L1030"></span>
<span class="line" id="L1031"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addWriteFiles</span>(b: *Build) *Step.WriteFile {</span>
<span class="line" id="L1032">    <span class="tok-kw">return</span> Step.WriteFile.create(b);</span>
<span class="line" id="L1033">}</span>
<span class="line" id="L1034"></span>
<span class="line" id="L1035"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addRemoveDirTree</span>(self: *Build, dir_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) *Step.RemoveDir {</span>
<span class="line" id="L1036">    <span class="tok-kw">return</span> Step.RemoveDir.create(self, dir_path);</span>
<span class="line" id="L1037">}</span>
<span class="line" id="L1038"></span>
<span class="line" id="L1039"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addFmt</span>(b: *Build, options: Step.Fmt.Options) *Step.Fmt {</span>
<span class="line" id="L1040">    <span class="tok-kw">return</span> Step.Fmt.create(b, options);</span>
<span class="line" id="L1041">}</span>
<span class="line" id="L1042"></span>
<span class="line" id="L1043"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addTranslateC</span>(self: *Build, options: Step.TranslateC.Options) *Step.TranslateC {</span>
<span class="line" id="L1044">    <span class="tok-kw">return</span> Step.TranslateC.create(self, options);</span>
<span class="line" id="L1045">}</span>
<span class="line" id="L1046"></span>
<span class="line" id="L1047"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getInstallStep</span>(self: *Build) *Step {</span>
<span class="line" id="L1048">    <span class="tok-kw">return</span> &amp;self.install_tls.step;</span>
<span class="line" id="L1049">}</span>
<span class="line" id="L1050"></span>
<span class="line" id="L1051"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getUninstallStep</span>(self: *Build) *Step {</span>
<span class="line" id="L1052">    <span class="tok-kw">return</span> &amp;self.uninstall_tls.step;</span>
<span class="line" id="L1053">}</span>
<span class="line" id="L1054"></span>
<span class="line" id="L1055"><span class="tok-kw">fn</span> <span class="tok-fn">makeUninstall</span>(uninstall_step: *Step, prog_node: *std.Progress.Node) <span class="tok-type">anyerror</span>!<span class="tok-type">void</span> {</span>
<span class="line" id="L1056">    _ = prog_node;</span>
<span class="line" id="L1057">    <span class="tok-kw">const</span> uninstall_tls = <span class="tok-builtin">@fieldParentPtr</span>(TopLevelStep, <span class="tok-str">&quot;step&quot;</span>, uninstall_step);</span>
<span class="line" id="L1058">    <span class="tok-kw">const</span> self = <span class="tok-builtin">@fieldParentPtr</span>(Build, <span class="tok-str">&quot;uninstall_tls&quot;</span>, uninstall_tls);</span>
<span class="line" id="L1059"></span>
<span class="line" id="L1060">    <span class="tok-kw">for</span> (self.installed_files.items) |installed_file| {</span>
<span class="line" id="L1061">        <span class="tok-kw">const</span> full_path = self.getInstallPath(installed_file.dir, installed_file.path);</span>
<span class="line" id="L1062">        <span class="tok-kw">if</span> (self.verbose) {</span>
<span class="line" id="L1063">            log.info(<span class="tok-str">&quot;rm {s}&quot;</span>, .{full_path});</span>
<span class="line" id="L1064">        }</span>
<span class="line" id="L1065">        fs.cwd().deleteTree(full_path) <span class="tok-kw">catch</span> {};</span>
<span class="line" id="L1066">    }</span>
<span class="line" id="L1067"></span>
<span class="line" id="L1068">    <span class="tok-comment">// TODO remove empty directories</span>
</span>
<span class="line" id="L1069">}</span>
<span class="line" id="L1070"></span>
<span class="line" id="L1071"><span class="tok-comment">/// Creates a configuration option to be passed to the build.zig script.</span></span>
<span class="line" id="L1072"><span class="tok-comment">/// When a user directly runs `zig build`, they can set these options with `-D` arguments.</span></span>
<span class="line" id="L1073"><span class="tok-comment">/// When a project depends on a Zig package as a dependency, it programmatically sets</span></span>
<span class="line" id="L1074"><span class="tok-comment">/// these options when calling the dependency's build.zig script as a function.</span></span>
<span class="line" id="L1075"><span class="tok-comment">/// `null` is returned when an option is left to default.</span></span>
<span class="line" id="L1076"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">option</span>(self: *Build, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, name_raw: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, description_raw: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ?T {</span>
<span class="line" id="L1077">    <span class="tok-kw">const</span> name = self.dupe(name_raw);</span>
<span class="line" id="L1078">    <span class="tok-kw">const</span> description = self.dupe(description_raw);</span>
<span class="line" id="L1079">    <span class="tok-kw">const</span> type_id = <span class="tok-kw">comptime</span> typeToEnum(T);</span>
<span class="line" id="L1080">    <span class="tok-kw">const</span> enum_options = <span class="tok-kw">if</span> (type_id == .@&quot;enum&quot;) blk: {</span>
<span class="line" id="L1081">        <span class="tok-kw">const</span> fields = <span class="tok-kw">comptime</span> std.meta.fields(T);</span>
<span class="line" id="L1082">        <span class="tok-kw">var</span> options = ArrayList([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>).initCapacity(self.allocator, fields.len) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L1083"></span>
<span class="line" id="L1084">        <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (fields) |field| {</span>
<span class="line" id="L1085">            options.appendAssumeCapacity(field.name);</span>
<span class="line" id="L1086">        }</span>
<span class="line" id="L1087"></span>
<span class="line" id="L1088">        <span class="tok-kw">break</span> :blk options.toOwnedSlice() <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L1089">    } <span class="tok-kw">else</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L1090">    <span class="tok-kw">const</span> available_option = AvailableOption{</span>
<span class="line" id="L1091">        .name = name,</span>
<span class="line" id="L1092">        .type_id = type_id,</span>
<span class="line" id="L1093">        .description = description,</span>
<span class="line" id="L1094">        .enum_options = enum_options,</span>
<span class="line" id="L1095">    };</span>
<span class="line" id="L1096">    <span class="tok-kw">if</span> ((self.available_options_map.fetchPut(name, available_option) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>)) != <span class="tok-null">null</span>) {</span>
<span class="line" id="L1097">        panic(<span class="tok-str">&quot;Option '{s}' declared twice&quot;</span>, .{name});</span>
<span class="line" id="L1098">    }</span>
<span class="line" id="L1099">    self.available_options_list.append(available_option) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L1100"></span>
<span class="line" id="L1101">    <span class="tok-kw">const</span> option_ptr = self.user_input_options.getPtr(name) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L1102">    option_ptr.used = <span class="tok-null">true</span>;</span>
<span class="line" id="L1103">    <span class="tok-kw">switch</span> (type_id) {</span>
<span class="line" id="L1104">        .<span class="tok-type">bool</span> =&gt; <span class="tok-kw">switch</span> (option_ptr.value) {</span>
<span class="line" id="L1105">            .flag =&gt; <span class="tok-kw">return</span> <span class="tok-null">true</span>,</span>
<span class="line" id="L1106">            .scalar =&gt; |s| {</span>
<span class="line" id="L1107">                <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, s, <span class="tok-str">&quot;true&quot;</span>)) {</span>
<span class="line" id="L1108">                    <span class="tok-kw">return</span> <span class="tok-null">true</span>;</span>
<span class="line" id="L1109">                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, s, <span class="tok-str">&quot;false&quot;</span>)) {</span>
<span class="line" id="L1110">                    <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L1111">                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1112">                    log.err(<span class="tok-str">&quot;Expected -D{s} to be a boolean, but received '{s}'&quot;</span>, .{ name, s });</span>
<span class="line" id="L1113">                    self.markInvalidUserInput();</span>
<span class="line" id="L1114">                    <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L1115">                }</span>
<span class="line" id="L1116">            },</span>
<span class="line" id="L1117">            .list, .map =&gt; {</span>
<span class="line" id="L1118">                log.err(<span class="tok-str">&quot;Expected -D{s} to be a boolean, but received a {s}.&quot;</span>, .{</span>
<span class="line" id="L1119">                    name, <span class="tok-builtin">@tagName</span>(option_ptr.value),</span>
<span class="line" id="L1120">                });</span>
<span class="line" id="L1121">                self.markInvalidUserInput();</span>
<span class="line" id="L1122">                <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L1123">            },</span>
<span class="line" id="L1124">        },</span>
<span class="line" id="L1125">        .int =&gt; <span class="tok-kw">switch</span> (option_ptr.value) {</span>
<span class="line" id="L1126">            .flag, .list, .map =&gt; {</span>
<span class="line" id="L1127">                log.err(<span class="tok-str">&quot;Expected -D{s} to be an integer, but received a {s}.&quot;</span>, .{</span>
<span class="line" id="L1128">                    name, <span class="tok-builtin">@tagName</span>(option_ptr.value),</span>
<span class="line" id="L1129">                });</span>
<span class="line" id="L1130">                self.markInvalidUserInput();</span>
<span class="line" id="L1131">                <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L1132">            },</span>
<span class="line" id="L1133">            .scalar =&gt; |s| {</span>
<span class="line" id="L1134">                <span class="tok-kw">const</span> n = std.fmt.parseInt(T, s, <span class="tok-number">10</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1135">                    <span class="tok-kw">error</span>.Overflow =&gt; {</span>
<span class="line" id="L1136">                        log.err(<span class="tok-str">&quot;-D{s} value {s} cannot fit into type {s}.&quot;</span>, .{ name, s, <span class="tok-builtin">@typeName</span>(T) });</span>
<span class="line" id="L1137">                        self.markInvalidUserInput();</span>
<span class="line" id="L1138">                        <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L1139">                    },</span>
<span class="line" id="L1140">                    <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L1141">                        log.err(<span class="tok-str">&quot;Expected -D{s} to be an integer of type {s}.&quot;</span>, .{ name, <span class="tok-builtin">@typeName</span>(T) });</span>
<span class="line" id="L1142">                        self.markInvalidUserInput();</span>
<span class="line" id="L1143">                        <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L1144">                    },</span>
<span class="line" id="L1145">                };</span>
<span class="line" id="L1146">                <span class="tok-kw">return</span> n;</span>
<span class="line" id="L1147">            },</span>
<span class="line" id="L1148">        },</span>
<span class="line" id="L1149">        .float =&gt; <span class="tok-kw">switch</span> (option_ptr.value) {</span>
<span class="line" id="L1150">            .flag, .map, .list =&gt; {</span>
<span class="line" id="L1151">                log.err(<span class="tok-str">&quot;Expected -D{s} to be a float, but received a {s}.&quot;</span>, .{</span>
<span class="line" id="L1152">                    name, <span class="tok-builtin">@tagName</span>(option_ptr.value),</span>
<span class="line" id="L1153">                });</span>
<span class="line" id="L1154">                self.markInvalidUserInput();</span>
<span class="line" id="L1155">                <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L1156">            },</span>
<span class="line" id="L1157">            .scalar =&gt; |s| {</span>
<span class="line" id="L1158">                <span class="tok-kw">const</span> n = std.fmt.parseFloat(T, s) <span class="tok-kw">catch</span> {</span>
<span class="line" id="L1159">                    log.err(<span class="tok-str">&quot;Expected -D{s} to be a float of type {s}.&quot;</span>, .{ name, <span class="tok-builtin">@typeName</span>(T) });</span>
<span class="line" id="L1160">                    self.markInvalidUserInput();</span>
<span class="line" id="L1161">                    <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L1162">                };</span>
<span class="line" id="L1163">                <span class="tok-kw">return</span> n;</span>
<span class="line" id="L1164">            },</span>
<span class="line" id="L1165">        },</span>
<span class="line" id="L1166">        .@&quot;enum&quot; =&gt; <span class="tok-kw">switch</span> (option_ptr.value) {</span>
<span class="line" id="L1167">            .flag, .map, .list =&gt; {</span>
<span class="line" id="L1168">                log.err(<span class="tok-str">&quot;Expected -D{s} to be an enum, but received a {s}.&quot;</span>, .{</span>
<span class="line" id="L1169">                    name, <span class="tok-builtin">@tagName</span>(option_ptr.value),</span>
<span class="line" id="L1170">                });</span>
<span class="line" id="L1171">                self.markInvalidUserInput();</span>
<span class="line" id="L1172">                <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L1173">            },</span>
<span class="line" id="L1174">            .scalar =&gt; |s| {</span>
<span class="line" id="L1175">                <span class="tok-kw">if</span> (std.meta.stringToEnum(T, s)) |enum_lit| {</span>
<span class="line" id="L1176">                    <span class="tok-kw">return</span> enum_lit;</span>
<span class="line" id="L1177">                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1178">                    log.err(<span class="tok-str">&quot;Expected -D{s} to be of type {s}.&quot;</span>, .{ name, <span class="tok-builtin">@typeName</span>(T) });</span>
<span class="line" id="L1179">                    self.markInvalidUserInput();</span>
<span class="line" id="L1180">                    <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L1181">                }</span>
<span class="line" id="L1182">            },</span>
<span class="line" id="L1183">        },</span>
<span class="line" id="L1184">        .string =&gt; <span class="tok-kw">switch</span> (option_ptr.value) {</span>
<span class="line" id="L1185">            .flag, .list, .map =&gt; {</span>
<span class="line" id="L1186">                log.err(<span class="tok-str">&quot;Expected -D{s} to be a string, but received a {s}.&quot;</span>, .{</span>
<span class="line" id="L1187">                    name, <span class="tok-builtin">@tagName</span>(option_ptr.value),</span>
<span class="line" id="L1188">                });</span>
<span class="line" id="L1189">                self.markInvalidUserInput();</span>
<span class="line" id="L1190">                <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L1191">            },</span>
<span class="line" id="L1192">            .scalar =&gt; |s| <span class="tok-kw">return</span> s,</span>
<span class="line" id="L1193">        },</span>
<span class="line" id="L1194">        .build_id =&gt; <span class="tok-kw">switch</span> (option_ptr.value) {</span>
<span class="line" id="L1195">            .flag, .map, .list =&gt; {</span>
<span class="line" id="L1196">                log.err(<span class="tok-str">&quot;Expected -D{s} to be an enum, but received a {s}.&quot;</span>, .{</span>
<span class="line" id="L1197">                    name, <span class="tok-builtin">@tagName</span>(option_ptr.value),</span>
<span class="line" id="L1198">                });</span>
<span class="line" id="L1199">                self.markInvalidUserInput();</span>
<span class="line" id="L1200">                <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L1201">            },</span>
<span class="line" id="L1202">            .scalar =&gt; |s| {</span>
<span class="line" id="L1203">                <span class="tok-kw">if</span> (std.zig.BuildId.parse(s)) |build_id| {</span>
<span class="line" id="L1204">                    <span class="tok-kw">return</span> build_id;</span>
<span class="line" id="L1205">                } <span class="tok-kw">else</span> |err| {</span>
<span class="line" id="L1206">                    log.err(<span class="tok-str">&quot;unable to parse option '-D{s}': {s}&quot;</span>, .{ name, <span class="tok-builtin">@errorName</span>(err) });</span>
<span class="line" id="L1207">                    self.markInvalidUserInput();</span>
<span class="line" id="L1208">                    <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L1209">                }</span>
<span class="line" id="L1210">            },</span>
<span class="line" id="L1211">        },</span>
<span class="line" id="L1212">        .list =&gt; <span class="tok-kw">switch</span> (option_ptr.value) {</span>
<span class="line" id="L1213">            .flag, .map =&gt; {</span>
<span class="line" id="L1214">                log.err(<span class="tok-str">&quot;Expected -D{s} to be a list, but received a {s}.&quot;</span>, .{</span>
<span class="line" id="L1215">                    name, <span class="tok-builtin">@tagName</span>(option_ptr.value),</span>
<span class="line" id="L1216">                });</span>
<span class="line" id="L1217">                self.markInvalidUserInput();</span>
<span class="line" id="L1218">                <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L1219">            },</span>
<span class="line" id="L1220">            .scalar =&gt; |s| {</span>
<span class="line" id="L1221">                <span class="tok-kw">return</span> self.allocator.dupe([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{s}) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L1222">            },</span>
<span class="line" id="L1223">            .list =&gt; |lst| <span class="tok-kw">return</span> lst.items,</span>
<span class="line" id="L1224">        },</span>
<span class="line" id="L1225">    }</span>
<span class="line" id="L1226">}</span>
<span class="line" id="L1227"></span>
<span class="line" id="L1228"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">step</span>(self: *Build, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, description: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) *Step {</span>
<span class="line" id="L1229">    <span class="tok-kw">const</span> step_info = self.allocator.create(TopLevelStep) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L1230">    step_info.* = .{</span>
<span class="line" id="L1231">        .step = Step.init(.{</span>
<span class="line" id="L1232">            .id = .top_level,</span>
<span class="line" id="L1233">            .name = name,</span>
<span class="line" id="L1234">            .owner = self,</span>
<span class="line" id="L1235">        }),</span>
<span class="line" id="L1236">        .description = self.dupe(description),</span>
<span class="line" id="L1237">    };</span>
<span class="line" id="L1238">    <span class="tok-kw">const</span> gop = self.top_level_steps.getOrPut(self.allocator, name) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L1239">    <span class="tok-kw">if</span> (gop.found_existing) std.debug.panic(<span class="tok-str">&quot;A top-level step with name \&quot;{s}\&quot; already exists&quot;</span>, .{name});</span>
<span class="line" id="L1240"></span>
<span class="line" id="L1241">    gop.key_ptr.* = step_info.step.name;</span>
<span class="line" id="L1242">    gop.value_ptr.* = step_info;</span>
<span class="line" id="L1243"></span>
<span class="line" id="L1244">    <span class="tok-kw">return</span> &amp;step_info.step;</span>
<span class="line" id="L1245">}</span>
<span class="line" id="L1246"></span>
<span class="line" id="L1247"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> StandardOptimizeOptionOptions = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1248">    preferred_optimize_mode: ?std.builtin.OptimizeMode = <span class="tok-null">null</span>,</span>
<span class="line" id="L1249">};</span>
<span class="line" id="L1250"></span>
<span class="line" id="L1251"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">standardOptimizeOption</span>(b: *Build, options: StandardOptimizeOptionOptions) std.builtin.OptimizeMode {</span>
<span class="line" id="L1252">    <span class="tok-kw">if</span> (options.preferred_optimize_mode) |mode| {</span>
<span class="line" id="L1253">        <span class="tok-kw">if</span> (b.option(<span class="tok-type">bool</span>, <span class="tok-str">&quot;release&quot;</span>, <span class="tok-str">&quot;optimize for end users&quot;</span>) <span class="tok-kw">orelse</span> (b.release_mode != .off)) {</span>
<span class="line" id="L1254">            <span class="tok-kw">return</span> mode;</span>
<span class="line" id="L1255">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1256">            <span class="tok-kw">return</span> .Debug;</span>
<span class="line" id="L1257">        }</span>
<span class="line" id="L1258">    }</span>
<span class="line" id="L1259"></span>
<span class="line" id="L1260">    <span class="tok-kw">if</span> (b.option(</span>
<span class="line" id="L1261">        std.builtin.OptimizeMode,</span>
<span class="line" id="L1262">        <span class="tok-str">&quot;optimize&quot;</span>,</span>
<span class="line" id="L1263">        <span class="tok-str">&quot;Prioritize performance, safety, or binary size&quot;</span>,</span>
<span class="line" id="L1264">    )) |mode| {</span>
<span class="line" id="L1265">        <span class="tok-kw">return</span> mode;</span>
<span class="line" id="L1266">    }</span>
<span class="line" id="L1267"></span>
<span class="line" id="L1268">    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (b.release_mode) {</span>
<span class="line" id="L1269">        .off =&gt; .Debug,</span>
<span class="line" id="L1270">        .any =&gt; {</span>
<span class="line" id="L1271">            std.debug.print(<span class="tok-str">&quot;the project does not declare a preferred optimization mode. choose: --release=fast, --release=safe, or --release=small\n&quot;</span>, .{});</span>
<span class="line" id="L1272">            process.exit(<span class="tok-number">1</span>);</span>
<span class="line" id="L1273">        },</span>
<span class="line" id="L1274">        .fast =&gt; .ReleaseFast,</span>
<span class="line" id="L1275">        .safe =&gt; .ReleaseSafe,</span>
<span class="line" id="L1276">        .small =&gt; .ReleaseSmall,</span>
<span class="line" id="L1277">    };</span>
<span class="line" id="L1278">}</span>
<span class="line" id="L1279"></span>
<span class="line" id="L1280"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> StandardTargetOptionsArgs = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1281">    whitelist: ?[]<span class="tok-kw">const</span> Target.Query = <span class="tok-null">null</span>,</span>
<span class="line" id="L1282">    default_target: Target.Query = .{},</span>
<span class="line" id="L1283">};</span>
<span class="line" id="L1284"></span>
<span class="line" id="L1285"><span class="tok-comment">/// Exposes standard `zig build` options for choosing a target and additionally</span></span>
<span class="line" id="L1286"><span class="tok-comment">/// resolves the target query.</span></span>
<span class="line" id="L1287"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">standardTargetOptions</span>(b: *Build, args: StandardTargetOptionsArgs) ResolvedTarget {</span>
<span class="line" id="L1288">    <span class="tok-kw">const</span> query = b.standardTargetOptionsQueryOnly(args);</span>
<span class="line" id="L1289">    <span class="tok-kw">return</span> b.resolveTargetQuery(query);</span>
<span class="line" id="L1290">}</span>
<span class="line" id="L1291"></span>
<span class="line" id="L1292"><span class="tok-comment">/// Obtain a target query from a string, reporting diagnostics to stderr if the</span></span>
<span class="line" id="L1293"><span class="tok-comment">/// parsing failed.</span></span>
<span class="line" id="L1294"><span class="tok-comment">/// Asserts that the `diagnostics` field of `options` is `null`. This use case</span></span>
<span class="line" id="L1295"><span class="tok-comment">/// is handled instead by calling `std.Target.Query.parse` directly.</span></span>
<span class="line" id="L1296"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">parseTargetQuery</span>(options: std.Target.Query.ParseOptions) <span class="tok-kw">error</span>{ParseFailed}!std.Target.Query {</span>
<span class="line" id="L1297">    assert(options.diagnostics == <span class="tok-null">null</span>);</span>
<span class="line" id="L1298">    <span class="tok-kw">var</span> diags: Target.Query.ParseOptions.Diagnostics = .{};</span>
<span class="line" id="L1299">    <span class="tok-kw">var</span> opts_copy = options;</span>
<span class="line" id="L1300">    opts_copy.diagnostics = &amp;diags;</span>
<span class="line" id="L1301">    <span class="tok-kw">return</span> std.Target.Query.parse(opts_copy) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1302">        <span class="tok-kw">error</span>.UnknownCpuModel =&gt; {</span>
<span class="line" id="L1303">            std.debug.print(<span class="tok-str">&quot;unknown CPU: '{s}'\navailable CPUs for architecture '{s}':\n&quot;</span>, .{</span>
<span class="line" id="L1304">                diags.cpu_name.?, <span class="tok-builtin">@tagName</span>(diags.arch.?),</span>
<span class="line" id="L1305">            });</span>
<span class="line" id="L1306">            <span class="tok-kw">for</span> (diags.arch.?.allCpuModels()) |cpu| {</span>
<span class="line" id="L1307">                std.debug.print(<span class="tok-str">&quot; {s}\n&quot;</span>, .{cpu.name});</span>
<span class="line" id="L1308">            }</span>
<span class="line" id="L1309">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ParseFailed;</span>
<span class="line" id="L1310">        },</span>
<span class="line" id="L1311">        <span class="tok-kw">error</span>.UnknownCpuFeature =&gt; {</span>
<span class="line" id="L1312">            std.debug.print(</span>
<span class="line" id="L1313">                <span class="tok-str">\\unknown CPU feature: '{s}'</span></span>

<span class="line" id="L1314">                <span class="tok-str">\\available CPU features for architecture '{s}':</span></span>

<span class="line" id="L1315">                <span class="tok-str">\\</span></span>

<span class="line" id="L1316">            , .{</span>
<span class="line" id="L1317">                diags.unknown_feature_name.?,</span>
<span class="line" id="L1318">                <span class="tok-builtin">@tagName</span>(diags.arch.?),</span>
<span class="line" id="L1319">            });</span>
<span class="line" id="L1320">            <span class="tok-kw">for</span> (diags.arch.?.allFeaturesList()) |feature| {</span>
<span class="line" id="L1321">                std.debug.print(<span class="tok-str">&quot; {s}: {s}\n&quot;</span>, .{ feature.name, feature.description });</span>
<span class="line" id="L1322">            }</span>
<span class="line" id="L1323">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ParseFailed;</span>
<span class="line" id="L1324">        },</span>
<span class="line" id="L1325">        <span class="tok-kw">error</span>.UnknownOperatingSystem =&gt; {</span>
<span class="line" id="L1326">            std.debug.print(</span>
<span class="line" id="L1327">                <span class="tok-str">\\unknown OS: '{s}'</span></span>

<span class="line" id="L1328">                <span class="tok-str">\\available operating systems:</span></span>

<span class="line" id="L1329">                <span class="tok-str">\\</span></span>

<span class="line" id="L1330">            , .{diags.os_name.?});</span>
<span class="line" id="L1331">            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (std.meta.fields(Target.Os.Tag)) |field| {</span>
<span class="line" id="L1332">                std.debug.print(<span class="tok-str">&quot; {s}\n&quot;</span>, .{field.name});</span>
<span class="line" id="L1333">            }</span>
<span class="line" id="L1334">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ParseFailed;</span>
<span class="line" id="L1335">        },</span>
<span class="line" id="L1336">        <span class="tok-kw">else</span> =&gt; |e| {</span>
<span class="line" id="L1337">            std.debug.print(<span class="tok-str">&quot;unable to parse target '{s}': {s}\n&quot;</span>, .{</span>
<span class="line" id="L1338">                options.arch_os_abi, <span class="tok-builtin">@errorName</span>(e),</span>
<span class="line" id="L1339">            });</span>
<span class="line" id="L1340">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ParseFailed;</span>
<span class="line" id="L1341">        },</span>
<span class="line" id="L1342">    };</span>
<span class="line" id="L1343">}</span>
<span class="line" id="L1344"></span>
<span class="line" id="L1345"><span class="tok-comment">/// Exposes standard `zig build` options for choosing a target.</span></span>
<span class="line" id="L1346"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">standardTargetOptionsQueryOnly</span>(b: *Build, args: StandardTargetOptionsArgs) Target.Query {</span>
<span class="line" id="L1347">    <span class="tok-kw">const</span> maybe_triple = b.option(</span>
<span class="line" id="L1348">        []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1349">        <span class="tok-str">&quot;target&quot;</span>,</span>
<span class="line" id="L1350">        <span class="tok-str">&quot;The CPU architecture, OS, and ABI to build for&quot;</span>,</span>
<span class="line" id="L1351">    );</span>
<span class="line" id="L1352">    <span class="tok-kw">const</span> mcpu = b.option(</span>
<span class="line" id="L1353">        []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1354">        <span class="tok-str">&quot;cpu&quot;</span>,</span>
<span class="line" id="L1355">        <span class="tok-str">&quot;Target CPU features to add or subtract&quot;</span>,</span>
<span class="line" id="L1356">    );</span>
<span class="line" id="L1357">    <span class="tok-kw">const</span> dynamic_linker = b.option(</span>
<span class="line" id="L1358">        []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1359">        <span class="tok-str">&quot;dynamic-linker&quot;</span>,</span>
<span class="line" id="L1360">        <span class="tok-str">&quot;Path to interpreter on the target system&quot;</span>,</span>
<span class="line" id="L1361">    );</span>
<span class="line" id="L1362"></span>
<span class="line" id="L1363">    <span class="tok-kw">if</span> (maybe_triple == <span class="tok-null">null</span> <span class="tok-kw">and</span> mcpu == <span class="tok-null">null</span> <span class="tok-kw">and</span> dynamic_linker == <span class="tok-null">null</span>)</span>
<span class="line" id="L1364">        <span class="tok-kw">return</span> args.default_target;</span>
<span class="line" id="L1365"></span>
<span class="line" id="L1366">    <span class="tok-kw">const</span> triple = maybe_triple <span class="tok-kw">orelse</span> <span class="tok-str">&quot;native&quot;</span>;</span>
<span class="line" id="L1367"></span>
<span class="line" id="L1368">    <span class="tok-kw">const</span> selected_target = parseTargetQuery(.{</span>
<span class="line" id="L1369">        .arch_os_abi = triple,</span>
<span class="line" id="L1370">        .cpu_features = mcpu,</span>
<span class="line" id="L1371">        .dynamic_linker = dynamic_linker,</span>
<span class="line" id="L1372">    }) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1373">        <span class="tok-kw">error</span>.ParseFailed =&gt; {</span>
<span class="line" id="L1374">            b.markInvalidUserInput();</span>
<span class="line" id="L1375">            <span class="tok-kw">return</span> args.default_target;</span>
<span class="line" id="L1376">        },</span>
<span class="line" id="L1377">    };</span>
<span class="line" id="L1378"></span>
<span class="line" id="L1379">    <span class="tok-kw">const</span> whitelist = args.whitelist <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> selected_target;</span>
<span class="line" id="L1380"></span>
<span class="line" id="L1381">    <span class="tok-comment">// Make sure it's a match of one of the list.</span>
</span>
<span class="line" id="L1382">    <span class="tok-kw">for</span> (whitelist) |q| {</span>
<span class="line" id="L1383">        <span class="tok-kw">if</span> (q.eql(selected_target))</span>
<span class="line" id="L1384">            <span class="tok-kw">return</span> selected_target;</span>
<span class="line" id="L1385">    }</span>
<span class="line" id="L1386"></span>
<span class="line" id="L1387">    <span class="tok-kw">for</span> (whitelist) |q| {</span>
<span class="line" id="L1388">        log.info(<span class="tok-str">&quot;allowed target: -Dtarget={s} -Dcpu={s}&quot;</span>, .{</span>
<span class="line" id="L1389">            q.zigTriple(b.allocator) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>),</span>
<span class="line" id="L1390">            q.serializeCpuAlloc(b.allocator) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>),</span>
<span class="line" id="L1391">        });</span>
<span class="line" id="L1392">    }</span>
<span class="line" id="L1393">    log.err(<span class="tok-str">&quot;chosen target '{s}' does not match one of the allowed targets&quot;</span>, .{</span>
<span class="line" id="L1394">        selected_target.zigTriple(b.allocator) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>),</span>
<span class="line" id="L1395">    });</span>
<span class="line" id="L1396">    b.markInvalidUserInput();</span>
<span class="line" id="L1397">    <span class="tok-kw">return</span> args.default_target;</span>
<span class="line" id="L1398">}</span>
<span class="line" id="L1399"></span>
<span class="line" id="L1400"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addUserInputOption</span>(self: *Build, name_raw: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, value_raw: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">bool</span> {</span>
<span class="line" id="L1401">    <span class="tok-kw">const</span> name = self.dupe(name_raw);</span>
<span class="line" id="L1402">    <span class="tok-kw">const</span> value = self.dupe(value_raw);</span>
<span class="line" id="L1403">    <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> self.user_input_options.getOrPut(name);</span>
<span class="line" id="L1404">    <span class="tok-kw">if</span> (!gop.found_existing) {</span>
<span class="line" id="L1405">        gop.value_ptr.* = UserInputOption{</span>
<span class="line" id="L1406">            .name = name,</span>
<span class="line" id="L1407">            .value = .{ .scalar = value },</span>
<span class="line" id="L1408">            .used = <span class="tok-null">false</span>,</span>
<span class="line" id="L1409">        };</span>
<span class="line" id="L1410">        <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L1411">    }</span>
<span class="line" id="L1412"></span>
<span class="line" id="L1413">    <span class="tok-comment">// option already exists</span>
</span>
<span class="line" id="L1414">    <span class="tok-kw">switch</span> (gop.value_ptr.value) {</span>
<span class="line" id="L1415">        .scalar =&gt; |s| {</span>
<span class="line" id="L1416">            <span class="tok-comment">// turn it into a list</span>
</span>
<span class="line" id="L1417">            <span class="tok-kw">var</span> list = ArrayList([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>).init(self.allocator);</span>
<span class="line" id="L1418">            <span class="tok-kw">try</span> list.append(s);</span>
<span class="line" id="L1419">            <span class="tok-kw">try</span> list.append(value);</span>
<span class="line" id="L1420">            <span class="tok-kw">try</span> self.user_input_options.put(name, .{</span>
<span class="line" id="L1421">                .name = name,</span>
<span class="line" id="L1422">                .value = .{ .list = list },</span>
<span class="line" id="L1423">                .used = <span class="tok-null">false</span>,</span>
<span class="line" id="L1424">            });</span>
<span class="line" id="L1425">        },</span>
<span class="line" id="L1426">        .list =&gt; |*list| {</span>
<span class="line" id="L1427">            <span class="tok-comment">// append to the list</span>
</span>
<span class="line" id="L1428">            <span class="tok-kw">try</span> list.append(value);</span>
<span class="line" id="L1429">            <span class="tok-kw">try</span> self.user_input_options.put(name, .{</span>
<span class="line" id="L1430">                .name = name,</span>
<span class="line" id="L1431">                .value = .{ .list = list.* },</span>
<span class="line" id="L1432">                .used = <span class="tok-null">false</span>,</span>
<span class="line" id="L1433">            });</span>
<span class="line" id="L1434">        },</span>
<span class="line" id="L1435">        .flag =&gt; {</span>
<span class="line" id="L1436">            log.warn(<span class="tok-str">&quot;option '-D{s}={s}' conflicts with flag '-D{s}'.&quot;</span>, .{ name, value, name });</span>
<span class="line" id="L1437">            <span class="tok-kw">return</span> <span class="tok-null">true</span>;</span>
<span class="line" id="L1438">        },</span>
<span class="line" id="L1439">        .map =&gt; |*map| {</span>
<span class="line" id="L1440">            _ = map;</span>
<span class="line" id="L1441">            log.warn(<span class="tok-str">&quot;TODO maps as command line arguments is not implemented yet.&quot;</span>, .{});</span>
<span class="line" id="L1442">            <span class="tok-kw">return</span> <span class="tok-null">true</span>;</span>
<span class="line" id="L1443">        },</span>
<span class="line" id="L1444">    }</span>
<span class="line" id="L1445">    <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L1446">}</span>
<span class="line" id="L1447"></span>
<span class="line" id="L1448"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addUserInputFlag</span>(self: *Build, name_raw: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">bool</span> {</span>
<span class="line" id="L1449">    <span class="tok-kw">const</span> name = self.dupe(name_raw);</span>
<span class="line" id="L1450">    <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> self.user_input_options.getOrPut(name);</span>
<span class="line" id="L1451">    <span class="tok-kw">if</span> (!gop.found_existing) {</span>
<span class="line" id="L1452">        gop.value_ptr.* = .{</span>
<span class="line" id="L1453">            .name = name,</span>
<span class="line" id="L1454">            .value = .{ .flag = {} },</span>
<span class="line" id="L1455">            .used = <span class="tok-null">false</span>,</span>
<span class="line" id="L1456">        };</span>
<span class="line" id="L1457">        <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L1458">    }</span>
<span class="line" id="L1459"></span>
<span class="line" id="L1460">    <span class="tok-comment">// option already exists</span>
</span>
<span class="line" id="L1461">    <span class="tok-kw">switch</span> (gop.value_ptr.value) {</span>
<span class="line" id="L1462">        .scalar =&gt; |s| {</span>
<span class="line" id="L1463">            log.err(<span class="tok-str">&quot;Flag '-D{s}' conflicts with option '-D{s}={s}'.&quot;</span>, .{ name, name, s });</span>
<span class="line" id="L1464">            <span class="tok-kw">return</span> <span class="tok-null">true</span>;</span>
<span class="line" id="L1465">        },</span>
<span class="line" id="L1466">        .list, .map =&gt; {</span>
<span class="line" id="L1467">            log.err(<span class="tok-str">&quot;Flag '-D{s}' conflicts with multiple options of the same name.&quot;</span>, .{name});</span>
<span class="line" id="L1468">            <span class="tok-kw">return</span> <span class="tok-null">true</span>;</span>
<span class="line" id="L1469">        },</span>
<span class="line" id="L1470">        .flag =&gt; {},</span>
<span class="line" id="L1471">    }</span>
<span class="line" id="L1472">    <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L1473">}</span>
<span class="line" id="L1474"></span>
<span class="line" id="L1475"><span class="tok-kw">fn</span> <span class="tok-fn">typeToEnum</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) TypeId {</span>
<span class="line" id="L1476">    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (T) {</span>
<span class="line" id="L1477">        std.zig.BuildId =&gt; .build_id,</span>
<span class="line" id="L1478">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {</span>
<span class="line" id="L1479">            .Int =&gt; .int,</span>
<span class="line" id="L1480">            .Float =&gt; .float,</span>
<span class="line" id="L1481">            .Bool =&gt; .<span class="tok-type">bool</span>,</span>
<span class="line" id="L1482">            .Enum =&gt; .@&quot;enum&quot;,</span>
<span class="line" id="L1483">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">switch</span> (T) {</span>
<span class="line" id="L1484">                []<span class="tok-kw">const</span> <span class="tok-type">u8</span> =&gt; .string,</span>
<span class="line" id="L1485">                []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span> =&gt; .list,</span>
<span class="line" id="L1486">                <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Unsupported type: &quot;</span> ++ <span class="tok-builtin">@typeName</span>(T)),</span>
<span class="line" id="L1487">            },</span>
<span class="line" id="L1488">        },</span>
<span class="line" id="L1489">    };</span>
<span class="line" id="L1490">}</span>
<span class="line" id="L1491"></span>
<span class="line" id="L1492"><span class="tok-kw">fn</span> <span class="tok-fn">markInvalidUserInput</span>(self: *Build) <span class="tok-type">void</span> {</span>
<span class="line" id="L1493">    self.invalid_user_input = <span class="tok-null">true</span>;</span>
<span class="line" id="L1494">}</span>
<span class="line" id="L1495"></span>
<span class="line" id="L1496"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">validateUserInputDidItFail</span>(b: *Build) <span class="tok-type">bool</span> {</span>
<span class="line" id="L1497">    <span class="tok-comment">// Make sure all args are used.</span>
</span>
<span class="line" id="L1498">    <span class="tok-kw">var</span> it = b.user_input_options.iterator();</span>
<span class="line" id="L1499">    <span class="tok-kw">while</span> (it.next()) |entry| {</span>
<span class="line" id="L1500">        <span class="tok-kw">if</span> (!entry.value_ptr.used) {</span>
<span class="line" id="L1501">            log.err(<span class="tok-str">&quot;invalid option: -D{s}&quot;</span>, .{entry.key_ptr.*});</span>
<span class="line" id="L1502">            b.markInvalidUserInput();</span>
<span class="line" id="L1503">        }</span>
<span class="line" id="L1504">    }</span>
<span class="line" id="L1505"></span>
<span class="line" id="L1506">    <span class="tok-kw">return</span> b.invalid_user_input;</span>
<span class="line" id="L1507">}</span>
<span class="line" id="L1508"></span>
<span class="line" id="L1509"><span class="tok-kw">fn</span> <span class="tok-fn">allocPrintCmd</span>(ally: Allocator, opt_cwd: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, argv: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span> {</span>
<span class="line" id="L1510">    <span class="tok-kw">var</span> buf = ArrayList(<span class="tok-type">u8</span>).init(ally);</span>
<span class="line" id="L1511">    <span class="tok-kw">if</span> (opt_cwd) |cwd| <span class="tok-kw">try</span> buf.writer().print(<span class="tok-str">&quot;cd {s} &amp;&amp; &quot;</span>, .{cwd});</span>
<span class="line" id="L1512">    <span class="tok-kw">for</span> (argv) |arg| {</span>
<span class="line" id="L1513">        <span class="tok-kw">try</span> buf.writer().print(<span class="tok-str">&quot;{s} &quot;</span>, .{arg});</span>
<span class="line" id="L1514">    }</span>
<span class="line" id="L1515">    <span class="tok-kw">return</span> buf.toOwnedSlice();</span>
<span class="line" id="L1516">}</span>
<span class="line" id="L1517"></span>
<span class="line" id="L1518"><span class="tok-kw">fn</span> <span class="tok-fn">printCmd</span>(ally: Allocator, cwd: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, argv: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L1519">    <span class="tok-kw">const</span> text = allocPrintCmd(ally, cwd, argv) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L1520">    std.debug.print(<span class="tok-str">&quot;{s}\n&quot;</span>, .{text});</span>
<span class="line" id="L1521">}</span>
<span class="line" id="L1522"></span>
<span class="line" id="L1523"><span class="tok-comment">/// This creates the install step and adds it to the dependencies of the</span></span>
<span class="line" id="L1524"><span class="tok-comment">/// top-level install step, using all the default options.</span></span>
<span class="line" id="L1525"><span class="tok-comment">/// See `addInstallArtifact` for a more flexible function.</span></span>
<span class="line" id="L1526"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">installArtifact</span>(self: *Build, artifact: *Step.Compile) <span class="tok-type">void</span> {</span>
<span class="line" id="L1527">    self.getInstallStep().dependOn(&amp;self.addInstallArtifact(artifact, .{}).step);</span>
<span class="line" id="L1528">}</span>
<span class="line" id="L1529"></span>
<span class="line" id="L1530"><span class="tok-comment">/// This merely creates the step; it does not add it to the dependencies of the</span></span>
<span class="line" id="L1531"><span class="tok-comment">/// top-level install step.</span></span>
<span class="line" id="L1532"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addInstallArtifact</span>(</span>
<span class="line" id="L1533">    self: *Build,</span>
<span class="line" id="L1534">    artifact: *Step.Compile,</span>
<span class="line" id="L1535">    options: Step.InstallArtifact.Options,</span>
<span class="line" id="L1536">) *Step.InstallArtifact {</span>
<span class="line" id="L1537">    <span class="tok-kw">return</span> Step.InstallArtifact.create(self, artifact, options);</span>
<span class="line" id="L1538">}</span>
<span class="line" id="L1539"></span>
<span class="line" id="L1540"><span class="tok-comment">///`dest_rel_path` is relative to prefix path</span></span>
<span class="line" id="L1541"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">installFile</span>(self: *Build, src_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, dest_rel_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L1542">    self.getInstallStep().dependOn(&amp;self.addInstallFileWithDir(.{ .path = src_path }, .prefix, dest_rel_path).step);</span>
<span class="line" id="L1543">}</span>
<span class="line" id="L1544"></span>
<span class="line" id="L1545"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">installDirectory</span>(self: *Build, options: Step.InstallDir.Options) <span class="tok-type">void</span> {</span>
<span class="line" id="L1546">    self.getInstallStep().dependOn(&amp;self.addInstallDirectory(options).step);</span>
<span class="line" id="L1547">}</span>
<span class="line" id="L1548"></span>
<span class="line" id="L1549"><span class="tok-comment">///`dest_rel_path` is relative to bin path</span></span>
<span class="line" id="L1550"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">installBinFile</span>(self: *Build, src_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, dest_rel_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L1551">    self.getInstallStep().dependOn(&amp;self.addInstallFileWithDir(.{ .path = src_path }, .bin, dest_rel_path).step);</span>
<span class="line" id="L1552">}</span>
<span class="line" id="L1553"></span>
<span class="line" id="L1554"><span class="tok-comment">///`dest_rel_path` is relative to lib path</span></span>
<span class="line" id="L1555"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">installLibFile</span>(self: *Build, src_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, dest_rel_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L1556">    self.getInstallStep().dependOn(&amp;self.addInstallFileWithDir(.{ .path = src_path }, .lib, dest_rel_path).step);</span>
<span class="line" id="L1557">}</span>
<span class="line" id="L1558"></span>
<span class="line" id="L1559"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addObjCopy</span>(b: *Build, source: LazyPath, options: Step.ObjCopy.Options) *Step.ObjCopy {</span>
<span class="line" id="L1560">    <span class="tok-kw">return</span> Step.ObjCopy.create(b, source, options);</span>
<span class="line" id="L1561">}</span>
<span class="line" id="L1562"></span>
<span class="line" id="L1563"><span class="tok-comment">///`dest_rel_path` is relative to install prefix path</span></span>
<span class="line" id="L1564"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addInstallFile</span>(self: *Build, source: LazyPath, dest_rel_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) *Step.InstallFile {</span>
<span class="line" id="L1565">    <span class="tok-kw">return</span> self.addInstallFileWithDir(source.dupe(self), .prefix, dest_rel_path);</span>
<span class="line" id="L1566">}</span>
<span class="line" id="L1567"></span>
<span class="line" id="L1568"><span class="tok-comment">///`dest_rel_path` is relative to bin path</span></span>
<span class="line" id="L1569"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addInstallBinFile</span>(self: *Build, source: LazyPath, dest_rel_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) *Step.InstallFile {</span>
<span class="line" id="L1570">    <span class="tok-kw">return</span> self.addInstallFileWithDir(source.dupe(self), .bin, dest_rel_path);</span>
<span class="line" id="L1571">}</span>
<span class="line" id="L1572"></span>
<span class="line" id="L1573"><span class="tok-comment">///`dest_rel_path` is relative to lib path</span></span>
<span class="line" id="L1574"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addInstallLibFile</span>(self: *Build, source: LazyPath, dest_rel_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) *Step.InstallFile {</span>
<span class="line" id="L1575">    <span class="tok-kw">return</span> self.addInstallFileWithDir(source.dupe(self), .lib, dest_rel_path);</span>
<span class="line" id="L1576">}</span>
<span class="line" id="L1577"></span>
<span class="line" id="L1578"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addInstallHeaderFile</span>(b: *Build, src_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, dest_rel_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) *Step.InstallFile {</span>
<span class="line" id="L1579">    <span class="tok-kw">return</span> b.addInstallFileWithDir(.{ .path = src_path }, .header, dest_rel_path);</span>
<span class="line" id="L1580">}</span>
<span class="line" id="L1581"></span>
<span class="line" id="L1582"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addInstallFileWithDir</span>(</span>
<span class="line" id="L1583">    self: *Build,</span>
<span class="line" id="L1584">    source: LazyPath,</span>
<span class="line" id="L1585">    install_dir: InstallDir,</span>
<span class="line" id="L1586">    dest_rel_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1587">) *Step.InstallFile {</span>
<span class="line" id="L1588">    <span class="tok-kw">return</span> Step.InstallFile.create(self, source.dupe(self), install_dir, dest_rel_path);</span>
<span class="line" id="L1589">}</span>
<span class="line" id="L1590"></span>
<span class="line" id="L1591"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addInstallDirectory</span>(self: *Build, options: Step.InstallDir.Options) *Step.InstallDir {</span>
<span class="line" id="L1592">    <span class="tok-kw">return</span> Step.InstallDir.create(self, options);</span>
<span class="line" id="L1593">}</span>
<span class="line" id="L1594"></span>
<span class="line" id="L1595"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addCheckFile</span>(</span>
<span class="line" id="L1596">    b: *Build,</span>
<span class="line" id="L1597">    file_source: LazyPath,</span>
<span class="line" id="L1598">    options: Step.CheckFile.Options,</span>
<span class="line" id="L1599">) *Step.CheckFile {</span>
<span class="line" id="L1600">    <span class="tok-kw">return</span> Step.CheckFile.create(b, file_source, options);</span>
<span class="line" id="L1601">}</span>
<span class="line" id="L1602"></span>
<span class="line" id="L1603"><span class="tok-comment">/// deprecated: https://github.com/ziglang/zig/issues/14943</span></span>
<span class="line" id="L1604"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pushInstalledFile</span>(self: *Build, dir: InstallDir, dest_rel_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L1605">    <span class="tok-kw">const</span> file = InstalledFile{</span>
<span class="line" id="L1606">        .dir = dir,</span>
<span class="line" id="L1607">        .path = dest_rel_path,</span>
<span class="line" id="L1608">    };</span>
<span class="line" id="L1609">    self.installed_files.append(file.dupe(self)) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L1610">}</span>
<span class="line" id="L1611"></span>
<span class="line" id="L1612"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">truncateFile</span>(self: *Build, dest_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1613">    <span class="tok-kw">if</span> (self.verbose) {</span>
<span class="line" id="L1614">        log.info(<span class="tok-str">&quot;truncate {s}&quot;</span>, .{dest_path});</span>
<span class="line" id="L1615">    }</span>
<span class="line" id="L1616">    <span class="tok-kw">const</span> cwd = fs.cwd();</span>
<span class="line" id="L1617">    <span class="tok-kw">var</span> src_file = cwd.createFile(dest_path, .{}) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L1618">        <span class="tok-kw">error</span>.FileNotFound =&gt; blk: {</span>
<span class="line" id="L1619">            <span class="tok-kw">if</span> (fs.path.dirname(dest_path)) |dirname| {</span>
<span class="line" id="L1620">                <span class="tok-kw">try</span> cwd.makePath(dirname);</span>
<span class="line" id="L1621">            }</span>
<span class="line" id="L1622">            <span class="tok-kw">break</span> :blk <span class="tok-kw">try</span> cwd.createFile(dest_path, .{});</span>
<span class="line" id="L1623">        },</span>
<span class="line" id="L1624">        <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L1625">    };</span>
<span class="line" id="L1626">    src_file.close();</span>
<span class="line" id="L1627">}</span>
<span class="line" id="L1628"></span>
<span class="line" id="L1629"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pathFromRoot</span>(b: *Build, p: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) []<span class="tok-type">u8</span> {</span>
<span class="line" id="L1630">    <span class="tok-kw">return</span> fs.path.resolve(b.allocator, &amp;.{ b.build_root.path <span class="tok-kw">orelse</span> <span class="tok-str">&quot;.&quot;</span>, p }) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L1631">}</span>
<span class="line" id="L1632"></span>
<span class="line" id="L1633"><span class="tok-kw">fn</span> <span class="tok-fn">pathFromCwd</span>(b: *Build, p: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) []<span class="tok-type">u8</span> {</span>
<span class="line" id="L1634">    <span class="tok-kw">const</span> cwd = process.getCwdAlloc(b.allocator) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L1635">    <span class="tok-kw">return</span> fs.path.resolve(b.allocator, &amp;.{ cwd, p }) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L1636">}</span>
<span class="line" id="L1637"></span>
<span class="line" id="L1638"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pathJoin</span>(self: *Build, paths: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) []<span class="tok-type">u8</span> {</span>
<span class="line" id="L1639">    <span class="tok-kw">return</span> fs.path.join(self.allocator, paths) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L1640">}</span>
<span class="line" id="L1641"></span>
<span class="line" id="L1642"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fmt</span>(self: *Build, <span class="tok-kw">comptime</span> format: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, args: <span class="tok-kw">anytype</span>) []<span class="tok-type">u8</span> {</span>
<span class="line" id="L1643">    <span class="tok-kw">return</span> fmt_lib.allocPrint(self.allocator, format, args) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L1644">}</span>
<span class="line" id="L1645"></span>
<span class="line" id="L1646"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">findProgram</span>(self: *Build, names: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, paths: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L1647">    <span class="tok-comment">// TODO report error for ambiguous situations</span>
</span>
<span class="line" id="L1648">    <span class="tok-kw">const</span> exe_extension = self.host.result.exeFileExt();</span>
<span class="line" id="L1649">    <span class="tok-kw">for</span> (self.search_prefixes.items) |search_prefix| {</span>
<span class="line" id="L1650">        <span class="tok-kw">for</span> (names) |name| {</span>
<span class="line" id="L1651">            <span class="tok-kw">if</span> (fs.path.isAbsolute(name)) {</span>
<span class="line" id="L1652">                <span class="tok-kw">return</span> name;</span>
<span class="line" id="L1653">            }</span>
<span class="line" id="L1654">            <span class="tok-kw">const</span> full_path = self.pathJoin(&amp;.{</span>
<span class="line" id="L1655">                search_prefix,</span>
<span class="line" id="L1656">                <span class="tok-str">&quot;bin&quot;</span>,</span>
<span class="line" id="L1657">                self.fmt(<span class="tok-str">&quot;{s}{s}&quot;</span>, .{ name, exe_extension }),</span>
<span class="line" id="L1658">            });</span>
<span class="line" id="L1659">            <span class="tok-kw">return</span> fs.realpathAlloc(self.allocator, full_path) <span class="tok-kw">catch</span> <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1660">        }</span>
<span class="line" id="L1661">    }</span>
<span class="line" id="L1662">    <span class="tok-kw">if</span> (self.graph.env_map.get(<span class="tok-str">&quot;PATH&quot;</span>)) |PATH| {</span>
<span class="line" id="L1663">        <span class="tok-kw">for</span> (names) |name| {</span>
<span class="line" id="L1664">            <span class="tok-kw">if</span> (fs.path.isAbsolute(name)) {</span>
<span class="line" id="L1665">                <span class="tok-kw">return</span> name;</span>
<span class="line" id="L1666">            }</span>
<span class="line" id="L1667">            <span class="tok-kw">var</span> it = mem.tokenizeScalar(<span class="tok-type">u8</span>, PATH, fs.path.delimiter);</span>
<span class="line" id="L1668">            <span class="tok-kw">while</span> (it.next()) |path| {</span>
<span class="line" id="L1669">                <span class="tok-kw">const</span> full_path = self.pathJoin(&amp;.{</span>
<span class="line" id="L1670">                    path,</span>
<span class="line" id="L1671">                    self.fmt(<span class="tok-str">&quot;{s}{s}&quot;</span>, .{ name, exe_extension }),</span>
<span class="line" id="L1672">                });</span>
<span class="line" id="L1673">                <span class="tok-kw">return</span> fs.realpathAlloc(self.allocator, full_path) <span class="tok-kw">catch</span> <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1674">            }</span>
<span class="line" id="L1675">        }</span>
<span class="line" id="L1676">    }</span>
<span class="line" id="L1677">    <span class="tok-kw">for</span> (names) |name| {</span>
<span class="line" id="L1678">        <span class="tok-kw">if</span> (fs.path.isAbsolute(name)) {</span>
<span class="line" id="L1679">            <span class="tok-kw">return</span> name;</span>
<span class="line" id="L1680">        }</span>
<span class="line" id="L1681">        <span class="tok-kw">for</span> (paths) |path| {</span>
<span class="line" id="L1682">            <span class="tok-kw">const</span> full_path = self.pathJoin(&amp;.{</span>
<span class="line" id="L1683">                path,</span>
<span class="line" id="L1684">                self.fmt(<span class="tok-str">&quot;{s}{s}&quot;</span>, .{ name, exe_extension }),</span>
<span class="line" id="L1685">            });</span>
<span class="line" id="L1686">            <span class="tok-kw">return</span> fs.realpathAlloc(self.allocator, full_path) <span class="tok-kw">catch</span> <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1687">        }</span>
<span class="line" id="L1688">    }</span>
<span class="line" id="L1689">    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound;</span>
<span class="line" id="L1690">}</span>
<span class="line" id="L1691"></span>
<span class="line" id="L1692"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">runAllowFail</span>(</span>
<span class="line" id="L1693">    self: *Build,</span>
<span class="line" id="L1694">    argv: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1695">    out_code: *<span class="tok-type">u8</span>,</span>
<span class="line" id="L1696">    stderr_behavior: std.ChildProcess.StdIo,</span>
<span class="line" id="L1697">) RunError![]<span class="tok-type">u8</span> {</span>
<span class="line" id="L1698">    assert(argv.len != <span class="tok-number">0</span>);</span>
<span class="line" id="L1699"></span>
<span class="line" id="L1700">    <span class="tok-kw">if</span> (!process.can_spawn)</span>
<span class="line" id="L1701">        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ExecNotSupported;</span>
<span class="line" id="L1702"></span>
<span class="line" id="L1703">    <span class="tok-kw">const</span> max_output_size = <span class="tok-number">400</span> * <span class="tok-number">1024</span>;</span>
<span class="line" id="L1704">    <span class="tok-kw">var</span> child = std.ChildProcess.init(argv, self.allocator);</span>
<span class="line" id="L1705">    child.stdin_behavior = .Ignore;</span>
<span class="line" id="L1706">    child.stdout_behavior = .Pipe;</span>
<span class="line" id="L1707">    child.stderr_behavior = stderr_behavior;</span>
<span class="line" id="L1708">    child.env_map = &amp;self.graph.env_map;</span>
<span class="line" id="L1709"></span>
<span class="line" id="L1710">    <span class="tok-kw">try</span> child.spawn();</span>
<span class="line" id="L1711"></span>
<span class="line" id="L1712">    <span class="tok-kw">const</span> stdout = child.stdout.?.reader().readAllAlloc(self.allocator, max_output_size) <span class="tok-kw">catch</span> {</span>
<span class="line" id="L1713">        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ReadFailure;</span>
<span class="line" id="L1714">    };</span>
<span class="line" id="L1715">    <span class="tok-kw">errdefer</span> self.allocator.free(stdout);</span>
<span class="line" id="L1716"></span>
<span class="line" id="L1717">    <span class="tok-kw">const</span> term = <span class="tok-kw">try</span> child.wait();</span>
<span class="line" id="L1718">    <span class="tok-kw">switch</span> (term) {</span>
<span class="line" id="L1719">        .Exited =&gt; |code| {</span>
<span class="line" id="L1720">            <span class="tok-kw">if</span> (code != <span class="tok-number">0</span>) {</span>
<span class="line" id="L1721">                out_code.* = <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@truncate</span>(code));</span>
<span class="line" id="L1722">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ExitCodeFailure;</span>
<span class="line" id="L1723">            }</span>
<span class="line" id="L1724">            <span class="tok-kw">return</span> stdout;</span>
<span class="line" id="L1725">        },</span>
<span class="line" id="L1726">        .Signal, .Stopped, .Unknown =&gt; |code| {</span>
<span class="line" id="L1727">            out_code.* = <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@truncate</span>(code));</span>
<span class="line" id="L1728">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessTerminated;</span>
<span class="line" id="L1729">        },</span>
<span class="line" id="L1730">    }</span>
<span class="line" id="L1731">}</span>
<span class="line" id="L1732"></span>
<span class="line" id="L1733"><span class="tok-comment">/// This is a helper function to be called from build.zig scripts, *not* from</span></span>
<span class="line" id="L1734"><span class="tok-comment">/// inside step make() functions. If any errors occur, it fails the build with</span></span>
<span class="line" id="L1735"><span class="tok-comment">/// a helpful message.</span></span>
<span class="line" id="L1736"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">run</span>(b: *Build, argv: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) []<span class="tok-type">u8</span> {</span>
<span class="line" id="L1737">    <span class="tok-kw">if</span> (!process.can_spawn) {</span>
<span class="line" id="L1738">        std.debug.print(<span class="tok-str">&quot;unable to spawn the following command: cannot spawn child process\n{s}\n&quot;</span>, .{</span>
<span class="line" id="L1739">            <span class="tok-kw">try</span> allocPrintCmd(b.allocator, <span class="tok-null">null</span>, argv),</span>
<span class="line" id="L1740">        });</span>
<span class="line" id="L1741">        process.exit(<span class="tok-number">1</span>);</span>
<span class="line" id="L1742">    }</span>
<span class="line" id="L1743"></span>
<span class="line" id="L1744">    <span class="tok-kw">var</span> code: <span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1745">    <span class="tok-kw">return</span> b.runAllowFail(argv, &amp;code, .Inherit) <span class="tok-kw">catch</span> |err| {</span>
<span class="line" id="L1746">        <span class="tok-kw">const</span> printed_cmd = allocPrintCmd(b.allocator, <span class="tok-null">null</span>, argv) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L1747">        std.debug.print(<span class="tok-str">&quot;unable to spawn the following command: {s}\n{s}\n&quot;</span>, .{</span>
<span class="line" id="L1748">            <span class="tok-builtin">@errorName</span>(err), printed_cmd,</span>
<span class="line" id="L1749">        });</span>
<span class="line" id="L1750">        process.exit(<span class="tok-number">1</span>);</span>
<span class="line" id="L1751">    };</span>
<span class="line" id="L1752">}</span>
<span class="line" id="L1753"></span>
<span class="line" id="L1754"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addSearchPrefix</span>(b: *Build, search_prefix: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L1755">    b.search_prefixes.append(b.allocator, b.dupePath(search_prefix)) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L1756">}</span>
<span class="line" id="L1757"></span>
<span class="line" id="L1758"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getInstallPath</span>(self: *Build, dir: InstallDir, dest_rel_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L1759">    assert(!fs.path.isAbsolute(dest_rel_path)); <span class="tok-comment">// Install paths must be relative to the prefix</span>
</span>
<span class="line" id="L1760">    <span class="tok-kw">const</span> base_dir = <span class="tok-kw">switch</span> (dir) {</span>
<span class="line" id="L1761">        .prefix =&gt; self.install_path,</span>
<span class="line" id="L1762">        .bin =&gt; self.exe_dir,</span>
<span class="line" id="L1763">        .lib =&gt; self.lib_dir,</span>
<span class="line" id="L1764">        .header =&gt; self.h_dir,</span>
<span class="line" id="L1765">        .custom =&gt; |path| self.pathJoin(&amp;.{ self.install_path, path }),</span>
<span class="line" id="L1766">    };</span>
<span class="line" id="L1767">    <span class="tok-kw">return</span> fs.path.resolve(</span>
<span class="line" id="L1768">        self.allocator,</span>
<span class="line" id="L1769">        &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ base_dir, dest_rel_path },</span>
<span class="line" id="L1770">    ) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L1771">}</span>
<span class="line" id="L1772"></span>
<span class="line" id="L1773"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Dependency = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1774">    builder: *Build,</span>
<span class="line" id="L1775"></span>
<span class="line" id="L1776">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">artifact</span>(d: *Dependency, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) *Step.Compile {</span>
<span class="line" id="L1777">        <span class="tok-kw">var</span> found: ?*Step.Compile = <span class="tok-null">null</span>;</span>
<span class="line" id="L1778">        <span class="tok-kw">for</span> (d.builder.install_tls.step.dependencies.items) |dep_step| {</span>
<span class="line" id="L1779">            <span class="tok-kw">const</span> inst = dep_step.cast(Step.InstallArtifact) <span class="tok-kw">orelse</span> <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1780">            <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, inst.artifact.name, name)) {</span>
<span class="line" id="L1781">                <span class="tok-kw">if</span> (found != <span class="tok-null">null</span>) panic(<span class="tok-str">&quot;artifact name '{s}' is ambiguous&quot;</span>, .{name});</span>
<span class="line" id="L1782">                found = inst.artifact;</span>
<span class="line" id="L1783">            }</span>
<span class="line" id="L1784">        }</span>
<span class="line" id="L1785">        <span class="tok-kw">return</span> found <span class="tok-kw">orelse</span> {</span>
<span class="line" id="L1786">            <span class="tok-kw">for</span> (d.builder.install_tls.step.dependencies.items) |dep_step| {</span>
<span class="line" id="L1787">                <span class="tok-kw">const</span> inst = dep_step.cast(Step.InstallArtifact) <span class="tok-kw">orelse</span> <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1788">                log.info(<span class="tok-str">&quot;available artifact: '{s}'&quot;</span>, .{inst.artifact.name});</span>
<span class="line" id="L1789">            }</span>
<span class="line" id="L1790">            panic(<span class="tok-str">&quot;unable to find artifact '{s}'&quot;</span>, .{name});</span>
<span class="line" id="L1791">        };</span>
<span class="line" id="L1792">    }</span>
<span class="line" id="L1793"></span>
<span class="line" id="L1794">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">module</span>(d: *Dependency, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) *Module {</span>
<span class="line" id="L1795">        <span class="tok-kw">return</span> d.builder.modules.get(name) <span class="tok-kw">orelse</span> {</span>
<span class="line" id="L1796">            panic(<span class="tok-str">&quot;unable to find module '{s}'&quot;</span>, .{name});</span>
<span class="line" id="L1797">        };</span>
<span class="line" id="L1798">    }</span>
<span class="line" id="L1799"></span>
<span class="line" id="L1800">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">namedWriteFiles</span>(d: *Dependency, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) *Step.WriteFile {</span>
<span class="line" id="L1801">        <span class="tok-kw">return</span> d.builder.named_writefiles.get(name) <span class="tok-kw">orelse</span> {</span>
<span class="line" id="L1802">            panic(<span class="tok-str">&quot;unable to find named writefiles '{s}'&quot;</span>, .{name});</span>
<span class="line" id="L1803">        };</span>
<span class="line" id="L1804">    }</span>
<span class="line" id="L1805"></span>
<span class="line" id="L1806">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">path</span>(d: *Dependency, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) LazyPath {</span>
<span class="line" id="L1807">        <span class="tok-kw">return</span> .{</span>
<span class="line" id="L1808">            .dependency = .{</span>
<span class="line" id="L1809">                .dependency = d,</span>
<span class="line" id="L1810">                .sub_path = sub_path,</span>
<span class="line" id="L1811">            },</span>
<span class="line" id="L1812">        };</span>
<span class="line" id="L1813">    }</span>
<span class="line" id="L1814">};</span>
<span class="line" id="L1815"></span>
<span class="line" id="L1816"><span class="tok-kw">fn</span> <span class="tok-fn">findPkgHashOrFatal</span>(b: *Build, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L1817">    <span class="tok-kw">for</span> (b.available_deps) |dep| {</span>
<span class="line" id="L1818">        <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, dep[<span class="tok-number">0</span>], name)) <span class="tok-kw">return</span> dep[<span class="tok-number">1</span>];</span>
<span class="line" id="L1819">    }</span>
<span class="line" id="L1820"></span>
<span class="line" id="L1821">    <span class="tok-kw">const</span> full_path = b.pathFromRoot(<span class="tok-str">&quot;build.zig.zon&quot;</span>);</span>
<span class="line" id="L1822">    std.debug.panic(<span class="tok-str">&quot;no dependency named '{s}' in '{s}'. All packages used in build.zig must be declared in this file&quot;</span>, .{ name, full_path });</span>
<span class="line" id="L1823">}</span>
<span class="line" id="L1824"></span>
<span class="line" id="L1825"><span class="tok-kw">fn</span> <span class="tok-fn">markNeededLazyDep</span>(b: *Build, pkg_hash: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L1826">    b.graph.needed_lazy_dependencies.put(b.graph.arena, pkg_hash, {}) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L1827">}</span>
<span class="line" id="L1828"></span>
<span class="line" id="L1829"><span class="tok-comment">/// When this function is called, it means that the current build does, in</span></span>
<span class="line" id="L1830"><span class="tok-comment">/// fact, require this dependency. If the dependency is already fetched, it</span></span>
<span class="line" id="L1831"><span class="tok-comment">/// proceeds in the same manner as `dependency`. However if the dependency was</span></span>
<span class="line" id="L1832"><span class="tok-comment">/// not fetched, then when the build script is finished running, the build will</span></span>
<span class="line" id="L1833"><span class="tok-comment">/// not proceed to the make phase. Instead, the parent process will</span></span>
<span class="line" id="L1834"><span class="tok-comment">/// additionally fetch all the lazy dependencies that were actually required by</span></span>
<span class="line" id="L1835"><span class="tok-comment">/// running the build script, rebuild the build script, and then run it again.</span></span>
<span class="line" id="L1836"><span class="tok-comment">/// In other words, if this function returns `null` it means that the only</span></span>
<span class="line" id="L1837"><span class="tok-comment">/// purpose of completing the configure phase is to find out all the other lazy</span></span>
<span class="line" id="L1838"><span class="tok-comment">/// dependencies that are also required.</span></span>
<span class="line" id="L1839"><span class="tok-comment">/// It is allowed to use this function for non-lazy dependencies, in which case</span></span>
<span class="line" id="L1840"><span class="tok-comment">/// it will never return `null`. This allows toggling laziness via</span></span>
<span class="line" id="L1841"><span class="tok-comment">/// build.zig.zon without changing build.zig logic.</span></span>
<span class="line" id="L1842"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lazyDependency</span>(b: *Build, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, args: <span class="tok-kw">anytype</span>) ?*Dependency {</span>
<span class="line" id="L1843">    <span class="tok-kw">const</span> build_runner = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;root&quot;</span>);</span>
<span class="line" id="L1844">    <span class="tok-kw">const</span> deps = build_runner.dependencies;</span>
<span class="line" id="L1845">    <span class="tok-kw">const</span> pkg_hash = findPkgHashOrFatal(b, name);</span>
<span class="line" id="L1846"></span>
<span class="line" id="L1847">    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(deps.packages).Struct.decls) |decl| {</span>
<span class="line" id="L1848">        <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, decl.name, pkg_hash)) {</span>
<span class="line" id="L1849">            <span class="tok-kw">const</span> pkg = <span class="tok-builtin">@field</span>(deps.packages, decl.name);</span>
<span class="line" id="L1850">            <span class="tok-kw">const</span> available = !<span class="tok-builtin">@hasDecl</span>(pkg, <span class="tok-str">&quot;available&quot;</span>) <span class="tok-kw">or</span> pkg.available;</span>
<span class="line" id="L1851">            <span class="tok-kw">if</span> (!available) {</span>
<span class="line" id="L1852">                markNeededLazyDep(b, pkg_hash);</span>
<span class="line" id="L1853">                <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L1854">            }</span>
<span class="line" id="L1855">            <span class="tok-kw">return</span> dependencyInner(b, name, pkg.build_root, <span class="tok-kw">if</span> (<span class="tok-builtin">@hasDecl</span>(pkg, <span class="tok-str">&quot;build_zig&quot;</span>)) pkg.build_zig <span class="tok-kw">else</span> <span class="tok-null">null</span>, pkg.deps, args);</span>
<span class="line" id="L1856">        }</span>
<span class="line" id="L1857">    }</span>
<span class="line" id="L1858"></span>
<span class="line" id="L1859">    <span class="tok-kw">unreachable</span>; <span class="tok-comment">// Bad @dependencies source</span>
</span>
<span class="line" id="L1860">}</span>
<span class="line" id="L1861"></span>
<span class="line" id="L1862"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dependency</span>(b: *Build, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, args: <span class="tok-kw">anytype</span>) *Dependency {</span>
<span class="line" id="L1863">    <span class="tok-kw">const</span> build_runner = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;root&quot;</span>);</span>
<span class="line" id="L1864">    <span class="tok-kw">const</span> deps = build_runner.dependencies;</span>
<span class="line" id="L1865">    <span class="tok-kw">const</span> pkg_hash = findPkgHashOrFatal(b, name);</span>
<span class="line" id="L1866"></span>
<span class="line" id="L1867">    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(deps.packages).Struct.decls) |decl| {</span>
<span class="line" id="L1868">        <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, decl.name, pkg_hash)) {</span>
<span class="line" id="L1869">            <span class="tok-kw">const</span> pkg = <span class="tok-builtin">@field</span>(deps.packages, decl.name);</span>
<span class="line" id="L1870">            <span class="tok-kw">if</span> (<span class="tok-builtin">@hasDecl</span>(pkg, <span class="tok-str">&quot;available&quot;</span>)) {</span>
<span class="line" id="L1871">                std.debug.panic(<span class="tok-str">&quot;dependency '{s}{s}' is marked as lazy in build.zig.zon which means it must use the lazyDependency function instead&quot;</span>, .{ b.dep_prefix, name });</span>
<span class="line" id="L1872">            }</span>
<span class="line" id="L1873">            <span class="tok-kw">return</span> dependencyInner(b, name, pkg.build_root, <span class="tok-kw">if</span> (<span class="tok-builtin">@hasDecl</span>(pkg, <span class="tok-str">&quot;build_zig&quot;</span>)) pkg.build_zig <span class="tok-kw">else</span> <span class="tok-null">null</span>, pkg.deps, args);</span>
<span class="line" id="L1874">        }</span>
<span class="line" id="L1875">    }</span>
<span class="line" id="L1876"></span>
<span class="line" id="L1877">    <span class="tok-kw">unreachable</span>; <span class="tok-comment">// Bad @dependencies source</span>
</span>
<span class="line" id="L1878">}</span>
<span class="line" id="L1879"></span>
<span class="line" id="L1880"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">anonymousDependency</span>(</span>
<span class="line" id="L1881">    b: *Build,</span>
<span class="line" id="L1882">    <span class="tok-comment">/// The path to the directory containing the dependency's build.zig file,</span></span>
<span class="line" id="L1883">    <span class="tok-comment">/// relative to the current package's build.zig.</span></span>
<span class="line" id="L1884">    relative_build_root: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1885">    <span class="tok-comment">/// A direct `@import` of the build.zig of the dependency.</span></span>
<span class="line" id="L1886">    <span class="tok-kw">comptime</span> build_zig: <span class="tok-type">type</span>,</span>
<span class="line" id="L1887">    args: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L1888">) *Dependency {</span>
<span class="line" id="L1889">    <span class="tok-kw">const</span> arena = b.allocator;</span>
<span class="line" id="L1890">    <span class="tok-kw">const</span> build_root = b.build_root.join(arena, &amp;.{relative_build_root}) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L1891">    <span class="tok-kw">const</span> name = arena.dupe(<span class="tok-type">u8</span>, relative_build_root) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L1892">    <span class="tok-kw">for</span> (name) |*byte| <span class="tok-kw">switch</span> (byte.*) {</span>
<span class="line" id="L1893">        <span class="tok-str">'/'</span>, <span class="tok-str">'\\'</span> =&gt; byte.* = <span class="tok-str">'.'</span>,</span>
<span class="line" id="L1894">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">continue</span>,</span>
<span class="line" id="L1895">    };</span>
<span class="line" id="L1896">    <span class="tok-kw">return</span> dependencyInner(b, name, build_root, build_zig, &amp;.{}, args);</span>
<span class="line" id="L1897">}</span>
<span class="line" id="L1898"></span>
<span class="line" id="L1899"><span class="tok-kw">fn</span> <span class="tok-fn">userValuesAreSame</span>(lhs: UserValue, rhs: UserValue) <span class="tok-type">bool</span> {</span>
<span class="line" id="L1900">    <span class="tok-kw">switch</span> (lhs) {</span>
<span class="line" id="L1901">        .flag =&gt; {},</span>
<span class="line" id="L1902">        .scalar =&gt; |lhs_scalar| {</span>
<span class="line" id="L1903">            <span class="tok-kw">const</span> rhs_scalar = <span class="tok-kw">switch</span> (rhs) {</span>
<span class="line" id="L1904">                .scalar =&gt; |scalar| scalar,</span>
<span class="line" id="L1905">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-null">false</span>,</span>
<span class="line" id="L1906">            };</span>
<span class="line" id="L1907"></span>
<span class="line" id="L1908">            <span class="tok-kw">if</span> (!std.mem.eql(<span class="tok-type">u8</span>, lhs_scalar, rhs_scalar))</span>
<span class="line" id="L1909">                <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L1910">        },</span>
<span class="line" id="L1911">        .list =&gt; |lhs_list| {</span>
<span class="line" id="L1912">            <span class="tok-kw">const</span> rhs_list = <span class="tok-kw">switch</span> (rhs) {</span>
<span class="line" id="L1913">                .list =&gt; |list| list,</span>
<span class="line" id="L1914">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-null">false</span>,</span>
<span class="line" id="L1915">            };</span>
<span class="line" id="L1916"></span>
<span class="line" id="L1917">            <span class="tok-kw">if</span> (lhs_list.items.len != rhs_list.items.len)</span>
<span class="line" id="L1918">                <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L1919"></span>
<span class="line" id="L1920">            <span class="tok-kw">for</span> (lhs_list.items, rhs_list.items) |lhs_list_entry, rhs_list_entry| {</span>
<span class="line" id="L1921">                <span class="tok-kw">if</span> (!std.mem.eql(<span class="tok-type">u8</span>, lhs_list_entry, rhs_list_entry))</span>
<span class="line" id="L1922">                    <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L1923">            }</span>
<span class="line" id="L1924">        },</span>
<span class="line" id="L1925">        .map =&gt; |lhs_map| {</span>
<span class="line" id="L1926">            <span class="tok-kw">const</span> rhs_map = <span class="tok-kw">switch</span> (rhs) {</span>
<span class="line" id="L1927">                .map =&gt; |map| map,</span>
<span class="line" id="L1928">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-null">false</span>,</span>
<span class="line" id="L1929">            };</span>
<span class="line" id="L1930"></span>
<span class="line" id="L1931">            <span class="tok-kw">if</span> (lhs_map.count() != rhs_map.count())</span>
<span class="line" id="L1932">                <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L1933"></span>
<span class="line" id="L1934">            <span class="tok-kw">var</span> lhs_it = lhs_map.iterator();</span>
<span class="line" id="L1935">            <span class="tok-kw">while</span> (lhs_it.next()) |lhs_entry| {</span>
<span class="line" id="L1936">                <span class="tok-kw">const</span> rhs_value = rhs_map.get(lhs_entry.key_ptr.*) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L1937">                <span class="tok-kw">if</span> (!userValuesAreSame(lhs_entry.value_ptr.*.*, rhs_value.*))</span>
<span class="line" id="L1938">                    <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L1939">            }</span>
<span class="line" id="L1940">        },</span>
<span class="line" id="L1941">    }</span>
<span class="line" id="L1942"></span>
<span class="line" id="L1943">    <span class="tok-kw">return</span> <span class="tok-null">true</span>;</span>
<span class="line" id="L1944">}</span>
<span class="line" id="L1945"></span>
<span class="line" id="L1946"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dependencyInner</span>(</span>
<span class="line" id="L1947">    b: *Build,</span>
<span class="line" id="L1948">    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1949">    build_root_string: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1950">    <span class="tok-kw">comptime</span> build_zig: ?<span class="tok-type">type</span>,</span>
<span class="line" id="L1951">    pkg_deps: AvailableDeps,</span>
<span class="line" id="L1952">    args: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L1953">) *Dependency {</span>
<span class="line" id="L1954">    <span class="tok-kw">const</span> user_input_options = userInputOptionsFromArgs(b.allocator, args);</span>
<span class="line" id="L1955">    <span class="tok-kw">if</span> (b.initialized_deps.get(.{</span>
<span class="line" id="L1956">        .build_root_string = build_root_string,</span>
<span class="line" id="L1957">        .user_input_options = user_input_options,</span>
<span class="line" id="L1958">    })) |dep|</span>
<span class="line" id="L1959">        <span class="tok-kw">return</span> dep;</span>
<span class="line" id="L1960"></span>
<span class="line" id="L1961">    <span class="tok-kw">const</span> build_root: std.Build.Cache.Directory = .{</span>
<span class="line" id="L1962">        .path = build_root_string,</span>
<span class="line" id="L1963">        .handle = std.fs.cwd().openDir(build_root_string, .{}) <span class="tok-kw">catch</span> |err| {</span>
<span class="line" id="L1964">            std.debug.print(<span class="tok-str">&quot;unable to open '{s}': {s}\n&quot;</span>, .{</span>
<span class="line" id="L1965">                build_root_string, <span class="tok-builtin">@errorName</span>(err),</span>
<span class="line" id="L1966">            });</span>
<span class="line" id="L1967">            process.exit(<span class="tok-number">1</span>);</span>
<span class="line" id="L1968">        },</span>
<span class="line" id="L1969">    };</span>
<span class="line" id="L1970"></span>
<span class="line" id="L1971">    <span class="tok-kw">const</span> sub_builder = b.createChild(name, build_root, pkg_deps, user_input_options) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;unhandled error&quot;</span>);</span>
<span class="line" id="L1972">    <span class="tok-kw">if</span> (build_zig) |bz| {</span>
<span class="line" id="L1973">        sub_builder.runBuild(bz) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;unhandled error&quot;</span>);</span>
<span class="line" id="L1974"></span>
<span class="line" id="L1975">        <span class="tok-kw">if</span> (sub_builder.validateUserInputDidItFail()) {</span>
<span class="line" id="L1976">            std.debug.dumpCurrentStackTrace(<span class="tok-builtin">@returnAddress</span>());</span>
<span class="line" id="L1977">        }</span>
<span class="line" id="L1978">    }</span>
<span class="line" id="L1979"></span>
<span class="line" id="L1980">    <span class="tok-kw">const</span> dep = b.allocator.create(Dependency) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L1981">    dep.* = .{ .builder = sub_builder };</span>
<span class="line" id="L1982"></span>
<span class="line" id="L1983">    b.initialized_deps.put(.{</span>
<span class="line" id="L1984">        .build_root_string = build_root_string,</span>
<span class="line" id="L1985">        .user_input_options = user_input_options,</span>
<span class="line" id="L1986">    }, dep) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L1987">    <span class="tok-kw">return</span> dep;</span>
<span class="line" id="L1988">}</span>
<span class="line" id="L1989"></span>
<span class="line" id="L1990"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">runBuild</span>(b: *Build, build_zig: <span class="tok-kw">anytype</span>) <span class="tok-type">anyerror</span>!<span class="tok-type">void</span> {</span>
<span class="line" id="L1991">    <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(build_zig.build)).Fn.return_type.?)) {</span>
<span class="line" id="L1992">        .Void =&gt; build_zig.build(b),</span>
<span class="line" id="L1993">        .ErrorUnion =&gt; <span class="tok-kw">try</span> build_zig.build(b),</span>
<span class="line" id="L1994">        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;expected return type of build to be 'void' or '!void'&quot;</span>),</span>
<span class="line" id="L1995">    }</span>
<span class="line" id="L1996">}</span>
<span class="line" id="L1997"></span>
<span class="line" id="L1998"><span class="tok-comment">/// A file that is generated by a build step.</span></span>
<span class="line" id="L1999"><span class="tok-comment">/// This struct is an interface that is meant to be used with `@fieldParentPtr` to implement the actual path logic.</span></span>
<span class="line" id="L2000"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> GeneratedFile = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2001">    <span class="tok-comment">/// The step that generates the file</span></span>
<span class="line" id="L2002">    step: *Step,</span>
<span class="line" id="L2003"></span>
<span class="line" id="L2004">    <span class="tok-comment">/// The path to the generated file. Must be either absolute or relative to the build root.</span></span>
<span class="line" id="L2005">    <span class="tok-comment">/// This value must be set in the `fn make()` of the `step` and must not be `null` afterwards.</span></span>
<span class="line" id="L2006">    path: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L2007"></span>
<span class="line" id="L2008">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPath</span>(self: GeneratedFile) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L2009">        <span class="tok-kw">return</span> self.path <span class="tok-kw">orelse</span> std.debug.panic(</span>
<span class="line" id="L2010">            <span class="tok-str">&quot;getPath() was called on a GeneratedFile that wasn't built yet. Is there a missing Step dependency on step '{s}'?&quot;</span>,</span>
<span class="line" id="L2011">            .{self.step.name},</span>
<span class="line" id="L2012">        );</span>
<span class="line" id="L2013">    }</span>
<span class="line" id="L2014">};</span>
<span class="line" id="L2015"></span>
<span class="line" id="L2016"><span class="tok-comment">// dirnameAllowEmpty is a variant of fs.path.dirname</span>
</span>
<span class="line" id="L2017"><span class="tok-comment">// that allows &quot;&quot; to refer to the root for relative paths.</span>
</span>
<span class="line" id="L2018"><span class="tok-comment">//</span>
</span>
<span class="line" id="L2019"><span class="tok-comment">// For context, dirname(&quot;foo&quot;) and dirname(&quot;&quot;) are both null.</span>
</span>
<span class="line" id="L2020"><span class="tok-comment">// However, for relative paths, we want dirname(&quot;foo&quot;) to be &quot;&quot;</span>
</span>
<span class="line" id="L2021"><span class="tok-comment">// so that we can join it with another path (e.g. build root, cache root, etc.)</span>
</span>
<span class="line" id="L2022"><span class="tok-comment">//</span>
</span>
<span class="line" id="L2023"><span class="tok-comment">// dirname(&quot;&quot;) should still be null, because we can't go up any further.</span>
</span>
<span class="line" id="L2024"><span class="tok-kw">fn</span> <span class="tok-fn">dirnameAllowEmpty</span>(path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L2025">    <span class="tok-kw">return</span> fs.path.dirname(path) <span class="tok-kw">orelse</span> {</span>
<span class="line" id="L2026">        <span class="tok-kw">if</span> (fs.path.isAbsolute(path) <span class="tok-kw">or</span> path.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L2027"></span>
<span class="line" id="L2028">        <span class="tok-kw">return</span> <span class="tok-str">&quot;&quot;</span>;</span>
<span class="line" id="L2029">    };</span>
<span class="line" id="L2030">}</span>
<span class="line" id="L2031"></span>
<span class="line" id="L2032"><span class="tok-kw">test</span> dirnameAllowEmpty {</span>
<span class="line" id="L2033">    <span class="tok-kw">try</span> std.testing.expectEqualStrings(</span>
<span class="line" id="L2034">        <span class="tok-str">&quot;foo&quot;</span>,</span>
<span class="line" id="L2035">        dirnameAllowEmpty(<span class="tok-str">&quot;foo&quot;</span> ++ fs.path.sep_str ++ <span class="tok-str">&quot;bar&quot;</span>) <span class="tok-kw">orelse</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;unexpected null&quot;</span>),</span>
<span class="line" id="L2036">    );</span>
<span class="line" id="L2037"></span>
<span class="line" id="L2038">    <span class="tok-kw">try</span> std.testing.expectEqualStrings(</span>
<span class="line" id="L2039">        <span class="tok-str">&quot;&quot;</span>,</span>
<span class="line" id="L2040">        dirnameAllowEmpty(<span class="tok-str">&quot;foo&quot;</span>) <span class="tok-kw">orelse</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;unexpected null&quot;</span>),</span>
<span class="line" id="L2041">    );</span>
<span class="line" id="L2042"></span>
<span class="line" id="L2043">    <span class="tok-kw">try</span> std.testing.expect(dirnameAllowEmpty(<span class="tok-str">&quot;&quot;</span>) == <span class="tok-null">null</span>);</span>
<span class="line" id="L2044">}</span>
<span class="line" id="L2045"></span>
<span class="line" id="L2046"><span class="tok-comment">/// A reference to an existing or future path.</span></span>
<span class="line" id="L2047"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> LazyPath = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {</span>
<span class="line" id="L2048">    <span class="tok-comment">/// A source file path relative to build root.</span></span>
<span class="line" id="L2049">    <span class="tok-comment">/// This should not be an absolute path, but in an older iteration of the zig build</span></span>
<span class="line" id="L2050">    <span class="tok-comment">/// system API, it was allowed to be absolute. Absolute paths should use `cwd_relative`.</span></span>
<span class="line" id="L2051">    path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L2052"></span>
<span class="line" id="L2053">    <span class="tok-comment">/// A file that is generated by an interface. Those files usually are</span></span>
<span class="line" id="L2054">    <span class="tok-comment">/// not available until built by a build step.</span></span>
<span class="line" id="L2055">    generated: *<span class="tok-kw">const</span> GeneratedFile,</span>
<span class="line" id="L2056"></span>
<span class="line" id="L2057">    <span class="tok-comment">/// One of the parent directories of a file generated by an interface.</span></span>
<span class="line" id="L2058">    <span class="tok-comment">/// The path is not available until built by a build step.</span></span>
<span class="line" id="L2059">    generated_dirname: <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2060">        generated: *<span class="tok-kw">const</span> GeneratedFile,</span>
<span class="line" id="L2061"></span>
<span class="line" id="L2062">        <span class="tok-comment">/// The number of parent directories to go up.</span></span>
<span class="line" id="L2063">        <span class="tok-comment">/// 0 means the directory of the generated file,</span></span>
<span class="line" id="L2064">        <span class="tok-comment">/// 1 means the parent of that directory, and so on.</span></span>
<span class="line" id="L2065">        up: <span class="tok-type">usize</span>,</span>
<span class="line" id="L2066">    },</span>
<span class="line" id="L2067"></span>
<span class="line" id="L2068">    <span class="tok-comment">/// An absolute path or a path relative to the current working directory of</span></span>
<span class="line" id="L2069">    <span class="tok-comment">/// the build runner process.</span></span>
<span class="line" id="L2070">    <span class="tok-comment">/// This is uncommon but used for system environment paths such as `--zig-lib-dir` which</span></span>
<span class="line" id="L2071">    <span class="tok-comment">/// ignore the file system path of build.zig and instead are relative to the directory from</span></span>
<span class="line" id="L2072">    <span class="tok-comment">/// which `zig build` was invoked.</span></span>
<span class="line" id="L2073">    <span class="tok-comment">/// Use of this tag indicates a dependency on the host system.</span></span>
<span class="line" id="L2074">    cwd_relative: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L2075"></span>
<span class="line" id="L2076">    dependency: <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2077">        dependency: *Dependency,</span>
<span class="line" id="L2078">        sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L2079">    },</span>
<span class="line" id="L2080"></span>
<span class="line" id="L2081">    <span class="tok-comment">/// Returns a new file source that will have a relative path to the build root guaranteed.</span></span>
<span class="line" id="L2082">    <span class="tok-comment">/// Asserts the parameter is not an absolute path.</span></span>
<span class="line" id="L2083">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">relative</span>(path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) LazyPath {</span>
<span class="line" id="L2084">        std.debug.assert(!std.fs.path.isAbsolute(path));</span>
<span class="line" id="L2085">        <span class="tok-kw">return</span> LazyPath{ .path = path };</span>
<span class="line" id="L2086">    }</span>
<span class="line" id="L2087"></span>
<span class="line" id="L2088">    <span class="tok-comment">/// Returns a lazy path referring to the directory containing this path.</span></span>
<span class="line" id="L2089">    <span class="tok-comment">///</span></span>
<span class="line" id="L2090">    <span class="tok-comment">/// The dirname is not allowed to escape the logical root for underlying path.</span></span>
<span class="line" id="L2091">    <span class="tok-comment">/// For example, if the path is relative to the build root,</span></span>
<span class="line" id="L2092">    <span class="tok-comment">/// the dirname is not allowed to traverse outside of the build root.</span></span>
<span class="line" id="L2093">    <span class="tok-comment">/// Similarly, if the path is a generated file inside zig-cache,</span></span>
<span class="line" id="L2094">    <span class="tok-comment">/// the dirname is not allowed to traverse outside of zig-cache.</span></span>
<span class="line" id="L2095">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dirname</span>(self: LazyPath) LazyPath {</span>
<span class="line" id="L2096">        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (self) {</span>
<span class="line" id="L2097">            .generated =&gt; |gen| .{ .generated_dirname = .{ .generated = gen, .up = <span class="tok-number">0</span> } },</span>
<span class="line" id="L2098">            .generated_dirname =&gt; |gen| .{ .generated_dirname = .{ .generated = gen.generated, .up = gen.up + <span class="tok-number">1</span> } },</span>
<span class="line" id="L2099">            .path =&gt; |p| .{</span>
<span class="line" id="L2100">                .path = dirnameAllowEmpty(p) <span class="tok-kw">orelse</span> {</span>
<span class="line" id="L2101">                    dumpBadDirnameHelp(<span class="tok-null">null</span>, <span class="tok-null">null</span>,</span>
<span class="line" id="L2102">                        <span class="tok-str">\\dirname() attempted to traverse outside the build root.</span></span>

<span class="line" id="L2103">                        <span class="tok-str">\\This is not allowed.</span></span>

<span class="line" id="L2104">                        <span class="tok-str">\\</span></span>

<span class="line" id="L2105">                    , .{}) <span class="tok-kw">catch</span> {};</span>
<span class="line" id="L2106">                    <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;misconfigured build script&quot;</span>);</span>
<span class="line" id="L2107">                },</span>
<span class="line" id="L2108">            },</span>
<span class="line" id="L2109">            .cwd_relative =&gt; |p| .{</span>
<span class="line" id="L2110">                .cwd_relative = dirnameAllowEmpty(p) <span class="tok-kw">orelse</span> {</span>
<span class="line" id="L2111">                    <span class="tok-comment">// If we get null, it means one of two things:</span>
</span>
<span class="line" id="L2112">                    <span class="tok-comment">// - p was absolute, and is now root</span>
</span>
<span class="line" id="L2113">                    <span class="tok-comment">// - p was relative, and is now &quot;&quot;</span>
</span>
<span class="line" id="L2114">                    <span class="tok-comment">// In either case, the build script tried to go too far</span>
</span>
<span class="line" id="L2115">                    <span class="tok-comment">// and we should panic.</span>
</span>
<span class="line" id="L2116">                    <span class="tok-kw">if</span> (fs.path.isAbsolute(p)) {</span>
<span class="line" id="L2117">                        dumpBadDirnameHelp(<span class="tok-null">null</span>, <span class="tok-null">null</span>,</span>
<span class="line" id="L2118">                            <span class="tok-str">\\dirname() attempted to traverse outside the root.</span></span>

<span class="line" id="L2119">                            <span class="tok-str">\\No more directories left to go up.</span></span>

<span class="line" id="L2120">                            <span class="tok-str">\\</span></span>

<span class="line" id="L2121">                        , .{}) <span class="tok-kw">catch</span> {};</span>
<span class="line" id="L2122">                        <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;misconfigured build script&quot;</span>);</span>
<span class="line" id="L2123">                    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2124">                        dumpBadDirnameHelp(<span class="tok-null">null</span>, <span class="tok-null">null</span>,</span>
<span class="line" id="L2125">                            <span class="tok-str">\\dirname() attempted to traverse outside the current working directory.</span></span>

<span class="line" id="L2126">                            <span class="tok-str">\\This is not allowed.</span></span>

<span class="line" id="L2127">                            <span class="tok-str">\\</span></span>

<span class="line" id="L2128">                        , .{}) <span class="tok-kw">catch</span> {};</span>
<span class="line" id="L2129">                        <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;misconfigured build script&quot;</span>);</span>
<span class="line" id="L2130">                    }</span>
<span class="line" id="L2131">                },</span>
<span class="line" id="L2132">            },</span>
<span class="line" id="L2133">            .dependency =&gt; |dep| .{ .dependency = .{</span>
<span class="line" id="L2134">                .dependency = dep.dependency,</span>
<span class="line" id="L2135">                .sub_path = dirnameAllowEmpty(dep.sub_path) <span class="tok-kw">orelse</span> {</span>
<span class="line" id="L2136">                    dumpBadDirnameHelp(<span class="tok-null">null</span>, <span class="tok-null">null</span>,</span>
<span class="line" id="L2137">                        <span class="tok-str">\\dirname() attempted to traverse outside the dependency root.</span></span>

<span class="line" id="L2138">                        <span class="tok-str">\\This is not allowed.</span></span>

<span class="line" id="L2139">                        <span class="tok-str">\\</span></span>

<span class="line" id="L2140">                    , .{}) <span class="tok-kw">catch</span> {};</span>
<span class="line" id="L2141">                    <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;misconfigured build script&quot;</span>);</span>
<span class="line" id="L2142">                },</span>
<span class="line" id="L2143">            } },</span>
<span class="line" id="L2144">        };</span>
<span class="line" id="L2145">    }</span>
<span class="line" id="L2146"></span>
<span class="line" id="L2147">    <span class="tok-comment">/// Returns a string that can be shown to represent the file source.</span></span>
<span class="line" id="L2148">    <span class="tok-comment">/// Either returns the path or `&quot;generated&quot;`.</span></span>
<span class="line" id="L2149">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getDisplayName</span>(self: LazyPath) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L2150">        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (self) {</span>
<span class="line" id="L2151">            .path, .cwd_relative =&gt; self.path,</span>
<span class="line" id="L2152">            .generated =&gt; <span class="tok-str">&quot;generated&quot;</span>,</span>
<span class="line" id="L2153">            .generated_dirname =&gt; <span class="tok-str">&quot;generated&quot;</span>,</span>
<span class="line" id="L2154">            .dependency =&gt; <span class="tok-str">&quot;dependency&quot;</span>,</span>
<span class="line" id="L2155">        };</span>
<span class="line" id="L2156">    }</span>
<span class="line" id="L2157"></span>
<span class="line" id="L2158">    <span class="tok-comment">/// Adds dependencies this file source implies to the given step.</span></span>
<span class="line" id="L2159">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addStepDependencies</span>(self: LazyPath, other_step: *Step) <span class="tok-type">void</span> {</span>
<span class="line" id="L2160">        <span class="tok-kw">switch</span> (self) {</span>
<span class="line" id="L2161">            .path, .cwd_relative, .dependency =&gt; {},</span>
<span class="line" id="L2162">            .generated =&gt; |gen| other_step.dependOn(gen.step),</span>
<span class="line" id="L2163">            .generated_dirname =&gt; |gen| other_step.dependOn(gen.generated.step),</span>
<span class="line" id="L2164">        }</span>
<span class="line" id="L2165">    }</span>
<span class="line" id="L2166"></span>
<span class="line" id="L2167">    <span class="tok-comment">/// Returns an absolute path.</span></span>
<span class="line" id="L2168">    <span class="tok-comment">/// Intended to be used during the make phase only.</span></span>
<span class="line" id="L2169">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPath</span>(self: LazyPath, src_builder: *Build) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L2170">        <span class="tok-kw">return</span> getPath2(self, src_builder, <span class="tok-null">null</span>);</span>
<span class="line" id="L2171">    }</span>
<span class="line" id="L2172"></span>
<span class="line" id="L2173">    <span class="tok-comment">/// Returns an absolute path.</span></span>
<span class="line" id="L2174">    <span class="tok-comment">/// Intended to be used during the make phase only.</span></span>
<span class="line" id="L2175">    <span class="tok-comment">///</span></span>
<span class="line" id="L2176">    <span class="tok-comment">/// `asking_step` is only used for debugging purposes; it's the step being</span></span>
<span class="line" id="L2177">    <span class="tok-comment">/// run that is asking for the path.</span></span>
<span class="line" id="L2178">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPath2</span>(self: LazyPath, src_builder: *Build, asking_step: ?*Step) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L2179">        <span class="tok-kw">switch</span> (self) {</span>
<span class="line" id="L2180">            .path =&gt; |p| <span class="tok-kw">return</span> src_builder.pathFromRoot(p),</span>
<span class="line" id="L2181">            .cwd_relative =&gt; |p| <span class="tok-kw">return</span> src_builder.pathFromCwd(p),</span>
<span class="line" id="L2182">            .generated =&gt; |gen| <span class="tok-kw">return</span> gen.path <span class="tok-kw">orelse</span> {</span>
<span class="line" id="L2183">                std.debug.getStderrMutex().lock();</span>
<span class="line" id="L2184">                <span class="tok-kw">const</span> stderr = std.io.getStdErr();</span>
<span class="line" id="L2185">                dumpBadGetPathHelp(gen.step, stderr, src_builder, asking_step) <span class="tok-kw">catch</span> {};</span>
<span class="line" id="L2186">                <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;misconfigured build script&quot;</span>);</span>
<span class="line" id="L2187">            },</span>
<span class="line" id="L2188">            .generated_dirname =&gt; |gen| {</span>
<span class="line" id="L2189">                <span class="tok-kw">const</span> cache_root_path = src_builder.cache_root.path <span class="tok-kw">orelse</span></span>
<span class="line" id="L2190">                    (src_builder.cache_root.join(src_builder.allocator, &amp;.{<span class="tok-str">&quot;.&quot;</span>}) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>));</span>
<span class="line" id="L2191"></span>
<span class="line" id="L2192">                <span class="tok-kw">const</span> gen_step = gen.generated.step;</span>
<span class="line" id="L2193">                <span class="tok-kw">var</span> path = getPath2(LazyPath{ .generated = gen.generated }, src_builder, asking_step);</span>
<span class="line" id="L2194">                <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L2195">                <span class="tok-kw">while</span> (i &lt;= gen.up) : (i += <span class="tok-number">1</span>) {</span>
<span class="line" id="L2196">                    <span class="tok-comment">// path is absolute.</span>
</span>
<span class="line" id="L2197">                    <span class="tok-comment">// dirname will return null only if we're at root.</span>
</span>
<span class="line" id="L2198">                    <span class="tok-comment">// Typically, we'll stop well before that at the cache root.</span>
</span>
<span class="line" id="L2199">                    path = fs.path.dirname(path) <span class="tok-kw">orelse</span> {</span>
<span class="line" id="L2200">                        dumpBadDirnameHelp(gen_step, asking_step,</span>
<span class="line" id="L2201">                            <span class="tok-str">\\dirname() reached root.</span></span>

<span class="line" id="L2202">                            <span class="tok-str">\\No more directories left to go up.</span></span>

<span class="line" id="L2203">                            <span class="tok-str">\\</span></span>

<span class="line" id="L2204">                        , .{}) <span class="tok-kw">catch</span> {};</span>
<span class="line" id="L2205">                        <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;misconfigured build script&quot;</span>);</span>
<span class="line" id="L2206">                    };</span>
<span class="line" id="L2207"></span>
<span class="line" id="L2208">                    <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, path, cache_root_path) <span class="tok-kw">and</span> i &lt; gen.up) {</span>
<span class="line" id="L2209">                        <span class="tok-comment">// If we hit the cache root and there's still more to go,</span>
</span>
<span class="line" id="L2210">                        <span class="tok-comment">// the script attempted to go too far.</span>
</span>
<span class="line" id="L2211">                        dumpBadDirnameHelp(gen_step, asking_step,</span>
<span class="line" id="L2212">                            <span class="tok-str">\\dirname() attempted to traverse outside the cache root.</span></span>

<span class="line" id="L2213">                            <span class="tok-str">\\This is not allowed.</span></span>

<span class="line" id="L2214">                            <span class="tok-str">\\</span></span>

<span class="line" id="L2215">                        , .{}) <span class="tok-kw">catch</span> {};</span>
<span class="line" id="L2216">                        <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;misconfigured build script&quot;</span>);</span>
<span class="line" id="L2217">                    }</span>
<span class="line" id="L2218">                }</span>
<span class="line" id="L2219">                <span class="tok-kw">return</span> path;</span>
<span class="line" id="L2220">            },</span>
<span class="line" id="L2221">            .dependency =&gt; |dep| {</span>
<span class="line" id="L2222">                <span class="tok-kw">return</span> dep.dependency.builder.pathJoin(&amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{</span>
<span class="line" id="L2223">                    dep.dependency.builder.build_root.path.?,</span>
<span class="line" id="L2224">                    dep.sub_path,</span>
<span class="line" id="L2225">                });</span>
<span class="line" id="L2226">            },</span>
<span class="line" id="L2227">        }</span>
<span class="line" id="L2228">    }</span>
<span class="line" id="L2229"></span>
<span class="line" id="L2230">    <span class="tok-comment">/// Duplicates the file source for a given builder.</span></span>
<span class="line" id="L2231">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dupe</span>(self: LazyPath, b: *Build) LazyPath {</span>
<span class="line" id="L2232">        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (self) {</span>
<span class="line" id="L2233">            .path =&gt; |p| .{ .path = b.dupePath(p) },</span>
<span class="line" id="L2234">            .cwd_relative =&gt; |p| .{ .cwd_relative = b.dupePath(p) },</span>
<span class="line" id="L2235">            .generated =&gt; |gen| .{ .generated = gen },</span>
<span class="line" id="L2236">            .generated_dirname =&gt; |gen| .{</span>
<span class="line" id="L2237">                .generated_dirname = .{</span>
<span class="line" id="L2238">                    .generated = gen.generated,</span>
<span class="line" id="L2239">                    .up = gen.up,</span>
<span class="line" id="L2240">                },</span>
<span class="line" id="L2241">            },</span>
<span class="line" id="L2242">            .dependency =&gt; |dep| .{ .dependency = dep },</span>
<span class="line" id="L2243">        };</span>
<span class="line" id="L2244">    }</span>
<span class="line" id="L2245">};</span>
<span class="line" id="L2246"></span>
<span class="line" id="L2247"><span class="tok-kw">fn</span> <span class="tok-fn">dumpBadDirnameHelp</span>(</span>
<span class="line" id="L2248">    fail_step: ?*Step,</span>
<span class="line" id="L2249">    asking_step: ?*Step,</span>
<span class="line" id="L2250">    <span class="tok-kw">comptime</span> msg: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L2251">    args: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L2252">) <span class="tok-type">anyerror</span>!<span class="tok-type">void</span> {</span>
<span class="line" id="L2253">    debug.getStderrMutex().lock();</span>
<span class="line" id="L2254">    <span class="tok-kw">defer</span> debug.getStderrMutex().unlock();</span>
<span class="line" id="L2255"></span>
<span class="line" id="L2256">    <span class="tok-kw">const</span> stderr = io.getStdErr();</span>
<span class="line" id="L2257">    <span class="tok-kw">const</span> w = stderr.writer();</span>
<span class="line" id="L2258">    <span class="tok-kw">try</span> w.print(msg, args);</span>
<span class="line" id="L2259"></span>
<span class="line" id="L2260">    <span class="tok-kw">const</span> tty_config = std.io.tty.detectConfig(stderr);</span>
<span class="line" id="L2261"></span>
<span class="line" id="L2262">    <span class="tok-kw">if</span> (fail_step) |s| {</span>
<span class="line" id="L2263">        tty_config.setColor(w, .red) <span class="tok-kw">catch</span> {};</span>
<span class="line" id="L2264">        <span class="tok-kw">try</span> stderr.writeAll(<span class="tok-str">&quot;    The step was created by this stack trace:\n&quot;</span>);</span>
<span class="line" id="L2265">        tty_config.setColor(w, .reset) <span class="tok-kw">catch</span> {};</span>
<span class="line" id="L2266"></span>
<span class="line" id="L2267">        s.dump(stderr);</span>
<span class="line" id="L2268">    }</span>
<span class="line" id="L2269"></span>
<span class="line" id="L2270">    <span class="tok-kw">if</span> (asking_step) |as| {</span>
<span class="line" id="L2271">        tty_config.setColor(w, .red) <span class="tok-kw">catch</span> {};</span>
<span class="line" id="L2272">        <span class="tok-kw">try</span> stderr.writer().print(<span class="tok-str">&quot;    The step '{s}' that is missing a dependency on the above step was created by this stack trace:\n&quot;</span>, .{as.name});</span>
<span class="line" id="L2273">        tty_config.setColor(w, .reset) <span class="tok-kw">catch</span> {};</span>
<span class="line" id="L2274"></span>
<span class="line" id="L2275">        as.dump(stderr);</span>
<span class="line" id="L2276">    }</span>
<span class="line" id="L2277"></span>
<span class="line" id="L2278">    tty_config.setColor(w, .red) <span class="tok-kw">catch</span> {};</span>
<span class="line" id="L2279">    <span class="tok-kw">try</span> stderr.writeAll(<span class="tok-str">&quot;    Hope that helps. Proceeding to panic.\n&quot;</span>);</span>
<span class="line" id="L2280">    tty_config.setColor(w, .reset) <span class="tok-kw">catch</span> {};</span>
<span class="line" id="L2281">}</span>
<span class="line" id="L2282"></span>
<span class="line" id="L2283"><span class="tok-comment">/// In this function the stderr mutex has already been locked.</span></span>
<span class="line" id="L2284"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dumpBadGetPathHelp</span>(</span>
<span class="line" id="L2285">    s: *Step,</span>
<span class="line" id="L2286">    stderr: fs.File,</span>
<span class="line" id="L2287">    src_builder: *Build,</span>
<span class="line" id="L2288">    asking_step: ?*Step,</span>
<span class="line" id="L2289">) <span class="tok-type">anyerror</span>!<span class="tok-type">void</span> {</span>
<span class="line" id="L2290">    <span class="tok-kw">const</span> w = stderr.writer();</span>
<span class="line" id="L2291">    <span class="tok-kw">try</span> w.print(</span>
<span class="line" id="L2292">        <span class="tok-str">\\getPath() was called on a GeneratedFile that wasn't built yet.</span></span>

<span class="line" id="L2293">        <span class="tok-str">\\  source package path: {s}</span></span>

<span class="line" id="L2294">        <span class="tok-str">\\  Is there a missing Step dependency on step '{s}'?</span></span>

<span class="line" id="L2295">        <span class="tok-str">\\</span></span>

<span class="line" id="L2296">    , .{</span>
<span class="line" id="L2297">        src_builder.build_root.path <span class="tok-kw">orelse</span> <span class="tok-str">&quot;.&quot;</span>,</span>
<span class="line" id="L2298">        s.name,</span>
<span class="line" id="L2299">    });</span>
<span class="line" id="L2300"></span>
<span class="line" id="L2301">    <span class="tok-kw">const</span> tty_config = std.io.tty.detectConfig(stderr);</span>
<span class="line" id="L2302">    tty_config.setColor(w, .red) <span class="tok-kw">catch</span> {};</span>
<span class="line" id="L2303">    <span class="tok-kw">try</span> stderr.writeAll(<span class="tok-str">&quot;    The step was created by this stack trace:\n&quot;</span>);</span>
<span class="line" id="L2304">    tty_config.setColor(w, .reset) <span class="tok-kw">catch</span> {};</span>
<span class="line" id="L2305"></span>
<span class="line" id="L2306">    s.dump(stderr);</span>
<span class="line" id="L2307">    <span class="tok-kw">if</span> (asking_step) |as| {</span>
<span class="line" id="L2308">        tty_config.setColor(w, .red) <span class="tok-kw">catch</span> {};</span>
<span class="line" id="L2309">        <span class="tok-kw">try</span> stderr.writer().print(<span class="tok-str">&quot;    The step '{s}' that is missing a dependency on the above step was created by this stack trace:\n&quot;</span>, .{as.name});</span>
<span class="line" id="L2310">        tty_config.setColor(w, .reset) <span class="tok-kw">catch</span> {};</span>
<span class="line" id="L2311"></span>
<span class="line" id="L2312">        as.dump(stderr);</span>
<span class="line" id="L2313">    }</span>
<span class="line" id="L2314">    tty_config.setColor(w, .red) <span class="tok-kw">catch</span> {};</span>
<span class="line" id="L2315">    <span class="tok-kw">try</span> stderr.writeAll(<span class="tok-str">&quot;    Hope that helps. Proceeding to panic.\n&quot;</span>);</span>
<span class="line" id="L2316">    tty_config.setColor(w, .reset) <span class="tok-kw">catch</span> {};</span>
<span class="line" id="L2317">}</span>
<span class="line" id="L2318"></span>
<span class="line" id="L2319"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> InstallDir = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {</span>
<span class="line" id="L2320">    prefix: <span class="tok-type">void</span>,</span>
<span class="line" id="L2321">    lib: <span class="tok-type">void</span>,</span>
<span class="line" id="L2322">    bin: <span class="tok-type">void</span>,</span>
<span class="line" id="L2323">    header: <span class="tok-type">void</span>,</span>
<span class="line" id="L2324">    <span class="tok-comment">/// A path relative to the prefix</span></span>
<span class="line" id="L2325">    custom: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L2326"></span>
<span class="line" id="L2327">    <span class="tok-comment">/// Duplicates the install directory including the path if set to custom.</span></span>
<span class="line" id="L2328">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dupe</span>(self: InstallDir, builder: *Build) InstallDir {</span>
<span class="line" id="L2329">        <span class="tok-kw">if</span> (self == .custom) {</span>
<span class="line" id="L2330">            <span class="tok-kw">return</span> .{ .custom = builder.dupe(self.custom) };</span>
<span class="line" id="L2331">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2332">            <span class="tok-kw">return</span> self;</span>
<span class="line" id="L2333">        }</span>
<span class="line" id="L2334">    }</span>
<span class="line" id="L2335">};</span>
<span class="line" id="L2336"></span>
<span class="line" id="L2337"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> InstalledFile = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2338">    dir: InstallDir,</span>
<span class="line" id="L2339">    path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L2340"></span>
<span class="line" id="L2341">    <span class="tok-comment">/// Duplicates the installed file path and directory.</span></span>
<span class="line" id="L2342">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dupe</span>(self: InstalledFile, builder: *Build) InstalledFile {</span>
<span class="line" id="L2343">        <span class="tok-kw">return</span> .{</span>
<span class="line" id="L2344">            .dir = self.dir.dupe(builder),</span>
<span class="line" id="L2345">            .path = builder.dupe(self.path),</span>
<span class="line" id="L2346">        };</span>
<span class="line" id="L2347">    }</span>
<span class="line" id="L2348">};</span>
<span class="line" id="L2349"></span>
<span class="line" id="L2350"><span class="tok-comment">/// This function is intended to be called in the `configure` phase only.</span></span>
<span class="line" id="L2351"><span class="tok-comment">/// It returns an absolute directory path, which is potentially going to be a</span></span>
<span class="line" id="L2352"><span class="tok-comment">/// source of API breakage in the future, so keep that in mind when using this</span></span>
<span class="line" id="L2353"><span class="tok-comment">/// function.</span></span>
<span class="line" id="L2354"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">makeTempPath</span>(b: *Build) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L2355">    <span class="tok-kw">const</span> rand_int = std.crypto.random.int(<span class="tok-type">u64</span>);</span>
<span class="line" id="L2356">    <span class="tok-kw">const</span> tmp_dir_sub_path = <span class="tok-str">&quot;tmp&quot;</span> ++ fs.path.sep_str ++ hex64(rand_int);</span>
<span class="line" id="L2357">    <span class="tok-kw">const</span> result_path = b.cache_root.join(b.allocator, &amp;.{tmp_dir_sub_path}) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L2358">    b.cache_root.handle.makePath(tmp_dir_sub_path) <span class="tok-kw">catch</span> |err| {</span>
<span class="line" id="L2359">        std.debug.print(<span class="tok-str">&quot;unable to make tmp path '{s}': {s}\n&quot;</span>, .{</span>
<span class="line" id="L2360">            result_path, <span class="tok-builtin">@errorName</span>(err),</span>
<span class="line" id="L2361">        });</span>
<span class="line" id="L2362">    };</span>
<span class="line" id="L2363">    <span class="tok-kw">return</span> result_path;</span>
<span class="line" id="L2364">}</span>
<span class="line" id="L2365"></span>
<span class="line" id="L2366"><span class="tok-comment">/// There are a few copies of this function in miscellaneous places. Would be nice to find</span></span>
<span class="line" id="L2367"><span class="tok-comment">/// a home for them.</span></span>
<span class="line" id="L2368"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hex64</span>(x: <span class="tok-type">u64</span>) [<span class="tok-number">16</span>]<span class="tok-type">u8</span> {</span>
<span class="line" id="L2369">    <span class="tok-kw">const</span> hex_charset = <span class="tok-str">&quot;0123456789abcdef&quot;</span>;</span>
<span class="line" id="L2370">    <span class="tok-kw">var</span> result: [<span class="tok-number">16</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L2371">    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L2372">    <span class="tok-kw">while</span> (i &lt; <span class="tok-number">8</span>) : (i += <span class="tok-number">1</span>) {</span>
<span class="line" id="L2373">        <span class="tok-kw">const</span> byte: <span class="tok-type">u8</span> = <span class="tok-builtin">@truncate</span>(x &gt;&gt; <span class="tok-builtin">@as</span>(<span class="tok-type">u6</span>, <span class="tok-builtin">@intCast</span>(<span class="tok-number">8</span> * i)));</span>
<span class="line" id="L2374">        result[i * <span class="tok-number">2</span> + <span class="tok-number">0</span>] = hex_charset[byte &gt;&gt; <span class="tok-number">4</span>];</span>
<span class="line" id="L2375">        result[i * <span class="tok-number">2</span> + <span class="tok-number">1</span>] = hex_charset[byte &amp; <span class="tok-number">15</span>];</span>
<span class="line" id="L2376">    }</span>
<span class="line" id="L2377">    <span class="tok-kw">return</span> result;</span>
<span class="line" id="L2378">}</span>
<span class="line" id="L2379"></span>
<span class="line" id="L2380"><span class="tok-comment">/// A pair of target query and fully resolved target.</span></span>
<span class="line" id="L2381"><span class="tok-comment">/// This type is generally required by build system API that need to be given a</span></span>
<span class="line" id="L2382"><span class="tok-comment">/// target. The query is kept because the Zig toolchain needs to know which parts</span></span>
<span class="line" id="L2383"><span class="tok-comment">/// of the target are &quot;native&quot;. This can apply to the CPU, the OS, or even the ABI.</span></span>
<span class="line" id="L2384"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ResolvedTarget = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2385">    query: Target.Query,</span>
<span class="line" id="L2386">    result: Target,</span>
<span class="line" id="L2387">};</span>
<span class="line" id="L2388"></span>
<span class="line" id="L2389"><span class="tok-comment">/// Converts a target query into a fully resolved target that can be passed to</span></span>
<span class="line" id="L2390"><span class="tok-comment">/// various parts of the API.</span></span>
<span class="line" id="L2391"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">resolveTargetQuery</span>(b: *Build, query: Target.Query) ResolvedTarget {</span>
<span class="line" id="L2392">    <span class="tok-kw">if</span> (query.isNative()) {</span>
<span class="line" id="L2393">        <span class="tok-kw">var</span> adjusted = b.host;</span>
<span class="line" id="L2394">        <span class="tok-kw">if</span> (query.ofmt) |ofmt| {</span>
<span class="line" id="L2395">            adjusted.query.ofmt = ofmt;</span>
<span class="line" id="L2396">            adjusted.result.ofmt = ofmt;</span>
<span class="line" id="L2397">        }</span>
<span class="line" id="L2398">        <span class="tok-kw">return</span> adjusted;</span>
<span class="line" id="L2399">    }</span>
<span class="line" id="L2400"></span>
<span class="line" id="L2401">    <span class="tok-kw">return</span> .{</span>
<span class="line" id="L2402">        .query = query,</span>
<span class="line" id="L2403">        .result = std.zig.system.resolveTargetQuery(query) <span class="tok-kw">catch</span></span>
<span class="line" id="L2404">            <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;unable to resolve target query&quot;</span>),</span>
<span class="line" id="L2405">    };</span>
<span class="line" id="L2406">}</span>
<span class="line" id="L2407"></span>
<span class="line" id="L2408"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">wantSharedLibSymLinks</span>(target: Target) <span class="tok-type">bool</span> {</span>
<span class="line" id="L2409">    <span class="tok-kw">return</span> target.os.tag != .windows;</span>
<span class="line" id="L2410">}</span>
<span class="line" id="L2411"></span>
<span class="line" id="L2412"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> SystemIntegrationOptionConfig = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2413">    <span class="tok-comment">/// If left as null, then the default will depend on system_package_mode.</span></span>
<span class="line" id="L2414">    default: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L2415">};</span>
<span class="line" id="L2416"></span>
<span class="line" id="L2417"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">systemIntegrationOption</span>(</span>
<span class="line" id="L2418">    b: *Build,</span>
<span class="line" id="L2419">    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L2420">    config: SystemIntegrationOptionConfig,</span>
<span class="line" id="L2421">) <span class="tok-type">bool</span> {</span>
<span class="line" id="L2422">    <span class="tok-kw">const</span> gop = b.graph.system_library_options.getOrPut(b.allocator, name) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);</span>
<span class="line" id="L2423">    <span class="tok-kw">if</span> (gop.found_existing) <span class="tok-kw">switch</span> (gop.value_ptr.*) {</span>
<span class="line" id="L2424">        .user_disabled =&gt; {</span>
<span class="line" id="L2425">            gop.value_ptr.* = .declared_disabled;</span>
<span class="line" id="L2426">            <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L2427">        },</span>
<span class="line" id="L2428">        .user_enabled =&gt; {</span>
<span class="line" id="L2429">            gop.value_ptr.* = .declared_enabled;</span>
<span class="line" id="L2430">            <span class="tok-kw">return</span> <span class="tok-null">true</span>;</span>
<span class="line" id="L2431">        },</span>
<span class="line" id="L2432">        .declared_disabled =&gt; <span class="tok-kw">return</span> <span class="tok-null">false</span>,</span>
<span class="line" id="L2433">        .declared_enabled =&gt; <span class="tok-kw">return</span> <span class="tok-null">true</span>,</span>
<span class="line" id="L2434">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2435">        gop.key_ptr.* = b.dupe(name);</span>
<span class="line" id="L2436">        <span class="tok-kw">if</span> (config.default <span class="tok-kw">orelse</span> b.graph.system_package_mode) {</span>
<span class="line" id="L2437">            gop.value_ptr.* = .declared_enabled;</span>
<span class="line" id="L2438">            <span class="tok-kw">return</span> <span class="tok-null">true</span>;</span>
<span class="line" id="L2439">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2440">            gop.value_ptr.* = .declared_disabled;</span>
<span class="line" id="L2441">            <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L2442">        }</span>
<span class="line" id="L2443">    }</span>
<span class="line" id="L2444">}</span>
<span class="line" id="L2445"></span>
<span class="line" id="L2446"><span class="tok-kw">test</span> {</span>
<span class="line" id="L2447">    _ = Cache;</span>
<span class="line" id="L2448">    _ = Step;</span>
<span class="line" id="L2449">}</span>
<span class="line" id="L2450"></span>
</code></pre></body>
</html>