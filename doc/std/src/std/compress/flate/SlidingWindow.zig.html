<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>compress/flate/SlidingWindow.zig - source view</title>
    <link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAgklEQVR4AWMYWuD7EllJIM4G4g4g5oIJ/odhOJ8wToOxSTXgNxDHoeiBMfA4+wGShjyYOCkG/IGqWQziEzYAoUAeiF9D5U+DxEg14DRU7jWIT5IBIOdCxf+A+CQZAAoopEB7QJwBCBwHiip8UYmRdrAlDpIMgApwQZNnNii5Dq0MBgCxxycBnwEd+wAAAABJRU5ErkJggg==">
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style>
      body{
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        margin: 0;
        line-height: 1.5;
      }

      pre > code {
        display: block;
        overflow: auto;
        line-height: normal;
        margin: 0em;
      }
      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #005C7A;
      }
      .tok-comment {
          color: #545454;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #005C5C;
      }
      .tok-number {
          color: #005C5C;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }
      pre {
        counter-reset: line;
      }
      pre .line:before {
        counter-increment: line;
        content: counter(line);
        display: inline-block;
        padding-right: 1em;
        width: 2em;
        text-align: right;
        color: #999;
      }
      
      .line {
        width: 100%;
        display: inline-block;
      }
      .line:target {
        border-top: 1px solid #ccc;
        border-bottom: 1px solid #ccc;
        background: #fafafa;
      }

      @media (prefers-color-scheme: dark) {
        body{
            background:#222;
            color: #ccc;
        }
        pre > code {
            color: #ccc;
            background: #222;
            border: unset;
        }
        .line:target {
            border-top: 1px solid #444;
            border-bottom: 1px solid #444;
            background: #333;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
</head>
<body>
<pre><code><span class="line" id="L1"><span class="tok-comment">//! Used in deflate (compression), holds uncompressed data form which Tokens are</span></span>
<span class="line" id="L2"><span class="tok-comment">//! produces. In combination with Lookup it is used to find matches in history data.</span></span>
<span class="line" id="L3"><span class="tok-comment">//!</span></span>
<span class="line" id="L4"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);</span>
<span class="line" id="L5"><span class="tok-kw">const</span> consts = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;consts.zig&quot;</span>);</span>
<span class="line" id="L6"></span>
<span class="line" id="L7"><span class="tok-kw">const</span> expect = testing.expect;</span>
<span class="line" id="L8"><span class="tok-kw">const</span> assert = std.debug.assert;</span>
<span class="line" id="L9"><span class="tok-kw">const</span> testing = std.testing;</span>
<span class="line" id="L10"></span>
<span class="line" id="L11"><span class="tok-kw">const</span> hist_len = consts.history.len;</span>
<span class="line" id="L12"><span class="tok-kw">const</span> buffer_len = <span class="tok-number">2</span> * hist_len;</span>
<span class="line" id="L13"><span class="tok-kw">const</span> min_lookahead = consts.match.min_length + consts.match.max_length;</span>
<span class="line" id="L14"><span class="tok-kw">const</span> max_rp = buffer_len - min_lookahead;</span>
<span class="line" id="L15"></span>
<span class="line" id="L16"><span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();</span>
<span class="line" id="L17"></span>
<span class="line" id="L18">buffer: [buffer_len]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L19">wp: <span class="tok-type">usize</span> = <span class="tok-number">0</span>, <span class="tok-comment">// write position</span>
</span>
<span class="line" id="L20">rp: <span class="tok-type">usize</span> = <span class="tok-number">0</span>, <span class="tok-comment">// read position</span>
</span>
<span class="line" id="L21">fp: <span class="tok-type">isize</span> = <span class="tok-number">0</span>, <span class="tok-comment">// last flush position, tokens are build from fp..rp</span>
</span>
<span class="line" id="L22"></span>
<span class="line" id="L23"><span class="tok-comment">/// Returns number of bytes written, or 0 if buffer is full and need to slide.</span></span>
<span class="line" id="L24"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">write</span>(self: *Self, buf: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">usize</span> {</span>
<span class="line" id="L25">    <span class="tok-kw">if</span> (self.rp &gt;= max_rp) <span class="tok-kw">return</span> <span class="tok-number">0</span>; <span class="tok-comment">// need to slide</span>
</span>
<span class="line" id="L26"></span>
<span class="line" id="L27">    <span class="tok-kw">const</span> n = <span class="tok-builtin">@min</span>(buf.len, buffer_len - self.wp);</span>
<span class="line" id="L28">    <span class="tok-builtin">@memcpy</span>(self.buffer[self.wp .. self.wp + n], buf[<span class="tok-number">0</span>..n]);</span>
<span class="line" id="L29">    self.wp += n;</span>
<span class="line" id="L30">    <span class="tok-kw">return</span> n;</span>
<span class="line" id="L31">}</span>
<span class="line" id="L32"></span>
<span class="line" id="L33"><span class="tok-comment">/// Slide buffer for hist_len.</span></span>
<span class="line" id="L34"><span class="tok-comment">/// Drops old history, preserves between hist_len and hist_len - min_lookahead.</span></span>
<span class="line" id="L35"><span class="tok-comment">/// Returns number of bytes removed.</span></span>
<span class="line" id="L36"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">slide</span>(self: *Self) <span class="tok-type">u16</span> {</span>
<span class="line" id="L37">    assert(self.rp &gt;= max_rp <span class="tok-kw">and</span> self.wp &gt;= self.rp);</span>
<span class="line" id="L38">    <span class="tok-kw">const</span> n = self.wp - hist_len;</span>
<span class="line" id="L39">    <span class="tok-builtin">@memcpy</span>(self.buffer[<span class="tok-number">0</span>..n], self.buffer[hist_len..self.wp]);</span>
<span class="line" id="L40">    self.rp -= hist_len;</span>
<span class="line" id="L41">    self.wp -= hist_len;</span>
<span class="line" id="L42">    self.fp -= hist_len;</span>
<span class="line" id="L43">    <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(n);</span>
<span class="line" id="L44">}</span>
<span class="line" id="L45"></span>
<span class="line" id="L46"><span class="tok-comment">/// Data from the current position (read position). Those part of the buffer is</span></span>
<span class="line" id="L47"><span class="tok-comment">/// not converted to tokens yet.</span></span>
<span class="line" id="L48"><span class="tok-kw">fn</span> <span class="tok-fn">lookahead</span>(self: *Self) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L49">    assert(self.wp &gt;= self.rp);</span>
<span class="line" id="L50">    <span class="tok-kw">return</span> self.buffer[self.rp..self.wp];</span>
<span class="line" id="L51">}</span>
<span class="line" id="L52"></span>
<span class="line" id="L53"><span class="tok-comment">/// Returns part of the lookahead buffer. If should_flush is set no lookahead is</span></span>
<span class="line" id="L54"><span class="tok-comment">/// preserved otherwise preserves enough data for the longest match. Returns</span></span>
<span class="line" id="L55"><span class="tok-comment">/// null if there is not enough data.</span></span>
<span class="line" id="L56"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">activeLookahead</span>(self: *Self, should_flush: <span class="tok-type">bool</span>) ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L57">    <span class="tok-kw">const</span> min: <span class="tok-type">usize</span> = <span class="tok-kw">if</span> (should_flush) <span class="tok-number">0</span> <span class="tok-kw">else</span> min_lookahead;</span>
<span class="line" id="L58">    <span class="tok-kw">const</span> lh = self.lookahead();</span>
<span class="line" id="L59">    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (lh.len &gt; min) lh <span class="tok-kw">else</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L60">}</span>
<span class="line" id="L61"></span>
<span class="line" id="L62"><span class="tok-comment">/// Advances read position, shrinks lookahead.</span></span>
<span class="line" id="L63"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">advance</span>(self: *Self, n: <span class="tok-type">u16</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L64">    assert(self.wp &gt;= self.rp + n);</span>
<span class="line" id="L65">    self.rp += n;</span>
<span class="line" id="L66">}</span>
<span class="line" id="L67"></span>
<span class="line" id="L68"><span class="tok-comment">/// Returns writable part of the buffer, where new uncompressed data can be</span></span>
<span class="line" id="L69"><span class="tok-comment">/// written.</span></span>
<span class="line" id="L70"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writable</span>(self: *Self) []<span class="tok-type">u8</span> {</span>
<span class="line" id="L71">    <span class="tok-kw">return</span> self.buffer[self.wp..];</span>
<span class="line" id="L72">}</span>
<span class="line" id="L73"></span>
<span class="line" id="L74"><span class="tok-comment">/// Notification of what part of writable buffer is filled with data.</span></span>
<span class="line" id="L75"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">written</span>(self: *Self, n: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L76">    self.wp += n;</span>
<span class="line" id="L77">}</span>
<span class="line" id="L78"></span>
<span class="line" id="L79"><span class="tok-comment">/// Finds match length between previous and current position.</span></span>
<span class="line" id="L80"><span class="tok-comment">/// Used in hot path!</span></span>
<span class="line" id="L81"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">match</span>(self: *Self, prev_pos: <span class="tok-type">u16</span>, curr_pos: <span class="tok-type">u16</span>, min_len: <span class="tok-type">u16</span>) <span class="tok-type">u16</span> {</span>
<span class="line" id="L82">    <span class="tok-kw">const</span> max_len: <span class="tok-type">usize</span> = <span class="tok-builtin">@min</span>(self.wp - curr_pos, consts.match.max_length);</span>
<span class="line" id="L83">    <span class="tok-comment">// lookahead buffers from previous and current positions</span>
</span>
<span class="line" id="L84">    <span class="tok-kw">const</span> prev_lh = self.buffer[prev_pos..][<span class="tok-number">0</span>..max_len];</span>
<span class="line" id="L85">    <span class="tok-kw">const</span> curr_lh = self.buffer[curr_pos..][<span class="tok-number">0</span>..max_len];</span>
<span class="line" id="L86"></span>
<span class="line" id="L87">    <span class="tok-comment">// If we alread have match (min_len &gt; 0),</span>
</span>
<span class="line" id="L88">    <span class="tok-comment">// test the first byte above previous len a[min_len] != b[min_len]</span>
</span>
<span class="line" id="L89">    <span class="tok-comment">// and then all the bytes from that position to zero.</span>
</span>
<span class="line" id="L90">    <span class="tok-comment">// That is likely positions to find difference than looping from first bytes.</span>
</span>
<span class="line" id="L91">    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = min_len;</span>
<span class="line" id="L92">    <span class="tok-kw">if</span> (i &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L93">        <span class="tok-kw">if</span> (max_len &lt;= i) <span class="tok-kw">return</span> <span class="tok-number">0</span>;</span>
<span class="line" id="L94">        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L95">            <span class="tok-kw">if</span> (prev_lh[i] != curr_lh[i]) <span class="tok-kw">return</span> <span class="tok-number">0</span>;</span>
<span class="line" id="L96">            <span class="tok-kw">if</span> (i == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;</span>
<span class="line" id="L97">            i -= <span class="tok-number">1</span>;</span>
<span class="line" id="L98">        }</span>
<span class="line" id="L99">        i = min_len;</span>
<span class="line" id="L100">    }</span>
<span class="line" id="L101">    <span class="tok-kw">while</span> (i &lt; max_len) : (i += <span class="tok-number">1</span>)</span>
<span class="line" id="L102">        <span class="tok-kw">if</span> (prev_lh[i] != curr_lh[i]) <span class="tok-kw">break</span>;</span>
<span class="line" id="L103">    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (i &gt;= consts.match.min_length) <span class="tok-builtin">@intCast</span>(i) <span class="tok-kw">else</span> <span class="tok-number">0</span>;</span>
<span class="line" id="L104">}</span>
<span class="line" id="L105"></span>
<span class="line" id="L106"><span class="tok-comment">/// Current position of non-compressed data. Data before rp are already converted</span></span>
<span class="line" id="L107"><span class="tok-comment">/// to tokens.</span></span>
<span class="line" id="L108"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pos</span>(self: *Self) <span class="tok-type">u16</span> {</span>
<span class="line" id="L109">    <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(self.rp);</span>
<span class="line" id="L110">}</span>
<span class="line" id="L111"></span>
<span class="line" id="L112"><span class="tok-comment">/// Notification that token list is cleared.</span></span>
<span class="line" id="L113"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">flush</span>(self: *Self) <span class="tok-type">void</span> {</span>
<span class="line" id="L114">    self.fp = <span class="tok-builtin">@intCast</span>(self.rp);</span>
<span class="line" id="L115">}</span>
<span class="line" id="L116"></span>
<span class="line" id="L117"><span class="tok-comment">/// Part of the buffer since last flush or null if there was slide in between (so</span></span>
<span class="line" id="L118"><span class="tok-comment">/// fp becomes negative).</span></span>
<span class="line" id="L119"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">tokensBuffer</span>(self: *Self) ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L120">    assert(self.fp &lt;= self.rp);</span>
<span class="line" id="L121">    <span class="tok-kw">if</span> (self.fp &lt; <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L122">    <span class="tok-kw">return</span> self.buffer[<span class="tok-builtin">@intCast</span>(self.fp)..self.rp];</span>
<span class="line" id="L123">}</span>
<span class="line" id="L124"></span>
<span class="line" id="L125"><span class="tok-kw">test</span> match {</span>
<span class="line" id="L126">    <span class="tok-kw">const</span> data = <span class="tok-str">&quot;Blah blah blah blah blah!&quot;</span>;</span>
<span class="line" id="L127">    <span class="tok-kw">var</span> win: Self = .{};</span>
<span class="line" id="L128">    <span class="tok-kw">try</span> expect(win.write(data) == data.len);</span>
<span class="line" id="L129">    <span class="tok-kw">try</span> expect(win.wp == data.len);</span>
<span class="line" id="L130">    <span class="tok-kw">try</span> expect(win.rp == <span class="tok-number">0</span>);</span>
<span class="line" id="L131"></span>
<span class="line" id="L132">    <span class="tok-comment">// length between l symbols</span>
</span>
<span class="line" id="L133">    <span class="tok-kw">try</span> expect(win.match(<span class="tok-number">1</span>, <span class="tok-number">6</span>, <span class="tok-number">0</span>) == <span class="tok-number">18</span>);</span>
<span class="line" id="L134">    <span class="tok-kw">try</span> expect(win.match(<span class="tok-number">1</span>, <span class="tok-number">11</span>, <span class="tok-number">0</span>) == <span class="tok-number">13</span>);</span>
<span class="line" id="L135">    <span class="tok-kw">try</span> expect(win.match(<span class="tok-number">1</span>, <span class="tok-number">16</span>, <span class="tok-number">0</span>) == <span class="tok-number">8</span>);</span>
<span class="line" id="L136">    <span class="tok-kw">try</span> expect(win.match(<span class="tok-number">1</span>, <span class="tok-number">21</span>, <span class="tok-number">0</span>) == <span class="tok-number">0</span>);</span>
<span class="line" id="L137"></span>
<span class="line" id="L138">    <span class="tok-comment">// position 15 = &quot;blah blah!&quot;</span>
</span>
<span class="line" id="L139">    <span class="tok-comment">// position 20 = &quot;blah!&quot;</span>
</span>
<span class="line" id="L140">    <span class="tok-kw">try</span> expect(win.match(<span class="tok-number">15</span>, <span class="tok-number">20</span>, <span class="tok-number">0</span>) == <span class="tok-number">4</span>);</span>
<span class="line" id="L141">    <span class="tok-kw">try</span> expect(win.match(<span class="tok-number">15</span>, <span class="tok-number">20</span>, <span class="tok-number">3</span>) == <span class="tok-number">4</span>);</span>
<span class="line" id="L142">    <span class="tok-kw">try</span> expect(win.match(<span class="tok-number">15</span>, <span class="tok-number">20</span>, <span class="tok-number">4</span>) == <span class="tok-number">0</span>);</span>
<span class="line" id="L143">}</span>
<span class="line" id="L144"></span>
<span class="line" id="L145"><span class="tok-kw">test</span> slide {</span>
<span class="line" id="L146">    <span class="tok-kw">var</span> win: Self = .{};</span>
<span class="line" id="L147">    win.wp = Self.buffer_len - <span class="tok-number">11</span>;</span>
<span class="line" id="L148">    win.rp = Self.buffer_len - <span class="tok-number">111</span>;</span>
<span class="line" id="L149">    win.buffer[win.rp] = <span class="tok-number">0xab</span>;</span>
<span class="line" id="L150">    <span class="tok-kw">try</span> expect(win.lookahead().len == <span class="tok-number">100</span>);</span>
<span class="line" id="L151">    <span class="tok-kw">try</span> expect(win.tokensBuffer().?.len == win.rp);</span>
<span class="line" id="L152"></span>
<span class="line" id="L153">    <span class="tok-kw">const</span> n = win.slide();</span>
<span class="line" id="L154">    <span class="tok-kw">try</span> expect(n == <span class="tok-number">32757</span>);</span>
<span class="line" id="L155">    <span class="tok-kw">try</span> expect(win.buffer[win.rp] == <span class="tok-number">0xab</span>);</span>
<span class="line" id="L156">    <span class="tok-kw">try</span> expect(win.rp == Self.hist_len - <span class="tok-number">111</span>);</span>
<span class="line" id="L157">    <span class="tok-kw">try</span> expect(win.wp == Self.hist_len - <span class="tok-number">11</span>);</span>
<span class="line" id="L158">    <span class="tok-kw">try</span> expect(win.lookahead().len == <span class="tok-number">100</span>);</span>
<span class="line" id="L159">    <span class="tok-kw">try</span> expect(win.tokensBuffer() == <span class="tok-null">null</span>);</span>
<span class="line" id="L160">}</span>
<span class="line" id="L161"></span>
</code></pre></body>
</html>