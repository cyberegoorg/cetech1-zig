<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>tar.zig - source view</title>
    <link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAgklEQVR4AWMYWuD7EllJIM4G4g4g5oIJ/odhOJ8wToOxSTXgNxDHoeiBMfA4+wGShjyYOCkG/IGqWQziEzYAoUAeiF9D5U+DxEg14DRU7jWIT5IBIOdCxf+A+CQZAAoopEB7QJwBCBwHiip8UYmRdrAlDpIMgApwQZNnNii5Dq0MBgCxxycBnwEd+wAAAABJRU5ErkJggg==">
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style>
      body{
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        margin: 0;
        line-height: 1.5;
      }

      pre > code {
        display: block;
        overflow: auto;
        line-height: normal;
        margin: 0em;
      }
      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #005C7A;
      }
      .tok-comment {
          color: #545454;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #005C5C;
      }
      .tok-number {
          color: #005C5C;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }
      pre {
        counter-reset: line;
      }
      pre .line:before {
        counter-increment: line;
        content: counter(line);
        display: inline-block;
        padding-right: 1em;
        width: 2em;
        text-align: right;
        color: #999;
      }
      
      .line {
        width: 100%;
        display: inline-block;
      }
      .line:target {
        border-top: 1px solid #ccc;
        border-bottom: 1px solid #ccc;
        background: #fafafa;
      }

      @media (prefers-color-scheme: dark) {
        body{
            background:#222;
            color: #ccc;
        }
        pre > code {
            color: #ccc;
            background: #222;
            border: unset;
        }
        .line:target {
            border-top: 1px solid #444;
            border-bottom: 1px solid #444;
            background: #333;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
</head>
<body>
<pre><code><span class="line" id="L1"><span class="tok-comment">/// Tar archive is single ordinary file which can contain many files (or</span></span>
<span class="line" id="L2"><span class="tok-comment">/// directories, symlinks, ...). It's build by series of blocks each size of 512</span></span>
<span class="line" id="L3"><span class="tok-comment">/// bytes. First block of each entry is header which defines type, name, size</span></span>
<span class="line" id="L4"><span class="tok-comment">/// permissions and other attributes. Header is followed by series of blocks of</span></span>
<span class="line" id="L5"><span class="tok-comment">/// file content, if any that entry has content. Content is padded to the block</span></span>
<span class="line" id="L6"><span class="tok-comment">/// size, so next header always starts at block boundary.</span></span>
<span class="line" id="L7"><span class="tok-comment">///</span></span>
<span class="line" id="L8"><span class="tok-comment">/// This simple format is extended by GNU and POSIX pax extensions to support</span></span>
<span class="line" id="L9"><span class="tok-comment">/// file names longer than 256 bytes and additional attributes.</span></span>
<span class="line" id="L10"><span class="tok-comment">///</span></span>
<span class="line" id="L11"><span class="tok-comment">/// This is not comprehensive tar parser. Here we are only file types needed to</span></span>
<span class="line" id="L12"><span class="tok-comment">/// support Zig package manager; normal file, directory, symbolic link. And</span></span>
<span class="line" id="L13"><span class="tok-comment">/// subset of attributes: name, size, permissions.</span></span>
<span class="line" id="L14"><span class="tok-comment">///</span></span>
<span class="line" id="L15"><span class="tok-comment">/// GNU tar reference: https://www.gnu.org/software/tar/manual/html_node/Standard.html</span></span>
<span class="line" id="L16"><span class="tok-comment">/// pax reference: https://pubs.opengroup.org/onlinepubs/9699919799/utilities/pax.html#tag_20_92_13</span></span>
<span class="line" id="L17"><span class="tok-comment">///</span></span>
<span class="line" id="L18"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std.zig&quot;</span>);</span>
<span class="line" id="L19"><span class="tok-kw">const</span> assert = std.debug.assert;</span>
<span class="line" id="L20"></span>
<span class="line" id="L21"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Options = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L22">    <span class="tok-comment">/// Number of directory levels to skip when extracting files.</span></span>
<span class="line" id="L23">    strip_components: <span class="tok-type">u32</span> = <span class="tok-number">0</span>,</span>
<span class="line" id="L24">    <span class="tok-comment">/// How to handle the &quot;mode&quot; property of files from within the tar file.</span></span>
<span class="line" id="L25">    mode_mode: ModeMode = .executable_bit_only,</span>
<span class="line" id="L26">    <span class="tok-comment">/// Prevents creation of empty directories.</span></span>
<span class="line" id="L27">    exclude_empty_directories: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,</span>
<span class="line" id="L28">    <span class="tok-comment">/// Provide this to receive detailed error messages.</span></span>
<span class="line" id="L29">    <span class="tok-comment">/// When this is provided, some errors which would otherwise be returned immediately</span></span>
<span class="line" id="L30">    <span class="tok-comment">/// will instead be added to this structure. The API user must check the errors</span></span>
<span class="line" id="L31">    <span class="tok-comment">/// in diagnostics to know whether the operation succeeded or failed.</span></span>
<span class="line" id="L32">    diagnostics: ?*Diagnostics = <span class="tok-null">null</span>,</span>
<span class="line" id="L33"></span>
<span class="line" id="L34">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ModeMode = <span class="tok-kw">enum</span> {</span>
<span class="line" id="L35">        <span class="tok-comment">/// The mode from the tar file is completely ignored. Files are created</span></span>
<span class="line" id="L36">        <span class="tok-comment">/// with the default mode when creating files.</span></span>
<span class="line" id="L37">        ignore,</span>
<span class="line" id="L38">        <span class="tok-comment">/// The mode from the tar file is inspected for the owner executable bit</span></span>
<span class="line" id="L39">        <span class="tok-comment">/// only. This bit is copied to the group and other executable bits.</span></span>
<span class="line" id="L40">        <span class="tok-comment">/// Other bits of the mode are left as the default when creating files.</span></span>
<span class="line" id="L41">        executable_bit_only,</span>
<span class="line" id="L42">    };</span>
<span class="line" id="L43"></span>
<span class="line" id="L44">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Diagnostics = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L45">        allocator: std.mem.Allocator,</span>
<span class="line" id="L46">        errors: std.ArrayListUnmanaged(Error) = .{},</span>
<span class="line" id="L47"></span>
<span class="line" id="L48">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Error = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {</span>
<span class="line" id="L49">            unable_to_create_sym_link: <span class="tok-kw">struct</span> {</span>
<span class="line" id="L50">                code: <span class="tok-type">anyerror</span>,</span>
<span class="line" id="L51">                file_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L52">                link_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L53">            },</span>
<span class="line" id="L54">            unable_to_create_file: <span class="tok-kw">struct</span> {</span>
<span class="line" id="L55">                code: <span class="tok-type">anyerror</span>,</span>
<span class="line" id="L56">                file_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L57">            },</span>
<span class="line" id="L58">            unsupported_file_type: <span class="tok-kw">struct</span> {</span>
<span class="line" id="L59">                file_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L60">                file_type: Header.Kind,</span>
<span class="line" id="L61">            },</span>
<span class="line" id="L62">        };</span>
<span class="line" id="L63"></span>
<span class="line" id="L64">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(d: *Diagnostics) <span class="tok-type">void</span> {</span>
<span class="line" id="L65">            <span class="tok-kw">for</span> (d.errors.items) |item| {</span>
<span class="line" id="L66">                <span class="tok-kw">switch</span> (item) {</span>
<span class="line" id="L67">                    .unable_to_create_sym_link =&gt; |info| {</span>
<span class="line" id="L68">                        d.allocator.free(info.file_name);</span>
<span class="line" id="L69">                        d.allocator.free(info.link_name);</span>
<span class="line" id="L70">                    },</span>
<span class="line" id="L71">                    .unable_to_create_file =&gt; |info| {</span>
<span class="line" id="L72">                        d.allocator.free(info.file_name);</span>
<span class="line" id="L73">                    },</span>
<span class="line" id="L74">                    .unsupported_file_type =&gt; |info| {</span>
<span class="line" id="L75">                        d.allocator.free(info.file_name);</span>
<span class="line" id="L76">                    },</span>
<span class="line" id="L77">                }</span>
<span class="line" id="L78">            }</span>
<span class="line" id="L79">            d.errors.deinit(d.allocator);</span>
<span class="line" id="L80">            d.* = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L81">        }</span>
<span class="line" id="L82">    };</span>
<span class="line" id="L83">};</span>
<span class="line" id="L84"></span>
<span class="line" id="L85"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Header = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L86">    <span class="tok-kw">const</span> SIZE = <span class="tok-number">512</span>;</span>
<span class="line" id="L87">    <span class="tok-kw">const</span> MAX_NAME_SIZE = <span class="tok-number">100</span> + <span class="tok-number">1</span> + <span class="tok-number">155</span>; <span class="tok-comment">// name(100) + separator(1) + prefix(155)</span>
</span>
<span class="line" id="L88">    <span class="tok-kw">const</span> LINK_NAME_SIZE = <span class="tok-number">100</span>;</span>
<span class="line" id="L89"></span>
<span class="line" id="L90">    bytes: *<span class="tok-kw">const</span> [SIZE]<span class="tok-type">u8</span>,</span>
<span class="line" id="L91"></span>
<span class="line" id="L92">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Kind = <span class="tok-kw">enum</span>(<span class="tok-type">u8</span>) {</span>
<span class="line" id="L93">        normal_alias = <span class="tok-number">0</span>,</span>
<span class="line" id="L94">        normal = <span class="tok-str">'0'</span>,</span>
<span class="line" id="L95">        hard_link = <span class="tok-str">'1'</span>,</span>
<span class="line" id="L96">        symbolic_link = <span class="tok-str">'2'</span>,</span>
<span class="line" id="L97">        character_special = <span class="tok-str">'3'</span>,</span>
<span class="line" id="L98">        block_special = <span class="tok-str">'4'</span>,</span>
<span class="line" id="L99">        directory = <span class="tok-str">'5'</span>,</span>
<span class="line" id="L100">        fifo = <span class="tok-str">'6'</span>,</span>
<span class="line" id="L101">        contiguous = <span class="tok-str">'7'</span>,</span>
<span class="line" id="L102">        global_extended_header = <span class="tok-str">'g'</span>,</span>
<span class="line" id="L103">        extended_header = <span class="tok-str">'x'</span>,</span>
<span class="line" id="L104">        <span class="tok-comment">// Types 'L' and 'K' are used by the GNU format for a meta file</span>
</span>
<span class="line" id="L105">        <span class="tok-comment">// used to store the path or link name for the next file.</span>
</span>
<span class="line" id="L106">        gnu_long_name = <span class="tok-str">'L'</span>,</span>
<span class="line" id="L107">        gnu_long_link = <span class="tok-str">'K'</span>,</span>
<span class="line" id="L108">        gnu_sparse = <span class="tok-str">'S'</span>,</span>
<span class="line" id="L109">        solaris_extended_header = <span class="tok-str">'X'</span>,</span>
<span class="line" id="L110">        _,</span>
<span class="line" id="L111">    };</span>
<span class="line" id="L112"></span>
<span class="line" id="L113">    <span class="tok-comment">/// Includes prefix concatenated, if any.</span></span>
<span class="line" id="L114">    <span class="tok-comment">/// TODO: check against &quot;../&quot; and other nefarious things</span></span>
<span class="line" id="L115">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fullName</span>(header: Header, buffer: *[MAX_NAME_SIZE]<span class="tok-type">u8</span>) ![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L116">        <span class="tok-kw">const</span> n = name(header);</span>
<span class="line" id="L117">        <span class="tok-kw">const</span> p = prefix(header);</span>
<span class="line" id="L118">        <span class="tok-kw">if</span> (!is_ustar(header) <span class="tok-kw">or</span> p.len == <span class="tok-number">0</span>) {</span>
<span class="line" id="L119">            <span class="tok-builtin">@memcpy</span>(buffer[<span class="tok-number">0</span>..n.len], n);</span>
<span class="line" id="L120">            <span class="tok-kw">return</span> buffer[<span class="tok-number">0</span>..n.len];</span>
<span class="line" id="L121">        }</span>
<span class="line" id="L122">        <span class="tok-builtin">@memcpy</span>(buffer[<span class="tok-number">0</span>..p.len], p);</span>
<span class="line" id="L123">        buffer[p.len] = <span class="tok-str">'/'</span>;</span>
<span class="line" id="L124">        <span class="tok-builtin">@memcpy</span>(buffer[p.len + <span class="tok-number">1</span> ..][<span class="tok-number">0</span>..n.len], n);</span>
<span class="line" id="L125">        <span class="tok-kw">return</span> buffer[<span class="tok-number">0</span> .. p.len + <span class="tok-number">1</span> + n.len];</span>
<span class="line" id="L126">    }</span>
<span class="line" id="L127"></span>
<span class="line" id="L128">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">linkName</span>(header: Header, buffer: *[LINK_NAME_SIZE]<span class="tok-type">u8</span>) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L129">        <span class="tok-kw">const</span> link_name = header.str(<span class="tok-number">157</span>, <span class="tok-number">100</span>);</span>
<span class="line" id="L130">        <span class="tok-kw">if</span> (link_name.len == <span class="tok-number">0</span>) {</span>
<span class="line" id="L131">            <span class="tok-kw">return</span> buffer[<span class="tok-number">0</span>..<span class="tok-number">0</span>];</span>
<span class="line" id="L132">        }</span>
<span class="line" id="L133">        <span class="tok-kw">const</span> buf = buffer[<span class="tok-number">0</span>..link_name.len];</span>
<span class="line" id="L134">        <span class="tok-builtin">@memcpy</span>(buf, link_name);</span>
<span class="line" id="L135">        <span class="tok-kw">return</span> buf;</span>
<span class="line" id="L136">    }</span>
<span class="line" id="L137"></span>
<span class="line" id="L138">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">name</span>(header: Header) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L139">        <span class="tok-kw">return</span> header.str(<span class="tok-number">0</span>, <span class="tok-number">100</span>);</span>
<span class="line" id="L140">    }</span>
<span class="line" id="L141"></span>
<span class="line" id="L142">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mode</span>(header: Header) !<span class="tok-type">u32</span> {</span>
<span class="line" id="L143">        <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(<span class="tok-kw">try</span> header.octal(<span class="tok-number">100</span>, <span class="tok-number">8</span>));</span>
<span class="line" id="L144">    }</span>
<span class="line" id="L145"></span>
<span class="line" id="L146">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">size</span>(header: Header) !<span class="tok-type">u64</span> {</span>
<span class="line" id="L147">        <span class="tok-kw">const</span> start = <span class="tok-number">124</span>;</span>
<span class="line" id="L148">        <span class="tok-kw">const</span> len = <span class="tok-number">12</span>;</span>
<span class="line" id="L149">        <span class="tok-kw">const</span> raw = header.bytes[start..][<span class="tok-number">0</span>..len];</span>
<span class="line" id="L150">        <span class="tok-comment">//  If the leading byte is 0xff (255), all the bytes of the field</span>
</span>
<span class="line" id="L151">        <span class="tok-comment">//  (including the leading byte) are concatenated in big-endian order,</span>
</span>
<span class="line" id="L152">        <span class="tok-comment">//  with the result being a negative number expressed in two’s</span>
</span>
<span class="line" id="L153">        <span class="tok-comment">//  complement form.</span>
</span>
<span class="line" id="L154">        <span class="tok-kw">if</span> (raw[<span class="tok-number">0</span>] == <span class="tok-number">0xff</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TarNumericValueNegative;</span>
<span class="line" id="L155">        <span class="tok-comment">// If the leading byte is 0x80 (128), the non-leading bytes of the</span>
</span>
<span class="line" id="L156">        <span class="tok-comment">// field are concatenated in big-endian order.</span>
</span>
<span class="line" id="L157">        <span class="tok-kw">if</span> (raw[<span class="tok-number">0</span>] == <span class="tok-number">0x80</span>) {</span>
<span class="line" id="L158">            <span class="tok-kw">if</span> (raw[<span class="tok-number">1</span>] != <span class="tok-number">0</span> <span class="tok-kw">or</span> raw[<span class="tok-number">2</span>] != <span class="tok-number">0</span> <span class="tok-kw">or</span> raw[<span class="tok-number">3</span>] != <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TarNumericValueTooBig;</span>
<span class="line" id="L159">            <span class="tok-kw">return</span> std.mem.readInt(<span class="tok-type">u64</span>, raw[<span class="tok-number">4</span>..<span class="tok-number">12</span>], .big);</span>
<span class="line" id="L160">        }</span>
<span class="line" id="L161">        <span class="tok-kw">return</span> <span class="tok-kw">try</span> header.octal(start, len);</span>
<span class="line" id="L162">    }</span>
<span class="line" id="L163"></span>
<span class="line" id="L164">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">chksum</span>(header: Header) !<span class="tok-type">u64</span> {</span>
<span class="line" id="L165">        <span class="tok-kw">return</span> header.octal(<span class="tok-number">148</span>, <span class="tok-number">8</span>);</span>
<span class="line" id="L166">    }</span>
<span class="line" id="L167"></span>
<span class="line" id="L168">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">is_ustar</span>(header: Header) <span class="tok-type">bool</span> {</span>
<span class="line" id="L169">        <span class="tok-kw">const</span> magic = header.bytes[<span class="tok-number">257</span>..][<span class="tok-number">0</span>..<span class="tok-number">6</span>];</span>
<span class="line" id="L170">        <span class="tok-kw">return</span> std.mem.eql(<span class="tok-type">u8</span>, magic[<span class="tok-number">0</span>..<span class="tok-number">5</span>], <span class="tok-str">&quot;ustar&quot;</span>) <span class="tok-kw">and</span> (magic[<span class="tok-number">5</span>] == <span class="tok-number">0</span> <span class="tok-kw">or</span> magic[<span class="tok-number">5</span>] == <span class="tok-str">' '</span>);</span>
<span class="line" id="L171">    }</span>
<span class="line" id="L172"></span>
<span class="line" id="L173">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">prefix</span>(header: Header) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L174">        <span class="tok-kw">return</span> header.str(<span class="tok-number">345</span>, <span class="tok-number">155</span>);</span>
<span class="line" id="L175">    }</span>
<span class="line" id="L176"></span>
<span class="line" id="L177">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">kind</span>(header: Header) Kind {</span>
<span class="line" id="L178">        <span class="tok-kw">const</span> result: Kind = <span class="tok-builtin">@enumFromInt</span>(header.bytes[<span class="tok-number">156</span>]);</span>
<span class="line" id="L179">        <span class="tok-kw">if</span> (result == .normal_alias) <span class="tok-kw">return</span> .normal;</span>
<span class="line" id="L180">        <span class="tok-kw">return</span> result;</span>
<span class="line" id="L181">    }</span>
<span class="line" id="L182"></span>
<span class="line" id="L183">    <span class="tok-kw">fn</span> <span class="tok-fn">str</span>(header: Header, start: <span class="tok-type">usize</span>, len: <span class="tok-type">usize</span>) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L184">        <span class="tok-kw">return</span> nullStr(header.bytes[start .. start + len]);</span>
<span class="line" id="L185">    }</span>
<span class="line" id="L186"></span>
<span class="line" id="L187">    <span class="tok-kw">fn</span> <span class="tok-fn">octal</span>(header: Header, start: <span class="tok-type">usize</span>, len: <span class="tok-type">usize</span>) !<span class="tok-type">u64</span> {</span>
<span class="line" id="L188">        <span class="tok-kw">const</span> raw = header.bytes[start..][<span class="tok-number">0</span>..len];</span>
<span class="line" id="L189">        <span class="tok-comment">// Zero-filled octal number in ASCII. Each numeric field of width w</span>
</span>
<span class="line" id="L190">        <span class="tok-comment">// contains w minus 1 digits, and a null</span>
</span>
<span class="line" id="L191">        <span class="tok-kw">const</span> ltrimmed = std.mem.trimLeft(<span class="tok-type">u8</span>, raw, <span class="tok-str">&quot;0 &quot;</span>);</span>
<span class="line" id="L192">        <span class="tok-kw">const</span> rtrimmed = std.mem.trimRight(<span class="tok-type">u8</span>, ltrimmed, <span class="tok-str">&quot; \x00&quot;</span>);</span>
<span class="line" id="L193">        <span class="tok-kw">if</span> (rtrimmed.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-number">0</span>;</span>
<span class="line" id="L194">        <span class="tok-kw">return</span> std.fmt.parseInt(<span class="tok-type">u64</span>, rtrimmed, <span class="tok-number">8</span>) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TarHeader;</span>
<span class="line" id="L195">    }</span>
<span class="line" id="L196"></span>
<span class="line" id="L197">    <span class="tok-kw">const</span> Chksums = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L198">        unsigned: <span class="tok-type">u64</span>,</span>
<span class="line" id="L199">        signed: <span class="tok-type">i64</span>,</span>
<span class="line" id="L200">    };</span>
<span class="line" id="L201"></span>
<span class="line" id="L202">    <span class="tok-comment">// Sum of all bytes in the header block. The chksum field is treated as if</span>
</span>
<span class="line" id="L203">    <span class="tok-comment">// it were filled with spaces (ASCII 32).</span>
</span>
<span class="line" id="L204">    <span class="tok-kw">fn</span> <span class="tok-fn">computeChksum</span>(header: Header) Chksums {</span>
<span class="line" id="L205">        <span class="tok-kw">var</span> cs: Chksums = .{ .signed = <span class="tok-number">0</span>, .unsigned = <span class="tok-number">0</span> };</span>
<span class="line" id="L206">        <span class="tok-kw">for</span> (header.bytes, <span class="tok-number">0</span>..) |v, i| {</span>
<span class="line" id="L207">            <span class="tok-kw">const</span> b = <span class="tok-kw">if</span> (<span class="tok-number">148</span> &lt;= i <span class="tok-kw">and</span> i &lt; <span class="tok-number">156</span>) <span class="tok-number">32</span> <span class="tok-kw">else</span> v; <span class="tok-comment">// Treating chksum bytes as spaces.</span>
</span>
<span class="line" id="L208">            cs.unsigned += b;</span>
<span class="line" id="L209">            cs.signed += <span class="tok-builtin">@as</span>(<span class="tok-type">i8</span>, <span class="tok-builtin">@bitCast</span>(b));</span>
<span class="line" id="L210">        }</span>
<span class="line" id="L211">        <span class="tok-kw">return</span> cs;</span>
<span class="line" id="L212">    }</span>
<span class="line" id="L213"></span>
<span class="line" id="L214">    <span class="tok-comment">// Checks calculated chksum with value of chksum field.</span>
</span>
<span class="line" id="L215">    <span class="tok-comment">// Returns error or valid chksum value.</span>
</span>
<span class="line" id="L216">    <span class="tok-comment">// Zero value indicates empty block.</span>
</span>
<span class="line" id="L217">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkChksum</span>(header: Header) !<span class="tok-type">u64</span> {</span>
<span class="line" id="L218">        <span class="tok-kw">const</span> field = <span class="tok-kw">try</span> header.chksum();</span>
<span class="line" id="L219">        <span class="tok-kw">const</span> cs = header.computeChksum();</span>
<span class="line" id="L220">        <span class="tok-kw">if</span> (field == <span class="tok-number">0</span> <span class="tok-kw">and</span> cs.unsigned == <span class="tok-number">256</span>) <span class="tok-kw">return</span> <span class="tok-number">0</span>;</span>
<span class="line" id="L221">        <span class="tok-kw">if</span> (field != cs.unsigned <span class="tok-kw">and</span> field != cs.signed) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TarHeaderChksum;</span>
<span class="line" id="L222">        <span class="tok-kw">return</span> field;</span>
<span class="line" id="L223">    }</span>
<span class="line" id="L224">};</span>
<span class="line" id="L225"></span>
<span class="line" id="L226"><span class="tok-comment">// Breaks string on first null character.</span>
</span>
<span class="line" id="L227"><span class="tok-kw">fn</span> <span class="tok-fn">nullStr</span>(str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L228">    <span class="tok-kw">for</span> (str, <span class="tok-number">0</span>..) |c, i| {</span>
<span class="line" id="L229">        <span class="tok-kw">if</span> (c == <span class="tok-number">0</span>) <span class="tok-kw">return</span> str[<span class="tok-number">0</span>..i];</span>
<span class="line" id="L230">    }</span>
<span class="line" id="L231">    <span class="tok-kw">return</span> str;</span>
<span class="line" id="L232">}</span>
<span class="line" id="L233"></span>
<span class="line" id="L234"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> IteratorOptions = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L235">    <span class="tok-comment">/// Use a buffer with length `std.fs.MAX_PATH_BYTES` to match file system capabilities.</span></span>
<span class="line" id="L236">    file_name_buffer: []<span class="tok-type">u8</span>,</span>
<span class="line" id="L237">    <span class="tok-comment">/// Use a buffer with length `std.fs.MAX_PATH_BYTES` to match file system capabilities.</span></span>
<span class="line" id="L238">    link_name_buffer: []<span class="tok-type">u8</span>,</span>
<span class="line" id="L239">    diagnostics: ?*Diagnostics = <span class="tok-null">null</span>,</span>
<span class="line" id="L240"></span>
<span class="line" id="L241">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Diagnostics = Options.Diagnostics;</span>
<span class="line" id="L242">};</span>
<span class="line" id="L243"></span>
<span class="line" id="L244"><span class="tok-comment">/// Iterates over files in tar archive.</span></span>
<span class="line" id="L245"><span class="tok-comment">/// `next` returns each file in `reader` tar archive.</span></span>
<span class="line" id="L246"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(reader: <span class="tok-kw">anytype</span>, options: IteratorOptions) Iterator(<span class="tok-builtin">@TypeOf</span>(reader)) {</span>
<span class="line" id="L247">    <span class="tok-kw">return</span> .{</span>
<span class="line" id="L248">        .reader = reader,</span>
<span class="line" id="L249">        .diagnostics = options.diagnostics,</span>
<span class="line" id="L250">        .header_buffer = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L251">        .file_name_buffer = options.file_name_buffer,</span>
<span class="line" id="L252">        .link_name_buffer = options.link_name_buffer,</span>
<span class="line" id="L253">        .padding = <span class="tok-number">0</span>,</span>
<span class="line" id="L254">        .file = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L255">    };</span>
<span class="line" id="L256">}</span>
<span class="line" id="L257"></span>
<span class="line" id="L258"><span class="tok-kw">fn</span> <span class="tok-fn">Iterator</span>(<span class="tok-kw">comptime</span> ReaderType: <span class="tok-type">type</span>) <span class="tok-type">type</span> {</span>
<span class="line" id="L259">    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {</span>
<span class="line" id="L260">        reader: ReaderType,</span>
<span class="line" id="L261">        diagnostics: ?*Options.Diagnostics,</span>
<span class="line" id="L262"></span>
<span class="line" id="L263">        <span class="tok-comment">// buffers for heeader and file attributes</span>
</span>
<span class="line" id="L264">        header_buffer: [Header.SIZE]<span class="tok-type">u8</span>,</span>
<span class="line" id="L265">        file_name_buffer: []<span class="tok-type">u8</span>,</span>
<span class="line" id="L266">        link_name_buffer: []<span class="tok-type">u8</span>,</span>
<span class="line" id="L267"></span>
<span class="line" id="L268">        <span class="tok-comment">// bytes of padding to the end of the block</span>
</span>
<span class="line" id="L269">        padding: <span class="tok-type">usize</span>,</span>
<span class="line" id="L270">        <span class="tok-comment">// current tar file</span>
</span>
<span class="line" id="L271">        file: File,</span>
<span class="line" id="L272"></span>
<span class="line" id="L273">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> File = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L274">            name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-comment">// name of file, symlink or directory</span>
</span>
<span class="line" id="L275">            link_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-comment">// target name of symlink</span>
</span>
<span class="line" id="L276">            size: <span class="tok-type">u64</span>, <span class="tok-comment">// size of the file in bytes</span>
</span>
<span class="line" id="L277">            mode: <span class="tok-type">u32</span>,</span>
<span class="line" id="L278">            kind: Header.Kind,</span>
<span class="line" id="L279"></span>
<span class="line" id="L280">            reader: ReaderType,</span>
<span class="line" id="L281"></span>
<span class="line" id="L282">            <span class="tok-comment">// Writes file content to writer.</span>
</span>
<span class="line" id="L283">            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">write</span>(self: File, writer: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L284">                <span class="tok-kw">var</span> buffer: [<span class="tok-number">4096</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L285"></span>
<span class="line" id="L286">                <span class="tok-kw">var</span> n: <span class="tok-type">u64</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L287">                <span class="tok-kw">while</span> (n &lt; self.size) {</span>
<span class="line" id="L288">                    <span class="tok-kw">const</span> buf = buffer[<span class="tok-number">0</span>..<span class="tok-builtin">@min</span>(buffer.len, self.size - n)];</span>
<span class="line" id="L289">                    <span class="tok-kw">try</span> self.reader.readNoEof(buf);</span>
<span class="line" id="L290">                    <span class="tok-kw">try</span> writer.writeAll(buf);</span>
<span class="line" id="L291">                    n += buf.len;</span>
<span class="line" id="L292">                }</span>
<span class="line" id="L293">            }</span>
<span class="line" id="L294"></span>
<span class="line" id="L295">            <span class="tok-comment">// Skips file content. Advances reader.</span>
</span>
<span class="line" id="L296">            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">skip</span>(self: File) !<span class="tok-type">void</span> {</span>
<span class="line" id="L297">                <span class="tok-kw">try</span> self.reader.skipBytes(self.size, .{});</span>
<span class="line" id="L298">            }</span>
<span class="line" id="L299">        };</span>
<span class="line" id="L300"></span>
<span class="line" id="L301">        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();</span>
<span class="line" id="L302"></span>
<span class="line" id="L303">        <span class="tok-kw">fn</span> <span class="tok-fn">readHeader</span>(self: *Self) !?Header {</span>
<span class="line" id="L304">            <span class="tok-kw">if</span> (self.padding &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L305">                <span class="tok-kw">try</span> self.reader.skipBytes(self.padding, .{});</span>
<span class="line" id="L306">            }</span>
<span class="line" id="L307">            <span class="tok-kw">const</span> n = <span class="tok-kw">try</span> self.reader.readAll(&amp;self.header_buffer);</span>
<span class="line" id="L308">            <span class="tok-kw">if</span> (n == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L309">            <span class="tok-kw">if</span> (n &lt; Header.SIZE) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedEndOfStream;</span>
<span class="line" id="L310">            <span class="tok-kw">const</span> header = Header{ .bytes = self.header_buffer[<span class="tok-number">0</span>..Header.SIZE] };</span>
<span class="line" id="L311">            <span class="tok-kw">if</span> (<span class="tok-kw">try</span> header.checkChksum() == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L312">            <span class="tok-kw">return</span> header;</span>
<span class="line" id="L313">        }</span>
<span class="line" id="L314"></span>
<span class="line" id="L315">        <span class="tok-kw">fn</span> <span class="tok-fn">readString</span>(self: *Self, size: <span class="tok-type">usize</span>, buffer: []<span class="tok-type">u8</span>) ![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L316">            <span class="tok-kw">if</span> (size &gt; buffer.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TarCorruptInput;</span>
<span class="line" id="L317">            <span class="tok-kw">const</span> buf = buffer[<span class="tok-number">0</span>..size];</span>
<span class="line" id="L318">            <span class="tok-kw">try</span> self.reader.readNoEof(buf);</span>
<span class="line" id="L319">            <span class="tok-kw">return</span> nullStr(buf);</span>
<span class="line" id="L320">        }</span>
<span class="line" id="L321"></span>
<span class="line" id="L322">        <span class="tok-kw">fn</span> <span class="tok-fn">initFile</span>(self: *Self) <span class="tok-type">void</span> {</span>
<span class="line" id="L323">            self.file = .{</span>
<span class="line" id="L324">                .name = self.file_name_buffer[<span class="tok-number">0</span>..<span class="tok-number">0</span>],</span>
<span class="line" id="L325">                .link_name = self.link_name_buffer[<span class="tok-number">0</span>..<span class="tok-number">0</span>],</span>
<span class="line" id="L326">                .size = <span class="tok-number">0</span>,</span>
<span class="line" id="L327">                .kind = .normal,</span>
<span class="line" id="L328">                .mode = <span class="tok-number">0</span>,</span>
<span class="line" id="L329">                .reader = self.reader,</span>
<span class="line" id="L330">            };</span>
<span class="line" id="L331">        }</span>
<span class="line" id="L332"></span>
<span class="line" id="L333">        <span class="tok-comment">// Number of padding bytes in the last file block.</span>
</span>
<span class="line" id="L334">        <span class="tok-kw">fn</span> <span class="tok-fn">blockPadding</span>(size: <span class="tok-type">u64</span>) <span class="tok-type">usize</span> {</span>
<span class="line" id="L335">            <span class="tok-kw">const</span> block_rounded = std.mem.alignForward(<span class="tok-type">u64</span>, size, Header.SIZE); <span class="tok-comment">// size rounded to te block boundary</span>
</span>
<span class="line" id="L336">            <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(block_rounded - size);</span>
<span class="line" id="L337">        }</span>
<span class="line" id="L338"></span>
<span class="line" id="L339">        <span class="tok-comment">/// Iterates through the tar archive as if it is a series of files.</span></span>
<span class="line" id="L340">        <span class="tok-comment">/// Internally, the tar format often uses entries (header with optional</span></span>
<span class="line" id="L341">        <span class="tok-comment">/// content) to add meta data that describes the next file. These</span></span>
<span class="line" id="L342">        <span class="tok-comment">/// entries should not normally be visible to the outside. As such, this</span></span>
<span class="line" id="L343">        <span class="tok-comment">/// loop iterates through one or more entries until it collects a all</span></span>
<span class="line" id="L344">        <span class="tok-comment">/// file attributes.</span></span>
<span class="line" id="L345">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *Self) !?File {</span>
<span class="line" id="L346">            self.initFile();</span>
<span class="line" id="L347"></span>
<span class="line" id="L348">            <span class="tok-kw">while</span> (<span class="tok-kw">try</span> self.readHeader()) |header| {</span>
<span class="line" id="L349">                <span class="tok-kw">const</span> kind = header.kind();</span>
<span class="line" id="L350">                <span class="tok-kw">const</span> size: <span class="tok-type">u64</span> = <span class="tok-kw">try</span> header.size();</span>
<span class="line" id="L351">                self.padding = blockPadding(size);</span>
<span class="line" id="L352"></span>
<span class="line" id="L353">                <span class="tok-kw">switch</span> (kind) {</span>
<span class="line" id="L354">                    <span class="tok-comment">// File types to retrun upstream</span>
</span>
<span class="line" id="L355">                    .directory, .normal, .symbolic_link =&gt; {</span>
<span class="line" id="L356">                        self.file.kind = kind;</span>
<span class="line" id="L357">                        self.file.mode = <span class="tok-kw">try</span> header.mode();</span>
<span class="line" id="L358"></span>
<span class="line" id="L359">                        <span class="tok-comment">// set file attributes if not already set by prefix/extended headers</span>
</span>
<span class="line" id="L360">                        <span class="tok-kw">if</span> (self.file.size == <span class="tok-number">0</span>) {</span>
<span class="line" id="L361">                            self.file.size = size;</span>
<span class="line" id="L362">                        }</span>
<span class="line" id="L363">                        <span class="tok-kw">if</span> (self.file.link_name.len == <span class="tok-number">0</span>) {</span>
<span class="line" id="L364">                            self.file.link_name = header.linkName(self.link_name_buffer[<span class="tok-number">0</span>..Header.LINK_NAME_SIZE]);</span>
<span class="line" id="L365">                        }</span>
<span class="line" id="L366">                        <span class="tok-kw">if</span> (self.file.name.len == <span class="tok-number">0</span>) {</span>
<span class="line" id="L367">                            self.file.name = <span class="tok-kw">try</span> header.fullName(self.file_name_buffer[<span class="tok-number">0</span>..Header.MAX_NAME_SIZE]);</span>
<span class="line" id="L368">                        }</span>
<span class="line" id="L369"></span>
<span class="line" id="L370">                        self.padding = blockPadding(self.file.size);</span>
<span class="line" id="L371">                        <span class="tok-kw">return</span> self.file;</span>
<span class="line" id="L372">                    },</span>
<span class="line" id="L373">                    <span class="tok-comment">// Prefix header types</span>
</span>
<span class="line" id="L374">                    .gnu_long_name =&gt; {</span>
<span class="line" id="L375">                        self.file.name = <span class="tok-kw">try</span> self.readString(<span class="tok-builtin">@intCast</span>(size), self.file_name_buffer);</span>
<span class="line" id="L376">                    },</span>
<span class="line" id="L377">                    .gnu_long_link =&gt; {</span>
<span class="line" id="L378">                        self.file.link_name = <span class="tok-kw">try</span> self.readString(<span class="tok-builtin">@intCast</span>(size), self.link_name_buffer);</span>
<span class="line" id="L379">                    },</span>
<span class="line" id="L380">                    .extended_header =&gt; {</span>
<span class="line" id="L381">                        <span class="tok-comment">// Use just attributes from last extended header.</span>
</span>
<span class="line" id="L382">                        self.initFile();</span>
<span class="line" id="L383"></span>
<span class="line" id="L384">                        <span class="tok-kw">var</span> rdr = paxIterator(self.reader, <span class="tok-builtin">@intCast</span>(size));</span>
<span class="line" id="L385">                        <span class="tok-kw">while</span> (<span class="tok-kw">try</span> rdr.next()) |attr| {</span>
<span class="line" id="L386">                            <span class="tok-kw">switch</span> (attr.kind) {</span>
<span class="line" id="L387">                                .path =&gt; {</span>
<span class="line" id="L388">                                    self.file.name = <span class="tok-kw">try</span> attr.value(self.file_name_buffer);</span>
<span class="line" id="L389">                                },</span>
<span class="line" id="L390">                                .linkpath =&gt; {</span>
<span class="line" id="L391">                                    self.file.link_name = <span class="tok-kw">try</span> attr.value(self.link_name_buffer);</span>
<span class="line" id="L392">                                },</span>
<span class="line" id="L393">                                .size =&gt; {</span>
<span class="line" id="L394">                                    <span class="tok-kw">var</span> buf: [pax_max_size_attr_len]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L395">                                    self.file.size = <span class="tok-kw">try</span> std.fmt.parseInt(<span class="tok-type">u64</span>, <span class="tok-kw">try</span> attr.value(&amp;buf), <span class="tok-number">10</span>);</span>
<span class="line" id="L396">                                },</span>
<span class="line" id="L397">                            }</span>
<span class="line" id="L398">                        }</span>
<span class="line" id="L399">                    },</span>
<span class="line" id="L400">                    <span class="tok-comment">// Ignored header type</span>
</span>
<span class="line" id="L401">                    .global_extended_header =&gt; {</span>
<span class="line" id="L402">                        self.reader.skipBytes(size, .{}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TarHeadersTooBig;</span>
<span class="line" id="L403">                    },</span>
<span class="line" id="L404">                    <span class="tok-comment">// All other are unsupported header types</span>
</span>
<span class="line" id="L405">                    <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L406">                        <span class="tok-kw">const</span> d = self.diagnostics <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TarUnsupportedHeader;</span>
<span class="line" id="L407">                        <span class="tok-kw">try</span> d.errors.append(d.allocator, .{ .unsupported_file_type = .{</span>
<span class="line" id="L408">                            .file_name = <span class="tok-kw">try</span> d.allocator.dupe(<span class="tok-type">u8</span>, header.name()),</span>
<span class="line" id="L409">                            .file_type = kind,</span>
<span class="line" id="L410">                        } });</span>
<span class="line" id="L411">                        <span class="tok-kw">if</span> (kind == .gnu_sparse) {</span>
<span class="line" id="L412">                            <span class="tok-kw">try</span> self.skipGnuSparseExtendedHeaders(header);</span>
<span class="line" id="L413">                        }</span>
<span class="line" id="L414">                        self.reader.skipBytes(size, .{}) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TarHeadersTooBig;</span>
<span class="line" id="L415">                    },</span>
<span class="line" id="L416">                }</span>
<span class="line" id="L417">            }</span>
<span class="line" id="L418">            <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L419">        }</span>
<span class="line" id="L420"></span>
<span class="line" id="L421">        <span class="tok-kw">fn</span> <span class="tok-fn">skipGnuSparseExtendedHeaders</span>(self: *Self, header: Header) !<span class="tok-type">void</span> {</span>
<span class="line" id="L422">            <span class="tok-kw">var</span> is_extended = header.bytes[<span class="tok-number">482</span>] &gt; <span class="tok-number">0</span>;</span>
<span class="line" id="L423">            <span class="tok-kw">while</span> (is_extended) {</span>
<span class="line" id="L424">                <span class="tok-kw">var</span> buf: [Header.SIZE]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L425">                <span class="tok-kw">const</span> n = <span class="tok-kw">try</span> self.reader.readAll(&amp;buf);</span>
<span class="line" id="L426">                <span class="tok-kw">if</span> (n &lt; Header.SIZE) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedEndOfStream;</span>
<span class="line" id="L427">                is_extended = buf[<span class="tok-number">504</span>] &gt; <span class="tok-number">0</span>;</span>
<span class="line" id="L428">            }</span>
<span class="line" id="L429">        }</span>
<span class="line" id="L430">    };</span>
<span class="line" id="L431">}</span>
<span class="line" id="L432"></span>
<span class="line" id="L433"><span class="tok-comment">/// Pax attributes iterator.</span></span>
<span class="line" id="L434"><span class="tok-comment">/// Size is length of pax extended header in reader.</span></span>
<span class="line" id="L435"><span class="tok-kw">fn</span> <span class="tok-fn">paxIterator</span>(reader: <span class="tok-kw">anytype</span>, size: <span class="tok-type">usize</span>) PaxIterator(<span class="tok-builtin">@TypeOf</span>(reader)) {</span>
<span class="line" id="L436">    <span class="tok-kw">return</span> PaxIterator(<span class="tok-builtin">@TypeOf</span>(reader)){</span>
<span class="line" id="L437">        .reader = reader,</span>
<span class="line" id="L438">        .size = size,</span>
<span class="line" id="L439">    };</span>
<span class="line" id="L440">}</span>
<span class="line" id="L441"></span>
<span class="line" id="L442"><span class="tok-kw">const</span> PaxAttributeKind = <span class="tok-kw">enum</span> {</span>
<span class="line" id="L443">    path,</span>
<span class="line" id="L444">    linkpath,</span>
<span class="line" id="L445">    size,</span>
<span class="line" id="L446">};</span>
<span class="line" id="L447"></span>
<span class="line" id="L448"><span class="tok-comment">// maxInt(u64) has 20 chars, base 10 in practice we got 24 chars</span>
</span>
<span class="line" id="L449"><span class="tok-kw">const</span> pax_max_size_attr_len = <span class="tok-number">64</span>;</span>
<span class="line" id="L450"></span>
<span class="line" id="L451"><span class="tok-kw">fn</span> <span class="tok-fn">PaxIterator</span>(<span class="tok-kw">comptime</span> ReaderType: <span class="tok-type">type</span>) <span class="tok-type">type</span> {</span>
<span class="line" id="L452">    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {</span>
<span class="line" id="L453">        size: <span class="tok-type">usize</span>, <span class="tok-comment">// cumulative size of all pax attributes</span>
</span>
<span class="line" id="L454">        reader: ReaderType,</span>
<span class="line" id="L455">        <span class="tok-comment">// scratch buffer used for reading attribute length and keyword</span>
</span>
<span class="line" id="L456">        scratch: [<span class="tok-number">128</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L457"></span>
<span class="line" id="L458">        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();</span>
<span class="line" id="L459"></span>
<span class="line" id="L460">        <span class="tok-kw">const</span> Attribute = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L461">            kind: PaxAttributeKind,</span>
<span class="line" id="L462">            len: <span class="tok-type">usize</span>, <span class="tok-comment">// length of the attribute value</span>
</span>
<span class="line" id="L463">            reader: ReaderType, <span class="tok-comment">// reader positioned at value start</span>
</span>
<span class="line" id="L464"></span>
<span class="line" id="L465">            <span class="tok-comment">// Copies pax attribute value into destination buffer.</span>
</span>
<span class="line" id="L466">            <span class="tok-comment">// Must be called with destination buffer of size at least Attribute.len.</span>
</span>
<span class="line" id="L467">            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">value</span>(self: Attribute, dst: []<span class="tok-type">u8</span>) ![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L468">                assert(self.len &lt;= dst.len);</span>
<span class="line" id="L469">                <span class="tok-kw">const</span> buf = dst[<span class="tok-number">0</span>..self.len];</span>
<span class="line" id="L470">                <span class="tok-kw">const</span> n = <span class="tok-kw">try</span> self.reader.readAll(buf);</span>
<span class="line" id="L471">                <span class="tok-kw">if</span> (n &lt; self.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedEndOfStream;</span>
<span class="line" id="L472">                <span class="tok-kw">try</span> validateAttributeEnding(self.reader);</span>
<span class="line" id="L473">                <span class="tok-kw">if</span> (hasNull(buf)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PaxNullInValue;</span>
<span class="line" id="L474">                <span class="tok-kw">return</span> buf;</span>
<span class="line" id="L475">            }</span>
<span class="line" id="L476">        };</span>
<span class="line" id="L477"></span>
<span class="line" id="L478">        <span class="tok-comment">// Iterates over pax attributes. Returns known only known attributes.</span>
</span>
<span class="line" id="L479">        <span class="tok-comment">// Caller has to call value in Attribute, to advance reader across value.</span>
</span>
<span class="line" id="L480">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *Self) !?Attribute {</span>
<span class="line" id="L481">            <span class="tok-comment">// Pax extended header consists of one or more attributes, each constructed as follows:</span>
</span>
<span class="line" id="L482">            <span class="tok-comment">// &quot;%d %s=%s\n&quot;, &lt;length&gt;, &lt;keyword&gt;, &lt;value&gt;</span>
</span>
<span class="line" id="L483">            <span class="tok-kw">while</span> (self.size &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L484">                <span class="tok-kw">const</span> length_buf = <span class="tok-kw">try</span> self.readUntil(<span class="tok-str">' '</span>);</span>
<span class="line" id="L485">                <span class="tok-kw">const</span> length = <span class="tok-kw">try</span> std.fmt.parseInt(<span class="tok-type">usize</span>, length_buf, <span class="tok-number">10</span>); <span class="tok-comment">// record length in bytes</span>
</span>
<span class="line" id="L486"></span>
<span class="line" id="L487">                <span class="tok-kw">const</span> keyword = <span class="tok-kw">try</span> self.readUntil(<span class="tok-str">'='</span>);</span>
<span class="line" id="L488">                <span class="tok-kw">if</span> (hasNull(keyword)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PaxNullInKeyword;</span>
<span class="line" id="L489"></span>
<span class="line" id="L490">                <span class="tok-comment">// calculate value_len</span>
</span>
<span class="line" id="L491">                <span class="tok-kw">const</span> value_start = length_buf.len + keyword.len + <span class="tok-number">2</span>; <span class="tok-comment">// 2 separators</span>
</span>
<span class="line" id="L492">                <span class="tok-kw">if</span> (length &lt; value_start + <span class="tok-number">1</span> <span class="tok-kw">or</span> self.size &lt; length) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedEndOfStream;</span>
<span class="line" id="L493">                <span class="tok-kw">const</span> value_len = length - value_start - <span class="tok-number">1</span>; <span class="tok-comment">// \n separator at end</span>
</span>
<span class="line" id="L494">                self.size -= length;</span>
<span class="line" id="L495"></span>
<span class="line" id="L496">                <span class="tok-kw">const</span> kind: PaxAttributeKind = <span class="tok-kw">if</span> (eql(keyword, <span class="tok-str">&quot;path&quot;</span>))</span>
<span class="line" id="L497">                    .path</span>
<span class="line" id="L498">                <span class="tok-kw">else</span> <span class="tok-kw">if</span> (eql(keyword, <span class="tok-str">&quot;linkpath&quot;</span>))</span>
<span class="line" id="L499">                    .linkpath</span>
<span class="line" id="L500">                <span class="tok-kw">else</span> <span class="tok-kw">if</span> (eql(keyword, <span class="tok-str">&quot;size&quot;</span>))</span>
<span class="line" id="L501">                    .size</span>
<span class="line" id="L502">                <span class="tok-kw">else</span> {</span>
<span class="line" id="L503">                    <span class="tok-kw">try</span> self.reader.skipBytes(value_len, .{});</span>
<span class="line" id="L504">                    <span class="tok-kw">try</span> validateAttributeEnding(self.reader);</span>
<span class="line" id="L505">                    <span class="tok-kw">continue</span>;</span>
<span class="line" id="L506">                };</span>
<span class="line" id="L507">                <span class="tok-kw">if</span> (kind == .size <span class="tok-kw">and</span> value_len &gt; pax_max_size_attr_len) {</span>
<span class="line" id="L508">                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PaxSizeAttrOverflow;</span>
<span class="line" id="L509">                }</span>
<span class="line" id="L510">                <span class="tok-kw">return</span> Attribute{</span>
<span class="line" id="L511">                    .kind = kind,</span>
<span class="line" id="L512">                    .len = value_len,</span>
<span class="line" id="L513">                    .reader = self.reader,</span>
<span class="line" id="L514">                };</span>
<span class="line" id="L515">            }</span>
<span class="line" id="L516"></span>
<span class="line" id="L517">            <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L518">        }</span>
<span class="line" id="L519"></span>
<span class="line" id="L520">        <span class="tok-kw">fn</span> <span class="tok-fn">readUntil</span>(self: *Self, delimiter: <span class="tok-type">u8</span>) ![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L521">            <span class="tok-kw">var</span> fbs = std.io.fixedBufferStream(&amp;self.scratch);</span>
<span class="line" id="L522">            <span class="tok-kw">try</span> self.reader.streamUntilDelimiter(fbs.writer(), delimiter, <span class="tok-null">null</span>);</span>
<span class="line" id="L523">            <span class="tok-kw">return</span> fbs.getWritten();</span>
<span class="line" id="L524">        }</span>
<span class="line" id="L525"></span>
<span class="line" id="L526">        <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(a: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, b: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">bool</span> {</span>
<span class="line" id="L527">            <span class="tok-kw">return</span> std.mem.eql(<span class="tok-type">u8</span>, a, b);</span>
<span class="line" id="L528">        }</span>
<span class="line" id="L529"></span>
<span class="line" id="L530">        <span class="tok-kw">fn</span> <span class="tok-fn">hasNull</span>(str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">bool</span> {</span>
<span class="line" id="L531">            <span class="tok-kw">return</span> (std.mem.indexOfScalar(<span class="tok-type">u8</span>, str, <span class="tok-number">0</span>)) != <span class="tok-null">null</span>;</span>
<span class="line" id="L532">        }</span>
<span class="line" id="L533"></span>
<span class="line" id="L534">        <span class="tok-comment">// Checks that each record ends with new line.</span>
</span>
<span class="line" id="L535">        <span class="tok-kw">fn</span> <span class="tok-fn">validateAttributeEnding</span>(reader: ReaderType) !<span class="tok-type">void</span> {</span>
<span class="line" id="L536">            <span class="tok-kw">if</span> (<span class="tok-kw">try</span> reader.readByte() != <span class="tok-str">'\n'</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PaxInvalidAttributeEnd;</span>
<span class="line" id="L537">        }</span>
<span class="line" id="L538">    };</span>
<span class="line" id="L539">}</span>
<span class="line" id="L540"></span>
<span class="line" id="L541"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pipeToFileSystem</span>(dir: std.fs.Dir, reader: <span class="tok-kw">anytype</span>, options: Options) !<span class="tok-type">void</span> {</span>
<span class="line" id="L542">    <span class="tok-kw">switch</span> (options.mode_mode) {</span>
<span class="line" id="L543">        .ignore =&gt; {},</span>
<span class="line" id="L544">        .executable_bit_only =&gt; {</span>
<span class="line" id="L545">            <span class="tok-comment">// This code does not look at the mode bits yet. To implement this feature,</span>
</span>
<span class="line" id="L546">            <span class="tok-comment">// the implementation must be adjusted to look at the mode, and check the</span>
</span>
<span class="line" id="L547">            <span class="tok-comment">// user executable bit, then call fchmod on newly created files when</span>
</span>
<span class="line" id="L548">            <span class="tok-comment">// the executable bit is supposed to be set.</span>
</span>
<span class="line" id="L549">            <span class="tok-comment">// It also needs to properly deal with ACLs on Windows.</span>
</span>
<span class="line" id="L550">            <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;TODO: unimplemented: tar ModeMode.executable_bit_only&quot;</span>);</span>
<span class="line" id="L551">        },</span>
<span class="line" id="L552">    }</span>
<span class="line" id="L553"></span>
<span class="line" id="L554">    <span class="tok-kw">var</span> file_name_buffer: [std.fs.MAX_PATH_BYTES]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L555">    <span class="tok-kw">var</span> link_name_buffer: [std.fs.MAX_PATH_BYTES]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L556">    <span class="tok-kw">var</span> iter = iterator(reader, .{</span>
<span class="line" id="L557">        .file_name_buffer = &amp;file_name_buffer,</span>
<span class="line" id="L558">        .link_name_buffer = &amp;link_name_buffer,</span>
<span class="line" id="L559">        .diagnostics = options.diagnostics,</span>
<span class="line" id="L560">    });</span>
<span class="line" id="L561">    <span class="tok-kw">while</span> (<span class="tok-kw">try</span> iter.next()) |file| {</span>
<span class="line" id="L562">        <span class="tok-kw">switch</span> (file.kind) {</span>
<span class="line" id="L563">            .directory =&gt; {</span>
<span class="line" id="L564">                <span class="tok-kw">const</span> file_name = stripComponents(file.name, options.strip_components);</span>
<span class="line" id="L565">                <span class="tok-kw">if</span> (file_name.len != <span class="tok-number">0</span> <span class="tok-kw">and</span> !options.exclude_empty_directories) {</span>
<span class="line" id="L566">                    <span class="tok-kw">try</span> dir.makePath(file_name);</span>
<span class="line" id="L567">                }</span>
<span class="line" id="L568">            },</span>
<span class="line" id="L569">            .normal =&gt; {</span>
<span class="line" id="L570">                <span class="tok-kw">if</span> (file.size == <span class="tok-number">0</span> <span class="tok-kw">and</span> file.name.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span>;</span>
<span class="line" id="L571">                <span class="tok-kw">const</span> file_name = stripComponents(file.name, options.strip_components);</span>
<span class="line" id="L572">                <span class="tok-kw">if</span> (file_name.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BadFileName;</span>
<span class="line" id="L573"></span>
<span class="line" id="L574">                <span class="tok-kw">if</span> (createDirAndFile(dir, file_name)) |fs_file| {</span>
<span class="line" id="L575">                    <span class="tok-kw">defer</span> fs_file.close();</span>
<span class="line" id="L576">                    <span class="tok-kw">try</span> file.write(fs_file);</span>
<span class="line" id="L577">                } <span class="tok-kw">else</span> |err| {</span>
<span class="line" id="L578">                    <span class="tok-kw">const</span> d = options.diagnostics <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> err;</span>
<span class="line" id="L579">                    <span class="tok-kw">try</span> d.errors.append(d.allocator, .{ .unable_to_create_file = .{</span>
<span class="line" id="L580">                        .code = err,</span>
<span class="line" id="L581">                        .file_name = <span class="tok-kw">try</span> d.allocator.dupe(<span class="tok-type">u8</span>, file_name),</span>
<span class="line" id="L582">                    } });</span>
<span class="line" id="L583">                    <span class="tok-kw">try</span> file.skip();</span>
<span class="line" id="L584">                }</span>
<span class="line" id="L585">            },</span>
<span class="line" id="L586">            .symbolic_link =&gt; {</span>
<span class="line" id="L587">                <span class="tok-comment">// The file system path of the symbolic link.</span>
</span>
<span class="line" id="L588">                <span class="tok-kw">const</span> file_name = stripComponents(file.name, options.strip_components);</span>
<span class="line" id="L589">                <span class="tok-kw">if</span> (file_name.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BadFileName;</span>
<span class="line" id="L590">                <span class="tok-comment">// The data inside the symbolic link.</span>
</span>
<span class="line" id="L591">                <span class="tok-kw">const</span> link_name = file.link_name;</span>
<span class="line" id="L592"></span>
<span class="line" id="L593">                createDirAndSymlink(dir, link_name, file_name) <span class="tok-kw">catch</span> |err| {</span>
<span class="line" id="L594">                    <span class="tok-kw">const</span> d = options.diagnostics <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnableToCreateSymLink;</span>
<span class="line" id="L595">                    <span class="tok-kw">try</span> d.errors.append(d.allocator, .{ .unable_to_create_sym_link = .{</span>
<span class="line" id="L596">                        .code = err,</span>
<span class="line" id="L597">                        .file_name = <span class="tok-kw">try</span> d.allocator.dupe(<span class="tok-type">u8</span>, file_name),</span>
<span class="line" id="L598">                        .link_name = <span class="tok-kw">try</span> d.allocator.dupe(<span class="tok-type">u8</span>, link_name),</span>
<span class="line" id="L599">                    } });</span>
<span class="line" id="L600">                };</span>
<span class="line" id="L601">            },</span>
<span class="line" id="L602">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L603">        }</span>
<span class="line" id="L604">    }</span>
<span class="line" id="L605">}</span>
<span class="line" id="L606"></span>
<span class="line" id="L607"><span class="tok-kw">fn</span> <span class="tok-fn">createDirAndFile</span>(dir: std.fs.Dir, file_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !std.fs.File {</span>
<span class="line" id="L608">    <span class="tok-kw">const</span> fs_file = dir.createFile(file_name, .{ .exclusive = <span class="tok-null">true</span> }) <span class="tok-kw">catch</span> |err| {</span>
<span class="line" id="L609">        <span class="tok-kw">if</span> (err == <span class="tok-kw">error</span>.FileNotFound) {</span>
<span class="line" id="L610">            <span class="tok-kw">if</span> (std.fs.path.dirname(file_name)) |dir_name| {</span>
<span class="line" id="L611">                <span class="tok-kw">try</span> dir.makePath(dir_name);</span>
<span class="line" id="L612">                <span class="tok-kw">return</span> <span class="tok-kw">try</span> dir.createFile(file_name, .{ .exclusive = <span class="tok-null">true</span> });</span>
<span class="line" id="L613">            }</span>
<span class="line" id="L614">        }</span>
<span class="line" id="L615">        <span class="tok-kw">return</span> err;</span>
<span class="line" id="L616">    };</span>
<span class="line" id="L617">    <span class="tok-kw">return</span> fs_file;</span>
<span class="line" id="L618">}</span>
<span class="line" id="L619"></span>
<span class="line" id="L620"><span class="tok-kw">fn</span> <span class="tok-fn">createDirAndSymlink</span>(dir: std.fs.Dir, link_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, file_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L621">    dir.symLink(link_name, file_name, .{}) <span class="tok-kw">catch</span> |err| {</span>
<span class="line" id="L622">        <span class="tok-kw">if</span> (err == <span class="tok-kw">error</span>.FileNotFound) {</span>
<span class="line" id="L623">            <span class="tok-kw">if</span> (std.fs.path.dirname(file_name)) |dir_name| {</span>
<span class="line" id="L624">                <span class="tok-kw">try</span> dir.makePath(dir_name);</span>
<span class="line" id="L625">                <span class="tok-kw">return</span> <span class="tok-kw">try</span> dir.symLink(link_name, file_name, .{});</span>
<span class="line" id="L626">            }</span>
<span class="line" id="L627">        }</span>
<span class="line" id="L628">        <span class="tok-kw">return</span> err;</span>
<span class="line" id="L629">    };</span>
<span class="line" id="L630">}</span>
<span class="line" id="L631"></span>
<span class="line" id="L632"><span class="tok-kw">fn</span> <span class="tok-fn">stripComponents</span>(path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, count: <span class="tok-type">u32</span>) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L633">    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L634">    <span class="tok-kw">var</span> c = count;</span>
<span class="line" id="L635">    <span class="tok-kw">while</span> (c &gt; <span class="tok-number">0</span>) : (c -= <span class="tok-number">1</span>) {</span>
<span class="line" id="L636">        <span class="tok-kw">if</span> (std.mem.indexOfScalarPos(<span class="tok-type">u8</span>, path, i, <span class="tok-str">'/'</span>)) |pos| {</span>
<span class="line" id="L637">            i = pos + <span class="tok-number">1</span>;</span>
<span class="line" id="L638">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L639">            i = path.len;</span>
<span class="line" id="L640">            <span class="tok-kw">break</span>;</span>
<span class="line" id="L641">        }</span>
<span class="line" id="L642">    }</span>
<span class="line" id="L643">    <span class="tok-kw">return</span> path[i..];</span>
<span class="line" id="L644">}</span>
<span class="line" id="L645"></span>
<span class="line" id="L646"><span class="tok-kw">test</span> <span class="tok-str">&quot;tar stripComponents&quot;</span> {</span>
<span class="line" id="L647">    <span class="tok-kw">const</span> expectEqualStrings = std.testing.expectEqualStrings;</span>
<span class="line" id="L648">    <span class="tok-kw">try</span> expectEqualStrings(<span class="tok-str">&quot;a/b/c&quot;</span>, stripComponents(<span class="tok-str">&quot;a/b/c&quot;</span>, <span class="tok-number">0</span>));</span>
<span class="line" id="L649">    <span class="tok-kw">try</span> expectEqualStrings(<span class="tok-str">&quot;b/c&quot;</span>, stripComponents(<span class="tok-str">&quot;a/b/c&quot;</span>, <span class="tok-number">1</span>));</span>
<span class="line" id="L650">    <span class="tok-kw">try</span> expectEqualStrings(<span class="tok-str">&quot;c&quot;</span>, stripComponents(<span class="tok-str">&quot;a/b/c&quot;</span>, <span class="tok-number">2</span>));</span>
<span class="line" id="L651">    <span class="tok-kw">try</span> expectEqualStrings(<span class="tok-str">&quot;&quot;</span>, stripComponents(<span class="tok-str">&quot;a/b/c&quot;</span>, <span class="tok-number">3</span>));</span>
<span class="line" id="L652">    <span class="tok-kw">try</span> expectEqualStrings(<span class="tok-str">&quot;&quot;</span>, stripComponents(<span class="tok-str">&quot;a/b/c&quot;</span>, <span class="tok-number">4</span>));</span>
<span class="line" id="L653">}</span>
<span class="line" id="L654"></span>
<span class="line" id="L655"><span class="tok-kw">test</span> <span class="tok-str">&quot;tar PaxIterator&quot;</span> {</span>
<span class="line" id="L656">    <span class="tok-kw">const</span> Attr = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L657">        kind: PaxAttributeKind,</span>
<span class="line" id="L658">        value: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L659">        err: ?<span class="tok-type">anyerror</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L660">    };</span>
<span class="line" id="L661">    <span class="tok-kw">const</span> cases = [_]<span class="tok-kw">struct</span> {</span>
<span class="line" id="L662">        data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L663">        attrs: []<span class="tok-kw">const</span> Attr,</span>
<span class="line" id="L664">        err: ?<span class="tok-type">anyerror</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L665">    }{</span>
<span class="line" id="L666">        .{ <span class="tok-comment">// valid but unknown keys</span>
</span>
<span class="line" id="L667">            .data =</span>
<span class="line" id="L668">            <span class="tok-str">\\30 mtime=1350244992.023960108</span></span>

<span class="line" id="L669">            <span class="tok-str">\\6 k=1</span></span>

<span class="line" id="L670">            <span class="tok-str">\\13 key1=val1</span></span>

<span class="line" id="L671">            <span class="tok-str">\\10 a=name</span></span>

<span class="line" id="L672">            <span class="tok-str">\\9 a=name</span></span>

<span class="line" id="L673">            <span class="tok-str">\\</span></span>

<span class="line" id="L674">            ,</span>
<span class="line" id="L675">            .attrs = &amp;[_]Attr{},</span>
<span class="line" id="L676">        },</span>
<span class="line" id="L677">        .{ <span class="tok-comment">// mix of known and unknown keys</span>
</span>
<span class="line" id="L678">            .data =</span>
<span class="line" id="L679">            <span class="tok-str">\\6 k=1</span></span>

<span class="line" id="L680">            <span class="tok-str">\\13 path=name</span></span>

<span class="line" id="L681">            <span class="tok-str">\\17 linkpath=link</span></span>

<span class="line" id="L682">            <span class="tok-str">\\13 key1=val1</span></span>

<span class="line" id="L683">            <span class="tok-str">\\12 size=123</span></span>

<span class="line" id="L684">            <span class="tok-str">\\13 key2=val2</span></span>

<span class="line" id="L685">            <span class="tok-str">\\</span></span>

<span class="line" id="L686">            ,</span>
<span class="line" id="L687">            .attrs = &amp;[_]Attr{</span>
<span class="line" id="L688">                .{ .kind = .path, .value = <span class="tok-str">&quot;name&quot;</span> },</span>
<span class="line" id="L689">                .{ .kind = .linkpath, .value = <span class="tok-str">&quot;link&quot;</span> },</span>
<span class="line" id="L690">                .{ .kind = .size, .value = <span class="tok-str">&quot;123&quot;</span> },</span>
<span class="line" id="L691">            },</span>
<span class="line" id="L692">        },</span>
<span class="line" id="L693">        .{ <span class="tok-comment">// too short size of the second key-value pair</span>
</span>
<span class="line" id="L694">            .data =</span>
<span class="line" id="L695">            <span class="tok-str">\\13 path=name</span></span>

<span class="line" id="L696">            <span class="tok-str">\\10 linkpath=value</span></span>

<span class="line" id="L697">            <span class="tok-str">\\</span></span>

<span class="line" id="L698">            ,</span>
<span class="line" id="L699">            .attrs = &amp;[_]Attr{</span>
<span class="line" id="L700">                .{ .kind = .path, .value = <span class="tok-str">&quot;name&quot;</span> },</span>
<span class="line" id="L701">            },</span>
<span class="line" id="L702">            .err = <span class="tok-kw">error</span>.UnexpectedEndOfStream,</span>
<span class="line" id="L703">        },</span>
<span class="line" id="L704">        .{ <span class="tok-comment">// too long size of the second key-value pair</span>
</span>
<span class="line" id="L705">            .data =</span>
<span class="line" id="L706">            <span class="tok-str">\\13 path=name</span></span>

<span class="line" id="L707">            <span class="tok-str">\\6 k=1</span></span>

<span class="line" id="L708">            <span class="tok-str">\\19 linkpath=value</span></span>

<span class="line" id="L709">            <span class="tok-str">\\</span></span>

<span class="line" id="L710">            ,</span>
<span class="line" id="L711">            .attrs = &amp;[_]Attr{</span>
<span class="line" id="L712">                .{ .kind = .path, .value = <span class="tok-str">&quot;name&quot;</span> },</span>
<span class="line" id="L713">            },</span>
<span class="line" id="L714">            .err = <span class="tok-kw">error</span>.UnexpectedEndOfStream,</span>
<span class="line" id="L715">        },</span>
<span class="line" id="L716"></span>
<span class="line" id="L717">        .{ <span class="tok-comment">// too long size of the second key-value pair</span>
</span>
<span class="line" id="L718">            .data =</span>
<span class="line" id="L719">            <span class="tok-str">\\13 path=name</span></span>

<span class="line" id="L720">            <span class="tok-str">\\19 linkpath=value</span></span>

<span class="line" id="L721">            <span class="tok-str">\\6 k=1</span></span>

<span class="line" id="L722">            <span class="tok-str">\\</span></span>

<span class="line" id="L723">            ,</span>
<span class="line" id="L724">            .attrs = &amp;[_]Attr{</span>
<span class="line" id="L725">                .{ .kind = .path, .value = <span class="tok-str">&quot;name&quot;</span> },</span>
<span class="line" id="L726">                .{ .kind = .linkpath, .err = <span class="tok-kw">error</span>.PaxInvalidAttributeEnd },</span>
<span class="line" id="L727">            },</span>
<span class="line" id="L728">        },</span>
<span class="line" id="L729">        .{ <span class="tok-comment">// null in keyword is not valid</span>
</span>
<span class="line" id="L730">            .data = <span class="tok-str">&quot;13 path=name\n&quot;</span> ++ <span class="tok-str">&quot;7 k\x00b=1\n&quot;</span>,</span>
<span class="line" id="L731">            .attrs = &amp;[_]Attr{</span>
<span class="line" id="L732">                .{ .kind = .path, .value = <span class="tok-str">&quot;name&quot;</span> },</span>
<span class="line" id="L733">            },</span>
<span class="line" id="L734">            .err = <span class="tok-kw">error</span>.PaxNullInKeyword,</span>
<span class="line" id="L735">        },</span>
<span class="line" id="L736">        .{ <span class="tok-comment">// null in value is not valid</span>
</span>
<span class="line" id="L737">            .data = <span class="tok-str">&quot;23 path=name\x00with null\n&quot;</span>,</span>
<span class="line" id="L738">            .attrs = &amp;[_]Attr{</span>
<span class="line" id="L739">                .{ .kind = .path, .err = <span class="tok-kw">error</span>.PaxNullInValue },</span>
<span class="line" id="L740">            },</span>
<span class="line" id="L741">        },</span>
<span class="line" id="L742">        .{ <span class="tok-comment">// 1000 characters path</span>
</span>
<span class="line" id="L743">            .data = <span class="tok-str">&quot;1011 path=&quot;</span> ++ <span class="tok-str">&quot;0123456789&quot;</span> ** <span class="tok-number">100</span> ++ <span class="tok-str">&quot;\n&quot;</span>,</span>
<span class="line" id="L744">            .attrs = &amp;[_]Attr{</span>
<span class="line" id="L745">                .{ .kind = .path, .value = <span class="tok-str">&quot;0123456789&quot;</span> ** <span class="tok-number">100</span> },</span>
<span class="line" id="L746">            },</span>
<span class="line" id="L747">        },</span>
<span class="line" id="L748">    };</span>
<span class="line" id="L749">    <span class="tok-kw">var</span> buffer: [<span class="tok-number">1024</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L750"></span>
<span class="line" id="L751">    outer: <span class="tok-kw">for</span> (cases) |case| {</span>
<span class="line" id="L752">        <span class="tok-kw">var</span> stream = std.io.fixedBufferStream(case.data);</span>
<span class="line" id="L753">        <span class="tok-kw">var</span> iter = paxIterator(stream.reader(), case.data.len);</span>
<span class="line" id="L754"></span>
<span class="line" id="L755">        <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L756">        <span class="tok-kw">while</span> (iter.next() <span class="tok-kw">catch</span> |err| {</span>
<span class="line" id="L757">            <span class="tok-kw">if</span> (case.err) |e| {</span>
<span class="line" id="L758">                <span class="tok-kw">try</span> std.testing.expectEqual(e, err);</span>
<span class="line" id="L759">                <span class="tok-kw">continue</span>;</span>
<span class="line" id="L760">            }</span>
<span class="line" id="L761">            <span class="tok-kw">return</span> err;</span>
<span class="line" id="L762">        }) |attr| : (i += <span class="tok-number">1</span>) {</span>
<span class="line" id="L763">            <span class="tok-kw">const</span> exp = case.attrs[i];</span>
<span class="line" id="L764">            <span class="tok-kw">try</span> std.testing.expectEqual(exp.kind, attr.kind);</span>
<span class="line" id="L765">            <span class="tok-kw">const</span> value = attr.value(&amp;buffer) <span class="tok-kw">catch</span> |err| {</span>
<span class="line" id="L766">                <span class="tok-kw">if</span> (exp.err) |e| {</span>
<span class="line" id="L767">                    <span class="tok-kw">try</span> std.testing.expectEqual(e, err);</span>
<span class="line" id="L768">                    <span class="tok-kw">break</span> :outer;</span>
<span class="line" id="L769">                }</span>
<span class="line" id="L770">                <span class="tok-kw">return</span> err;</span>
<span class="line" id="L771">            };</span>
<span class="line" id="L772">            <span class="tok-kw">try</span> std.testing.expectEqualStrings(exp.value, value);</span>
<span class="line" id="L773">        }</span>
<span class="line" id="L774">        <span class="tok-kw">try</span> std.testing.expectEqual(case.attrs.len, i);</span>
<span class="line" id="L775">        <span class="tok-kw">try</span> std.testing.expect(case.err == <span class="tok-null">null</span>);</span>
<span class="line" id="L776">    }</span>
<span class="line" id="L777">}</span>
<span class="line" id="L778"></span>
<span class="line" id="L779"><span class="tok-kw">test</span> {</span>
<span class="line" id="L780">    _ = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;tar/test.zig&quot;</span>);</span>
<span class="line" id="L781">}</span>
<span class="line" id="L782"></span>
<span class="line" id="L783"><span class="tok-kw">test</span> <span class="tok-str">&quot;tar header parse size&quot;</span> {</span>
<span class="line" id="L784">    <span class="tok-kw">const</span> cases = [_]<span class="tok-kw">struct</span> {</span>
<span class="line" id="L785">        in: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L786">        want: <span class="tok-type">u64</span> = <span class="tok-number">0</span>,</span>
<span class="line" id="L787">        err: ?<span class="tok-type">anyerror</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L788">    }{</span>
<span class="line" id="L789">        <span class="tok-comment">// Test base-256 (binary) encoded values.</span>
</span>
<span class="line" id="L790">        .{ .in = <span class="tok-str">&quot;&quot;</span>, .want = <span class="tok-number">0</span> },</span>
<span class="line" id="L791">        .{ .in = <span class="tok-str">&quot;\x80&quot;</span>, .want = <span class="tok-number">0</span> },</span>
<span class="line" id="L792">        .{ .in = <span class="tok-str">&quot;\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01&quot;</span>, .want = <span class="tok-number">1</span> },</span>
<span class="line" id="L793">        .{ .in = <span class="tok-str">&quot;\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x02&quot;</span>, .want = <span class="tok-number">0x0102</span> },</span>
<span class="line" id="L794">        .{ .in = <span class="tok-str">&quot;\x80\x00\x00\x00\x01\x02\x03\x04\x05\x06\x07\x08&quot;</span>, .want = <span class="tok-number">0x0102030405060708</span> },</span>
<span class="line" id="L795">        .{ .in = <span class="tok-str">&quot;\x80\x00\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09&quot;</span>, .err = <span class="tok-kw">error</span>.TarNumericValueTooBig },</span>
<span class="line" id="L796">        .{ .in = <span class="tok-str">&quot;\x80\x00\x00\x00\x07\x76\xa2\x22\xeb\x8a\x72\x61&quot;</span>, .want = <span class="tok-number">537795476381659745</span> },</span>
<span class="line" id="L797">        .{ .in = <span class="tok-str">&quot;\x80\x80\x80\x00\x01\x02\x03\x04\x05\x06\x07\x08&quot;</span>, .err = <span class="tok-kw">error</span>.TarNumericValueTooBig },</span>
<span class="line" id="L798"></span>
<span class="line" id="L799">        <span class="tok-comment">// // Test base-8 (octal) encoded values.</span>
</span>
<span class="line" id="L800">        .{ .in = <span class="tok-str">&quot;00000000227\x00&quot;</span>, .want = <span class="tok-number">0o227</span> },</span>
<span class="line" id="L801">        .{ .in = <span class="tok-str">&quot;  000000227\x00&quot;</span>, .want = <span class="tok-number">0o227</span> },</span>
<span class="line" id="L802">        .{ .in = <span class="tok-str">&quot;00000000228\x00&quot;</span>, .err = <span class="tok-kw">error</span>.TarHeader },</span>
<span class="line" id="L803">        .{ .in = <span class="tok-str">&quot;11111111111\x00&quot;</span>, .want = <span class="tok-number">0o11111111111</span> },</span>
<span class="line" id="L804">    };</span>
<span class="line" id="L805"></span>
<span class="line" id="L806">    <span class="tok-kw">for</span> (cases) |case| {</span>
<span class="line" id="L807">        <span class="tok-kw">var</span> bytes = [_]<span class="tok-type">u8</span>{<span class="tok-number">0</span>} ** Header.SIZE;</span>
<span class="line" id="L808">        <span class="tok-builtin">@memcpy</span>(bytes[<span class="tok-number">124</span> .. <span class="tok-number">124</span> + case.in.len], case.in);</span>
<span class="line" id="L809">        <span class="tok-kw">var</span> header = Header{ .bytes = &amp;bytes };</span>
<span class="line" id="L810">        <span class="tok-kw">if</span> (case.err) |err| {</span>
<span class="line" id="L811">            <span class="tok-kw">try</span> std.testing.expectError(err, header.size());</span>
<span class="line" id="L812">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L813">            <span class="tok-kw">try</span> std.testing.expectEqual(case.want, <span class="tok-kw">try</span> header.size());</span>
<span class="line" id="L814">        }</span>
<span class="line" id="L815">    }</span>
<span class="line" id="L816">}</span>
<span class="line" id="L817"></span>
<span class="line" id="L818"><span class="tok-kw">test</span> <span class="tok-str">&quot;tar header parse mode&quot;</span> {</span>
<span class="line" id="L819">    <span class="tok-kw">const</span> cases = [_]<span class="tok-kw">struct</span> {</span>
<span class="line" id="L820">        in: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L821">        want: <span class="tok-type">u64</span> = <span class="tok-number">0</span>,</span>
<span class="line" id="L822">        err: ?<span class="tok-type">anyerror</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L823">    }{</span>
<span class="line" id="L824">        .{ .in = <span class="tok-str">&quot;0000644\x00&quot;</span>, .want = <span class="tok-number">0o644</span> },</span>
<span class="line" id="L825">        .{ .in = <span class="tok-str">&quot;0000777\x00&quot;</span>, .want = <span class="tok-number">0o777</span> },</span>
<span class="line" id="L826">        .{ .in = <span class="tok-str">&quot;7777777\x00&quot;</span>, .want = <span class="tok-number">0o7777777</span> },</span>
<span class="line" id="L827">        .{ .in = <span class="tok-str">&quot;7777778\x00&quot;</span>, .err = <span class="tok-kw">error</span>.TarHeader },</span>
<span class="line" id="L828">        .{ .in = <span class="tok-str">&quot;77777777&quot;</span>, .want = <span class="tok-number">0o77777777</span> },</span>
<span class="line" id="L829">        .{ .in = <span class="tok-str">&quot;777777777777&quot;</span>, .want = <span class="tok-number">0o77777777</span> },</span>
<span class="line" id="L830">    };</span>
<span class="line" id="L831">    <span class="tok-kw">for</span> (cases) |case| {</span>
<span class="line" id="L832">        <span class="tok-kw">var</span> bytes = [_]<span class="tok-type">u8</span>{<span class="tok-number">0</span>} ** Header.SIZE;</span>
<span class="line" id="L833">        <span class="tok-builtin">@memcpy</span>(bytes[<span class="tok-number">100</span> .. <span class="tok-number">100</span> + case.in.len], case.in);</span>
<span class="line" id="L834">        <span class="tok-kw">var</span> header = Header{ .bytes = &amp;bytes };</span>
<span class="line" id="L835">        <span class="tok-kw">if</span> (case.err) |err| {</span>
<span class="line" id="L836">            <span class="tok-kw">try</span> std.testing.expectError(err, header.mode());</span>
<span class="line" id="L837">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L838">            <span class="tok-kw">try</span> std.testing.expectEqual(case.want, <span class="tok-kw">try</span> header.mode());</span>
<span class="line" id="L839">        }</span>
<span class="line" id="L840">    }</span>
<span class="line" id="L841">}</span>
<span class="line" id="L842"></span>
</code></pre></body>
</html>