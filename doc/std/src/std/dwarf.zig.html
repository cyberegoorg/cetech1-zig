<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>dwarf.zig - source view</title>
    <link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAgklEQVR4AWMYWuD7EllJIM4G4g4g5oIJ/odhOJ8wToOxSTXgNxDHoeiBMfA4+wGShjyYOCkG/IGqWQziEzYAoUAeiF9D5U+DxEg14DRU7jWIT5IBIOdCxf+A+CQZAAoopEB7QJwBCBwHiip8UYmRdrAlDpIMgApwQZNnNii5Dq0MBgCxxycBnwEd+wAAAABJRU5ErkJggg==">
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style>
      body{
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        margin: 0;
        line-height: 1.5;
      }

      pre > code {
        display: block;
        overflow: auto;
        line-height: normal;
        margin: 0em;
      }
      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #005C7A;
      }
      .tok-comment {
          color: #545454;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #005C5C;
      }
      .tok-number {
          color: #005C5C;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }
      pre {
        counter-reset: line;
      }
      pre .line:before {
        counter-increment: line;
        content: counter(line);
        display: inline-block;
        padding-right: 1em;
        width: 2em;
        text-align: right;
        color: #999;
      }
      
      .line {
        width: 100%;
        display: inline-block;
      }
      .line:target {
        border-top: 1px solid #ccc;
        border-bottom: 1px solid #ccc;
        background: #fafafa;
      }

      @media (prefers-color-scheme: dark) {
        body{
            background:#222;
            color: #ccc;
        }
        pre > code {
            color: #ccc;
            background: #222;
            border: unset;
        }
        .line:target {
            border-top: 1px solid #444;
            border-bottom: 1px solid #444;
            background: #333;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
</head>
<body>
<pre><code><span class="line" id="L1"><span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);</span>
<span class="line" id="L2"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std.zig&quot;</span>);</span>
<span class="line" id="L3"><span class="tok-kw">const</span> debug = std.debug;</span>
<span class="line" id="L4"><span class="tok-kw">const</span> mem = std.mem;</span>
<span class="line" id="L5"><span class="tok-kw">const</span> math = std.math;</span>
<span class="line" id="L6"><span class="tok-kw">const</span> assert = debug.assert;</span>
<span class="line" id="L7"><span class="tok-kw">const</span> native_endian = builtin.cpu.arch.endian();</span>
<span class="line" id="L8"></span>
<span class="line" id="L9"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> TAG = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;dwarf/TAG.zig&quot;</span>);</span>
<span class="line" id="L10"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> AT = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;dwarf/AT.zig&quot;</span>);</span>
<span class="line" id="L11"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> OP = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;dwarf/OP.zig&quot;</span>);</span>
<span class="line" id="L12"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> LANG = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;dwarf/LANG.zig&quot;</span>);</span>
<span class="line" id="L13"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> FORM = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;dwarf/FORM.zig&quot;</span>);</span>
<span class="line" id="L14"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ATE = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;dwarf/ATE.zig&quot;</span>);</span>
<span class="line" id="L15"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> EH = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;dwarf/EH.zig&quot;</span>);</span>
<span class="line" id="L16"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> abi = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;dwarf/abi.zig&quot;</span>);</span>
<span class="line" id="L17"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> call_frame = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;dwarf/call_frame.zig&quot;</span>);</span>
<span class="line" id="L18"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> expressions = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;dwarf/expressions.zig&quot;</span>);</span>
<span class="line" id="L19"></span>
<span class="line" id="L20"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> LLE = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L21">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> end_of_list = <span class="tok-number">0x00</span>;</span>
<span class="line" id="L22">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> base_addressx = <span class="tok-number">0x01</span>;</span>
<span class="line" id="L23">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> startx_endx = <span class="tok-number">0x02</span>;</span>
<span class="line" id="L24">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> startx_length = <span class="tok-number">0x03</span>;</span>
<span class="line" id="L25">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> offset_pair = <span class="tok-number">0x04</span>;</span>
<span class="line" id="L26">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> default_location = <span class="tok-number">0x05</span>;</span>
<span class="line" id="L27">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> base_address = <span class="tok-number">0x06</span>;</span>
<span class="line" id="L28">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> start_end = <span class="tok-number">0x07</span>;</span>
<span class="line" id="L29">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> start_length = <span class="tok-number">0x08</span>;</span>
<span class="line" id="L30">};</span>
<span class="line" id="L31"></span>
<span class="line" id="L32"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> CFA = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L33">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> advance_loc = <span class="tok-number">0x40</span>;</span>
<span class="line" id="L34">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> offset = <span class="tok-number">0x80</span>;</span>
<span class="line" id="L35">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> restore = <span class="tok-number">0xc0</span>;</span>
<span class="line" id="L36">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> nop = <span class="tok-number">0x00</span>;</span>
<span class="line" id="L37">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> set_loc = <span class="tok-number">0x01</span>;</span>
<span class="line" id="L38">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> advance_loc1 = <span class="tok-number">0x02</span>;</span>
<span class="line" id="L39">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> advance_loc2 = <span class="tok-number">0x03</span>;</span>
<span class="line" id="L40">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> advance_loc4 = <span class="tok-number">0x04</span>;</span>
<span class="line" id="L41">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> offset_extended = <span class="tok-number">0x05</span>;</span>
<span class="line" id="L42">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> restore_extended = <span class="tok-number">0x06</span>;</span>
<span class="line" id="L43">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> @&quot;undefined&quot; = <span class="tok-number">0x07</span>;</span>
<span class="line" id="L44">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> same_value = <span class="tok-number">0x08</span>;</span>
<span class="line" id="L45">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> register = <span class="tok-number">0x09</span>;</span>
<span class="line" id="L46">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> remember_state = <span class="tok-number">0x0a</span>;</span>
<span class="line" id="L47">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> restore_state = <span class="tok-number">0x0b</span>;</span>
<span class="line" id="L48">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> def_cfa = <span class="tok-number">0x0c</span>;</span>
<span class="line" id="L49">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> def_cfa_register = <span class="tok-number">0x0d</span>;</span>
<span class="line" id="L50">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> def_cfa_offset = <span class="tok-number">0x0e</span>;</span>
<span class="line" id="L51"></span>
<span class="line" id="L52">    <span class="tok-comment">// DWARF 3.</span>
</span>
<span class="line" id="L53">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> def_cfa_expression = <span class="tok-number">0x0f</span>;</span>
<span class="line" id="L54">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> expression = <span class="tok-number">0x10</span>;</span>
<span class="line" id="L55">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> offset_extended_sf = <span class="tok-number">0x11</span>;</span>
<span class="line" id="L56">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> def_cfa_sf = <span class="tok-number">0x12</span>;</span>
<span class="line" id="L57">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> def_cfa_offset_sf = <span class="tok-number">0x13</span>;</span>
<span class="line" id="L58">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> val_offset = <span class="tok-number">0x14</span>;</span>
<span class="line" id="L59">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> val_offset_sf = <span class="tok-number">0x15</span>;</span>
<span class="line" id="L60">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> val_expression = <span class="tok-number">0x16</span>;</span>
<span class="line" id="L61"></span>
<span class="line" id="L62">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> lo_user = <span class="tok-number">0x1c</span>;</span>
<span class="line" id="L63">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> hi_user = <span class="tok-number">0x3f</span>;</span>
<span class="line" id="L64"></span>
<span class="line" id="L65">    <span class="tok-comment">// SGI/MIPS specific.</span>
</span>
<span class="line" id="L66">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> MIPS_advance_loc8 = <span class="tok-number">0x1d</span>;</span>
<span class="line" id="L67"></span>
<span class="line" id="L68">    <span class="tok-comment">// GNU extensions.</span>
</span>
<span class="line" id="L69">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> GNU_window_save = <span class="tok-number">0x2d</span>;</span>
<span class="line" id="L70">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> GNU_args_size = <span class="tok-number">0x2e</span>;</span>
<span class="line" id="L71">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> GNU_negative_offset_extended = <span class="tok-number">0x2f</span>;</span>
<span class="line" id="L72">};</span>
<span class="line" id="L73"></span>
<span class="line" id="L74"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> CHILDREN = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L75">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> no = <span class="tok-number">0x00</span>;</span>
<span class="line" id="L76">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> yes = <span class="tok-number">0x01</span>;</span>
<span class="line" id="L77">};</span>
<span class="line" id="L78"></span>
<span class="line" id="L79"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> LNS = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L80">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> extended_op = <span class="tok-number">0x00</span>;</span>
<span class="line" id="L81">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> copy = <span class="tok-number">0x01</span>;</span>
<span class="line" id="L82">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> advance_pc = <span class="tok-number">0x02</span>;</span>
<span class="line" id="L83">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> advance_line = <span class="tok-number">0x03</span>;</span>
<span class="line" id="L84">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> set_file = <span class="tok-number">0x04</span>;</span>
<span class="line" id="L85">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> set_column = <span class="tok-number">0x05</span>;</span>
<span class="line" id="L86">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> negate_stmt = <span class="tok-number">0x06</span>;</span>
<span class="line" id="L87">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> set_basic_block = <span class="tok-number">0x07</span>;</span>
<span class="line" id="L88">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> const_add_pc = <span class="tok-number">0x08</span>;</span>
<span class="line" id="L89">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> fixed_advance_pc = <span class="tok-number">0x09</span>;</span>
<span class="line" id="L90">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> set_prologue_end = <span class="tok-number">0x0a</span>;</span>
<span class="line" id="L91">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> set_epilogue_begin = <span class="tok-number">0x0b</span>;</span>
<span class="line" id="L92">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> set_isa = <span class="tok-number">0x0c</span>;</span>
<span class="line" id="L93">};</span>
<span class="line" id="L94"></span>
<span class="line" id="L95"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> LNE = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L96">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> end_sequence = <span class="tok-number">0x01</span>;</span>
<span class="line" id="L97">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> set_address = <span class="tok-number">0x02</span>;</span>
<span class="line" id="L98">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> define_file = <span class="tok-number">0x03</span>;</span>
<span class="line" id="L99">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> set_discriminator = <span class="tok-number">0x04</span>;</span>
<span class="line" id="L100">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> lo_user = <span class="tok-number">0x80</span>;</span>
<span class="line" id="L101">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> hi_user = <span class="tok-number">0xff</span>;</span>
<span class="line" id="L102">};</span>
<span class="line" id="L103"></span>
<span class="line" id="L104"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> UT = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L105">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> compile = <span class="tok-number">0x01</span>;</span>
<span class="line" id="L106">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> @&quot;type&quot; = <span class="tok-number">0x02</span>;</span>
<span class="line" id="L107">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> partial = <span class="tok-number">0x03</span>;</span>
<span class="line" id="L108">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> skeleton = <span class="tok-number">0x04</span>;</span>
<span class="line" id="L109">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> split_compile = <span class="tok-number">0x05</span>;</span>
<span class="line" id="L110">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> split_type = <span class="tok-number">0x06</span>;</span>
<span class="line" id="L111"></span>
<span class="line" id="L112">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> lo_user = <span class="tok-number">0x80</span>;</span>
<span class="line" id="L113">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> hi_user = <span class="tok-number">0xff</span>;</span>
<span class="line" id="L114">};</span>
<span class="line" id="L115"></span>
<span class="line" id="L116"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> LNCT = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L117">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> path = <span class="tok-number">0x1</span>;</span>
<span class="line" id="L118">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> directory_index = <span class="tok-number">0x2</span>;</span>
<span class="line" id="L119">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> timestamp = <span class="tok-number">0x3</span>;</span>
<span class="line" id="L120">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> size = <span class="tok-number">0x4</span>;</span>
<span class="line" id="L121">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> MD5 = <span class="tok-number">0x5</span>;</span>
<span class="line" id="L122"></span>
<span class="line" id="L123">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> lo_user = <span class="tok-number">0x2000</span>;</span>
<span class="line" id="L124">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> hi_user = <span class="tok-number">0x3fff</span>;</span>
<span class="line" id="L125">};</span>
<span class="line" id="L126"></span>
<span class="line" id="L127"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> RLE = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L128">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> end_of_list = <span class="tok-number">0x00</span>;</span>
<span class="line" id="L129">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> base_addressx = <span class="tok-number">0x01</span>;</span>
<span class="line" id="L130">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> startx_endx = <span class="tok-number">0x02</span>;</span>
<span class="line" id="L131">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> startx_length = <span class="tok-number">0x03</span>;</span>
<span class="line" id="L132">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> offset_pair = <span class="tok-number">0x04</span>;</span>
<span class="line" id="L133">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> base_address = <span class="tok-number">0x05</span>;</span>
<span class="line" id="L134">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> start_end = <span class="tok-number">0x06</span>;</span>
<span class="line" id="L135">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> start_length = <span class="tok-number">0x07</span>;</span>
<span class="line" id="L136">};</span>
<span class="line" id="L137"></span>
<span class="line" id="L138"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> CC = <span class="tok-kw">enum</span>(<span class="tok-type">u8</span>) {</span>
<span class="line" id="L139">    normal = <span class="tok-number">0x1</span>,</span>
<span class="line" id="L140">    program = <span class="tok-number">0x2</span>,</span>
<span class="line" id="L141">    nocall = <span class="tok-number">0x3</span>,</span>
<span class="line" id="L142"></span>
<span class="line" id="L143">    pass_by_reference = <span class="tok-number">0x4</span>,</span>
<span class="line" id="L144">    pass_by_value = <span class="tok-number">0x5</span>,</span>
<span class="line" id="L145"></span>
<span class="line" id="L146">    GNU_renesas_sh = <span class="tok-number">0x40</span>,</span>
<span class="line" id="L147">    GNU_borland_fastcall_i386 = <span class="tok-number">0x41</span>,</span>
<span class="line" id="L148"></span>
<span class="line" id="L149">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> lo_user = <span class="tok-number">0x40</span>;</span>
<span class="line" id="L150">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> hi_user = <span class="tok-number">0xff</span>;</span>
<span class="line" id="L151">};</span>
<span class="line" id="L152"></span>
<span class="line" id="L153"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Format = <span class="tok-kw">enum</span> { @&quot;32&quot;, @&quot;64&quot; };</span>
<span class="line" id="L154"></span>
<span class="line" id="L155"><span class="tok-kw">const</span> PcRange = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L156">    start: <span class="tok-type">u64</span>,</span>
<span class="line" id="L157">    end: <span class="tok-type">u64</span>,</span>
<span class="line" id="L158">};</span>
<span class="line" id="L159"></span>
<span class="line" id="L160"><span class="tok-kw">const</span> Func = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L161">    pc_range: ?PcRange,</span>
<span class="line" id="L162">    name: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L163">};</span>
<span class="line" id="L164"></span>
<span class="line" id="L165"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> CompileUnit = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L166">    version: <span class="tok-type">u16</span>,</span>
<span class="line" id="L167">    format: Format,</span>
<span class="line" id="L168">    die: Die,</span>
<span class="line" id="L169">    pc_range: ?PcRange,</span>
<span class="line" id="L170"></span>
<span class="line" id="L171">    str_offsets_base: <span class="tok-type">usize</span>,</span>
<span class="line" id="L172">    addr_base: <span class="tok-type">usize</span>,</span>
<span class="line" id="L173">    rnglists_base: <span class="tok-type">usize</span>,</span>
<span class="line" id="L174">    loclists_base: <span class="tok-type">usize</span>,</span>
<span class="line" id="L175">    frame_base: ?*<span class="tok-kw">const</span> FormValue,</span>
<span class="line" id="L176">};</span>
<span class="line" id="L177"></span>
<span class="line" id="L178"><span class="tok-kw">const</span> Abbrev = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L179">    code: <span class="tok-type">u64</span>,</span>
<span class="line" id="L180">    tag_id: <span class="tok-type">u64</span>,</span>
<span class="line" id="L181">    has_children: <span class="tok-type">bool</span>,</span>
<span class="line" id="L182">    attrs: []Attr,</span>
<span class="line" id="L183"></span>
<span class="line" id="L184">    <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(abbrev: *Abbrev, allocator: mem.Allocator) <span class="tok-type">void</span> {</span>
<span class="line" id="L185">        allocator.free(abbrev.attrs);</span>
<span class="line" id="L186">        abbrev.* = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L187">    }</span>
<span class="line" id="L188"></span>
<span class="line" id="L189">    <span class="tok-kw">const</span> Attr = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L190">        id: <span class="tok-type">u64</span>,</span>
<span class="line" id="L191">        form_id: <span class="tok-type">u64</span>,</span>
<span class="line" id="L192">        <span class="tok-comment">/// Only valid if form_id is .implicit_const</span></span>
<span class="line" id="L193">        payload: <span class="tok-type">i64</span>,</span>
<span class="line" id="L194">    };</span>
<span class="line" id="L195"></span>
<span class="line" id="L196">    <span class="tok-kw">const</span> Table = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L197">        <span class="tok-comment">// offset from .debug_abbrev</span>
</span>
<span class="line" id="L198">        offset: <span class="tok-type">u64</span>,</span>
<span class="line" id="L199">        abbrevs: []Abbrev,</span>
<span class="line" id="L200"></span>
<span class="line" id="L201">        <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(table: *Table, allocator: mem.Allocator) <span class="tok-type">void</span> {</span>
<span class="line" id="L202">            <span class="tok-kw">for</span> (table.abbrevs) |*abbrev| {</span>
<span class="line" id="L203">                abbrev.deinit(allocator);</span>
<span class="line" id="L204">            }</span>
<span class="line" id="L205">            allocator.free(table.abbrevs);</span>
<span class="line" id="L206">            table.* = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L207">        }</span>
<span class="line" id="L208"></span>
<span class="line" id="L209">        <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(table: *<span class="tok-kw">const</span> Table, abbrev_code: <span class="tok-type">u64</span>) ?*<span class="tok-kw">const</span> Abbrev {</span>
<span class="line" id="L210">            <span class="tok-kw">return</span> <span class="tok-kw">for</span> (table.abbrevs) |*abbrev| {</span>
<span class="line" id="L211">                <span class="tok-kw">if</span> (abbrev.code == abbrev_code) <span class="tok-kw">break</span> abbrev;</span>
<span class="line" id="L212">            } <span class="tok-kw">else</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L213">        }</span>
<span class="line" id="L214">    };</span>
<span class="line" id="L215">};</span>
<span class="line" id="L216"></span>
<span class="line" id="L217"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> FormValue = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {</span>
<span class="line" id="L218">    addr: <span class="tok-type">u64</span>,</span>
<span class="line" id="L219">    addrx: <span class="tok-type">usize</span>,</span>
<span class="line" id="L220">    block: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L221">    udata: <span class="tok-type">u64</span>,</span>
<span class="line" id="L222">    data16: *<span class="tok-kw">const</span> [<span class="tok-number">16</span>]<span class="tok-type">u8</span>,</span>
<span class="line" id="L223">    sdata: <span class="tok-type">i64</span>,</span>
<span class="line" id="L224">    exprloc: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L225">    flag: <span class="tok-type">bool</span>,</span>
<span class="line" id="L226">    sec_offset: <span class="tok-type">u64</span>,</span>
<span class="line" id="L227">    ref: <span class="tok-type">u64</span>,</span>
<span class="line" id="L228">    ref_addr: <span class="tok-type">u64</span>,</span>
<span class="line" id="L229">    string: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L230">    strp: <span class="tok-type">u64</span>,</span>
<span class="line" id="L231">    strx: <span class="tok-type">usize</span>,</span>
<span class="line" id="L232">    line_strp: <span class="tok-type">u64</span>,</span>
<span class="line" id="L233">    loclistx: <span class="tok-type">u64</span>,</span>
<span class="line" id="L234">    rnglistx: <span class="tok-type">u64</span>,</span>
<span class="line" id="L235"></span>
<span class="line" id="L236">    <span class="tok-kw">fn</span> <span class="tok-fn">getString</span>(fv: FormValue, di: DwarfInfo) ![:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L237">        <span class="tok-kw">switch</span> (fv) {</span>
<span class="line" id="L238">            .string =&gt; |s| <span class="tok-kw">return</span> s,</span>
<span class="line" id="L239">            .strp =&gt; |off| <span class="tok-kw">return</span> di.getString(off),</span>
<span class="line" id="L240">            .line_strp =&gt; |off| <span class="tok-kw">return</span> di.getLineString(off),</span>
<span class="line" id="L241">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> badDwarf(),</span>
<span class="line" id="L242">        }</span>
<span class="line" id="L243">    }</span>
<span class="line" id="L244"></span>
<span class="line" id="L245">    <span class="tok-kw">fn</span> <span class="tok-fn">getUInt</span>(fv: FormValue, <span class="tok-kw">comptime</span> U: <span class="tok-type">type</span>) !U {</span>
<span class="line" id="L246">        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (fv) {</span>
<span class="line" id="L247">            <span class="tok-kw">inline</span> .udata,</span>
<span class="line" id="L248">            .sdata,</span>
<span class="line" id="L249">            .sec_offset,</span>
<span class="line" id="L250">            =&gt; |c| math.cast(U, c) <span class="tok-kw">orelse</span> badDwarf(),</span>
<span class="line" id="L251">            <span class="tok-kw">else</span> =&gt; badDwarf(),</span>
<span class="line" id="L252">        };</span>
<span class="line" id="L253">    }</span>
<span class="line" id="L254">};</span>
<span class="line" id="L255"></span>
<span class="line" id="L256"><span class="tok-kw">const</span> Die = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L257">    tag_id: <span class="tok-type">u64</span>,</span>
<span class="line" id="L258">    has_children: <span class="tok-type">bool</span>,</span>
<span class="line" id="L259">    attrs: []Attr,</span>
<span class="line" id="L260"></span>
<span class="line" id="L261">    <span class="tok-kw">const</span> Attr = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L262">        id: <span class="tok-type">u64</span>,</span>
<span class="line" id="L263">        value: FormValue,</span>
<span class="line" id="L264">    };</span>
<span class="line" id="L265"></span>
<span class="line" id="L266">    <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *Die, allocator: mem.Allocator) <span class="tok-type">void</span> {</span>
<span class="line" id="L267">        allocator.free(self.attrs);</span>
<span class="line" id="L268">        self.* = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L269">    }</span>
<span class="line" id="L270"></span>
<span class="line" id="L271">    <span class="tok-kw">fn</span> <span class="tok-fn">getAttr</span>(self: *<span class="tok-kw">const</span> Die, id: <span class="tok-type">u64</span>) ?*<span class="tok-kw">const</span> FormValue {</span>
<span class="line" id="L272">        <span class="tok-kw">for</span> (self.attrs) |*attr| {</span>
<span class="line" id="L273">            <span class="tok-kw">if</span> (attr.id == id) <span class="tok-kw">return</span> &amp;attr.value;</span>
<span class="line" id="L274">        }</span>
<span class="line" id="L275">        <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L276">    }</span>
<span class="line" id="L277"></span>
<span class="line" id="L278">    <span class="tok-kw">fn</span> <span class="tok-fn">getAttrAddr</span>(</span>
<span class="line" id="L279">        self: *<span class="tok-kw">const</span> Die,</span>
<span class="line" id="L280">        di: *<span class="tok-kw">const</span> DwarfInfo,</span>
<span class="line" id="L281">        id: <span class="tok-type">u64</span>,</span>
<span class="line" id="L282">        compile_unit: CompileUnit,</span>
<span class="line" id="L283">    ) <span class="tok-kw">error</span>{ InvalidDebugInfo, MissingDebugInfo }!<span class="tok-type">u64</span> {</span>
<span class="line" id="L284">        <span class="tok-kw">const</span> form_value = self.getAttr(id) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;</span>
<span class="line" id="L285">        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (form_value.*) {</span>
<span class="line" id="L286">            .addr =&gt; |value| value,</span>
<span class="line" id="L287">            .addrx =&gt; |index| di.readDebugAddr(compile_unit, index),</span>
<span class="line" id="L288">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">error</span>.InvalidDebugInfo,</span>
<span class="line" id="L289">        };</span>
<span class="line" id="L290">    }</span>
<span class="line" id="L291"></span>
<span class="line" id="L292">    <span class="tok-kw">fn</span> <span class="tok-fn">getAttrSecOffset</span>(self: *<span class="tok-kw">const</span> Die, id: <span class="tok-type">u64</span>) !<span class="tok-type">u64</span> {</span>
<span class="line" id="L293">        <span class="tok-kw">const</span> form_value = self.getAttr(id) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;</span>
<span class="line" id="L294">        <span class="tok-kw">return</span> form_value.getUInt(<span class="tok-type">u64</span>);</span>
<span class="line" id="L295">    }</span>
<span class="line" id="L296"></span>
<span class="line" id="L297">    <span class="tok-kw">fn</span> <span class="tok-fn">getAttrUnsignedLe</span>(self: *<span class="tok-kw">const</span> Die, id: <span class="tok-type">u64</span>) !<span class="tok-type">u64</span> {</span>
<span class="line" id="L298">        <span class="tok-kw">const</span> form_value = self.getAttr(id) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;</span>
<span class="line" id="L299">        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (form_value.*) {</span>
<span class="line" id="L300">            .Const =&gt; |value| value.asUnsignedLe(),</span>
<span class="line" id="L301">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">error</span>.InvalidDebugInfo,</span>
<span class="line" id="L302">        };</span>
<span class="line" id="L303">    }</span>
<span class="line" id="L304"></span>
<span class="line" id="L305">    <span class="tok-kw">fn</span> <span class="tok-fn">getAttrRef</span>(self: *<span class="tok-kw">const</span> Die, id: <span class="tok-type">u64</span>) !<span class="tok-type">u64</span> {</span>
<span class="line" id="L306">        <span class="tok-kw">const</span> form_value = self.getAttr(id) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;</span>
<span class="line" id="L307">        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (form_value.*) {</span>
<span class="line" id="L308">            .ref =&gt; |value| value,</span>
<span class="line" id="L309">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">error</span>.InvalidDebugInfo,</span>
<span class="line" id="L310">        };</span>
<span class="line" id="L311">    }</span>
<span class="line" id="L312"></span>
<span class="line" id="L313">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAttrString</span>(</span>
<span class="line" id="L314">        self: *<span class="tok-kw">const</span> Die,</span>
<span class="line" id="L315">        di: *DwarfInfo,</span>
<span class="line" id="L316">        id: <span class="tok-type">u64</span>,</span>
<span class="line" id="L317">        opt_str: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L318">        compile_unit: CompileUnit,</span>
<span class="line" id="L319">    ) <span class="tok-kw">error</span>{ InvalidDebugInfo, MissingDebugInfo }![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L320">        <span class="tok-kw">const</span> form_value = self.getAttr(id) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;</span>
<span class="line" id="L321">        <span class="tok-kw">switch</span> (form_value.*) {</span>
<span class="line" id="L322">            .string =&gt; |value| <span class="tok-kw">return</span> value,</span>
<span class="line" id="L323">            .strp =&gt; |offset| <span class="tok-kw">return</span> di.getString(offset),</span>
<span class="line" id="L324">            .strx =&gt; |index| {</span>
<span class="line" id="L325">                <span class="tok-kw">const</span> debug_str_offsets = di.section(.debug_str_offsets) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L326">                <span class="tok-kw">if</span> (compile_unit.str_offsets_base == <span class="tok-number">0</span>) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L327">                <span class="tok-kw">switch</span> (compile_unit.format) {</span>
<span class="line" id="L328">                    .@&quot;32&quot; =&gt; {</span>
<span class="line" id="L329">                        <span class="tok-kw">const</span> byte_offset = compile_unit.str_offsets_base + <span class="tok-number">4</span> * index;</span>
<span class="line" id="L330">                        <span class="tok-kw">if</span> (byte_offset + <span class="tok-number">4</span> &gt; debug_str_offsets.len) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L331">                        <span class="tok-kw">const</span> offset = mem.readInt(<span class="tok-type">u32</span>, debug_str_offsets[byte_offset..][<span class="tok-number">0</span>..<span class="tok-number">4</span>], di.endian);</span>
<span class="line" id="L332">                        <span class="tok-kw">return</span> getStringGeneric(opt_str, offset);</span>
<span class="line" id="L333">                    },</span>
<span class="line" id="L334">                    .@&quot;64&quot; =&gt; {</span>
<span class="line" id="L335">                        <span class="tok-kw">const</span> byte_offset = compile_unit.str_offsets_base + <span class="tok-number">8</span> * index;</span>
<span class="line" id="L336">                        <span class="tok-kw">if</span> (byte_offset + <span class="tok-number">8</span> &gt; debug_str_offsets.len) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L337">                        <span class="tok-kw">const</span> offset = mem.readInt(<span class="tok-type">u64</span>, debug_str_offsets[byte_offset..][<span class="tok-number">0</span>..<span class="tok-number">8</span>], di.endian);</span>
<span class="line" id="L338">                        <span class="tok-kw">return</span> getStringGeneric(opt_str, offset);</span>
<span class="line" id="L339">                    },</span>
<span class="line" id="L340">                }</span>
<span class="line" id="L341">            },</span>
<span class="line" id="L342">            .line_strp =&gt; |offset| <span class="tok-kw">return</span> di.getLineString(offset),</span>
<span class="line" id="L343">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> badDwarf(),</span>
<span class="line" id="L344">        }</span>
<span class="line" id="L345">    }</span>
<span class="line" id="L346">};</span>
<span class="line" id="L347"></span>
<span class="line" id="L348"><span class="tok-kw">const</span> FileEntry = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L349">    path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L350">    dir_index: <span class="tok-type">u32</span> = <span class="tok-number">0</span>,</span>
<span class="line" id="L351">    mtime: <span class="tok-type">u64</span> = <span class="tok-number">0</span>,</span>
<span class="line" id="L352">    size: <span class="tok-type">u64</span> = <span class="tok-number">0</span>,</span>
<span class="line" id="L353">    md5: [<span class="tok-number">16</span>]<span class="tok-type">u8</span> = [<span class="tok-number">1</span>]<span class="tok-type">u8</span>{<span class="tok-number">0</span>} ** <span class="tok-number">16</span>,</span>
<span class="line" id="L354">};</span>
<span class="line" id="L355"></span>
<span class="line" id="L356"><span class="tok-kw">const</span> LineNumberProgram = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L357">    address: <span class="tok-type">u64</span>,</span>
<span class="line" id="L358">    file: <span class="tok-type">usize</span>,</span>
<span class="line" id="L359">    line: <span class="tok-type">i64</span>,</span>
<span class="line" id="L360">    column: <span class="tok-type">u64</span>,</span>
<span class="line" id="L361">    version: <span class="tok-type">u16</span>,</span>
<span class="line" id="L362">    is_stmt: <span class="tok-type">bool</span>,</span>
<span class="line" id="L363">    basic_block: <span class="tok-type">bool</span>,</span>
<span class="line" id="L364">    end_sequence: <span class="tok-type">bool</span>,</span>
<span class="line" id="L365"></span>
<span class="line" id="L366">    default_is_stmt: <span class="tok-type">bool</span>,</span>
<span class="line" id="L367">    target_address: <span class="tok-type">u64</span>,</span>
<span class="line" id="L368">    include_dirs: []<span class="tok-kw">const</span> FileEntry,</span>
<span class="line" id="L369"></span>
<span class="line" id="L370">    prev_valid: <span class="tok-type">bool</span>,</span>
<span class="line" id="L371">    prev_address: <span class="tok-type">u64</span>,</span>
<span class="line" id="L372">    prev_file: <span class="tok-type">usize</span>,</span>
<span class="line" id="L373">    prev_line: <span class="tok-type">i64</span>,</span>
<span class="line" id="L374">    prev_column: <span class="tok-type">u64</span>,</span>
<span class="line" id="L375">    prev_is_stmt: <span class="tok-type">bool</span>,</span>
<span class="line" id="L376">    prev_basic_block: <span class="tok-type">bool</span>,</span>
<span class="line" id="L377">    prev_end_sequence: <span class="tok-type">bool</span>,</span>
<span class="line" id="L378"></span>
<span class="line" id="L379">    <span class="tok-comment">// Reset the state machine following the DWARF specification</span>
</span>
<span class="line" id="L380">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *LineNumberProgram) <span class="tok-type">void</span> {</span>
<span class="line" id="L381">        self.address = <span class="tok-number">0</span>;</span>
<span class="line" id="L382">        self.file = <span class="tok-number">1</span>;</span>
<span class="line" id="L383">        self.line = <span class="tok-number">1</span>;</span>
<span class="line" id="L384">        self.column = <span class="tok-number">0</span>;</span>
<span class="line" id="L385">        self.is_stmt = self.default_is_stmt;</span>
<span class="line" id="L386">        self.basic_block = <span class="tok-null">false</span>;</span>
<span class="line" id="L387">        self.end_sequence = <span class="tok-null">false</span>;</span>
<span class="line" id="L388">        <span class="tok-comment">// Invalidate all the remaining fields</span>
</span>
<span class="line" id="L389">        self.prev_valid = <span class="tok-null">false</span>;</span>
<span class="line" id="L390">        self.prev_address = <span class="tok-number">0</span>;</span>
<span class="line" id="L391">        self.prev_file = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L392">        self.prev_line = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L393">        self.prev_column = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L394">        self.prev_is_stmt = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L395">        self.prev_basic_block = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L396">        self.prev_end_sequence = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L397">    }</span>
<span class="line" id="L398"></span>
<span class="line" id="L399">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(</span>
<span class="line" id="L400">        is_stmt: <span class="tok-type">bool</span>,</span>
<span class="line" id="L401">        include_dirs: []<span class="tok-kw">const</span> FileEntry,</span>
<span class="line" id="L402">        target_address: <span class="tok-type">u64</span>,</span>
<span class="line" id="L403">        version: <span class="tok-type">u16</span>,</span>
<span class="line" id="L404">    ) LineNumberProgram {</span>
<span class="line" id="L405">        <span class="tok-kw">return</span> LineNumberProgram{</span>
<span class="line" id="L406">            .address = <span class="tok-number">0</span>,</span>
<span class="line" id="L407">            .file = <span class="tok-number">1</span>,</span>
<span class="line" id="L408">            .line = <span class="tok-number">1</span>,</span>
<span class="line" id="L409">            .column = <span class="tok-number">0</span>,</span>
<span class="line" id="L410">            .version = version,</span>
<span class="line" id="L411">            .is_stmt = is_stmt,</span>
<span class="line" id="L412">            .basic_block = <span class="tok-null">false</span>,</span>
<span class="line" id="L413">            .end_sequence = <span class="tok-null">false</span>,</span>
<span class="line" id="L414">            .include_dirs = include_dirs,</span>
<span class="line" id="L415">            .default_is_stmt = is_stmt,</span>
<span class="line" id="L416">            .target_address = target_address,</span>
<span class="line" id="L417">            .prev_valid = <span class="tok-null">false</span>,</span>
<span class="line" id="L418">            .prev_address = <span class="tok-number">0</span>,</span>
<span class="line" id="L419">            .prev_file = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L420">            .prev_line = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L421">            .prev_column = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L422">            .prev_is_stmt = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L423">            .prev_basic_block = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L424">            .prev_end_sequence = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L425">        };</span>
<span class="line" id="L426">    }</span>
<span class="line" id="L427"></span>
<span class="line" id="L428">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkLineMatch</span>(</span>
<span class="line" id="L429">        self: *LineNumberProgram,</span>
<span class="line" id="L430">        allocator: mem.Allocator,</span>
<span class="line" id="L431">        file_entries: []<span class="tok-kw">const</span> FileEntry,</span>
<span class="line" id="L432">    ) !?debug.LineInfo {</span>
<span class="line" id="L433">        <span class="tok-kw">if</span> (self.prev_valid <span class="tok-kw">and</span></span>
<span class="line" id="L434">            self.target_address &gt;= self.prev_address <span class="tok-kw">and</span></span>
<span class="line" id="L435">            self.target_address &lt; self.address)</span>
<span class="line" id="L436">        {</span>
<span class="line" id="L437">            <span class="tok-kw">const</span> file_index = <span class="tok-kw">if</span> (self.version &gt;= <span class="tok-number">5</span>) self.prev_file <span class="tok-kw">else</span> i: {</span>
<span class="line" id="L438">                <span class="tok-kw">if</span> (self.prev_file == <span class="tok-number">0</span>) <span class="tok-kw">return</span> missingDwarf();</span>
<span class="line" id="L439">                <span class="tok-kw">break</span> :i self.prev_file - <span class="tok-number">1</span>;</span>
<span class="line" id="L440">            };</span>
<span class="line" id="L441"></span>
<span class="line" id="L442">            <span class="tok-kw">if</span> (file_index &gt;= file_entries.len) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L443">            <span class="tok-kw">const</span> file_entry = &amp;file_entries[file_index];</span>
<span class="line" id="L444"></span>
<span class="line" id="L445">            <span class="tok-kw">if</span> (file_entry.dir_index &gt;= self.include_dirs.len) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L446">            <span class="tok-kw">const</span> dir_name = self.include_dirs[file_entry.dir_index].path;</span>
<span class="line" id="L447"></span>
<span class="line" id="L448">            <span class="tok-kw">const</span> file_name = <span class="tok-kw">try</span> std.fs.path.join(allocator, &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{</span>
<span class="line" id="L449">                dir_name, file_entry.path,</span>
<span class="line" id="L450">            });</span>
<span class="line" id="L451"></span>
<span class="line" id="L452">            <span class="tok-kw">return</span> debug.LineInfo{</span>
<span class="line" id="L453">                .line = <span class="tok-kw">if</span> (self.prev_line &gt;= <span class="tok-number">0</span>) <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-builtin">@intCast</span>(self.prev_line)) <span class="tok-kw">else</span> <span class="tok-number">0</span>,</span>
<span class="line" id="L454">                .column = self.prev_column,</span>
<span class="line" id="L455">                .file_name = file_name,</span>
<span class="line" id="L456">            };</span>
<span class="line" id="L457">        }</span>
<span class="line" id="L458"></span>
<span class="line" id="L459">        self.prev_valid = <span class="tok-null">true</span>;</span>
<span class="line" id="L460">        self.prev_address = self.address;</span>
<span class="line" id="L461">        self.prev_file = self.file;</span>
<span class="line" id="L462">        self.prev_line = self.line;</span>
<span class="line" id="L463">        self.prev_column = self.column;</span>
<span class="line" id="L464">        self.prev_is_stmt = self.is_stmt;</span>
<span class="line" id="L465">        self.prev_basic_block = self.basic_block;</span>
<span class="line" id="L466">        self.prev_end_sequence = self.end_sequence;</span>
<span class="line" id="L467">        <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L468">    }</span>
<span class="line" id="L469">};</span>
<span class="line" id="L470"></span>
<span class="line" id="L471"><span class="tok-kw">const</span> UnitHeader = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L472">    format: Format,</span>
<span class="line" id="L473">    header_length: <span class="tok-type">u4</span>,</span>
<span class="line" id="L474">    unit_length: <span class="tok-type">u64</span>,</span>
<span class="line" id="L475">};</span>
<span class="line" id="L476"><span class="tok-kw">fn</span> <span class="tok-fn">readUnitHeader</span>(fbr: *FixedBufferReader) !UnitHeader {</span>
<span class="line" id="L477">    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u32</span>)) {</span>
<span class="line" id="L478">        <span class="tok-number">0</span>...<span class="tok-number">0xfffffff0</span> - <span class="tok-number">1</span> =&gt; |unit_length| .{</span>
<span class="line" id="L479">            .format = .@&quot;32&quot;,</span>
<span class="line" id="L480">            .header_length = <span class="tok-number">4</span>,</span>
<span class="line" id="L481">            .unit_length = unit_length,</span>
<span class="line" id="L482">        },</span>
<span class="line" id="L483">        <span class="tok-number">0xfffffff0</span>...<span class="tok-number">0xffffffff</span> - <span class="tok-number">1</span> =&gt; badDwarf(),</span>
<span class="line" id="L484">        <span class="tok-number">0xffffffff</span> =&gt; .{</span>
<span class="line" id="L485">            .format = .@&quot;64&quot;,</span>
<span class="line" id="L486">            .header_length = <span class="tok-number">12</span>,</span>
<span class="line" id="L487">            .unit_length = <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u64</span>),</span>
<span class="line" id="L488">        },</span>
<span class="line" id="L489">    };</span>
<span class="line" id="L490">}</span>
<span class="line" id="L491"></span>
<span class="line" id="L492"><span class="tok-kw">fn</span> <span class="tok-fn">parseFormValue</span>(</span>
<span class="line" id="L493">    fbr: *FixedBufferReader,</span>
<span class="line" id="L494">    form_id: <span class="tok-type">u64</span>,</span>
<span class="line" id="L495">    format: Format,</span>
<span class="line" id="L496">    implicit_const: ?<span class="tok-type">i64</span>,</span>
<span class="line" id="L497">) <span class="tok-type">anyerror</span>!FormValue {</span>
<span class="line" id="L498">    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (form_id) {</span>
<span class="line" id="L499">        FORM.addr =&gt; .{ .addr = <span class="tok-kw">try</span> fbr.readAddress(<span class="tok-kw">switch</span> (<span class="tok-builtin">@bitSizeOf</span>(<span class="tok-type">usize</span>)) {</span>
<span class="line" id="L500">            <span class="tok-number">32</span> =&gt; .@&quot;32&quot;,</span>
<span class="line" id="L501">            <span class="tok-number">64</span> =&gt; .@&quot;64&quot;,</span>
<span class="line" id="L502">            <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;unsupported @sizeOf(usize)&quot;</span>),</span>
<span class="line" id="L503">        }) },</span>
<span class="line" id="L504">        FORM.addrx1 =&gt; .{ .addrx = <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u8</span>) },</span>
<span class="line" id="L505">        FORM.addrx2 =&gt; .{ .addrx = <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u16</span>) },</span>
<span class="line" id="L506">        FORM.addrx3 =&gt; .{ .addrx = <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u24</span>) },</span>
<span class="line" id="L507">        FORM.addrx4 =&gt; .{ .addrx = <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u32</span>) },</span>
<span class="line" id="L508">        FORM.addrx =&gt; .{ .addrx = <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">usize</span>) },</span>
<span class="line" id="L509"></span>
<span class="line" id="L510">        FORM.block1,</span>
<span class="line" id="L511">        FORM.block2,</span>
<span class="line" id="L512">        FORM.block4,</span>
<span class="line" id="L513">        FORM.block,</span>
<span class="line" id="L514">        =&gt; .{ .block = <span class="tok-kw">try</span> fbr.readBytes(<span class="tok-kw">switch</span> (form_id) {</span>
<span class="line" id="L515">            FORM.block1 =&gt; <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u8</span>),</span>
<span class="line" id="L516">            FORM.block2 =&gt; <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u16</span>),</span>
<span class="line" id="L517">            FORM.block4 =&gt; <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u32</span>),</span>
<span class="line" id="L518">            FORM.block =&gt; <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">usize</span>),</span>
<span class="line" id="L519">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L520">        }) },</span>
<span class="line" id="L521"></span>
<span class="line" id="L522">        FORM.data1 =&gt; .{ .udata = <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u8</span>) },</span>
<span class="line" id="L523">        FORM.data2 =&gt; .{ .udata = <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u16</span>) },</span>
<span class="line" id="L524">        FORM.data4 =&gt; .{ .udata = <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u32</span>) },</span>
<span class="line" id="L525">        FORM.data8 =&gt; .{ .udata = <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u64</span>) },</span>
<span class="line" id="L526">        FORM.data16 =&gt; .{ .data16 = (<span class="tok-kw">try</span> fbr.readBytes(<span class="tok-number">16</span>))[<span class="tok-number">0</span>..<span class="tok-number">16</span>] },</span>
<span class="line" id="L527">        FORM.udata =&gt; .{ .udata = <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">u64</span>) },</span>
<span class="line" id="L528">        FORM.sdata =&gt; .{ .sdata = <span class="tok-kw">try</span> fbr.readIleb128(<span class="tok-type">i64</span>) },</span>
<span class="line" id="L529">        FORM.exprloc =&gt; .{ .exprloc = <span class="tok-kw">try</span> fbr.readBytes(<span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">usize</span>)) },</span>
<span class="line" id="L530">        FORM.flag =&gt; .{ .flag = (<span class="tok-kw">try</span> fbr.readByte()) != <span class="tok-number">0</span> },</span>
<span class="line" id="L531">        FORM.flag_present =&gt; .{ .flag = <span class="tok-null">true</span> },</span>
<span class="line" id="L532">        FORM.sec_offset =&gt; .{ .sec_offset = <span class="tok-kw">try</span> fbr.readAddress(format) },</span>
<span class="line" id="L533"></span>
<span class="line" id="L534">        FORM.ref1 =&gt; .{ .ref = <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u8</span>) },</span>
<span class="line" id="L535">        FORM.ref2 =&gt; .{ .ref = <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u16</span>) },</span>
<span class="line" id="L536">        FORM.ref4 =&gt; .{ .ref = <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u32</span>) },</span>
<span class="line" id="L537">        FORM.ref8 =&gt; .{ .ref = <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u64</span>) },</span>
<span class="line" id="L538">        FORM.ref_udata =&gt; .{ .ref = <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">u64</span>) },</span>
<span class="line" id="L539"></span>
<span class="line" id="L540">        FORM.ref_addr =&gt; .{ .ref_addr = <span class="tok-kw">try</span> fbr.readAddress(format) },</span>
<span class="line" id="L541">        FORM.ref_sig8 =&gt; .{ .ref = <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u64</span>) },</span>
<span class="line" id="L542"></span>
<span class="line" id="L543">        FORM.string =&gt; .{ .string = <span class="tok-kw">try</span> fbr.readBytesTo(<span class="tok-number">0</span>) },</span>
<span class="line" id="L544">        FORM.strp =&gt; .{ .strp = <span class="tok-kw">try</span> fbr.readAddress(format) },</span>
<span class="line" id="L545">        FORM.strx1 =&gt; .{ .strx = <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u8</span>) },</span>
<span class="line" id="L546">        FORM.strx2 =&gt; .{ .strx = <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u16</span>) },</span>
<span class="line" id="L547">        FORM.strx3 =&gt; .{ .strx = <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u24</span>) },</span>
<span class="line" id="L548">        FORM.strx4 =&gt; .{ .strx = <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u32</span>) },</span>
<span class="line" id="L549">        FORM.strx =&gt; .{ .strx = <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">usize</span>) },</span>
<span class="line" id="L550">        FORM.line_strp =&gt; .{ .line_strp = <span class="tok-kw">try</span> fbr.readAddress(format) },</span>
<span class="line" id="L551">        FORM.indirect =&gt; parseFormValue(fbr, <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">u64</span>), format, implicit_const),</span>
<span class="line" id="L552">        FORM.implicit_const =&gt; .{ .sdata = implicit_const <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> badDwarf() },</span>
<span class="line" id="L553">        FORM.loclistx =&gt; .{ .loclistx = <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">u64</span>) },</span>
<span class="line" id="L554">        FORM.rnglistx =&gt; .{ .rnglistx = <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">u64</span>) },</span>
<span class="line" id="L555">        <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L556">            <span class="tok-comment">//debug.print(&quot;unrecognized form id: {x}\n&quot;, .{form_id});</span>
</span>
<span class="line" id="L557">            <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L558">        },</span>
<span class="line" id="L559">    };</span>
<span class="line" id="L560">}</span>
<span class="line" id="L561"></span>
<span class="line" id="L562"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> DwarfSection = <span class="tok-kw">enum</span> {</span>
<span class="line" id="L563">    debug_info,</span>
<span class="line" id="L564">    debug_abbrev,</span>
<span class="line" id="L565">    debug_str,</span>
<span class="line" id="L566">    debug_str_offsets,</span>
<span class="line" id="L567">    debug_line,</span>
<span class="line" id="L568">    debug_line_str,</span>
<span class="line" id="L569">    debug_ranges,</span>
<span class="line" id="L570">    debug_loclists,</span>
<span class="line" id="L571">    debug_rnglists,</span>
<span class="line" id="L572">    debug_addr,</span>
<span class="line" id="L573">    debug_names,</span>
<span class="line" id="L574">    debug_frame,</span>
<span class="line" id="L575">    eh_frame,</span>
<span class="line" id="L576">    eh_frame_hdr,</span>
<span class="line" id="L577">};</span>
<span class="line" id="L578"></span>
<span class="line" id="L579"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> DwarfInfo = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L580">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Section = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L581">        data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L582">        <span class="tok-comment">// Module-relative virtual address.</span>
</span>
<span class="line" id="L583">        <span class="tok-comment">// Only set if the section data was loaded from disk.</span>
</span>
<span class="line" id="L584">        virtual_address: ?<span class="tok-type">usize</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L585">        <span class="tok-comment">// If `data` is owned by this DwarfInfo.</span>
</span>
<span class="line" id="L586">        owned: <span class="tok-type">bool</span>,</span>
<span class="line" id="L587"></span>
<span class="line" id="L588">        <span class="tok-comment">// For sections that are not memory mapped by the loader, this is an offset</span>
</span>
<span class="line" id="L589">        <span class="tok-comment">// from `data.ptr` to where the section would have been mapped. Otherwise,</span>
</span>
<span class="line" id="L590">        <span class="tok-comment">// `data` is directly backed by the section and the offset is zero.</span>
</span>
<span class="line" id="L591">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">virtualOffset</span>(self: Section, base_address: <span class="tok-type">usize</span>) <span class="tok-type">i64</span> {</span>
<span class="line" id="L592">            <span class="tok-kw">return</span> <span class="tok-kw">if</span> (self.virtual_address) |va|</span>
<span class="line" id="L593">                <span class="tok-builtin">@as</span>(<span class="tok-type">i64</span>, <span class="tok-builtin">@intCast</span>(base_address + va)) -</span>
<span class="line" id="L594">                    <span class="tok-builtin">@as</span>(<span class="tok-type">i64</span>, <span class="tok-builtin">@intCast</span>(<span class="tok-builtin">@intFromPtr</span>(self.data.ptr)))</span>
<span class="line" id="L595">            <span class="tok-kw">else</span></span>
<span class="line" id="L596">                <span class="tok-number">0</span>;</span>
<span class="line" id="L597">        }</span>
<span class="line" id="L598">    };</span>
<span class="line" id="L599"></span>
<span class="line" id="L600">    <span class="tok-kw">const</span> num_sections = std.enums.directEnumArrayLen(DwarfSection, <span class="tok-number">0</span>);</span>
<span class="line" id="L601">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> SectionArray = [num_sections]?Section;</span>
<span class="line" id="L602">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> null_section_array = [_]?Section{<span class="tok-null">null</span>} ** num_sections;</span>
<span class="line" id="L603"></span>
<span class="line" id="L604">    endian: std.builtin.Endian,</span>
<span class="line" id="L605">    sections: SectionArray = null_section_array,</span>
<span class="line" id="L606">    is_macho: <span class="tok-type">bool</span>,</span>
<span class="line" id="L607"></span>
<span class="line" id="L608">    <span class="tok-comment">// Filled later by the initializer</span>
</span>
<span class="line" id="L609">    abbrev_table_list: std.ArrayListUnmanaged(Abbrev.Table) = .{},</span>
<span class="line" id="L610">    compile_unit_list: std.ArrayListUnmanaged(CompileUnit) = .{},</span>
<span class="line" id="L611">    func_list: std.ArrayListUnmanaged(Func) = .{},</span>
<span class="line" id="L612"></span>
<span class="line" id="L613">    eh_frame_hdr: ?ExceptionFrameHeader = <span class="tok-null">null</span>,</span>
<span class="line" id="L614">    <span class="tok-comment">// These lookup tables are only used if `eh_frame_hdr` is null</span>
</span>
<span class="line" id="L615">    cie_map: std.AutoArrayHashMapUnmanaged(<span class="tok-type">u64</span>, CommonInformationEntry) = .{},</span>
<span class="line" id="L616">    <span class="tok-comment">// Sorted by start_pc</span>
</span>
<span class="line" id="L617">    fde_list: std.ArrayListUnmanaged(FrameDescriptionEntry) = .{},</span>
<span class="line" id="L618"></span>
<span class="line" id="L619">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">section</span>(di: DwarfInfo, dwarf_section: DwarfSection) ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L620">        <span class="tok-kw">return</span> <span class="tok-kw">if</span> (di.sections[<span class="tok-builtin">@intFromEnum</span>(dwarf_section)]) |s| s.data <span class="tok-kw">else</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L621">    }</span>
<span class="line" id="L622"></span>
<span class="line" id="L623">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sectionVirtualOffset</span>(di: DwarfInfo, dwarf_section: DwarfSection, base_address: <span class="tok-type">usize</span>) ?<span class="tok-type">i64</span> {</span>
<span class="line" id="L624">        <span class="tok-kw">return</span> <span class="tok-kw">if</span> (di.sections[<span class="tok-builtin">@intFromEnum</span>(dwarf_section)]) |s| s.virtualOffset(base_address) <span class="tok-kw">else</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L625">    }</span>
<span class="line" id="L626"></span>
<span class="line" id="L627">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(di: *DwarfInfo, allocator: mem.Allocator) <span class="tok-type">void</span> {</span>
<span class="line" id="L628">        <span class="tok-kw">for</span> (di.sections) |opt_section| {</span>
<span class="line" id="L629">            <span class="tok-kw">if</span> (opt_section) |s| <span class="tok-kw">if</span> (s.owned) allocator.free(s.data);</span>
<span class="line" id="L630">        }</span>
<span class="line" id="L631">        <span class="tok-kw">for</span> (di.abbrev_table_list.items) |*abbrev| {</span>
<span class="line" id="L632">            abbrev.deinit(allocator);</span>
<span class="line" id="L633">        }</span>
<span class="line" id="L634">        di.abbrev_table_list.deinit(allocator);</span>
<span class="line" id="L635">        <span class="tok-kw">for</span> (di.compile_unit_list.items) |*cu| {</span>
<span class="line" id="L636">            cu.die.deinit(allocator);</span>
<span class="line" id="L637">        }</span>
<span class="line" id="L638">        di.compile_unit_list.deinit(allocator);</span>
<span class="line" id="L639">        di.func_list.deinit(allocator);</span>
<span class="line" id="L640">        di.cie_map.deinit(allocator);</span>
<span class="line" id="L641">        di.fde_list.deinit(allocator);</span>
<span class="line" id="L642">        di.* = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L643">    }</span>
<span class="line" id="L644"></span>
<span class="line" id="L645">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getSymbolName</span>(di: *DwarfInfo, address: <span class="tok-type">u64</span>) ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L646">        <span class="tok-kw">for</span> (di.func_list.items) |*func| {</span>
<span class="line" id="L647">            <span class="tok-kw">if</span> (func.pc_range) |range| {</span>
<span class="line" id="L648">                <span class="tok-kw">if</span> (address &gt;= range.start <span class="tok-kw">and</span> address &lt; range.end) {</span>
<span class="line" id="L649">                    <span class="tok-kw">return</span> func.name;</span>
<span class="line" id="L650">                }</span>
<span class="line" id="L651">            }</span>
<span class="line" id="L652">        }</span>
<span class="line" id="L653"></span>
<span class="line" id="L654">        <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L655">    }</span>
<span class="line" id="L656"></span>
<span class="line" id="L657">    <span class="tok-kw">fn</span> <span class="tok-fn">scanAllFunctions</span>(di: *DwarfInfo, allocator: mem.Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L658">        <span class="tok-kw">var</span> fbr: FixedBufferReader = .{ .buf = di.section(.debug_info).?, .endian = di.endian };</span>
<span class="line" id="L659">        <span class="tok-kw">var</span> this_unit_offset: <span class="tok-type">u64</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L660"></span>
<span class="line" id="L661">        <span class="tok-kw">while</span> (this_unit_offset &lt; fbr.buf.len) {</span>
<span class="line" id="L662">            <span class="tok-kw">try</span> fbr.seekTo(this_unit_offset);</span>
<span class="line" id="L663"></span>
<span class="line" id="L664">            <span class="tok-kw">const</span> unit_header = <span class="tok-kw">try</span> readUnitHeader(&amp;fbr);</span>
<span class="line" id="L665">            <span class="tok-kw">if</span> (unit_header.unit_length == <span class="tok-number">0</span>) <span class="tok-kw">return</span>;</span>
<span class="line" id="L666">            <span class="tok-kw">const</span> next_offset = unit_header.header_length + unit_header.unit_length;</span>
<span class="line" id="L667"></span>
<span class="line" id="L668">            <span class="tok-kw">const</span> version = <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u16</span>);</span>
<span class="line" id="L669">            <span class="tok-kw">if</span> (version &lt; <span class="tok-number">2</span> <span class="tok-kw">or</span> version &gt; <span class="tok-number">5</span>) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L670"></span>
<span class="line" id="L671">            <span class="tok-kw">var</span> address_size: <span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L672">            <span class="tok-kw">var</span> debug_abbrev_offset: <span class="tok-type">u64</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L673">            <span class="tok-kw">if</span> (version &gt;= <span class="tok-number">5</span>) {</span>
<span class="line" id="L674">                <span class="tok-kw">const</span> unit_type = <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u8</span>);</span>
<span class="line" id="L675">                <span class="tok-kw">if</span> (unit_type != UT.compile) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L676">                address_size = <span class="tok-kw">try</span> fbr.readByte();</span>
<span class="line" id="L677">                debug_abbrev_offset = <span class="tok-kw">try</span> fbr.readAddress(unit_header.format);</span>
<span class="line" id="L678">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L679">                debug_abbrev_offset = <span class="tok-kw">try</span> fbr.readAddress(unit_header.format);</span>
<span class="line" id="L680">                address_size = <span class="tok-kw">try</span> fbr.readByte();</span>
<span class="line" id="L681">            }</span>
<span class="line" id="L682">            <span class="tok-kw">if</span> (address_size != <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>)) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L683"></span>
<span class="line" id="L684">            <span class="tok-kw">const</span> abbrev_table = <span class="tok-kw">try</span> di.getAbbrevTable(allocator, debug_abbrev_offset);</span>
<span class="line" id="L685"></span>
<span class="line" id="L686">            <span class="tok-kw">var</span> max_attrs: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L687">            <span class="tok-kw">var</span> zig_padding_abbrev_code: <span class="tok-type">u7</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L688">            <span class="tok-kw">for</span> (abbrev_table.abbrevs) |abbrev| {</span>
<span class="line" id="L689">                max_attrs = <span class="tok-builtin">@max</span>(max_attrs, abbrev.attrs.len);</span>
<span class="line" id="L690">                <span class="tok-kw">if</span> (math.cast(<span class="tok-type">u7</span>, abbrev.code)) |code| {</span>
<span class="line" id="L691">                    <span class="tok-kw">if</span> (abbrev.tag_id == TAG.ZIG_padding <span class="tok-kw">and</span></span>
<span class="line" id="L692">                        !abbrev.has_children <span class="tok-kw">and</span></span>
<span class="line" id="L693">                        abbrev.attrs.len == <span class="tok-number">0</span>)</span>
<span class="line" id="L694">                    {</span>
<span class="line" id="L695">                        zig_padding_abbrev_code = code;</span>
<span class="line" id="L696">                    }</span>
<span class="line" id="L697">                }</span>
<span class="line" id="L698">            }</span>
<span class="line" id="L699">            <span class="tok-kw">const</span> attrs_buf = <span class="tok-kw">try</span> allocator.alloc(Die.Attr, max_attrs * <span class="tok-number">3</span>);</span>
<span class="line" id="L700">            <span class="tok-kw">defer</span> allocator.free(attrs_buf);</span>
<span class="line" id="L701">            <span class="tok-kw">var</span> attrs_bufs: [<span class="tok-number">3</span>][]Die.Attr = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L702">            <span class="tok-kw">for</span> (&amp;attrs_bufs, <span class="tok-number">0</span>..) |*buf, index| buf.* = attrs_buf[index * max_attrs ..][<span class="tok-number">0</span>..max_attrs];</span>
<span class="line" id="L703"></span>
<span class="line" id="L704">            <span class="tok-kw">const</span> next_unit_pos = this_unit_offset + next_offset;</span>
<span class="line" id="L705"></span>
<span class="line" id="L706">            <span class="tok-kw">var</span> compile_unit: CompileUnit = .{</span>
<span class="line" id="L707">                .version = version,</span>
<span class="line" id="L708">                .format = unit_header.format,</span>
<span class="line" id="L709">                .die = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L710">                .pc_range = <span class="tok-null">null</span>,</span>
<span class="line" id="L711"></span>
<span class="line" id="L712">                .str_offsets_base = <span class="tok-number">0</span>,</span>
<span class="line" id="L713">                .addr_base = <span class="tok-number">0</span>,</span>
<span class="line" id="L714">                .rnglists_base = <span class="tok-number">0</span>,</span>
<span class="line" id="L715">                .loclists_base = <span class="tok-number">0</span>,</span>
<span class="line" id="L716">                .frame_base = <span class="tok-null">null</span>,</span>
<span class="line" id="L717">            };</span>
<span class="line" id="L718"></span>
<span class="line" id="L719">            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L720">                fbr.pos = mem.indexOfNonePos(<span class="tok-type">u8</span>, fbr.buf, fbr.pos, &amp;.{</span>
<span class="line" id="L721">                    zig_padding_abbrev_code, <span class="tok-number">0</span>,</span>
<span class="line" id="L722">                }) <span class="tok-kw">orelse</span> fbr.buf.len;</span>
<span class="line" id="L723">                <span class="tok-kw">if</span> (fbr.pos &gt;= next_unit_pos) <span class="tok-kw">break</span>;</span>
<span class="line" id="L724">                <span class="tok-kw">var</span> die_obj = (<span class="tok-kw">try</span> parseDie(</span>
<span class="line" id="L725">                    &amp;fbr,</span>
<span class="line" id="L726">                    attrs_bufs[<span class="tok-number">0</span>],</span>
<span class="line" id="L727">                    abbrev_table,</span>
<span class="line" id="L728">                    unit_header.format,</span>
<span class="line" id="L729">                )) <span class="tok-kw">orelse</span> <span class="tok-kw">continue</span>;</span>
<span class="line" id="L730"></span>
<span class="line" id="L731">                <span class="tok-kw">switch</span> (die_obj.tag_id) {</span>
<span class="line" id="L732">                    TAG.compile_unit =&gt; {</span>
<span class="line" id="L733">                        compile_unit.die = die_obj;</span>
<span class="line" id="L734">                        compile_unit.die.attrs = attrs_bufs[<span class="tok-number">1</span>][<span class="tok-number">0</span>..die_obj.attrs.len];</span>
<span class="line" id="L735">                        <span class="tok-builtin">@memcpy</span>(compile_unit.die.attrs, die_obj.attrs);</span>
<span class="line" id="L736"></span>
<span class="line" id="L737">                        compile_unit.str_offsets_base = <span class="tok-kw">if</span> (die_obj.getAttr(AT.str_offsets_base)) |fv| <span class="tok-kw">try</span> fv.getUInt(<span class="tok-type">usize</span>) <span class="tok-kw">else</span> <span class="tok-number">0</span>;</span>
<span class="line" id="L738">                        compile_unit.addr_base = <span class="tok-kw">if</span> (die_obj.getAttr(AT.addr_base)) |fv| <span class="tok-kw">try</span> fv.getUInt(<span class="tok-type">usize</span>) <span class="tok-kw">else</span> <span class="tok-number">0</span>;</span>
<span class="line" id="L739">                        compile_unit.rnglists_base = <span class="tok-kw">if</span> (die_obj.getAttr(AT.rnglists_base)) |fv| <span class="tok-kw">try</span> fv.getUInt(<span class="tok-type">usize</span>) <span class="tok-kw">else</span> <span class="tok-number">0</span>;</span>
<span class="line" id="L740">                        compile_unit.loclists_base = <span class="tok-kw">if</span> (die_obj.getAttr(AT.loclists_base)) |fv| <span class="tok-kw">try</span> fv.getUInt(<span class="tok-type">usize</span>) <span class="tok-kw">else</span> <span class="tok-number">0</span>;</span>
<span class="line" id="L741">                        compile_unit.frame_base = die_obj.getAttr(AT.frame_base);</span>
<span class="line" id="L742">                    },</span>
<span class="line" id="L743">                    TAG.subprogram, TAG.inlined_subroutine, TAG.subroutine, TAG.entry_point =&gt; {</span>
<span class="line" id="L744">                        <span class="tok-kw">const</span> fn_name = x: {</span>
<span class="line" id="L745">                            <span class="tok-kw">var</span> this_die_obj = die_obj;</span>
<span class="line" id="L746">                            <span class="tok-comment">// Prevent endless loops</span>
</span>
<span class="line" id="L747">                            <span class="tok-kw">for</span> (<span class="tok-number">0</span>..<span class="tok-number">3</span>) |_| {</span>
<span class="line" id="L748">                                <span class="tok-kw">if</span> (this_die_obj.getAttr(AT.name)) |_| {</span>
<span class="line" id="L749">                                    <span class="tok-kw">break</span> :x <span class="tok-kw">try</span> this_die_obj.getAttrString(di, AT.name, di.section(.debug_str), compile_unit);</span>
<span class="line" id="L750">                                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (this_die_obj.getAttr(AT.abstract_origin)) |_| {</span>
<span class="line" id="L751">                                    <span class="tok-kw">const</span> after_die_offset = fbr.pos;</span>
<span class="line" id="L752">                                    <span class="tok-kw">defer</span> fbr.pos = after_die_offset;</span>
<span class="line" id="L753"></span>
<span class="line" id="L754">                                    <span class="tok-comment">// Follow the DIE it points to and repeat</span>
</span>
<span class="line" id="L755">                                    <span class="tok-kw">const</span> ref_offset = <span class="tok-kw">try</span> this_die_obj.getAttrRef(AT.abstract_origin);</span>
<span class="line" id="L756">                                    <span class="tok-kw">if</span> (ref_offset &gt; next_offset) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L757">                                    <span class="tok-kw">try</span> fbr.seekTo(this_unit_offset + ref_offset);</span>
<span class="line" id="L758">                                    this_die_obj = (<span class="tok-kw">try</span> parseDie(</span>
<span class="line" id="L759">                                        &amp;fbr,</span>
<span class="line" id="L760">                                        attrs_bufs[<span class="tok-number">2</span>],</span>
<span class="line" id="L761">                                        abbrev_table,</span>
<span class="line" id="L762">                                        unit_header.format,</span>
<span class="line" id="L763">                                    )) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L764">                                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (this_die_obj.getAttr(AT.specification)) |_| {</span>
<span class="line" id="L765">                                    <span class="tok-kw">const</span> after_die_offset = fbr.pos;</span>
<span class="line" id="L766">                                    <span class="tok-kw">defer</span> fbr.pos = after_die_offset;</span>
<span class="line" id="L767"></span>
<span class="line" id="L768">                                    <span class="tok-comment">// Follow the DIE it points to and repeat</span>
</span>
<span class="line" id="L769">                                    <span class="tok-kw">const</span> ref_offset = <span class="tok-kw">try</span> this_die_obj.getAttrRef(AT.specification);</span>
<span class="line" id="L770">                                    <span class="tok-kw">if</span> (ref_offset &gt; next_offset) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L771">                                    <span class="tok-kw">try</span> fbr.seekTo(this_unit_offset + ref_offset);</span>
<span class="line" id="L772">                                    this_die_obj = (<span class="tok-kw">try</span> parseDie(</span>
<span class="line" id="L773">                                        &amp;fbr,</span>
<span class="line" id="L774">                                        attrs_bufs[<span class="tok-number">2</span>],</span>
<span class="line" id="L775">                                        abbrev_table,</span>
<span class="line" id="L776">                                        unit_header.format,</span>
<span class="line" id="L777">                                    )) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L778">                                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L779">                                    <span class="tok-kw">break</span> :x <span class="tok-null">null</span>;</span>
<span class="line" id="L780">                                }</span>
<span class="line" id="L781">                            }</span>
<span class="line" id="L782"></span>
<span class="line" id="L783">                            <span class="tok-kw">break</span> :x <span class="tok-null">null</span>;</span>
<span class="line" id="L784">                        };</span>
<span class="line" id="L785"></span>
<span class="line" id="L786">                        <span class="tok-kw">var</span> range_added = <span class="tok-kw">if</span> (die_obj.getAttrAddr(di, AT.low_pc, compile_unit)) |low_pc| blk: {</span>
<span class="line" id="L787">                            <span class="tok-kw">if</span> (die_obj.getAttr(AT.high_pc)) |high_pc_value| {</span>
<span class="line" id="L788">                                <span class="tok-kw">const</span> pc_end = <span class="tok-kw">switch</span> (high_pc_value.*) {</span>
<span class="line" id="L789">                                    .addr =&gt; |value| value,</span>
<span class="line" id="L790">                                    .udata =&gt; |offset| low_pc + offset,</span>
<span class="line" id="L791">                                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> badDwarf(),</span>
<span class="line" id="L792">                                };</span>
<span class="line" id="L793"></span>
<span class="line" id="L794">                                <span class="tok-kw">try</span> di.func_list.append(allocator, .{</span>
<span class="line" id="L795">                                    .name = fn_name,</span>
<span class="line" id="L796">                                    .pc_range = .{</span>
<span class="line" id="L797">                                        .start = low_pc,</span>
<span class="line" id="L798">                                        .end = pc_end,</span>
<span class="line" id="L799">                                    },</span>
<span class="line" id="L800">                                });</span>
<span class="line" id="L801"></span>
<span class="line" id="L802">                                <span class="tok-kw">break</span> :blk <span class="tok-null">true</span>;</span>
<span class="line" id="L803">                            }</span>
<span class="line" id="L804"></span>
<span class="line" id="L805">                            <span class="tok-kw">break</span> :blk <span class="tok-null">false</span>;</span>
<span class="line" id="L806">                        } <span class="tok-kw">else</span> |err| blk: {</span>
<span class="line" id="L807">                            <span class="tok-kw">if</span> (err != <span class="tok-kw">error</span>.MissingDebugInfo) <span class="tok-kw">return</span> err;</span>
<span class="line" id="L808">                            <span class="tok-kw">break</span> :blk <span class="tok-null">false</span>;</span>
<span class="line" id="L809">                        };</span>
<span class="line" id="L810"></span>
<span class="line" id="L811">                        <span class="tok-kw">if</span> (die_obj.getAttr(AT.ranges)) |ranges_value| blk: {</span>
<span class="line" id="L812">                            <span class="tok-kw">var</span> iter = DebugRangeIterator.init(ranges_value, di, &amp;compile_unit) <span class="tok-kw">catch</span> |err| {</span>
<span class="line" id="L813">                                <span class="tok-kw">if</span> (err != <span class="tok-kw">error</span>.MissingDebugInfo) <span class="tok-kw">return</span> err;</span>
<span class="line" id="L814">                                <span class="tok-kw">break</span> :blk;</span>
<span class="line" id="L815">                            };</span>
<span class="line" id="L816"></span>
<span class="line" id="L817">                            <span class="tok-kw">while</span> (<span class="tok-kw">try</span> iter.next()) |range| {</span>
<span class="line" id="L818">                                range_added = <span class="tok-null">true</span>;</span>
<span class="line" id="L819">                                <span class="tok-kw">try</span> di.func_list.append(allocator, .{</span>
<span class="line" id="L820">                                    .name = fn_name,</span>
<span class="line" id="L821">                                    .pc_range = .{</span>
<span class="line" id="L822">                                        .start = range.start_addr,</span>
<span class="line" id="L823">                                        .end = range.end_addr,</span>
<span class="line" id="L824">                                    },</span>
<span class="line" id="L825">                                });</span>
<span class="line" id="L826">                            }</span>
<span class="line" id="L827">                        }</span>
<span class="line" id="L828"></span>
<span class="line" id="L829">                        <span class="tok-kw">if</span> (fn_name != <span class="tok-null">null</span> <span class="tok-kw">and</span> !range_added) {</span>
<span class="line" id="L830">                            <span class="tok-kw">try</span> di.func_list.append(allocator, .{</span>
<span class="line" id="L831">                                .name = fn_name,</span>
<span class="line" id="L832">                                .pc_range = <span class="tok-null">null</span>,</span>
<span class="line" id="L833">                            });</span>
<span class="line" id="L834">                        }</span>
<span class="line" id="L835">                    },</span>
<span class="line" id="L836">                    <span class="tok-kw">else</span> =&gt; {},</span>
<span class="line" id="L837">                }</span>
<span class="line" id="L838">            }</span>
<span class="line" id="L839"></span>
<span class="line" id="L840">            this_unit_offset += next_offset;</span>
<span class="line" id="L841">        }</span>
<span class="line" id="L842">    }</span>
<span class="line" id="L843"></span>
<span class="line" id="L844">    <span class="tok-kw">fn</span> <span class="tok-fn">scanAllCompileUnits</span>(di: *DwarfInfo, allocator: mem.Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L845">        <span class="tok-kw">var</span> fbr: FixedBufferReader = .{ .buf = di.section(.debug_info).?, .endian = di.endian };</span>
<span class="line" id="L846">        <span class="tok-kw">var</span> this_unit_offset: <span class="tok-type">u64</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L847"></span>
<span class="line" id="L848">        <span class="tok-kw">var</span> attrs_buf = std.ArrayList(Die.Attr).init(allocator);</span>
<span class="line" id="L849">        <span class="tok-kw">defer</span> attrs_buf.deinit();</span>
<span class="line" id="L850"></span>
<span class="line" id="L851">        <span class="tok-kw">while</span> (this_unit_offset &lt; fbr.buf.len) {</span>
<span class="line" id="L852">            <span class="tok-kw">try</span> fbr.seekTo(this_unit_offset);</span>
<span class="line" id="L853"></span>
<span class="line" id="L854">            <span class="tok-kw">const</span> unit_header = <span class="tok-kw">try</span> readUnitHeader(&amp;fbr);</span>
<span class="line" id="L855">            <span class="tok-kw">if</span> (unit_header.unit_length == <span class="tok-number">0</span>) <span class="tok-kw">return</span>;</span>
<span class="line" id="L856">            <span class="tok-kw">const</span> next_offset = unit_header.header_length + unit_header.unit_length;</span>
<span class="line" id="L857"></span>
<span class="line" id="L858">            <span class="tok-kw">const</span> version = <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u16</span>);</span>
<span class="line" id="L859">            <span class="tok-kw">if</span> (version &lt; <span class="tok-number">2</span> <span class="tok-kw">or</span> version &gt; <span class="tok-number">5</span>) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L860"></span>
<span class="line" id="L861">            <span class="tok-kw">var</span> address_size: <span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L862">            <span class="tok-kw">var</span> debug_abbrev_offset: <span class="tok-type">u64</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L863">            <span class="tok-kw">if</span> (version &gt;= <span class="tok-number">5</span>) {</span>
<span class="line" id="L864">                <span class="tok-kw">const</span> unit_type = <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u8</span>);</span>
<span class="line" id="L865">                <span class="tok-kw">if</span> (unit_type != UT.compile) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L866">                address_size = <span class="tok-kw">try</span> fbr.readByte();</span>
<span class="line" id="L867">                debug_abbrev_offset = <span class="tok-kw">try</span> fbr.readAddress(unit_header.format);</span>
<span class="line" id="L868">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L869">                debug_abbrev_offset = <span class="tok-kw">try</span> fbr.readAddress(unit_header.format);</span>
<span class="line" id="L870">                address_size = <span class="tok-kw">try</span> fbr.readByte();</span>
<span class="line" id="L871">            }</span>
<span class="line" id="L872">            <span class="tok-kw">if</span> (address_size != <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>)) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L873"></span>
<span class="line" id="L874">            <span class="tok-kw">const</span> abbrev_table = <span class="tok-kw">try</span> di.getAbbrevTable(allocator, debug_abbrev_offset);</span>
<span class="line" id="L875"></span>
<span class="line" id="L876">            <span class="tok-kw">var</span> max_attrs: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L877">            <span class="tok-kw">for</span> (abbrev_table.abbrevs) |abbrev| {</span>
<span class="line" id="L878">                max_attrs = <span class="tok-builtin">@max</span>(max_attrs, abbrev.attrs.len);</span>
<span class="line" id="L879">            }</span>
<span class="line" id="L880">            <span class="tok-kw">try</span> attrs_buf.resize(max_attrs);</span>
<span class="line" id="L881"></span>
<span class="line" id="L882">            <span class="tok-kw">var</span> compile_unit_die = (<span class="tok-kw">try</span> parseDie(</span>
<span class="line" id="L883">                &amp;fbr,</span>
<span class="line" id="L884">                attrs_buf.items,</span>
<span class="line" id="L885">                abbrev_table,</span>
<span class="line" id="L886">                unit_header.format,</span>
<span class="line" id="L887">            )) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L888"></span>
<span class="line" id="L889">            <span class="tok-kw">if</span> (compile_unit_die.tag_id != TAG.compile_unit) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L890"></span>
<span class="line" id="L891">            compile_unit_die.attrs = <span class="tok-kw">try</span> allocator.dupe(Die.Attr, compile_unit_die.attrs);</span>
<span class="line" id="L892"></span>
<span class="line" id="L893">            <span class="tok-kw">var</span> compile_unit: CompileUnit = .{</span>
<span class="line" id="L894">                .version = version,</span>
<span class="line" id="L895">                .format = unit_header.format,</span>
<span class="line" id="L896">                .pc_range = <span class="tok-null">null</span>,</span>
<span class="line" id="L897">                .die = compile_unit_die,</span>
<span class="line" id="L898">                .str_offsets_base = <span class="tok-kw">if</span> (compile_unit_die.getAttr(AT.str_offsets_base)) |fv| <span class="tok-kw">try</span> fv.getUInt(<span class="tok-type">usize</span>) <span class="tok-kw">else</span> <span class="tok-number">0</span>,</span>
<span class="line" id="L899">                .addr_base = <span class="tok-kw">if</span> (compile_unit_die.getAttr(AT.addr_base)) |fv| <span class="tok-kw">try</span> fv.getUInt(<span class="tok-type">usize</span>) <span class="tok-kw">else</span> <span class="tok-number">0</span>,</span>
<span class="line" id="L900">                .rnglists_base = <span class="tok-kw">if</span> (compile_unit_die.getAttr(AT.rnglists_base)) |fv| <span class="tok-kw">try</span> fv.getUInt(<span class="tok-type">usize</span>) <span class="tok-kw">else</span> <span class="tok-number">0</span>,</span>
<span class="line" id="L901">                .loclists_base = <span class="tok-kw">if</span> (compile_unit_die.getAttr(AT.loclists_base)) |fv| <span class="tok-kw">try</span> fv.getUInt(<span class="tok-type">usize</span>) <span class="tok-kw">else</span> <span class="tok-number">0</span>,</span>
<span class="line" id="L902">                .frame_base = compile_unit_die.getAttr(AT.frame_base),</span>
<span class="line" id="L903">            };</span>
<span class="line" id="L904"></span>
<span class="line" id="L905">            compile_unit.pc_range = x: {</span>
<span class="line" id="L906">                <span class="tok-kw">if</span> (compile_unit_die.getAttrAddr(di, AT.low_pc, compile_unit)) |low_pc| {</span>
<span class="line" id="L907">                    <span class="tok-kw">if</span> (compile_unit_die.getAttr(AT.high_pc)) |high_pc_value| {</span>
<span class="line" id="L908">                        <span class="tok-kw">const</span> pc_end = <span class="tok-kw">switch</span> (high_pc_value.*) {</span>
<span class="line" id="L909">                            .addr =&gt; |value| value,</span>
<span class="line" id="L910">                            .udata =&gt; |offset| low_pc + offset,</span>
<span class="line" id="L911">                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> badDwarf(),</span>
<span class="line" id="L912">                        };</span>
<span class="line" id="L913">                        <span class="tok-kw">break</span> :x PcRange{</span>
<span class="line" id="L914">                            .start = low_pc,</span>
<span class="line" id="L915">                            .end = pc_end,</span>
<span class="line" id="L916">                        };</span>
<span class="line" id="L917">                    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L918">                        <span class="tok-kw">break</span> :x <span class="tok-null">null</span>;</span>
<span class="line" id="L919">                    }</span>
<span class="line" id="L920">                } <span class="tok-kw">else</span> |err| {</span>
<span class="line" id="L921">                    <span class="tok-kw">if</span> (err != <span class="tok-kw">error</span>.MissingDebugInfo) <span class="tok-kw">return</span> err;</span>
<span class="line" id="L922">                    <span class="tok-kw">break</span> :x <span class="tok-null">null</span>;</span>
<span class="line" id="L923">                }</span>
<span class="line" id="L924">            };</span>
<span class="line" id="L925"></span>
<span class="line" id="L926">            <span class="tok-kw">try</span> di.compile_unit_list.append(allocator, compile_unit);</span>
<span class="line" id="L927"></span>
<span class="line" id="L928">            this_unit_offset += next_offset;</span>
<span class="line" id="L929">        }</span>
<span class="line" id="L930">    }</span>
<span class="line" id="L931"></span>
<span class="line" id="L932">    <span class="tok-kw">const</span> DebugRangeIterator = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L933">        base_address: <span class="tok-type">u64</span>,</span>
<span class="line" id="L934">        section_type: DwarfSection,</span>
<span class="line" id="L935">        di: *<span class="tok-kw">const</span> DwarfInfo,</span>
<span class="line" id="L936">        compile_unit: *<span class="tok-kw">const</span> CompileUnit,</span>
<span class="line" id="L937">        fbr: FixedBufferReader,</span>
<span class="line" id="L938"></span>
<span class="line" id="L939">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(ranges_value: *<span class="tok-kw">const</span> FormValue, di: *<span class="tok-kw">const</span> DwarfInfo, compile_unit: *<span class="tok-kw">const</span> CompileUnit) !<span class="tok-builtin">@This</span>() {</span>
<span class="line" id="L940">            <span class="tok-kw">const</span> section_type = <span class="tok-kw">if</span> (compile_unit.version &gt;= <span class="tok-number">5</span>) DwarfSection.debug_rnglists <span class="tok-kw">else</span> DwarfSection.debug_ranges;</span>
<span class="line" id="L941">            <span class="tok-kw">const</span> debug_ranges = di.section(section_type) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;</span>
<span class="line" id="L942"></span>
<span class="line" id="L943">            <span class="tok-kw">const</span> ranges_offset = <span class="tok-kw">switch</span> (ranges_value.*) {</span>
<span class="line" id="L944">                .sec_offset, .udata =&gt; |off| off,</span>
<span class="line" id="L945">                .rnglistx =&gt; |idx| off: {</span>
<span class="line" id="L946">                    <span class="tok-kw">switch</span> (compile_unit.format) {</span>
<span class="line" id="L947">                        .@&quot;32&quot; =&gt; {</span>
<span class="line" id="L948">                            <span class="tok-kw">const</span> offset_loc = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(compile_unit.rnglists_base + <span class="tok-number">4</span> * idx));</span>
<span class="line" id="L949">                            <span class="tok-kw">if</span> (offset_loc + <span class="tok-number">4</span> &gt; debug_ranges.len) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L950">                            <span class="tok-kw">const</span> offset = mem.readInt(<span class="tok-type">u32</span>, debug_ranges[offset_loc..][<span class="tok-number">0</span>..<span class="tok-number">4</span>], di.endian);</span>
<span class="line" id="L951">                            <span class="tok-kw">break</span> :off compile_unit.rnglists_base + offset;</span>
<span class="line" id="L952">                        },</span>
<span class="line" id="L953">                        .@&quot;64&quot; =&gt; {</span>
<span class="line" id="L954">                            <span class="tok-kw">const</span> offset_loc = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(compile_unit.rnglists_base + <span class="tok-number">8</span> * idx));</span>
<span class="line" id="L955">                            <span class="tok-kw">if</span> (offset_loc + <span class="tok-number">8</span> &gt; debug_ranges.len) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L956">                            <span class="tok-kw">const</span> offset = mem.readInt(<span class="tok-type">u64</span>, debug_ranges[offset_loc..][<span class="tok-number">0</span>..<span class="tok-number">8</span>], di.endian);</span>
<span class="line" id="L957">                            <span class="tok-kw">break</span> :off compile_unit.rnglists_base + offset;</span>
<span class="line" id="L958">                        },</span>
<span class="line" id="L959">                    }</span>
<span class="line" id="L960">                },</span>
<span class="line" id="L961">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> badDwarf(),</span>
<span class="line" id="L962">            };</span>
<span class="line" id="L963"></span>
<span class="line" id="L964">            <span class="tok-comment">// All the addresses in the list are relative to the value</span>
</span>
<span class="line" id="L965">            <span class="tok-comment">// specified by DW_AT.low_pc or to some other value encoded</span>
</span>
<span class="line" id="L966">            <span class="tok-comment">// in the list itself.</span>
</span>
<span class="line" id="L967">            <span class="tok-comment">// If no starting value is specified use zero.</span>
</span>
<span class="line" id="L968">            <span class="tok-kw">const</span> base_address = compile_unit.die.getAttrAddr(di, AT.low_pc, compile_unit.*) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L969">                <span class="tok-kw">error</span>.MissingDebugInfo =&gt; <span class="tok-number">0</span>,</span>
<span class="line" id="L970">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,</span>
<span class="line" id="L971">            };</span>
<span class="line" id="L972"></span>
<span class="line" id="L973">            <span class="tok-kw">return</span> .{</span>
<span class="line" id="L974">                .base_address = base_address,</span>
<span class="line" id="L975">                .section_type = section_type,</span>
<span class="line" id="L976">                .di = di,</span>
<span class="line" id="L977">                .compile_unit = compile_unit,</span>
<span class="line" id="L978">                .fbr = .{</span>
<span class="line" id="L979">                    .buf = debug_ranges,</span>
<span class="line" id="L980">                    .pos = math.cast(<span class="tok-type">usize</span>, ranges_offset) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> badDwarf(),</span>
<span class="line" id="L981">                    .endian = di.endian,</span>
<span class="line" id="L982">                },</span>
<span class="line" id="L983">            };</span>
<span class="line" id="L984">        }</span>
<span class="line" id="L985"></span>
<span class="line" id="L986">        <span class="tok-comment">// Returns the next range in the list, or null if the end was reached.</span>
</span>
<span class="line" id="L987">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<span class="tok-builtin">@This</span>()) !?<span class="tok-kw">struct</span> { start_addr: <span class="tok-type">u64</span>, end_addr: <span class="tok-type">u64</span> } {</span>
<span class="line" id="L988">            <span class="tok-kw">switch</span> (self.section_type) {</span>
<span class="line" id="L989">                .debug_rnglists =&gt; {</span>
<span class="line" id="L990">                    <span class="tok-kw">const</span> kind = <span class="tok-kw">try</span> self.fbr.readByte();</span>
<span class="line" id="L991">                    <span class="tok-kw">switch</span> (kind) {</span>
<span class="line" id="L992">                        RLE.end_of_list =&gt; <span class="tok-kw">return</span> <span class="tok-null">null</span>,</span>
<span class="line" id="L993">                        RLE.base_addressx =&gt; {</span>
<span class="line" id="L994">                            <span class="tok-kw">const</span> index = <span class="tok-kw">try</span> self.fbr.readUleb128(<span class="tok-type">usize</span>);</span>
<span class="line" id="L995">                            self.base_address = <span class="tok-kw">try</span> self.di.readDebugAddr(self.compile_unit.*, index);</span>
<span class="line" id="L996">                            <span class="tok-kw">return</span> <span class="tok-kw">try</span> self.next();</span>
<span class="line" id="L997">                        },</span>
<span class="line" id="L998">                        RLE.startx_endx =&gt; {</span>
<span class="line" id="L999">                            <span class="tok-kw">const</span> start_index = <span class="tok-kw">try</span> self.fbr.readUleb128(<span class="tok-type">usize</span>);</span>
<span class="line" id="L1000">                            <span class="tok-kw">const</span> start_addr = <span class="tok-kw">try</span> self.di.readDebugAddr(self.compile_unit.*, start_index);</span>
<span class="line" id="L1001"></span>
<span class="line" id="L1002">                            <span class="tok-kw">const</span> end_index = <span class="tok-kw">try</span> self.fbr.readUleb128(<span class="tok-type">usize</span>);</span>
<span class="line" id="L1003">                            <span class="tok-kw">const</span> end_addr = <span class="tok-kw">try</span> self.di.readDebugAddr(self.compile_unit.*, end_index);</span>
<span class="line" id="L1004"></span>
<span class="line" id="L1005">                            <span class="tok-kw">return</span> .{</span>
<span class="line" id="L1006">                                .start_addr = start_addr,</span>
<span class="line" id="L1007">                                .end_addr = end_addr,</span>
<span class="line" id="L1008">                            };</span>
<span class="line" id="L1009">                        },</span>
<span class="line" id="L1010">                        RLE.startx_length =&gt; {</span>
<span class="line" id="L1011">                            <span class="tok-kw">const</span> start_index = <span class="tok-kw">try</span> self.fbr.readUleb128(<span class="tok-type">usize</span>);</span>
<span class="line" id="L1012">                            <span class="tok-kw">const</span> start_addr = <span class="tok-kw">try</span> self.di.readDebugAddr(self.compile_unit.*, start_index);</span>
<span class="line" id="L1013"></span>
<span class="line" id="L1014">                            <span class="tok-kw">const</span> len = <span class="tok-kw">try</span> self.fbr.readUleb128(<span class="tok-type">usize</span>);</span>
<span class="line" id="L1015">                            <span class="tok-kw">const</span> end_addr = start_addr + len;</span>
<span class="line" id="L1016"></span>
<span class="line" id="L1017">                            <span class="tok-kw">return</span> .{</span>
<span class="line" id="L1018">                                .start_addr = start_addr,</span>
<span class="line" id="L1019">                                .end_addr = end_addr,</span>
<span class="line" id="L1020">                            };</span>
<span class="line" id="L1021">                        },</span>
<span class="line" id="L1022">                        RLE.offset_pair =&gt; {</span>
<span class="line" id="L1023">                            <span class="tok-kw">const</span> start_addr = <span class="tok-kw">try</span> self.fbr.readUleb128(<span class="tok-type">usize</span>);</span>
<span class="line" id="L1024">                            <span class="tok-kw">const</span> end_addr = <span class="tok-kw">try</span> self.fbr.readUleb128(<span class="tok-type">usize</span>);</span>
<span class="line" id="L1025"></span>
<span class="line" id="L1026">                            <span class="tok-comment">// This is the only kind that uses the base address</span>
</span>
<span class="line" id="L1027">                            <span class="tok-kw">return</span> .{</span>
<span class="line" id="L1028">                                .start_addr = self.base_address + start_addr,</span>
<span class="line" id="L1029">                                .end_addr = self.base_address + end_addr,</span>
<span class="line" id="L1030">                            };</span>
<span class="line" id="L1031">                        },</span>
<span class="line" id="L1032">                        RLE.base_address =&gt; {</span>
<span class="line" id="L1033">                            self.base_address = <span class="tok-kw">try</span> self.fbr.readInt(<span class="tok-type">usize</span>);</span>
<span class="line" id="L1034">                            <span class="tok-kw">return</span> <span class="tok-kw">try</span> self.next();</span>
<span class="line" id="L1035">                        },</span>
<span class="line" id="L1036">                        RLE.start_end =&gt; {</span>
<span class="line" id="L1037">                            <span class="tok-kw">const</span> start_addr = <span class="tok-kw">try</span> self.fbr.readInt(<span class="tok-type">usize</span>);</span>
<span class="line" id="L1038">                            <span class="tok-kw">const</span> end_addr = <span class="tok-kw">try</span> self.fbr.readInt(<span class="tok-type">usize</span>);</span>
<span class="line" id="L1039"></span>
<span class="line" id="L1040">                            <span class="tok-kw">return</span> .{</span>
<span class="line" id="L1041">                                .start_addr = start_addr,</span>
<span class="line" id="L1042">                                .end_addr = end_addr,</span>
<span class="line" id="L1043">                            };</span>
<span class="line" id="L1044">                        },</span>
<span class="line" id="L1045">                        RLE.start_length =&gt; {</span>
<span class="line" id="L1046">                            <span class="tok-kw">const</span> start_addr = <span class="tok-kw">try</span> self.fbr.readInt(<span class="tok-type">usize</span>);</span>
<span class="line" id="L1047">                            <span class="tok-kw">const</span> len = <span class="tok-kw">try</span> self.fbr.readUleb128(<span class="tok-type">usize</span>);</span>
<span class="line" id="L1048">                            <span class="tok-kw">const</span> end_addr = start_addr + len;</span>
<span class="line" id="L1049"></span>
<span class="line" id="L1050">                            <span class="tok-kw">return</span> .{</span>
<span class="line" id="L1051">                                .start_addr = start_addr,</span>
<span class="line" id="L1052">                                .end_addr = end_addr,</span>
<span class="line" id="L1053">                            };</span>
<span class="line" id="L1054">                        },</span>
<span class="line" id="L1055">                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> badDwarf(),</span>
<span class="line" id="L1056">                    }</span>
<span class="line" id="L1057">                },</span>
<span class="line" id="L1058">                .debug_ranges =&gt; {</span>
<span class="line" id="L1059">                    <span class="tok-kw">const</span> start_addr = <span class="tok-kw">try</span> self.fbr.readInt(<span class="tok-type">usize</span>);</span>
<span class="line" id="L1060">                    <span class="tok-kw">const</span> end_addr = <span class="tok-kw">try</span> self.fbr.readInt(<span class="tok-type">usize</span>);</span>
<span class="line" id="L1061">                    <span class="tok-kw">if</span> (start_addr == <span class="tok-number">0</span> <span class="tok-kw">and</span> end_addr == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L1062"></span>
<span class="line" id="L1063">                    <span class="tok-comment">// This entry selects a new value for the base address</span>
</span>
<span class="line" id="L1064">                    <span class="tok-kw">if</span> (start_addr == math.maxInt(<span class="tok-type">usize</span>)) {</span>
<span class="line" id="L1065">                        self.base_address = end_addr;</span>
<span class="line" id="L1066">                        <span class="tok-kw">return</span> <span class="tok-kw">try</span> self.next();</span>
<span class="line" id="L1067">                    }</span>
<span class="line" id="L1068"></span>
<span class="line" id="L1069">                    <span class="tok-kw">return</span> .{</span>
<span class="line" id="L1070">                        .start_addr = self.base_address + start_addr,</span>
<span class="line" id="L1071">                        .end_addr = self.base_address + end_addr,</span>
<span class="line" id="L1072">                    };</span>
<span class="line" id="L1073">                },</span>
<span class="line" id="L1074">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L1075">            }</span>
<span class="line" id="L1076">        }</span>
<span class="line" id="L1077">    };</span>
<span class="line" id="L1078"></span>
<span class="line" id="L1079">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">findCompileUnit</span>(di: *<span class="tok-kw">const</span> DwarfInfo, target_address: <span class="tok-type">u64</span>) !*<span class="tok-kw">const</span> CompileUnit {</span>
<span class="line" id="L1080">        <span class="tok-kw">for</span> (di.compile_unit_list.items) |*compile_unit| {</span>
<span class="line" id="L1081">            <span class="tok-kw">if</span> (compile_unit.pc_range) |range| {</span>
<span class="line" id="L1082">                <span class="tok-kw">if</span> (target_address &gt;= range.start <span class="tok-kw">and</span> target_address &lt; range.end) <span class="tok-kw">return</span> compile_unit;</span>
<span class="line" id="L1083">            }</span>
<span class="line" id="L1084"></span>
<span class="line" id="L1085">            <span class="tok-kw">const</span> ranges_value = compile_unit.die.getAttr(AT.ranges) <span class="tok-kw">orelse</span> <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1086">            <span class="tok-kw">var</span> iter = DebugRangeIterator.init(ranges_value, di, compile_unit) <span class="tok-kw">catch</span> <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1087">            <span class="tok-kw">while</span> (<span class="tok-kw">try</span> iter.next()) |range| {</span>
<span class="line" id="L1088">                <span class="tok-kw">if</span> (target_address &gt;= range.start_addr <span class="tok-kw">and</span> target_address &lt; range.end_addr) <span class="tok-kw">return</span> compile_unit;</span>
<span class="line" id="L1089">            }</span>
<span class="line" id="L1090">        }</span>
<span class="line" id="L1091"></span>
<span class="line" id="L1092">        <span class="tok-kw">return</span> missingDwarf();</span>
<span class="line" id="L1093">    }</span>
<span class="line" id="L1094"></span>
<span class="line" id="L1095">    <span class="tok-comment">/// Gets an already existing AbbrevTable given the abbrev_offset, or if not found,</span></span>
<span class="line" id="L1096">    <span class="tok-comment">/// seeks in the stream and parses it.</span></span>
<span class="line" id="L1097">    <span class="tok-kw">fn</span> <span class="tok-fn">getAbbrevTable</span>(di: *DwarfInfo, allocator: mem.Allocator, abbrev_offset: <span class="tok-type">u64</span>) !*<span class="tok-kw">const</span> Abbrev.Table {</span>
<span class="line" id="L1098">        <span class="tok-kw">for</span> (di.abbrev_table_list.items) |*table| {</span>
<span class="line" id="L1099">            <span class="tok-kw">if</span> (table.offset == abbrev_offset) {</span>
<span class="line" id="L1100">                <span class="tok-kw">return</span> table;</span>
<span class="line" id="L1101">            }</span>
<span class="line" id="L1102">        }</span>
<span class="line" id="L1103">        <span class="tok-kw">try</span> di.abbrev_table_list.append(</span>
<span class="line" id="L1104">            allocator,</span>
<span class="line" id="L1105">            <span class="tok-kw">try</span> di.parseAbbrevTable(allocator, abbrev_offset),</span>
<span class="line" id="L1106">        );</span>
<span class="line" id="L1107">        <span class="tok-kw">return</span> &amp;di.abbrev_table_list.items[di.abbrev_table_list.items.len - <span class="tok-number">1</span>];</span>
<span class="line" id="L1108">    }</span>
<span class="line" id="L1109"></span>
<span class="line" id="L1110">    <span class="tok-kw">fn</span> <span class="tok-fn">parseAbbrevTable</span>(di: *DwarfInfo, allocator: mem.Allocator, offset: <span class="tok-type">u64</span>) !Abbrev.Table {</span>
<span class="line" id="L1111">        <span class="tok-kw">var</span> fbr: FixedBufferReader = .{</span>
<span class="line" id="L1112">            .buf = di.section(.debug_abbrev).?,</span>
<span class="line" id="L1113">            .pos = math.cast(<span class="tok-type">usize</span>, offset) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> badDwarf(),</span>
<span class="line" id="L1114">            .endian = di.endian,</span>
<span class="line" id="L1115">        };</span>
<span class="line" id="L1116"></span>
<span class="line" id="L1117">        <span class="tok-kw">var</span> abbrevs = std.ArrayList(Abbrev).init(allocator);</span>
<span class="line" id="L1118">        <span class="tok-kw">defer</span> {</span>
<span class="line" id="L1119">            <span class="tok-kw">for</span> (abbrevs.items) |*abbrev| {</span>
<span class="line" id="L1120">                abbrev.deinit(allocator);</span>
<span class="line" id="L1121">            }</span>
<span class="line" id="L1122">            abbrevs.deinit();</span>
<span class="line" id="L1123">        }</span>
<span class="line" id="L1124"></span>
<span class="line" id="L1125">        <span class="tok-kw">var</span> attrs = std.ArrayList(Abbrev.Attr).init(allocator);</span>
<span class="line" id="L1126">        <span class="tok-kw">defer</span> attrs.deinit();</span>
<span class="line" id="L1127"></span>
<span class="line" id="L1128">        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L1129">            <span class="tok-kw">const</span> code = <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">u64</span>);</span>
<span class="line" id="L1130">            <span class="tok-kw">if</span> (code == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;</span>
<span class="line" id="L1131">            <span class="tok-kw">const</span> tag_id = <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">u64</span>);</span>
<span class="line" id="L1132">            <span class="tok-kw">const</span> has_children = (<span class="tok-kw">try</span> fbr.readByte()) == CHILDREN.yes;</span>
<span class="line" id="L1133"></span>
<span class="line" id="L1134">            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L1135">                <span class="tok-kw">const</span> attr_id = <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">u64</span>);</span>
<span class="line" id="L1136">                <span class="tok-kw">const</span> form_id = <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">u64</span>);</span>
<span class="line" id="L1137">                <span class="tok-kw">if</span> (attr_id == <span class="tok-number">0</span> <span class="tok-kw">and</span> form_id == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;</span>
<span class="line" id="L1138">                <span class="tok-kw">try</span> attrs.append(.{</span>
<span class="line" id="L1139">                    .id = attr_id,</span>
<span class="line" id="L1140">                    .form_id = form_id,</span>
<span class="line" id="L1141">                    .payload = <span class="tok-kw">switch</span> (form_id) {</span>
<span class="line" id="L1142">                        FORM.implicit_const =&gt; <span class="tok-kw">try</span> fbr.readIleb128(<span class="tok-type">i64</span>),</span>
<span class="line" id="L1143">                        <span class="tok-kw">else</span> =&gt; <span class="tok-null">undefined</span>,</span>
<span class="line" id="L1144">                    },</span>
<span class="line" id="L1145">                });</span>
<span class="line" id="L1146">            }</span>
<span class="line" id="L1147"></span>
<span class="line" id="L1148">            <span class="tok-kw">try</span> abbrevs.append(.{</span>
<span class="line" id="L1149">                .code = code,</span>
<span class="line" id="L1150">                .tag_id = tag_id,</span>
<span class="line" id="L1151">                .has_children = has_children,</span>
<span class="line" id="L1152">                .attrs = <span class="tok-kw">try</span> attrs.toOwnedSlice(),</span>
<span class="line" id="L1153">            });</span>
<span class="line" id="L1154">        }</span>
<span class="line" id="L1155"></span>
<span class="line" id="L1156">        <span class="tok-kw">return</span> .{</span>
<span class="line" id="L1157">            .offset = offset,</span>
<span class="line" id="L1158">            .abbrevs = <span class="tok-kw">try</span> abbrevs.toOwnedSlice(),</span>
<span class="line" id="L1159">        };</span>
<span class="line" id="L1160">    }</span>
<span class="line" id="L1161"></span>
<span class="line" id="L1162">    <span class="tok-kw">fn</span> <span class="tok-fn">parseDie</span>(</span>
<span class="line" id="L1163">        fbr: *FixedBufferReader,</span>
<span class="line" id="L1164">        attrs_buf: []Die.Attr,</span>
<span class="line" id="L1165">        abbrev_table: *<span class="tok-kw">const</span> Abbrev.Table,</span>
<span class="line" id="L1166">        format: Format,</span>
<span class="line" id="L1167">    ) !?Die {</span>
<span class="line" id="L1168">        <span class="tok-kw">const</span> abbrev_code = <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">u64</span>);</span>
<span class="line" id="L1169">        <span class="tok-kw">if</span> (abbrev_code == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L1170">        <span class="tok-kw">const</span> table_entry = abbrev_table.get(abbrev_code) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L1171"></span>
<span class="line" id="L1172">        <span class="tok-kw">const</span> attrs = attrs_buf[<span class="tok-number">0</span>..table_entry.attrs.len];</span>
<span class="line" id="L1173">        <span class="tok-kw">for</span> (attrs, table_entry.attrs) |*result_attr, attr| result_attr.* = Die.Attr{</span>
<span class="line" id="L1174">            .id = attr.id,</span>
<span class="line" id="L1175">            .value = <span class="tok-kw">try</span> parseFormValue(</span>
<span class="line" id="L1176">                fbr,</span>
<span class="line" id="L1177">                attr.form_id,</span>
<span class="line" id="L1178">                format,</span>
<span class="line" id="L1179">                attr.payload,</span>
<span class="line" id="L1180">            ),</span>
<span class="line" id="L1181">        };</span>
<span class="line" id="L1182">        <span class="tok-kw">return</span> .{</span>
<span class="line" id="L1183">            .tag_id = table_entry.tag_id,</span>
<span class="line" id="L1184">            .has_children = table_entry.has_children,</span>
<span class="line" id="L1185">            .attrs = attrs,</span>
<span class="line" id="L1186">        };</span>
<span class="line" id="L1187">    }</span>
<span class="line" id="L1188"></span>
<span class="line" id="L1189">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getLineNumberInfo</span>(</span>
<span class="line" id="L1190">        di: *DwarfInfo,</span>
<span class="line" id="L1191">        allocator: mem.Allocator,</span>
<span class="line" id="L1192">        compile_unit: CompileUnit,</span>
<span class="line" id="L1193">        target_address: <span class="tok-type">u64</span>,</span>
<span class="line" id="L1194">    ) !debug.LineInfo {</span>
<span class="line" id="L1195">        <span class="tok-kw">const</span> compile_unit_cwd = <span class="tok-kw">try</span> compile_unit.die.getAttrString(di, AT.comp_dir, di.section(.debug_line_str), compile_unit);</span>
<span class="line" id="L1196">        <span class="tok-kw">const</span> line_info_offset = <span class="tok-kw">try</span> compile_unit.die.getAttrSecOffset(AT.stmt_list);</span>
<span class="line" id="L1197"></span>
<span class="line" id="L1198">        <span class="tok-kw">var</span> fbr: FixedBufferReader = .{ .buf = di.section(.debug_line).?, .endian = di.endian };</span>
<span class="line" id="L1199">        <span class="tok-kw">try</span> fbr.seekTo(line_info_offset);</span>
<span class="line" id="L1200"></span>
<span class="line" id="L1201">        <span class="tok-kw">const</span> unit_header = <span class="tok-kw">try</span> readUnitHeader(&amp;fbr);</span>
<span class="line" id="L1202">        <span class="tok-kw">if</span> (unit_header.unit_length == <span class="tok-number">0</span>) <span class="tok-kw">return</span> missingDwarf();</span>
<span class="line" id="L1203">        <span class="tok-kw">const</span> next_offset = unit_header.header_length + unit_header.unit_length;</span>
<span class="line" id="L1204"></span>
<span class="line" id="L1205">        <span class="tok-kw">const</span> version = <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u16</span>);</span>
<span class="line" id="L1206">        <span class="tok-kw">if</span> (version &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L1207"></span>
<span class="line" id="L1208">        <span class="tok-kw">var</span> addr_size: <span class="tok-type">u8</span> = <span class="tok-kw">switch</span> (unit_header.format) {</span>
<span class="line" id="L1209">            .@&quot;32&quot; =&gt; <span class="tok-number">4</span>,</span>
<span class="line" id="L1210">            .@&quot;64&quot; =&gt; <span class="tok-number">8</span>,</span>
<span class="line" id="L1211">        };</span>
<span class="line" id="L1212">        <span class="tok-kw">var</span> seg_size: <span class="tok-type">u8</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1213">        <span class="tok-kw">if</span> (version &gt;= <span class="tok-number">5</span>) {</span>
<span class="line" id="L1214">            addr_size = <span class="tok-kw">try</span> fbr.readByte();</span>
<span class="line" id="L1215">            seg_size = <span class="tok-kw">try</span> fbr.readByte();</span>
<span class="line" id="L1216">        }</span>
<span class="line" id="L1217"></span>
<span class="line" id="L1218">        <span class="tok-kw">const</span> prologue_length = <span class="tok-kw">try</span> fbr.readAddress(unit_header.format);</span>
<span class="line" id="L1219">        <span class="tok-kw">const</span> prog_start_offset = fbr.pos + prologue_length;</span>
<span class="line" id="L1220"></span>
<span class="line" id="L1221">        <span class="tok-kw">const</span> minimum_instruction_length = <span class="tok-kw">try</span> fbr.readByte();</span>
<span class="line" id="L1222">        <span class="tok-kw">if</span> (minimum_instruction_length == <span class="tok-number">0</span>) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L1223"></span>
<span class="line" id="L1224">        <span class="tok-kw">if</span> (version &gt;= <span class="tok-number">4</span>) {</span>
<span class="line" id="L1225">            <span class="tok-comment">// maximum_operations_per_instruction</span>
</span>
<span class="line" id="L1226">            _ = <span class="tok-kw">try</span> fbr.readByte();</span>
<span class="line" id="L1227">        }</span>
<span class="line" id="L1228"></span>
<span class="line" id="L1229">        <span class="tok-kw">const</span> default_is_stmt = (<span class="tok-kw">try</span> fbr.readByte()) != <span class="tok-number">0</span>;</span>
<span class="line" id="L1230">        <span class="tok-kw">const</span> line_base = <span class="tok-kw">try</span> fbr.readByteSigned();</span>
<span class="line" id="L1231"></span>
<span class="line" id="L1232">        <span class="tok-kw">const</span> line_range = <span class="tok-kw">try</span> fbr.readByte();</span>
<span class="line" id="L1233">        <span class="tok-kw">if</span> (line_range == <span class="tok-number">0</span>) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L1234"></span>
<span class="line" id="L1235">        <span class="tok-kw">const</span> opcode_base = <span class="tok-kw">try</span> fbr.readByte();</span>
<span class="line" id="L1236"></span>
<span class="line" id="L1237">        <span class="tok-kw">const</span> standard_opcode_lengths = <span class="tok-kw">try</span> allocator.alloc(<span class="tok-type">u8</span>, opcode_base - <span class="tok-number">1</span>);</span>
<span class="line" id="L1238">        <span class="tok-kw">defer</span> allocator.free(standard_opcode_lengths);</span>
<span class="line" id="L1239"></span>
<span class="line" id="L1240">        {</span>
<span class="line" id="L1241">            <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1242">            <span class="tok-kw">while</span> (i &lt; opcode_base - <span class="tok-number">1</span>) : (i += <span class="tok-number">1</span>) {</span>
<span class="line" id="L1243">                standard_opcode_lengths[i] = <span class="tok-kw">try</span> fbr.readByte();</span>
<span class="line" id="L1244">            }</span>
<span class="line" id="L1245">        }</span>
<span class="line" id="L1246"></span>
<span class="line" id="L1247">        <span class="tok-kw">var</span> include_directories = std.ArrayList(FileEntry).init(allocator);</span>
<span class="line" id="L1248">        <span class="tok-kw">defer</span> include_directories.deinit();</span>
<span class="line" id="L1249">        <span class="tok-kw">var</span> file_entries = std.ArrayList(FileEntry).init(allocator);</span>
<span class="line" id="L1250">        <span class="tok-kw">defer</span> file_entries.deinit();</span>
<span class="line" id="L1251"></span>
<span class="line" id="L1252">        <span class="tok-kw">if</span> (version &lt; <span class="tok-number">5</span>) {</span>
<span class="line" id="L1253">            <span class="tok-kw">try</span> include_directories.append(.{ .path = compile_unit_cwd });</span>
<span class="line" id="L1254"></span>
<span class="line" id="L1255">            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L1256">                <span class="tok-kw">const</span> dir = <span class="tok-kw">try</span> fbr.readBytesTo(<span class="tok-number">0</span>);</span>
<span class="line" id="L1257">                <span class="tok-kw">if</span> (dir.len == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;</span>
<span class="line" id="L1258">                <span class="tok-kw">try</span> include_directories.append(.{ .path = dir });</span>
<span class="line" id="L1259">            }</span>
<span class="line" id="L1260"></span>
<span class="line" id="L1261">            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L1262">                <span class="tok-kw">const</span> file_name = <span class="tok-kw">try</span> fbr.readBytesTo(<span class="tok-number">0</span>);</span>
<span class="line" id="L1263">                <span class="tok-kw">if</span> (file_name.len == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;</span>
<span class="line" id="L1264">                <span class="tok-kw">const</span> dir_index = <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">u32</span>);</span>
<span class="line" id="L1265">                <span class="tok-kw">const</span> mtime = <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">u64</span>);</span>
<span class="line" id="L1266">                <span class="tok-kw">const</span> size = <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">u64</span>);</span>
<span class="line" id="L1267">                <span class="tok-kw">try</span> file_entries.append(.{</span>
<span class="line" id="L1268">                    .path = file_name,</span>
<span class="line" id="L1269">                    .dir_index = dir_index,</span>
<span class="line" id="L1270">                    .mtime = mtime,</span>
<span class="line" id="L1271">                    .size = size,</span>
<span class="line" id="L1272">                });</span>
<span class="line" id="L1273">            }</span>
<span class="line" id="L1274">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1275">            <span class="tok-kw">const</span> FileEntFmt = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1276">                content_type_code: <span class="tok-type">u8</span>,</span>
<span class="line" id="L1277">                form_code: <span class="tok-type">u16</span>,</span>
<span class="line" id="L1278">            };</span>
<span class="line" id="L1279">            {</span>
<span class="line" id="L1280">                <span class="tok-kw">var</span> dir_ent_fmt_buf: [<span class="tok-number">10</span>]FileEntFmt = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1281">                <span class="tok-kw">const</span> directory_entry_format_count = <span class="tok-kw">try</span> fbr.readByte();</span>
<span class="line" id="L1282">                <span class="tok-kw">if</span> (directory_entry_format_count &gt; dir_ent_fmt_buf.len) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L1283">                <span class="tok-kw">for</span> (dir_ent_fmt_buf[<span class="tok-number">0</span>..directory_entry_format_count]) |*ent_fmt| {</span>
<span class="line" id="L1284">                    ent_fmt.* = .{</span>
<span class="line" id="L1285">                        .content_type_code = <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">u8</span>),</span>
<span class="line" id="L1286">                        .form_code = <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">u16</span>),</span>
<span class="line" id="L1287">                    };</span>
<span class="line" id="L1288">                }</span>
<span class="line" id="L1289"></span>
<span class="line" id="L1290">                <span class="tok-kw">const</span> directories_count = <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">usize</span>);</span>
<span class="line" id="L1291">                <span class="tok-kw">try</span> include_directories.ensureUnusedCapacity(directories_count);</span>
<span class="line" id="L1292">                {</span>
<span class="line" id="L1293">                    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1294">                    <span class="tok-kw">while</span> (i &lt; directories_count) : (i += <span class="tok-number">1</span>) {</span>
<span class="line" id="L1295">                        <span class="tok-kw">var</span> e: FileEntry = .{ .path = &amp;.{} };</span>
<span class="line" id="L1296">                        <span class="tok-kw">for</span> (dir_ent_fmt_buf[<span class="tok-number">0</span>..directory_entry_format_count]) |ent_fmt| {</span>
<span class="line" id="L1297">                            <span class="tok-kw">const</span> form_value = <span class="tok-kw">try</span> parseFormValue(</span>
<span class="line" id="L1298">                                &amp;fbr,</span>
<span class="line" id="L1299">                                ent_fmt.form_code,</span>
<span class="line" id="L1300">                                unit_header.format,</span>
<span class="line" id="L1301">                                <span class="tok-null">null</span>,</span>
<span class="line" id="L1302">                            );</span>
<span class="line" id="L1303">                            <span class="tok-kw">switch</span> (ent_fmt.content_type_code) {</span>
<span class="line" id="L1304">                                LNCT.path =&gt; e.path = <span class="tok-kw">try</span> form_value.getString(di.*),</span>
<span class="line" id="L1305">                                LNCT.directory_index =&gt; e.dir_index = <span class="tok-kw">try</span> form_value.getUInt(<span class="tok-type">u32</span>),</span>
<span class="line" id="L1306">                                LNCT.timestamp =&gt; e.mtime = <span class="tok-kw">try</span> form_value.getUInt(<span class="tok-type">u64</span>),</span>
<span class="line" id="L1307">                                LNCT.size =&gt; e.size = <span class="tok-kw">try</span> form_value.getUInt(<span class="tok-type">u64</span>),</span>
<span class="line" id="L1308">                                LNCT.MD5 =&gt; e.md5 = <span class="tok-kw">switch</span> (form_value) {</span>
<span class="line" id="L1309">                                    .data16 =&gt; |data16| data16.*,</span>
<span class="line" id="L1310">                                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> badDwarf(),</span>
<span class="line" id="L1311">                                },</span>
<span class="line" id="L1312">                                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">continue</span>,</span>
<span class="line" id="L1313">                            }</span>
<span class="line" id="L1314">                        }</span>
<span class="line" id="L1315">                        include_directories.appendAssumeCapacity(e);</span>
<span class="line" id="L1316">                    }</span>
<span class="line" id="L1317">                }</span>
<span class="line" id="L1318">            }</span>
<span class="line" id="L1319"></span>
<span class="line" id="L1320">            <span class="tok-kw">var</span> file_ent_fmt_buf: [<span class="tok-number">10</span>]FileEntFmt = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1321">            <span class="tok-kw">const</span> file_name_entry_format_count = <span class="tok-kw">try</span> fbr.readByte();</span>
<span class="line" id="L1322">            <span class="tok-kw">if</span> (file_name_entry_format_count &gt; file_ent_fmt_buf.len) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L1323">            <span class="tok-kw">for</span> (file_ent_fmt_buf[<span class="tok-number">0</span>..file_name_entry_format_count]) |*ent_fmt| {</span>
<span class="line" id="L1324">                ent_fmt.* = .{</span>
<span class="line" id="L1325">                    .content_type_code = <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">u8</span>),</span>
<span class="line" id="L1326">                    .form_code = <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">u16</span>),</span>
<span class="line" id="L1327">                };</span>
<span class="line" id="L1328">            }</span>
<span class="line" id="L1329"></span>
<span class="line" id="L1330">            <span class="tok-kw">const</span> file_names_count = <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">usize</span>);</span>
<span class="line" id="L1331">            <span class="tok-kw">try</span> file_entries.ensureUnusedCapacity(file_names_count);</span>
<span class="line" id="L1332">            {</span>
<span class="line" id="L1333">                <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1334">                <span class="tok-kw">while</span> (i &lt; file_names_count) : (i += <span class="tok-number">1</span>) {</span>
<span class="line" id="L1335">                    <span class="tok-kw">var</span> e: FileEntry = .{ .path = &amp;.{} };</span>
<span class="line" id="L1336">                    <span class="tok-kw">for</span> (file_ent_fmt_buf[<span class="tok-number">0</span>..file_name_entry_format_count]) |ent_fmt| {</span>
<span class="line" id="L1337">                        <span class="tok-kw">const</span> form_value = <span class="tok-kw">try</span> parseFormValue(</span>
<span class="line" id="L1338">                            &amp;fbr,</span>
<span class="line" id="L1339">                            ent_fmt.form_code,</span>
<span class="line" id="L1340">                            unit_header.format,</span>
<span class="line" id="L1341">                            <span class="tok-null">null</span>,</span>
<span class="line" id="L1342">                        );</span>
<span class="line" id="L1343">                        <span class="tok-kw">switch</span> (ent_fmt.content_type_code) {</span>
<span class="line" id="L1344">                            LNCT.path =&gt; e.path = <span class="tok-kw">try</span> form_value.getString(di.*),</span>
<span class="line" id="L1345">                            LNCT.directory_index =&gt; e.dir_index = <span class="tok-kw">try</span> form_value.getUInt(<span class="tok-type">u32</span>),</span>
<span class="line" id="L1346">                            LNCT.timestamp =&gt; e.mtime = <span class="tok-kw">try</span> form_value.getUInt(<span class="tok-type">u64</span>),</span>
<span class="line" id="L1347">                            LNCT.size =&gt; e.size = <span class="tok-kw">try</span> form_value.getUInt(<span class="tok-type">u64</span>),</span>
<span class="line" id="L1348">                            LNCT.MD5 =&gt; e.md5 = <span class="tok-kw">switch</span> (form_value) {</span>
<span class="line" id="L1349">                                .data16 =&gt; |data16| data16.*,</span>
<span class="line" id="L1350">                                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> badDwarf(),</span>
<span class="line" id="L1351">                            },</span>
<span class="line" id="L1352">                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">continue</span>,</span>
<span class="line" id="L1353">                        }</span>
<span class="line" id="L1354">                    }</span>
<span class="line" id="L1355">                    file_entries.appendAssumeCapacity(e);</span>
<span class="line" id="L1356">                }</span>
<span class="line" id="L1357">            }</span>
<span class="line" id="L1358">        }</span>
<span class="line" id="L1359"></span>
<span class="line" id="L1360">        <span class="tok-kw">var</span> prog = LineNumberProgram.init(</span>
<span class="line" id="L1361">            default_is_stmt,</span>
<span class="line" id="L1362">            include_directories.items,</span>
<span class="line" id="L1363">            target_address,</span>
<span class="line" id="L1364">            version,</span>
<span class="line" id="L1365">        );</span>
<span class="line" id="L1366"></span>
<span class="line" id="L1367">        <span class="tok-kw">try</span> fbr.seekTo(prog_start_offset);</span>
<span class="line" id="L1368"></span>
<span class="line" id="L1369">        <span class="tok-kw">const</span> next_unit_pos = line_info_offset + next_offset;</span>
<span class="line" id="L1370"></span>
<span class="line" id="L1371">        <span class="tok-kw">while</span> (fbr.pos &lt; next_unit_pos) {</span>
<span class="line" id="L1372">            <span class="tok-kw">const</span> opcode = <span class="tok-kw">try</span> fbr.readByte();</span>
<span class="line" id="L1373"></span>
<span class="line" id="L1374">            <span class="tok-kw">if</span> (opcode == LNS.extended_op) {</span>
<span class="line" id="L1375">                <span class="tok-kw">const</span> op_size = <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">u64</span>);</span>
<span class="line" id="L1376">                <span class="tok-kw">if</span> (op_size &lt; <span class="tok-number">1</span>) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L1377">                <span class="tok-kw">const</span> sub_op = <span class="tok-kw">try</span> fbr.readByte();</span>
<span class="line" id="L1378">                <span class="tok-kw">switch</span> (sub_op) {</span>
<span class="line" id="L1379">                    LNE.end_sequence =&gt; {</span>
<span class="line" id="L1380">                        prog.end_sequence = <span class="tok-null">true</span>;</span>
<span class="line" id="L1381">                        <span class="tok-kw">if</span> (<span class="tok-kw">try</span> prog.checkLineMatch(allocator, file_entries.items)) |info| <span class="tok-kw">return</span> info;</span>
<span class="line" id="L1382">                        prog.reset();</span>
<span class="line" id="L1383">                    },</span>
<span class="line" id="L1384">                    LNE.set_address =&gt; {</span>
<span class="line" id="L1385">                        <span class="tok-kw">const</span> addr = <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">usize</span>);</span>
<span class="line" id="L1386">                        prog.address = addr;</span>
<span class="line" id="L1387">                    },</span>
<span class="line" id="L1388">                    LNE.define_file =&gt; {</span>
<span class="line" id="L1389">                        <span class="tok-kw">const</span> path = <span class="tok-kw">try</span> fbr.readBytesTo(<span class="tok-number">0</span>);</span>
<span class="line" id="L1390">                        <span class="tok-kw">const</span> dir_index = <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">u32</span>);</span>
<span class="line" id="L1391">                        <span class="tok-kw">const</span> mtime = <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">u64</span>);</span>
<span class="line" id="L1392">                        <span class="tok-kw">const</span> size = <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">u64</span>);</span>
<span class="line" id="L1393">                        <span class="tok-kw">try</span> file_entries.append(.{</span>
<span class="line" id="L1394">                            .path = path,</span>
<span class="line" id="L1395">                            .dir_index = dir_index,</span>
<span class="line" id="L1396">                            .mtime = mtime,</span>
<span class="line" id="L1397">                            .size = size,</span>
<span class="line" id="L1398">                        });</span>
<span class="line" id="L1399">                    },</span>
<span class="line" id="L1400">                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">try</span> fbr.seekForward(op_size - <span class="tok-number">1</span>),</span>
<span class="line" id="L1401">                }</span>
<span class="line" id="L1402">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (opcode &gt;= opcode_base) {</span>
<span class="line" id="L1403">                <span class="tok-comment">// special opcodes</span>
</span>
<span class="line" id="L1404">                <span class="tok-kw">const</span> adjusted_opcode = opcode - opcode_base;</span>
<span class="line" id="L1405">                <span class="tok-kw">const</span> inc_addr = minimum_instruction_length * (adjusted_opcode / line_range);</span>
<span class="line" id="L1406">                <span class="tok-kw">const</span> inc_line = <span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, line_base) + <span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, adjusted_opcode % line_range);</span>
<span class="line" id="L1407">                prog.line += inc_line;</span>
<span class="line" id="L1408">                prog.address += inc_addr;</span>
<span class="line" id="L1409">                <span class="tok-kw">if</span> (<span class="tok-kw">try</span> prog.checkLineMatch(allocator, file_entries.items)) |info| <span class="tok-kw">return</span> info;</span>
<span class="line" id="L1410">                prog.basic_block = <span class="tok-null">false</span>;</span>
<span class="line" id="L1411">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1412">                <span class="tok-kw">switch</span> (opcode) {</span>
<span class="line" id="L1413">                    LNS.copy =&gt; {</span>
<span class="line" id="L1414">                        <span class="tok-kw">if</span> (<span class="tok-kw">try</span> prog.checkLineMatch(allocator, file_entries.items)) |info| <span class="tok-kw">return</span> info;</span>
<span class="line" id="L1415">                        prog.basic_block = <span class="tok-null">false</span>;</span>
<span class="line" id="L1416">                    },</span>
<span class="line" id="L1417">                    LNS.advance_pc =&gt; {</span>
<span class="line" id="L1418">                        <span class="tok-kw">const</span> arg = <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">usize</span>);</span>
<span class="line" id="L1419">                        prog.address += arg * minimum_instruction_length;</span>
<span class="line" id="L1420">                    },</span>
<span class="line" id="L1421">                    LNS.advance_line =&gt; {</span>
<span class="line" id="L1422">                        <span class="tok-kw">const</span> arg = <span class="tok-kw">try</span> fbr.readIleb128(<span class="tok-type">i64</span>);</span>
<span class="line" id="L1423">                        prog.line += arg;</span>
<span class="line" id="L1424">                    },</span>
<span class="line" id="L1425">                    LNS.set_file =&gt; {</span>
<span class="line" id="L1426">                        <span class="tok-kw">const</span> arg = <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">usize</span>);</span>
<span class="line" id="L1427">                        prog.file = arg;</span>
<span class="line" id="L1428">                    },</span>
<span class="line" id="L1429">                    LNS.set_column =&gt; {</span>
<span class="line" id="L1430">                        <span class="tok-kw">const</span> arg = <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">u64</span>);</span>
<span class="line" id="L1431">                        prog.column = arg;</span>
<span class="line" id="L1432">                    },</span>
<span class="line" id="L1433">                    LNS.negate_stmt =&gt; {</span>
<span class="line" id="L1434">                        prog.is_stmt = !prog.is_stmt;</span>
<span class="line" id="L1435">                    },</span>
<span class="line" id="L1436">                    LNS.set_basic_block =&gt; {</span>
<span class="line" id="L1437">                        prog.basic_block = <span class="tok-null">true</span>;</span>
<span class="line" id="L1438">                    },</span>
<span class="line" id="L1439">                    LNS.const_add_pc =&gt; {</span>
<span class="line" id="L1440">                        <span class="tok-kw">const</span> inc_addr = minimum_instruction_length * ((<span class="tok-number">255</span> - opcode_base) / line_range);</span>
<span class="line" id="L1441">                        prog.address += inc_addr;</span>
<span class="line" id="L1442">                    },</span>
<span class="line" id="L1443">                    LNS.fixed_advance_pc =&gt; {</span>
<span class="line" id="L1444">                        <span class="tok-kw">const</span> arg = <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u16</span>);</span>
<span class="line" id="L1445">                        prog.address += arg;</span>
<span class="line" id="L1446">                    },</span>
<span class="line" id="L1447">                    LNS.set_prologue_end =&gt; {},</span>
<span class="line" id="L1448">                    <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L1449">                        <span class="tok-kw">if</span> (opcode - <span class="tok-number">1</span> &gt;= standard_opcode_lengths.len) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L1450">                        <span class="tok-kw">try</span> fbr.seekForward(standard_opcode_lengths[opcode - <span class="tok-number">1</span>]);</span>
<span class="line" id="L1451">                    },</span>
<span class="line" id="L1452">                }</span>
<span class="line" id="L1453">            }</span>
<span class="line" id="L1454">        }</span>
<span class="line" id="L1455"></span>
<span class="line" id="L1456">        <span class="tok-kw">return</span> missingDwarf();</span>
<span class="line" id="L1457">    }</span>
<span class="line" id="L1458"></span>
<span class="line" id="L1459">    <span class="tok-kw">fn</span> <span class="tok-fn">getString</span>(di: DwarfInfo, offset: <span class="tok-type">u64</span>) ![:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L1460">        <span class="tok-kw">return</span> getStringGeneric(di.section(.debug_str), offset);</span>
<span class="line" id="L1461">    }</span>
<span class="line" id="L1462"></span>
<span class="line" id="L1463">    <span class="tok-kw">fn</span> <span class="tok-fn">getLineString</span>(di: DwarfInfo, offset: <span class="tok-type">u64</span>) ![:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L1464">        <span class="tok-kw">return</span> getStringGeneric(di.section(.debug_line_str), offset);</span>
<span class="line" id="L1465">    }</span>
<span class="line" id="L1466"></span>
<span class="line" id="L1467">    <span class="tok-kw">fn</span> <span class="tok-fn">readDebugAddr</span>(di: DwarfInfo, compile_unit: CompileUnit, index: <span class="tok-type">u64</span>) !<span class="tok-type">u64</span> {</span>
<span class="line" id="L1468">        <span class="tok-kw">const</span> debug_addr = di.section(.debug_addr) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L1469"></span>
<span class="line" id="L1470">        <span class="tok-comment">// addr_base points to the first item after the header, however we</span>
</span>
<span class="line" id="L1471">        <span class="tok-comment">// need to read the header to know the size of each item. Empirically,</span>
</span>
<span class="line" id="L1472">        <span class="tok-comment">// it may disagree with is_64 on the compile unit.</span>
</span>
<span class="line" id="L1473">        <span class="tok-comment">// The header is 8 or 12 bytes depending on is_64.</span>
</span>
<span class="line" id="L1474">        <span class="tok-kw">if</span> (compile_unit.addr_base &lt; <span class="tok-number">8</span>) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L1475"></span>
<span class="line" id="L1476">        <span class="tok-kw">const</span> version = mem.readInt(<span class="tok-type">u16</span>, debug_addr[compile_unit.addr_base - <span class="tok-number">4</span> ..][<span class="tok-number">0</span>..<span class="tok-number">2</span>], di.endian);</span>
<span class="line" id="L1477">        <span class="tok-kw">if</span> (version != <span class="tok-number">5</span>) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L1478"></span>
<span class="line" id="L1479">        <span class="tok-kw">const</span> addr_size = debug_addr[compile_unit.addr_base - <span class="tok-number">2</span>];</span>
<span class="line" id="L1480">        <span class="tok-kw">const</span> seg_size = debug_addr[compile_unit.addr_base - <span class="tok-number">1</span>];</span>
<span class="line" id="L1481"></span>
<span class="line" id="L1482">        <span class="tok-kw">const</span> byte_offset = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(compile_unit.addr_base + (addr_size + seg_size) * index));</span>
<span class="line" id="L1483">        <span class="tok-kw">if</span> (byte_offset + addr_size &gt; debug_addr.len) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L1484">        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (addr_size) {</span>
<span class="line" id="L1485">            <span class="tok-number">1</span> =&gt; debug_addr[byte_offset],</span>
<span class="line" id="L1486">            <span class="tok-number">2</span> =&gt; mem.readInt(<span class="tok-type">u16</span>, debug_addr[byte_offset..][<span class="tok-number">0</span>..<span class="tok-number">2</span>], di.endian),</span>
<span class="line" id="L1487">            <span class="tok-number">4</span> =&gt; mem.readInt(<span class="tok-type">u32</span>, debug_addr[byte_offset..][<span class="tok-number">0</span>..<span class="tok-number">4</span>], di.endian),</span>
<span class="line" id="L1488">            <span class="tok-number">8</span> =&gt; mem.readInt(<span class="tok-type">u64</span>, debug_addr[byte_offset..][<span class="tok-number">0</span>..<span class="tok-number">8</span>], di.endian),</span>
<span class="line" id="L1489">            <span class="tok-kw">else</span> =&gt; badDwarf(),</span>
<span class="line" id="L1490">        };</span>
<span class="line" id="L1491">    }</span>
<span class="line" id="L1492"></span>
<span class="line" id="L1493">    <span class="tok-comment">/// If .eh_frame_hdr is present, then only the header needs to be parsed.</span></span>
<span class="line" id="L1494">    <span class="tok-comment">///</span></span>
<span class="line" id="L1495">    <span class="tok-comment">/// Otherwise, .eh_frame and .debug_frame are scanned and a sorted list</span></span>
<span class="line" id="L1496">    <span class="tok-comment">/// of FDEs is built for binary searching during unwinding.</span></span>
<span class="line" id="L1497">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">scanAllUnwindInfo</span>(di: *DwarfInfo, allocator: mem.Allocator, base_address: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1498">        <span class="tok-kw">if</span> (di.section(.eh_frame_hdr)) |eh_frame_hdr| blk: {</span>
<span class="line" id="L1499">            <span class="tok-kw">var</span> fbr: FixedBufferReader = .{ .buf = eh_frame_hdr, .endian = native_endian };</span>
<span class="line" id="L1500"></span>
<span class="line" id="L1501">            <span class="tok-kw">const</span> version = <span class="tok-kw">try</span> fbr.readByte();</span>
<span class="line" id="L1502">            <span class="tok-kw">if</span> (version != <span class="tok-number">1</span>) <span class="tok-kw">break</span> :blk;</span>
<span class="line" id="L1503"></span>
<span class="line" id="L1504">            <span class="tok-kw">const</span> eh_frame_ptr_enc = <span class="tok-kw">try</span> fbr.readByte();</span>
<span class="line" id="L1505">            <span class="tok-kw">if</span> (eh_frame_ptr_enc == EH.PE.omit) <span class="tok-kw">break</span> :blk;</span>
<span class="line" id="L1506">            <span class="tok-kw">const</span> fde_count_enc = <span class="tok-kw">try</span> fbr.readByte();</span>
<span class="line" id="L1507">            <span class="tok-kw">if</span> (fde_count_enc == EH.PE.omit) <span class="tok-kw">break</span> :blk;</span>
<span class="line" id="L1508">            <span class="tok-kw">const</span> table_enc = <span class="tok-kw">try</span> fbr.readByte();</span>
<span class="line" id="L1509">            <span class="tok-kw">if</span> (table_enc == EH.PE.omit) <span class="tok-kw">break</span> :blk;</span>
<span class="line" id="L1510"></span>
<span class="line" id="L1511">            <span class="tok-kw">const</span> eh_frame_ptr = math.cast(<span class="tok-type">usize</span>, <span class="tok-kw">try</span> readEhPointer(&amp;fbr, eh_frame_ptr_enc, <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>), .{</span>
<span class="line" id="L1512">                .pc_rel_base = <span class="tok-builtin">@intFromPtr</span>(&amp;eh_frame_hdr[fbr.pos]),</span>
<span class="line" id="L1513">                .follow_indirect = <span class="tok-null">true</span>,</span>
<span class="line" id="L1514">            }) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> badDwarf()) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L1515"></span>
<span class="line" id="L1516">            <span class="tok-kw">const</span> fde_count = math.cast(<span class="tok-type">usize</span>, <span class="tok-kw">try</span> readEhPointer(&amp;fbr, fde_count_enc, <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>), .{</span>
<span class="line" id="L1517">                .pc_rel_base = <span class="tok-builtin">@intFromPtr</span>(&amp;eh_frame_hdr[fbr.pos]),</span>
<span class="line" id="L1518">                .follow_indirect = <span class="tok-null">true</span>,</span>
<span class="line" id="L1519">            }) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> badDwarf()) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L1520"></span>
<span class="line" id="L1521">            <span class="tok-kw">const</span> entry_size = <span class="tok-kw">try</span> ExceptionFrameHeader.entrySize(table_enc);</span>
<span class="line" id="L1522">            <span class="tok-kw">const</span> entries_len = fde_count * entry_size;</span>
<span class="line" id="L1523">            <span class="tok-kw">if</span> (entries_len &gt; eh_frame_hdr.len - fbr.pos) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L1524"></span>
<span class="line" id="L1525">            di.eh_frame_hdr = .{</span>
<span class="line" id="L1526">                .eh_frame_ptr = eh_frame_ptr,</span>
<span class="line" id="L1527">                .table_enc = table_enc,</span>
<span class="line" id="L1528">                .fde_count = fde_count,</span>
<span class="line" id="L1529">                .entries = eh_frame_hdr[fbr.pos..][<span class="tok-number">0</span>..entries_len],</span>
<span class="line" id="L1530">            };</span>
<span class="line" id="L1531"></span>
<span class="line" id="L1532">            <span class="tok-comment">// No need to scan .eh_frame, we have a binary search table already</span>
</span>
<span class="line" id="L1533">            <span class="tok-kw">return</span>;</span>
<span class="line" id="L1534">        }</span>
<span class="line" id="L1535"></span>
<span class="line" id="L1536">        <span class="tok-kw">const</span> frame_sections = [<span class="tok-number">2</span>]DwarfSection{ .eh_frame, .debug_frame };</span>
<span class="line" id="L1537">        <span class="tok-kw">for</span> (frame_sections) |frame_section| {</span>
<span class="line" id="L1538">            <span class="tok-kw">if</span> (di.section(frame_section)) |section_data| {</span>
<span class="line" id="L1539">                <span class="tok-kw">var</span> fbr: FixedBufferReader = .{ .buf = section_data, .endian = di.endian };</span>
<span class="line" id="L1540">                <span class="tok-kw">while</span> (fbr.pos &lt; fbr.buf.len) {</span>
<span class="line" id="L1541">                    <span class="tok-kw">const</span> entry_header = <span class="tok-kw">try</span> EntryHeader.read(&amp;fbr, frame_section);</span>
<span class="line" id="L1542">                    <span class="tok-kw">switch</span> (entry_header.<span class="tok-type">type</span>) {</span>
<span class="line" id="L1543">                        .cie =&gt; {</span>
<span class="line" id="L1544">                            <span class="tok-kw">const</span> cie = <span class="tok-kw">try</span> CommonInformationEntry.parse(</span>
<span class="line" id="L1545">                                entry_header.entry_bytes,</span>
<span class="line" id="L1546">                                di.sectionVirtualOffset(frame_section, base_address).?,</span>
<span class="line" id="L1547">                                <span class="tok-null">true</span>,</span>
<span class="line" id="L1548">                                entry_header.format,</span>
<span class="line" id="L1549">                                frame_section,</span>
<span class="line" id="L1550">                                entry_header.length_offset,</span>
<span class="line" id="L1551">                                <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>),</span>
<span class="line" id="L1552">                                di.endian,</span>
<span class="line" id="L1553">                            );</span>
<span class="line" id="L1554">                            <span class="tok-kw">try</span> di.cie_map.put(allocator, entry_header.length_offset, cie);</span>
<span class="line" id="L1555">                        },</span>
<span class="line" id="L1556">                        .fde =&gt; |cie_offset| {</span>
<span class="line" id="L1557">                            <span class="tok-kw">const</span> cie = di.cie_map.get(cie_offset) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L1558">                            <span class="tok-kw">const</span> fde = <span class="tok-kw">try</span> FrameDescriptionEntry.parse(</span>
<span class="line" id="L1559">                                entry_header.entry_bytes,</span>
<span class="line" id="L1560">                                di.sectionVirtualOffset(frame_section, base_address).?,</span>
<span class="line" id="L1561">                                <span class="tok-null">true</span>,</span>
<span class="line" id="L1562">                                cie,</span>
<span class="line" id="L1563">                                <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>),</span>
<span class="line" id="L1564">                                di.endian,</span>
<span class="line" id="L1565">                            );</span>
<span class="line" id="L1566">                            <span class="tok-kw">try</span> di.fde_list.append(allocator, fde);</span>
<span class="line" id="L1567">                        },</span>
<span class="line" id="L1568">                        .terminator =&gt; <span class="tok-kw">break</span>,</span>
<span class="line" id="L1569">                    }</span>
<span class="line" id="L1570">                }</span>
<span class="line" id="L1571"></span>
<span class="line" id="L1572">                mem.sortUnstable(FrameDescriptionEntry, di.fde_list.items, {}, <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1573">                    <span class="tok-kw">fn</span> <span class="tok-fn">lessThan</span>(ctx: <span class="tok-type">void</span>, a: FrameDescriptionEntry, b: FrameDescriptionEntry) <span class="tok-type">bool</span> {</span>
<span class="line" id="L1574">                        _ = ctx;</span>
<span class="line" id="L1575">                        <span class="tok-kw">return</span> a.pc_begin &lt; b.pc_begin;</span>
<span class="line" id="L1576">                    }</span>
<span class="line" id="L1577">                }.lessThan);</span>
<span class="line" id="L1578">            }</span>
<span class="line" id="L1579">        }</span>
<span class="line" id="L1580">    }</span>
<span class="line" id="L1581"></span>
<span class="line" id="L1582">    <span class="tok-comment">/// Unwind a stack frame using DWARF unwinding info, updating the register context.</span></span>
<span class="line" id="L1583">    <span class="tok-comment">///</span></span>
<span class="line" id="L1584">    <span class="tok-comment">/// If `.eh_frame_hdr` is available, it will be used to binary search for the FDE.</span></span>
<span class="line" id="L1585">    <span class="tok-comment">/// Otherwise, a linear scan of `.eh_frame` and `.debug_frame` is done to find the FDE.</span></span>
<span class="line" id="L1586">    <span class="tok-comment">///</span></span>
<span class="line" id="L1587">    <span class="tok-comment">/// `explicit_fde_offset` is for cases where the FDE offset is known, such as when __unwind_info</span></span>
<span class="line" id="L1588">    <span class="tok-comment">/// defers unwinding to DWARF. This is an offset into the `.eh_frame` section.</span></span>
<span class="line" id="L1589">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unwindFrame</span>(di: *<span class="tok-kw">const</span> DwarfInfo, context: *UnwindContext, explicit_fde_offset: ?<span class="tok-type">usize</span>) !<span class="tok-type">usize</span> {</span>
<span class="line" id="L1590">        <span class="tok-kw">if</span> (!<span class="tok-kw">comptime</span> abi.supportsUnwinding(builtin.target)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnsupportedCpuArchitecture;</span>
<span class="line" id="L1591">        <span class="tok-kw">if</span> (context.pc == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-number">0</span>;</span>
<span class="line" id="L1592"></span>
<span class="line" id="L1593">        <span class="tok-comment">// Find the FDE and CIE</span>
</span>
<span class="line" id="L1594">        <span class="tok-kw">var</span> cie: CommonInformationEntry = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1595">        <span class="tok-kw">var</span> fde: FrameDescriptionEntry = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1596"></span>
<span class="line" id="L1597">        <span class="tok-kw">if</span> (explicit_fde_offset) |fde_offset| {</span>
<span class="line" id="L1598">            <span class="tok-kw">const</span> dwarf_section: DwarfSection = .eh_frame;</span>
<span class="line" id="L1599">            <span class="tok-kw">const</span> frame_section = di.section(dwarf_section) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingFDE;</span>
<span class="line" id="L1600">            <span class="tok-kw">if</span> (fde_offset &gt;= frame_section.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingFDE;</span>
<span class="line" id="L1601"></span>
<span class="line" id="L1602">            <span class="tok-kw">var</span> fbr: FixedBufferReader = .{</span>
<span class="line" id="L1603">                .buf = frame_section,</span>
<span class="line" id="L1604">                .pos = fde_offset,</span>
<span class="line" id="L1605">                .endian = di.endian,</span>
<span class="line" id="L1606">            };</span>
<span class="line" id="L1607"></span>
<span class="line" id="L1608">            <span class="tok-kw">const</span> fde_entry_header = <span class="tok-kw">try</span> EntryHeader.read(&amp;fbr, dwarf_section);</span>
<span class="line" id="L1609">            <span class="tok-kw">if</span> (fde_entry_header.<span class="tok-type">type</span> != .fde) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingFDE;</span>
<span class="line" id="L1610"></span>
<span class="line" id="L1611">            <span class="tok-kw">const</span> cie_offset = fde_entry_header.<span class="tok-type">type</span>.fde;</span>
<span class="line" id="L1612">            <span class="tok-kw">try</span> fbr.seekTo(cie_offset);</span>
<span class="line" id="L1613"></span>
<span class="line" id="L1614">            fbr.endian = native_endian;</span>
<span class="line" id="L1615">            <span class="tok-kw">const</span> cie_entry_header = <span class="tok-kw">try</span> EntryHeader.read(&amp;fbr, dwarf_section);</span>
<span class="line" id="L1616">            <span class="tok-kw">if</span> (cie_entry_header.<span class="tok-type">type</span> != .cie) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L1617"></span>
<span class="line" id="L1618">            cie = <span class="tok-kw">try</span> CommonInformationEntry.parse(</span>
<span class="line" id="L1619">                cie_entry_header.entry_bytes,</span>
<span class="line" id="L1620">                <span class="tok-number">0</span>,</span>
<span class="line" id="L1621">                <span class="tok-null">true</span>,</span>
<span class="line" id="L1622">                cie_entry_header.format,</span>
<span class="line" id="L1623">                dwarf_section,</span>
<span class="line" id="L1624">                cie_entry_header.length_offset,</span>
<span class="line" id="L1625">                <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>),</span>
<span class="line" id="L1626">                native_endian,</span>
<span class="line" id="L1627">            );</span>
<span class="line" id="L1628"></span>
<span class="line" id="L1629">            fde = <span class="tok-kw">try</span> FrameDescriptionEntry.parse(</span>
<span class="line" id="L1630">                fde_entry_header.entry_bytes,</span>
<span class="line" id="L1631">                <span class="tok-number">0</span>,</span>
<span class="line" id="L1632">                <span class="tok-null">true</span>,</span>
<span class="line" id="L1633">                cie,</span>
<span class="line" id="L1634">                <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>),</span>
<span class="line" id="L1635">                native_endian,</span>
<span class="line" id="L1636">            );</span>
<span class="line" id="L1637">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (di.eh_frame_hdr) |header| {</span>
<span class="line" id="L1638">            <span class="tok-kw">const</span> eh_frame_len = <span class="tok-kw">if</span> (di.section(.eh_frame)) |eh_frame| eh_frame.len <span class="tok-kw">else</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L1639">            <span class="tok-kw">try</span> header.findEntry(</span>
<span class="line" id="L1640">                context.isValidMemory,</span>
<span class="line" id="L1641">                eh_frame_len,</span>
<span class="line" id="L1642">                <span class="tok-builtin">@intFromPtr</span>(di.section(.eh_frame_hdr).?.ptr),</span>
<span class="line" id="L1643">                context.pc,</span>
<span class="line" id="L1644">                &amp;cie,</span>
<span class="line" id="L1645">                &amp;fde,</span>
<span class="line" id="L1646">            );</span>
<span class="line" id="L1647">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1648">            <span class="tok-kw">const</span> index = std.sort.binarySearch(FrameDescriptionEntry, context.pc, di.fde_list.items, {}, <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1649">                <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">compareFn</span>(_: <span class="tok-type">void</span>, pc: <span class="tok-type">usize</span>, mid_item: FrameDescriptionEntry) math.Order {</span>
<span class="line" id="L1650">                    <span class="tok-kw">if</span> (pc &lt; mid_item.pc_begin) <span class="tok-kw">return</span> .lt;</span>
<span class="line" id="L1651"></span>
<span class="line" id="L1652">                    <span class="tok-kw">const</span> range_end = mid_item.pc_begin + mid_item.pc_range;</span>
<span class="line" id="L1653">                    <span class="tok-kw">if</span> (pc &lt; range_end) <span class="tok-kw">return</span> .eq;</span>
<span class="line" id="L1654"></span>
<span class="line" id="L1655">                    <span class="tok-kw">return</span> .gt;</span>
<span class="line" id="L1656">                }</span>
<span class="line" id="L1657">            }.compareFn);</span>
<span class="line" id="L1658"></span>
<span class="line" id="L1659">            fde = <span class="tok-kw">if</span> (index) |i| di.fde_list.items[i] <span class="tok-kw">else</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingFDE;</span>
<span class="line" id="L1660">            cie = di.cie_map.get(fde.cie_length_offset) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingCIE;</span>
<span class="line" id="L1661">        }</span>
<span class="line" id="L1662"></span>
<span class="line" id="L1663">        <span class="tok-kw">var</span> expression_context: expressions.ExpressionContext = .{</span>
<span class="line" id="L1664">            .format = cie.format,</span>
<span class="line" id="L1665">            .isValidMemory = context.isValidMemory,</span>
<span class="line" id="L1666">            .compile_unit = di.findCompileUnit(fde.pc_begin) <span class="tok-kw">catch</span> <span class="tok-null">null</span>,</span>
<span class="line" id="L1667">            .thread_context = context.thread_context,</span>
<span class="line" id="L1668">            .reg_context = context.reg_context,</span>
<span class="line" id="L1669">            .cfa = context.cfa,</span>
<span class="line" id="L1670">        };</span>
<span class="line" id="L1671"></span>
<span class="line" id="L1672">        context.vm.reset();</span>
<span class="line" id="L1673">        context.reg_context.eh_frame = cie.version != <span class="tok-number">4</span>;</span>
<span class="line" id="L1674">        context.reg_context.is_macho = di.is_macho;</span>
<span class="line" id="L1675"></span>
<span class="line" id="L1676">        <span class="tok-kw">const</span> row = <span class="tok-kw">try</span> context.vm.runToNative(context.allocator, context.pc, cie, fde);</span>
<span class="line" id="L1677">        context.cfa = <span class="tok-kw">switch</span> (row.cfa.rule) {</span>
<span class="line" id="L1678">            .val_offset =&gt; |offset| blk: {</span>
<span class="line" id="L1679">                <span class="tok-kw">const</span> register = row.cfa.register <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCFARule;</span>
<span class="line" id="L1680">                <span class="tok-kw">const</span> value = mem.readInt(<span class="tok-type">usize</span>, (<span class="tok-kw">try</span> abi.regBytes(context.thread_context, register, context.reg_context))[<span class="tok-number">0</span>..<span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>)], native_endian);</span>
<span class="line" id="L1681">                <span class="tok-kw">break</span> :blk <span class="tok-kw">try</span> call_frame.applyOffset(value, offset);</span>
<span class="line" id="L1682">            },</span>
<span class="line" id="L1683">            .expression =&gt; |expression| blk: {</span>
<span class="line" id="L1684">                context.stack_machine.reset();</span>
<span class="line" id="L1685">                <span class="tok-kw">const</span> value = <span class="tok-kw">try</span> context.stack_machine.run(</span>
<span class="line" id="L1686">                    expression,</span>
<span class="line" id="L1687">                    context.allocator,</span>
<span class="line" id="L1688">                    expression_context,</span>
<span class="line" id="L1689">                    context.cfa,</span>
<span class="line" id="L1690">                );</span>
<span class="line" id="L1691"></span>
<span class="line" id="L1692">                <span class="tok-kw">if</span> (value) |v| {</span>
<span class="line" id="L1693">                    <span class="tok-kw">if</span> (v != .generic) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpressionValue;</span>
<span class="line" id="L1694">                    <span class="tok-kw">break</span> :blk v.generic;</span>
<span class="line" id="L1695">                } <span class="tok-kw">else</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoExpressionValue;</span>
<span class="line" id="L1696">            },</span>
<span class="line" id="L1697">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCFARule,</span>
<span class="line" id="L1698">        };</span>
<span class="line" id="L1699"></span>
<span class="line" id="L1700">        <span class="tok-kw">if</span> (!context.isValidMemory(context.cfa.?)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCFA;</span>
<span class="line" id="L1701">        expression_context.cfa = context.cfa;</span>
<span class="line" id="L1702"></span>
<span class="line" id="L1703">        <span class="tok-comment">// Buffering the modifications is done because copying the thread context is not portable,</span>
</span>
<span class="line" id="L1704">        <span class="tok-comment">// some implementations (ie. darwin) use internal pointers to the mcontext.</span>
</span>
<span class="line" id="L1705">        <span class="tok-kw">var</span> arena = std.heap.ArenaAllocator.init(context.allocator);</span>
<span class="line" id="L1706">        <span class="tok-kw">defer</span> arena.deinit();</span>
<span class="line" id="L1707">        <span class="tok-kw">const</span> update_allocator = arena.allocator();</span>
<span class="line" id="L1708"></span>
<span class="line" id="L1709">        <span class="tok-kw">const</span> RegisterUpdate = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1710">            <span class="tok-comment">// Backed by thread_context</span>
</span>
<span class="line" id="L1711">            dest: []<span class="tok-type">u8</span>,</span>
<span class="line" id="L1712">            <span class="tok-comment">// Backed by arena</span>
</span>
<span class="line" id="L1713">            src: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L1714">            prev: ?*<span class="tok-builtin">@This</span>(),</span>
<span class="line" id="L1715">        };</span>
<span class="line" id="L1716"></span>
<span class="line" id="L1717">        <span class="tok-kw">var</span> update_tail: ?*RegisterUpdate = <span class="tok-null">null</span>;</span>
<span class="line" id="L1718">        <span class="tok-kw">var</span> has_return_address = <span class="tok-null">true</span>;</span>
<span class="line" id="L1719">        <span class="tok-kw">for</span> (context.vm.rowColumns(row)) |column| {</span>
<span class="line" id="L1720">            <span class="tok-kw">if</span> (column.register) |register| {</span>
<span class="line" id="L1721">                <span class="tok-kw">if</span> (register == cie.return_address_register) {</span>
<span class="line" id="L1722">                    has_return_address = column.rule != .<span class="tok-null">undefined</span>;</span>
<span class="line" id="L1723">                }</span>
<span class="line" id="L1724"></span>
<span class="line" id="L1725">                <span class="tok-kw">const</span> dest = <span class="tok-kw">try</span> abi.regBytes(context.thread_context, register, context.reg_context);</span>
<span class="line" id="L1726">                <span class="tok-kw">const</span> src = <span class="tok-kw">try</span> update_allocator.alloc(<span class="tok-type">u8</span>, dest.len);</span>
<span class="line" id="L1727"></span>
<span class="line" id="L1728">                <span class="tok-kw">const</span> prev = update_tail;</span>
<span class="line" id="L1729">                update_tail = <span class="tok-kw">try</span> update_allocator.create(RegisterUpdate);</span>
<span class="line" id="L1730">                update_tail.?.* = .{</span>
<span class="line" id="L1731">                    .dest = dest,</span>
<span class="line" id="L1732">                    .src = src,</span>
<span class="line" id="L1733">                    .prev = prev,</span>
<span class="line" id="L1734">                };</span>
<span class="line" id="L1735"></span>
<span class="line" id="L1736">                <span class="tok-kw">try</span> column.resolveValue(</span>
<span class="line" id="L1737">                    context,</span>
<span class="line" id="L1738">                    expression_context,</span>
<span class="line" id="L1739">                    src,</span>
<span class="line" id="L1740">                );</span>
<span class="line" id="L1741">            }</span>
<span class="line" id="L1742">        }</span>
<span class="line" id="L1743"></span>
<span class="line" id="L1744">        <span class="tok-comment">// On all implemented architectures, the CFA is defined as being the previous frame's SP</span>
</span>
<span class="line" id="L1745">        (<span class="tok-kw">try</span> abi.regValueNative(<span class="tok-type">usize</span>, context.thread_context, abi.spRegNum(context.reg_context), context.reg_context)).* = context.cfa.?;</span>
<span class="line" id="L1746"></span>
<span class="line" id="L1747">        <span class="tok-kw">while</span> (update_tail) |tail| {</span>
<span class="line" id="L1748">            <span class="tok-builtin">@memcpy</span>(tail.dest, tail.src);</span>
<span class="line" id="L1749">            update_tail = tail.prev;</span>
<span class="line" id="L1750">        }</span>
<span class="line" id="L1751"></span>
<span class="line" id="L1752">        <span class="tok-kw">if</span> (has_return_address) {</span>
<span class="line" id="L1753">            context.pc = abi.stripInstructionPtrAuthCode(mem.readInt(<span class="tok-type">usize</span>, (<span class="tok-kw">try</span> abi.regBytes(</span>
<span class="line" id="L1754">                context.thread_context,</span>
<span class="line" id="L1755">                cie.return_address_register,</span>
<span class="line" id="L1756">                context.reg_context,</span>
<span class="line" id="L1757">            ))[<span class="tok-number">0</span>..<span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>)], native_endian));</span>
<span class="line" id="L1758">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1759">            context.pc = <span class="tok-number">0</span>;</span>
<span class="line" id="L1760">        }</span>
<span class="line" id="L1761"></span>
<span class="line" id="L1762">        (<span class="tok-kw">try</span> abi.regValueNative(<span class="tok-type">usize</span>, context.thread_context, abi.ipRegNum(), context.reg_context)).* = context.pc;</span>
<span class="line" id="L1763"></span>
<span class="line" id="L1764">        <span class="tok-comment">// The call instruction will have pushed the address of the instruction that follows the call as the return address.</span>
</span>
<span class="line" id="L1765">        <span class="tok-comment">// This next instruction may be past the end of the function if the caller was `noreturn` (ie. the last instruction in</span>
</span>
<span class="line" id="L1766">        <span class="tok-comment">// the function was the call). If we were to look up an FDE entry using the return address directly, it could end up</span>
</span>
<span class="line" id="L1767">        <span class="tok-comment">// either not finding an FDE at all, or using the next FDE in the program, producing incorrect results. To prevent this,</span>
</span>
<span class="line" id="L1768">        <span class="tok-comment">// we subtract one so that the next lookup is guaranteed to land inside the</span>
</span>
<span class="line" id="L1769">        <span class="tok-comment">//</span>
</span>
<span class="line" id="L1770">        <span class="tok-comment">// The exception to this rule is signal frames, where we return execution would be returned to the instruction</span>
</span>
<span class="line" id="L1771">        <span class="tok-comment">// that triggered the handler.</span>
</span>
<span class="line" id="L1772">        <span class="tok-kw">const</span> return_address = context.pc;</span>
<span class="line" id="L1773">        <span class="tok-kw">if</span> (context.pc &gt; <span class="tok-number">0</span> <span class="tok-kw">and</span> !cie.isSignalFrame()) context.pc -= <span class="tok-number">1</span>;</span>
<span class="line" id="L1774"></span>
<span class="line" id="L1775">        <span class="tok-kw">return</span> return_address;</span>
<span class="line" id="L1776">    }</span>
<span class="line" id="L1777">};</span>
<span class="line" id="L1778"></span>
<span class="line" id="L1779"><span class="tok-comment">/// Returns the DWARF register number for an x86_64 register number found in compact unwind info</span></span>
<span class="line" id="L1780"><span class="tok-kw">fn</span> <span class="tok-fn">compactUnwindToDwarfRegNumber</span>(unwind_reg_number: <span class="tok-type">u3</span>) !<span class="tok-type">u8</span> {</span>
<span class="line" id="L1781">    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (unwind_reg_number) {</span>
<span class="line" id="L1782">        <span class="tok-number">1</span> =&gt; <span class="tok-number">3</span>, <span class="tok-comment">// RBX</span>
</span>
<span class="line" id="L1783">        <span class="tok-number">2</span> =&gt; <span class="tok-number">12</span>, <span class="tok-comment">// R12</span>
</span>
<span class="line" id="L1784">        <span class="tok-number">3</span> =&gt; <span class="tok-number">13</span>, <span class="tok-comment">// R13</span>
</span>
<span class="line" id="L1785">        <span class="tok-number">4</span> =&gt; <span class="tok-number">14</span>, <span class="tok-comment">// R14</span>
</span>
<span class="line" id="L1786">        <span class="tok-number">5</span> =&gt; <span class="tok-number">15</span>, <span class="tok-comment">// R15</span>
</span>
<span class="line" id="L1787">        <span class="tok-number">6</span> =&gt; <span class="tok-number">6</span>, <span class="tok-comment">// RBP</span>
</span>
<span class="line" id="L1788">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">error</span>.InvalidUnwindRegisterNumber,</span>
<span class="line" id="L1789">    };</span>
<span class="line" id="L1790">}</span>
<span class="line" id="L1791"></span>
<span class="line" id="L1792"><span class="tok-kw">const</span> macho = std.macho;</span>
<span class="line" id="L1793"></span>
<span class="line" id="L1794"><span class="tok-comment">/// Unwind a frame using MachO compact unwind info (from __unwind_info).</span></span>
<span class="line" id="L1795"><span class="tok-comment">/// If the compact encoding can't encode a way to unwind a frame, it will</span></span>
<span class="line" id="L1796"><span class="tok-comment">/// defer unwinding to DWARF, in which case `.eh_frame` will be used if available.</span></span>
<span class="line" id="L1797"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unwindFrameMachO</span>(context: *UnwindContext, unwind_info: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, eh_frame: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, module_base_address: <span class="tok-type">usize</span>) !<span class="tok-type">usize</span> {</span>
<span class="line" id="L1798">    <span class="tok-kw">const</span> header = mem.bytesAsValue(</span>
<span class="line" id="L1799">        macho.unwind_info_section_header,</span>
<span class="line" id="L1800">        unwind_info[<span class="tok-number">0</span>..<span class="tok-builtin">@sizeOf</span>(macho.unwind_info_section_header)],</span>
<span class="line" id="L1801">    );</span>
<span class="line" id="L1802">    <span class="tok-kw">const</span> indices = mem.bytesAsSlice(</span>
<span class="line" id="L1803">        macho.unwind_info_section_header_index_entry,</span>
<span class="line" id="L1804">        unwind_info[header.indexSectionOffset..][<span class="tok-number">0</span> .. header.indexCount * <span class="tok-builtin">@sizeOf</span>(macho.unwind_info_section_header_index_entry)],</span>
<span class="line" id="L1805">    );</span>
<span class="line" id="L1806">    <span class="tok-kw">if</span> (indices.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingUnwindInfo;</span>
<span class="line" id="L1807"></span>
<span class="line" id="L1808">    <span class="tok-kw">const</span> mapped_pc = context.pc - module_base_address;</span>
<span class="line" id="L1809">    <span class="tok-kw">const</span> second_level_index = blk: {</span>
<span class="line" id="L1810">        <span class="tok-kw">var</span> left: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1811">        <span class="tok-kw">var</span> len: <span class="tok-type">usize</span> = indices.len;</span>
<span class="line" id="L1812"></span>
<span class="line" id="L1813">        <span class="tok-kw">while</span> (len &gt; <span class="tok-number">1</span>) {</span>
<span class="line" id="L1814">            <span class="tok-kw">const</span> mid = left + len / <span class="tok-number">2</span>;</span>
<span class="line" id="L1815">            <span class="tok-kw">const</span> offset = indices[mid].functionOffset;</span>
<span class="line" id="L1816">            <span class="tok-kw">if</span> (mapped_pc &lt; offset) {</span>
<span class="line" id="L1817">                len /= <span class="tok-number">2</span>;</span>
<span class="line" id="L1818">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1819">                left = mid;</span>
<span class="line" id="L1820">                <span class="tok-kw">if</span> (mapped_pc == offset) <span class="tok-kw">break</span>;</span>
<span class="line" id="L1821">                len -= len / <span class="tok-number">2</span>;</span>
<span class="line" id="L1822">            }</span>
<span class="line" id="L1823">        }</span>
<span class="line" id="L1824"></span>
<span class="line" id="L1825">        <span class="tok-comment">// Last index is a sentinel containing the highest address as its functionOffset</span>
</span>
<span class="line" id="L1826">        <span class="tok-kw">if</span> (indices[left].secondLevelPagesSectionOffset == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingUnwindInfo;</span>
<span class="line" id="L1827">        <span class="tok-kw">break</span> :blk &amp;indices[left];</span>
<span class="line" id="L1828">    };</span>
<span class="line" id="L1829"></span>
<span class="line" id="L1830">    <span class="tok-kw">const</span> common_encodings = mem.bytesAsSlice(</span>
<span class="line" id="L1831">        macho.compact_unwind_encoding_t,</span>
<span class="line" id="L1832">        unwind_info[header.commonEncodingsArraySectionOffset..][<span class="tok-number">0</span> .. header.commonEncodingsArrayCount * <span class="tok-builtin">@sizeOf</span>(macho.compact_unwind_encoding_t)],</span>
<span class="line" id="L1833">    );</span>
<span class="line" id="L1834"></span>
<span class="line" id="L1835">    <span class="tok-kw">const</span> start_offset = second_level_index.secondLevelPagesSectionOffset;</span>
<span class="line" id="L1836">    <span class="tok-kw">const</span> kind = mem.bytesAsValue(</span>
<span class="line" id="L1837">        macho.UNWIND_SECOND_LEVEL,</span>
<span class="line" id="L1838">        unwind_info[start_offset..][<span class="tok-number">0</span>..<span class="tok-builtin">@sizeOf</span>(macho.UNWIND_SECOND_LEVEL)],</span>
<span class="line" id="L1839">    );</span>
<span class="line" id="L1840"></span>
<span class="line" id="L1841">    <span class="tok-kw">const</span> entry: <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1842">        function_offset: <span class="tok-type">usize</span>,</span>
<span class="line" id="L1843">        raw_encoding: <span class="tok-type">u32</span>,</span>
<span class="line" id="L1844">    } = <span class="tok-kw">switch</span> (kind.*) {</span>
<span class="line" id="L1845">        .REGULAR =&gt; blk: {</span>
<span class="line" id="L1846">            <span class="tok-kw">const</span> page_header = mem.bytesAsValue(</span>
<span class="line" id="L1847">                macho.unwind_info_regular_second_level_page_header,</span>
<span class="line" id="L1848">                unwind_info[start_offset..][<span class="tok-number">0</span>..<span class="tok-builtin">@sizeOf</span>(macho.unwind_info_regular_second_level_page_header)],</span>
<span class="line" id="L1849">            );</span>
<span class="line" id="L1850"></span>
<span class="line" id="L1851">            <span class="tok-kw">const</span> entries = mem.bytesAsSlice(</span>
<span class="line" id="L1852">                macho.unwind_info_regular_second_level_entry,</span>
<span class="line" id="L1853">                unwind_info[start_offset + page_header.entryPageOffset ..][<span class="tok-number">0</span> .. page_header.entryCount * <span class="tok-builtin">@sizeOf</span>(macho.unwind_info_regular_second_level_entry)],</span>
<span class="line" id="L1854">            );</span>
<span class="line" id="L1855">            <span class="tok-kw">if</span> (entries.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUnwindInfo;</span>
<span class="line" id="L1856"></span>
<span class="line" id="L1857">            <span class="tok-kw">var</span> left: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1858">            <span class="tok-kw">var</span> len: <span class="tok-type">usize</span> = entries.len;</span>
<span class="line" id="L1859">            <span class="tok-kw">while</span> (len &gt; <span class="tok-number">1</span>) {</span>
<span class="line" id="L1860">                <span class="tok-kw">const</span> mid = left + len / <span class="tok-number">2</span>;</span>
<span class="line" id="L1861">                <span class="tok-kw">const</span> offset = entries[mid].functionOffset;</span>
<span class="line" id="L1862">                <span class="tok-kw">if</span> (mapped_pc &lt; offset) {</span>
<span class="line" id="L1863">                    len /= <span class="tok-number">2</span>;</span>
<span class="line" id="L1864">                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1865">                    left = mid;</span>
<span class="line" id="L1866">                    <span class="tok-kw">if</span> (mapped_pc == offset) <span class="tok-kw">break</span>;</span>
<span class="line" id="L1867">                    len -= len / <span class="tok-number">2</span>;</span>
<span class="line" id="L1868">                }</span>
<span class="line" id="L1869">            }</span>
<span class="line" id="L1870"></span>
<span class="line" id="L1871">            <span class="tok-kw">break</span> :blk .{</span>
<span class="line" id="L1872">                .function_offset = entries[left].functionOffset,</span>
<span class="line" id="L1873">                .raw_encoding = entries[left].encoding,</span>
<span class="line" id="L1874">            };</span>
<span class="line" id="L1875">        },</span>
<span class="line" id="L1876">        .COMPRESSED =&gt; blk: {</span>
<span class="line" id="L1877">            <span class="tok-kw">const</span> page_header = mem.bytesAsValue(</span>
<span class="line" id="L1878">                macho.unwind_info_compressed_second_level_page_header,</span>
<span class="line" id="L1879">                unwind_info[start_offset..][<span class="tok-number">0</span>..<span class="tok-builtin">@sizeOf</span>(macho.unwind_info_compressed_second_level_page_header)],</span>
<span class="line" id="L1880">            );</span>
<span class="line" id="L1881"></span>
<span class="line" id="L1882">            <span class="tok-kw">const</span> entries = mem.bytesAsSlice(</span>
<span class="line" id="L1883">                macho.UnwindInfoCompressedEntry,</span>
<span class="line" id="L1884">                unwind_info[start_offset + page_header.entryPageOffset ..][<span class="tok-number">0</span> .. page_header.entryCount * <span class="tok-builtin">@sizeOf</span>(macho.UnwindInfoCompressedEntry)],</span>
<span class="line" id="L1885">            );</span>
<span class="line" id="L1886">            <span class="tok-kw">if</span> (entries.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUnwindInfo;</span>
<span class="line" id="L1887"></span>
<span class="line" id="L1888">            <span class="tok-kw">var</span> left: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1889">            <span class="tok-kw">var</span> len: <span class="tok-type">usize</span> = entries.len;</span>
<span class="line" id="L1890">            <span class="tok-kw">while</span> (len &gt; <span class="tok-number">1</span>) {</span>
<span class="line" id="L1891">                <span class="tok-kw">const</span> mid = left + len / <span class="tok-number">2</span>;</span>
<span class="line" id="L1892">                <span class="tok-kw">const</span> offset = second_level_index.functionOffset + entries[mid].funcOffset;</span>
<span class="line" id="L1893">                <span class="tok-kw">if</span> (mapped_pc &lt; offset) {</span>
<span class="line" id="L1894">                    len /= <span class="tok-number">2</span>;</span>
<span class="line" id="L1895">                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1896">                    left = mid;</span>
<span class="line" id="L1897">                    <span class="tok-kw">if</span> (mapped_pc == offset) <span class="tok-kw">break</span>;</span>
<span class="line" id="L1898">                    len -= len / <span class="tok-number">2</span>;</span>
<span class="line" id="L1899">                }</span>
<span class="line" id="L1900">            }</span>
<span class="line" id="L1901"></span>
<span class="line" id="L1902">            <span class="tok-kw">const</span> entry = entries[left];</span>
<span class="line" id="L1903">            <span class="tok-kw">const</span> function_offset = second_level_index.functionOffset + entry.funcOffset;</span>
<span class="line" id="L1904">            <span class="tok-kw">if</span> (entry.encodingIndex &lt; header.commonEncodingsArrayCount) {</span>
<span class="line" id="L1905">                <span class="tok-kw">if</span> (entry.encodingIndex &gt;= common_encodings.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUnwindInfo;</span>
<span class="line" id="L1906">                <span class="tok-kw">break</span> :blk .{</span>
<span class="line" id="L1907">                    .function_offset = function_offset,</span>
<span class="line" id="L1908">                    .raw_encoding = common_encodings[entry.encodingIndex],</span>
<span class="line" id="L1909">                };</span>
<span class="line" id="L1910">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1911">                <span class="tok-kw">const</span> local_index = <span class="tok-kw">try</span> math.sub(</span>
<span class="line" id="L1912">                    <span class="tok-type">u8</span>,</span>
<span class="line" id="L1913">                    entry.encodingIndex,</span>
<span class="line" id="L1914">                    math.cast(<span class="tok-type">u8</span>, header.commonEncodingsArrayCount) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUnwindInfo,</span>
<span class="line" id="L1915">                );</span>
<span class="line" id="L1916">                <span class="tok-kw">const</span> local_encodings = mem.bytesAsSlice(</span>
<span class="line" id="L1917">                    macho.compact_unwind_encoding_t,</span>
<span class="line" id="L1918">                    unwind_info[start_offset + page_header.encodingsPageOffset ..][<span class="tok-number">0</span> .. page_header.encodingsCount * <span class="tok-builtin">@sizeOf</span>(macho.compact_unwind_encoding_t)],</span>
<span class="line" id="L1919">                );</span>
<span class="line" id="L1920">                <span class="tok-kw">if</span> (local_index &gt;= local_encodings.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUnwindInfo;</span>
<span class="line" id="L1921">                <span class="tok-kw">break</span> :blk .{</span>
<span class="line" id="L1922">                    .function_offset = function_offset,</span>
<span class="line" id="L1923">                    .raw_encoding = local_encodings[local_index],</span>
<span class="line" id="L1924">                };</span>
<span class="line" id="L1925">            }</span>
<span class="line" id="L1926">        },</span>
<span class="line" id="L1927">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUnwindInfo,</span>
<span class="line" id="L1928">    };</span>
<span class="line" id="L1929"></span>
<span class="line" id="L1930">    <span class="tok-kw">if</span> (entry.raw_encoding == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NoUnwindInfo;</span>
<span class="line" id="L1931">    <span class="tok-kw">const</span> reg_context = abi.RegisterContext{</span>
<span class="line" id="L1932">        .eh_frame = <span class="tok-null">false</span>,</span>
<span class="line" id="L1933">        .is_macho = <span class="tok-null">true</span>,</span>
<span class="line" id="L1934">    };</span>
<span class="line" id="L1935"></span>
<span class="line" id="L1936">    <span class="tok-kw">const</span> encoding: macho.CompactUnwindEncoding = <span class="tok-builtin">@bitCast</span>(entry.raw_encoding);</span>
<span class="line" id="L1937">    <span class="tok-kw">const</span> new_ip = <span class="tok-kw">switch</span> (builtin.cpu.arch) {</span>
<span class="line" id="L1938">        .x86_64 =&gt; <span class="tok-kw">switch</span> (encoding.mode.x86_64) {</span>
<span class="line" id="L1939">            .OLD =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnimplementedUnwindEncoding,</span>
<span class="line" id="L1940">            .RBP_FRAME =&gt; blk: {</span>
<span class="line" id="L1941">                <span class="tok-kw">const</span> regs: [<span class="tok-number">5</span>]<span class="tok-type">u3</span> = .{</span>
<span class="line" id="L1942">                    encoding.value.x86_64.frame.reg0,</span>
<span class="line" id="L1943">                    encoding.value.x86_64.frame.reg1,</span>
<span class="line" id="L1944">                    encoding.value.x86_64.frame.reg2,</span>
<span class="line" id="L1945">                    encoding.value.x86_64.frame.reg3,</span>
<span class="line" id="L1946">                    encoding.value.x86_64.frame.reg4,</span>
<span class="line" id="L1947">                };</span>
<span class="line" id="L1948"></span>
<span class="line" id="L1949">                <span class="tok-kw">const</span> frame_offset = encoding.value.x86_64.frame.frame_offset * <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>);</span>
<span class="line" id="L1950">                <span class="tok-kw">var</span> max_reg: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1951">                <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (regs, <span class="tok-number">0</span>..) |reg, i| {</span>
<span class="line" id="L1952">                    <span class="tok-kw">if</span> (reg &gt; <span class="tok-number">0</span>) max_reg = i;</span>
<span class="line" id="L1953">                }</span>
<span class="line" id="L1954"></span>
<span class="line" id="L1955">                <span class="tok-kw">const</span> fp = (<span class="tok-kw">try</span> abi.regValueNative(<span class="tok-type">usize</span>, context.thread_context, abi.fpRegNum(reg_context), reg_context)).*;</span>
<span class="line" id="L1956">                <span class="tok-kw">const</span> new_sp = fp + <span class="tok-number">2</span> * <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>);</span>
<span class="line" id="L1957"></span>
<span class="line" id="L1958">                <span class="tok-comment">// Verify the stack range we're about to read register values from</span>
</span>
<span class="line" id="L1959">                <span class="tok-kw">if</span> (!context.isValidMemory(new_sp) <span class="tok-kw">or</span> !context.isValidMemory(fp - frame_offset + max_reg * <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>))) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUnwindInfo;</span>
<span class="line" id="L1960"></span>
<span class="line" id="L1961">                <span class="tok-kw">const</span> ip_ptr = fp + <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>);</span>
<span class="line" id="L1962">                <span class="tok-kw">const</span> new_ip = <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">usize</span>, <span class="tok-builtin">@ptrFromInt</span>(ip_ptr)).*;</span>
<span class="line" id="L1963">                <span class="tok-kw">const</span> new_fp = <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">usize</span>, <span class="tok-builtin">@ptrFromInt</span>(fp)).*;</span>
<span class="line" id="L1964"></span>
<span class="line" id="L1965">                (<span class="tok-kw">try</span> abi.regValueNative(<span class="tok-type">usize</span>, context.thread_context, abi.fpRegNum(reg_context), reg_context)).* = new_fp;</span>
<span class="line" id="L1966">                (<span class="tok-kw">try</span> abi.regValueNative(<span class="tok-type">usize</span>, context.thread_context, abi.spRegNum(reg_context), reg_context)).* = new_sp;</span>
<span class="line" id="L1967">                (<span class="tok-kw">try</span> abi.regValueNative(<span class="tok-type">usize</span>, context.thread_context, abi.ipRegNum(), reg_context)).* = new_ip;</span>
<span class="line" id="L1968"></span>
<span class="line" id="L1969">                <span class="tok-kw">for</span> (regs, <span class="tok-number">0</span>..) |reg, i| {</span>
<span class="line" id="L1970">                    <span class="tok-kw">if</span> (reg == <span class="tok-number">0</span>) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1971">                    <span class="tok-kw">const</span> addr = fp - frame_offset + i * <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>);</span>
<span class="line" id="L1972">                    <span class="tok-kw">const</span> reg_number = <span class="tok-kw">try</span> compactUnwindToDwarfRegNumber(reg);</span>
<span class="line" id="L1973">                    (<span class="tok-kw">try</span> abi.regValueNative(<span class="tok-type">usize</span>, context.thread_context, reg_number, reg_context)).* = <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">usize</span>, <span class="tok-builtin">@ptrFromInt</span>(addr)).*;</span>
<span class="line" id="L1974">                }</span>
<span class="line" id="L1975"></span>
<span class="line" id="L1976">                <span class="tok-kw">break</span> :blk new_ip;</span>
<span class="line" id="L1977">            },</span>
<span class="line" id="L1978">            .STACK_IMMD,</span>
<span class="line" id="L1979">            .STACK_IND,</span>
<span class="line" id="L1980">            =&gt; blk: {</span>
<span class="line" id="L1981">                <span class="tok-kw">const</span> sp = (<span class="tok-kw">try</span> abi.regValueNative(<span class="tok-type">usize</span>, context.thread_context, abi.spRegNum(reg_context), reg_context)).*;</span>
<span class="line" id="L1982">                <span class="tok-kw">const</span> stack_size = <span class="tok-kw">if</span> (encoding.mode.x86_64 == .STACK_IMMD)</span>
<span class="line" id="L1983">                    <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, encoding.value.x86_64.frameless.stack.direct.stack_size) * <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>)</span>
<span class="line" id="L1984">                <span class="tok-kw">else</span> stack_size: {</span>
<span class="line" id="L1985">                    <span class="tok-comment">// In .STACK_IND, the stack size is inferred from the subq instruction at the beginning of the function.</span>
</span>
<span class="line" id="L1986">                    <span class="tok-kw">const</span> sub_offset_addr =</span>
<span class="line" id="L1987">                        module_base_address +</span>
<span class="line" id="L1988">                        entry.function_offset +</span>
<span class="line" id="L1989">                        encoding.value.x86_64.frameless.stack.indirect.sub_offset;</span>
<span class="line" id="L1990">                    <span class="tok-kw">if</span> (!context.isValidMemory(sub_offset_addr)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUnwindInfo;</span>
<span class="line" id="L1991"></span>
<span class="line" id="L1992">                    <span class="tok-comment">// `sub_offset_addr` points to the offset of the literal within the instruction</span>
</span>
<span class="line" id="L1993">                    <span class="tok-kw">const</span> sub_operand = <span class="tok-builtin">@as</span>(*<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> <span class="tok-type">u32</span>, <span class="tok-builtin">@ptrFromInt</span>(sub_offset_addr)).*;</span>
<span class="line" id="L1994">                    <span class="tok-kw">break</span> :stack_size sub_operand + <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>) * <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, encoding.value.x86_64.frameless.stack.indirect.stack_adjust);</span>
<span class="line" id="L1995">                };</span>
<span class="line" id="L1996"></span>
<span class="line" id="L1997">                <span class="tok-comment">// Decode the Lehmer-coded sequence of registers.</span>
</span>
<span class="line" id="L1998">                <span class="tok-comment">// For a description of the encoding see lib/libc/include/any-macos.13-any/mach-o/compact_unwind_encoding.h</span>
</span>
<span class="line" id="L1999"></span>
<span class="line" id="L2000">                <span class="tok-comment">// Decode the variable-based permutation number into its digits. Each digit represents</span>
</span>
<span class="line" id="L2001">                <span class="tok-comment">// an index into the list of register numbers that weren't yet used in the sequence at</span>
</span>
<span class="line" id="L2002">                <span class="tok-comment">// the time the digit was added.</span>
</span>
<span class="line" id="L2003">                <span class="tok-kw">const</span> reg_count = encoding.value.x86_64.frameless.stack_reg_count;</span>
<span class="line" id="L2004">                <span class="tok-kw">const</span> ip_ptr = <span class="tok-kw">if</span> (reg_count &gt; <span class="tok-number">0</span>) reg_blk: {</span>
<span class="line" id="L2005">                    <span class="tok-kw">var</span> digits: [<span class="tok-number">6</span>]<span class="tok-type">u3</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L2006">                    <span class="tok-kw">var</span> accumulator: <span class="tok-type">usize</span> = encoding.value.x86_64.frameless.stack_reg_permutation;</span>
<span class="line" id="L2007">                    <span class="tok-kw">var</span> base: <span class="tok-type">usize</span> = <span class="tok-number">2</span>;</span>
<span class="line" id="L2008">                    <span class="tok-kw">for</span> (<span class="tok-number">0</span>..reg_count) |i| {</span>
<span class="line" id="L2009">                        <span class="tok-kw">const</span> div = accumulator / base;</span>
<span class="line" id="L2010">                        digits[digits.len - <span class="tok-number">1</span> - i] = <span class="tok-builtin">@intCast</span>(accumulator - base * div);</span>
<span class="line" id="L2011">                        accumulator = div;</span>
<span class="line" id="L2012">                        base += <span class="tok-number">1</span>;</span>
<span class="line" id="L2013">                    }</span>
<span class="line" id="L2014"></span>
<span class="line" id="L2015">                    <span class="tok-kw">const</span> reg_numbers = [_]<span class="tok-type">u3</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span>, <span class="tok-number">6</span> };</span>
<span class="line" id="L2016">                    <span class="tok-kw">var</span> registers: [reg_numbers.len]<span class="tok-type">u3</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L2017">                    <span class="tok-kw">var</span> used_indices = [_]<span class="tok-type">bool</span>{<span class="tok-null">false</span>} ** reg_numbers.len;</span>
<span class="line" id="L2018">                    <span class="tok-kw">for</span> (digits[digits.len - reg_count ..], <span class="tok-number">0</span>..) |target_unused_index, i| {</span>
<span class="line" id="L2019">                        <span class="tok-kw">var</span> unused_count: <span class="tok-type">u8</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L2020">                        <span class="tok-kw">const</span> unused_index = <span class="tok-kw">for</span> (used_indices, <span class="tok-number">0</span>..) |used, index| {</span>
<span class="line" id="L2021">                            <span class="tok-kw">if</span> (!used) {</span>
<span class="line" id="L2022">                                <span class="tok-kw">if</span> (target_unused_index == unused_count) <span class="tok-kw">break</span> index;</span>
<span class="line" id="L2023">                                unused_count += <span class="tok-number">1</span>;</span>
<span class="line" id="L2024">                            }</span>
<span class="line" id="L2025">                        } <span class="tok-kw">else</span> <span class="tok-kw">unreachable</span>;</span>
<span class="line" id="L2026"></span>
<span class="line" id="L2027">                        registers[i] = reg_numbers[unused_index];</span>
<span class="line" id="L2028">                        used_indices[unused_index] = <span class="tok-null">true</span>;</span>
<span class="line" id="L2029">                    }</span>
<span class="line" id="L2030"></span>
<span class="line" id="L2031">                    <span class="tok-kw">var</span> reg_addr = sp + stack_size - <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>) * <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, reg_count + <span class="tok-number">1</span>);</span>
<span class="line" id="L2032">                    <span class="tok-kw">if</span> (!context.isValidMemory(reg_addr)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUnwindInfo;</span>
<span class="line" id="L2033">                    <span class="tok-kw">for</span> (<span class="tok-number">0</span>..reg_count) |i| {</span>
<span class="line" id="L2034">                        <span class="tok-kw">const</span> reg_number = <span class="tok-kw">try</span> compactUnwindToDwarfRegNumber(registers[i]);</span>
<span class="line" id="L2035">                        (<span class="tok-kw">try</span> abi.regValueNative(<span class="tok-type">usize</span>, context.thread_context, reg_number, reg_context)).* = <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">usize</span>, <span class="tok-builtin">@ptrFromInt</span>(reg_addr)).*;</span>
<span class="line" id="L2036">                        reg_addr += <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>);</span>
<span class="line" id="L2037">                    }</span>
<span class="line" id="L2038"></span>
<span class="line" id="L2039">                    <span class="tok-kw">break</span> :reg_blk reg_addr;</span>
<span class="line" id="L2040">                } <span class="tok-kw">else</span> sp + stack_size - <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>);</span>
<span class="line" id="L2041"></span>
<span class="line" id="L2042">                <span class="tok-kw">const</span> new_ip = <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">usize</span>, <span class="tok-builtin">@ptrFromInt</span>(ip_ptr)).*;</span>
<span class="line" id="L2043">                <span class="tok-kw">const</span> new_sp = ip_ptr + <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>);</span>
<span class="line" id="L2044">                <span class="tok-kw">if</span> (!context.isValidMemory(new_sp)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUnwindInfo;</span>
<span class="line" id="L2045"></span>
<span class="line" id="L2046">                (<span class="tok-kw">try</span> abi.regValueNative(<span class="tok-type">usize</span>, context.thread_context, abi.spRegNum(reg_context), reg_context)).* = new_sp;</span>
<span class="line" id="L2047">                (<span class="tok-kw">try</span> abi.regValueNative(<span class="tok-type">usize</span>, context.thread_context, abi.ipRegNum(), reg_context)).* = new_ip;</span>
<span class="line" id="L2048"></span>
<span class="line" id="L2049">                <span class="tok-kw">break</span> :blk new_ip;</span>
<span class="line" id="L2050">            },</span>
<span class="line" id="L2051">            .DWARF =&gt; {</span>
<span class="line" id="L2052">                <span class="tok-kw">return</span> unwindFrameMachODwarf(context, eh_frame <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingEhFrame, <span class="tok-builtin">@intCast</span>(encoding.value.x86_64.dwarf));</span>
<span class="line" id="L2053">            },</span>
<span class="line" id="L2054">        },</span>
<span class="line" id="L2055">        .aarch64 =&gt; <span class="tok-kw">switch</span> (encoding.mode.arm64) {</span>
<span class="line" id="L2056">            .OLD =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnimplementedUnwindEncoding,</span>
<span class="line" id="L2057">            .FRAMELESS =&gt; blk: {</span>
<span class="line" id="L2058">                <span class="tok-kw">const</span> sp = (<span class="tok-kw">try</span> abi.regValueNative(<span class="tok-type">usize</span>, context.thread_context, abi.spRegNum(reg_context), reg_context)).*;</span>
<span class="line" id="L2059">                <span class="tok-kw">const</span> new_sp = sp + encoding.value.arm64.frameless.stack_size * <span class="tok-number">16</span>;</span>
<span class="line" id="L2060">                <span class="tok-kw">const</span> new_ip = (<span class="tok-kw">try</span> abi.regValueNative(<span class="tok-type">usize</span>, context.thread_context, <span class="tok-number">30</span>, reg_context)).*;</span>
<span class="line" id="L2061">                <span class="tok-kw">if</span> (!context.isValidMemory(new_sp)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUnwindInfo;</span>
<span class="line" id="L2062">                (<span class="tok-kw">try</span> abi.regValueNative(<span class="tok-type">usize</span>, context.thread_context, abi.spRegNum(reg_context), reg_context)).* = new_sp;</span>
<span class="line" id="L2063">                <span class="tok-kw">break</span> :blk new_ip;</span>
<span class="line" id="L2064">            },</span>
<span class="line" id="L2065">            .DWARF =&gt; {</span>
<span class="line" id="L2066">                <span class="tok-kw">return</span> unwindFrameMachODwarf(context, eh_frame <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingEhFrame, <span class="tok-builtin">@intCast</span>(encoding.value.arm64.dwarf));</span>
<span class="line" id="L2067">            },</span>
<span class="line" id="L2068">            .FRAME =&gt; blk: {</span>
<span class="line" id="L2069">                <span class="tok-kw">const</span> fp = (<span class="tok-kw">try</span> abi.regValueNative(<span class="tok-type">usize</span>, context.thread_context, abi.fpRegNum(reg_context), reg_context)).*;</span>
<span class="line" id="L2070">                <span class="tok-kw">const</span> new_sp = fp + <span class="tok-number">16</span>;</span>
<span class="line" id="L2071">                <span class="tok-kw">const</span> ip_ptr = fp + <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>);</span>
<span class="line" id="L2072"></span>
<span class="line" id="L2073">                <span class="tok-kw">const</span> num_restored_pairs: <span class="tok-type">usize</span> =</span>
<span class="line" id="L2074">                    <span class="tok-builtin">@popCount</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">u5</span>, <span class="tok-builtin">@bitCast</span>(encoding.value.arm64.frame.x_reg_pairs))) +</span>
<span class="line" id="L2075">                    <span class="tok-builtin">@popCount</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">u4</span>, <span class="tok-builtin">@bitCast</span>(encoding.value.arm64.frame.d_reg_pairs)));</span>
<span class="line" id="L2076">                <span class="tok-kw">const</span> min_reg_addr = fp - num_restored_pairs * <span class="tok-number">2</span> * <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>);</span>
<span class="line" id="L2077"></span>
<span class="line" id="L2078">                <span class="tok-kw">if</span> (!context.isValidMemory(new_sp) <span class="tok-kw">or</span> !context.isValidMemory(min_reg_addr)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUnwindInfo;</span>
<span class="line" id="L2079"></span>
<span class="line" id="L2080">                <span class="tok-kw">var</span> reg_addr = fp - <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>);</span>
<span class="line" id="L2081">                <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(encoding.value.arm64.frame.x_reg_pairs)).Struct.fields, <span class="tok-number">0</span>..) |field, i| {</span>
<span class="line" id="L2082">                    <span class="tok-kw">if</span> (<span class="tok-builtin">@field</span>(encoding.value.arm64.frame.x_reg_pairs, field.name) != <span class="tok-number">0</span>) {</span>
<span class="line" id="L2083">                        (<span class="tok-kw">try</span> abi.regValueNative(<span class="tok-type">usize</span>, context.thread_context, <span class="tok-number">19</span> + i, reg_context)).* = <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">usize</span>, <span class="tok-builtin">@ptrFromInt</span>(reg_addr)).*;</span>
<span class="line" id="L2084">                        reg_addr += <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>);</span>
<span class="line" id="L2085">                        (<span class="tok-kw">try</span> abi.regValueNative(<span class="tok-type">usize</span>, context.thread_context, <span class="tok-number">20</span> + i, reg_context)).* = <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">usize</span>, <span class="tok-builtin">@ptrFromInt</span>(reg_addr)).*;</span>
<span class="line" id="L2086">                        reg_addr += <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>);</span>
<span class="line" id="L2087">                    }</span>
<span class="line" id="L2088">                }</span>
<span class="line" id="L2089"></span>
<span class="line" id="L2090">                <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(encoding.value.arm64.frame.d_reg_pairs)).Struct.fields, <span class="tok-number">0</span>..) |field, i| {</span>
<span class="line" id="L2091">                    <span class="tok-kw">if</span> (<span class="tok-builtin">@field</span>(encoding.value.arm64.frame.d_reg_pairs, field.name) != <span class="tok-number">0</span>) {</span>
<span class="line" id="L2092">                        <span class="tok-comment">// Only the lower half of the 128-bit V registers are restored during unwinding</span>
</span>
<span class="line" id="L2093">                        <span class="tok-builtin">@memcpy</span>(</span>
<span class="line" id="L2094">                            <span class="tok-kw">try</span> abi.regBytes(context.thread_context, <span class="tok-number">64</span> + <span class="tok-number">8</span> + i, context.reg_context),</span>
<span class="line" id="L2095">                            mem.asBytes(<span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">usize</span>, <span class="tok-builtin">@ptrFromInt</span>(reg_addr))),</span>
<span class="line" id="L2096">                        );</span>
<span class="line" id="L2097">                        reg_addr += <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>);</span>
<span class="line" id="L2098">                        <span class="tok-builtin">@memcpy</span>(</span>
<span class="line" id="L2099">                            <span class="tok-kw">try</span> abi.regBytes(context.thread_context, <span class="tok-number">64</span> + <span class="tok-number">9</span> + i, context.reg_context),</span>
<span class="line" id="L2100">                            mem.asBytes(<span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">usize</span>, <span class="tok-builtin">@ptrFromInt</span>(reg_addr))),</span>
<span class="line" id="L2101">                        );</span>
<span class="line" id="L2102">                        reg_addr += <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>);</span>
<span class="line" id="L2103">                    }</span>
<span class="line" id="L2104">                }</span>
<span class="line" id="L2105"></span>
<span class="line" id="L2106">                <span class="tok-kw">const</span> new_ip = <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">usize</span>, <span class="tok-builtin">@ptrFromInt</span>(ip_ptr)).*;</span>
<span class="line" id="L2107">                <span class="tok-kw">const</span> new_fp = <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">usize</span>, <span class="tok-builtin">@ptrFromInt</span>(fp)).*;</span>
<span class="line" id="L2108"></span>
<span class="line" id="L2109">                (<span class="tok-kw">try</span> abi.regValueNative(<span class="tok-type">usize</span>, context.thread_context, abi.fpRegNum(reg_context), reg_context)).* = new_fp;</span>
<span class="line" id="L2110">                (<span class="tok-kw">try</span> abi.regValueNative(<span class="tok-type">usize</span>, context.thread_context, abi.ipRegNum(), reg_context)).* = new_ip;</span>
<span class="line" id="L2111"></span>
<span class="line" id="L2112">                <span class="tok-kw">break</span> :blk new_ip;</span>
<span class="line" id="L2113">            },</span>
<span class="line" id="L2114">        },</span>
<span class="line" id="L2115">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnimplementedArch,</span>
<span class="line" id="L2116">    };</span>
<span class="line" id="L2117"></span>
<span class="line" id="L2118">    context.pc = abi.stripInstructionPtrAuthCode(new_ip);</span>
<span class="line" id="L2119">    <span class="tok-kw">if</span> (context.pc &gt; <span class="tok-number">0</span>) context.pc -= <span class="tok-number">1</span>;</span>
<span class="line" id="L2120">    <span class="tok-kw">return</span> new_ip;</span>
<span class="line" id="L2121">}</span>
<span class="line" id="L2122"></span>
<span class="line" id="L2123"><span class="tok-kw">fn</span> <span class="tok-fn">unwindFrameMachODwarf</span>(context: *UnwindContext, eh_frame: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, fde_offset: <span class="tok-type">usize</span>) !<span class="tok-type">usize</span> {</span>
<span class="line" id="L2124">    <span class="tok-kw">var</span> di = DwarfInfo{</span>
<span class="line" id="L2125">        .endian = native_endian,</span>
<span class="line" id="L2126">        .is_macho = <span class="tok-null">true</span>,</span>
<span class="line" id="L2127">    };</span>
<span class="line" id="L2128">    <span class="tok-kw">defer</span> di.deinit(context.allocator);</span>
<span class="line" id="L2129"></span>
<span class="line" id="L2130">    di.sections[<span class="tok-builtin">@intFromEnum</span>(DwarfSection.eh_frame)] = .{</span>
<span class="line" id="L2131">        .data = eh_frame,</span>
<span class="line" id="L2132">        .owned = <span class="tok-null">false</span>,</span>
<span class="line" id="L2133">    };</span>
<span class="line" id="L2134"></span>
<span class="line" id="L2135">    <span class="tok-kw">return</span> di.unwindFrame(context, fde_offset);</span>
<span class="line" id="L2136">}</span>
<span class="line" id="L2137"></span>
<span class="line" id="L2138"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> UnwindContext = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2139">    allocator: mem.Allocator,</span>
<span class="line" id="L2140">    cfa: ?<span class="tok-type">usize</span>,</span>
<span class="line" id="L2141">    pc: <span class="tok-type">usize</span>,</span>
<span class="line" id="L2142">    thread_context: *debug.ThreadContext,</span>
<span class="line" id="L2143">    reg_context: abi.RegisterContext,</span>
<span class="line" id="L2144">    isValidMemory: *<span class="tok-kw">const</span> <span class="tok-kw">fn</span> (address: <span class="tok-type">usize</span>) <span class="tok-type">bool</span>,</span>
<span class="line" id="L2145">    vm: call_frame.VirtualMachine,</span>
<span class="line" id="L2146">    stack_machine: expressions.StackMachine(.{ .call_frame_context = <span class="tok-null">true</span> }),</span>
<span class="line" id="L2147"></span>
<span class="line" id="L2148">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: mem.Allocator, thread_context: *<span class="tok-kw">const</span> debug.ThreadContext, isValidMemory: *<span class="tok-kw">const</span> <span class="tok-kw">fn</span> (address: <span class="tok-type">usize</span>) <span class="tok-type">bool</span>) !UnwindContext {</span>
<span class="line" id="L2149">        <span class="tok-kw">const</span> pc = abi.stripInstructionPtrAuthCode((<span class="tok-kw">try</span> abi.regValueNative(<span class="tok-type">usize</span>, thread_context, abi.ipRegNum(), <span class="tok-null">null</span>)).*);</span>
<span class="line" id="L2150"></span>
<span class="line" id="L2151">        <span class="tok-kw">const</span> context_copy = <span class="tok-kw">try</span> allocator.create(debug.ThreadContext);</span>
<span class="line" id="L2152">        debug.copyContext(thread_context, context_copy);</span>
<span class="line" id="L2153"></span>
<span class="line" id="L2154">        <span class="tok-kw">return</span> .{</span>
<span class="line" id="L2155">            .allocator = allocator,</span>
<span class="line" id="L2156">            .cfa = <span class="tok-null">null</span>,</span>
<span class="line" id="L2157">            .pc = pc,</span>
<span class="line" id="L2158">            .thread_context = context_copy,</span>
<span class="line" id="L2159">            .reg_context = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L2160">            .isValidMemory = isValidMemory,</span>
<span class="line" id="L2161">            .vm = .{},</span>
<span class="line" id="L2162">            .stack_machine = .{},</span>
<span class="line" id="L2163">        };</span>
<span class="line" id="L2164">    }</span>
<span class="line" id="L2165"></span>
<span class="line" id="L2166">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *UnwindContext) <span class="tok-type">void</span> {</span>
<span class="line" id="L2167">        self.vm.deinit(self.allocator);</span>
<span class="line" id="L2168">        self.stack_machine.deinit(self.allocator);</span>
<span class="line" id="L2169">        self.allocator.destroy(self.thread_context);</span>
<span class="line" id="L2170">        self.* = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L2171">    }</span>
<span class="line" id="L2172"></span>
<span class="line" id="L2173">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getFp</span>(self: *<span class="tok-kw">const</span> UnwindContext) !<span class="tok-type">usize</span> {</span>
<span class="line" id="L2174">        <span class="tok-kw">return</span> (<span class="tok-kw">try</span> abi.regValueNative(<span class="tok-type">usize</span>, self.thread_context, abi.fpRegNum(self.reg_context), self.reg_context)).*;</span>
<span class="line" id="L2175">    }</span>
<span class="line" id="L2176">};</span>
<span class="line" id="L2177"></span>
<span class="line" id="L2178"><span class="tok-comment">/// Initialize DWARF info. The caller has the responsibility to initialize most</span></span>
<span class="line" id="L2179"><span class="tok-comment">/// the DwarfInfo fields before calling. `binary_mem` is the raw bytes of the</span></span>
<span class="line" id="L2180"><span class="tok-comment">/// main binary file (not the secondary debug info file).</span></span>
<span class="line" id="L2181"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openDwarfDebugInfo</span>(di: *DwarfInfo, allocator: mem.Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L2182">    <span class="tok-kw">try</span> di.scanAllFunctions(allocator);</span>
<span class="line" id="L2183">    <span class="tok-kw">try</span> di.scanAllCompileUnits(allocator);</span>
<span class="line" id="L2184">}</span>
<span class="line" id="L2185"></span>
<span class="line" id="L2186"><span class="tok-comment">/// This function is to make it handy to comment out the return and make it</span></span>
<span class="line" id="L2187"><span class="tok-comment">/// into a crash when working on this file.</span></span>
<span class="line" id="L2188"><span class="tok-kw">fn</span> <span class="tok-fn">badDwarf</span>() <span class="tok-kw">error</span>{InvalidDebugInfo} {</span>
<span class="line" id="L2189">    <span class="tok-comment">//std.os.abort(); // can be handy to uncomment when working on this file</span>
</span>
<span class="line" id="L2190">    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDebugInfo;</span>
<span class="line" id="L2191">}</span>
<span class="line" id="L2192"></span>
<span class="line" id="L2193"><span class="tok-kw">fn</span> <span class="tok-fn">missingDwarf</span>() <span class="tok-kw">error</span>{MissingDebugInfo} {</span>
<span class="line" id="L2194">    <span class="tok-comment">//std.os.abort(); // can be handy to uncomment when working on this file</span>
</span>
<span class="line" id="L2195">    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingDebugInfo;</span>
<span class="line" id="L2196">}</span>
<span class="line" id="L2197"></span>
<span class="line" id="L2198"><span class="tok-kw">fn</span> <span class="tok-fn">getStringGeneric</span>(opt_str: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, offset: <span class="tok-type">u64</span>) ![:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L2199">    <span class="tok-kw">const</span> str = opt_str <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L2200">    <span class="tok-kw">if</span> (offset &gt; str.len) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L2201">    <span class="tok-kw">const</span> casted_offset = math.cast(<span class="tok-type">usize</span>, offset) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L2202">    <span class="tok-comment">// Valid strings always have a terminating zero byte</span>
</span>
<span class="line" id="L2203">    <span class="tok-kw">const</span> last = mem.indexOfScalarPos(<span class="tok-type">u8</span>, str, casted_offset, <span class="tok-number">0</span>) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L2204">    <span class="tok-kw">return</span> str[casted_offset..last :<span class="tok-number">0</span>];</span>
<span class="line" id="L2205">}</span>
<span class="line" id="L2206"></span>
<span class="line" id="L2207"><span class="tok-kw">const</span> EhPointerContext = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2208">    <span class="tok-comment">// The address of the pointer field itself</span>
</span>
<span class="line" id="L2209">    pc_rel_base: <span class="tok-type">u64</span>,</span>
<span class="line" id="L2210"></span>
<span class="line" id="L2211">    <span class="tok-comment">// Whether or not to follow indirect pointers. This should only be</span>
</span>
<span class="line" id="L2212">    <span class="tok-comment">// used when decoding pointers at runtime using the current process's</span>
</span>
<span class="line" id="L2213">    <span class="tok-comment">// debug info</span>
</span>
<span class="line" id="L2214">    follow_indirect: <span class="tok-type">bool</span>,</span>
<span class="line" id="L2215"></span>
<span class="line" id="L2216">    <span class="tok-comment">// These relative addressing modes are only used in specific cases, and</span>
</span>
<span class="line" id="L2217">    <span class="tok-comment">// might not be available / required in all parsing contexts</span>
</span>
<span class="line" id="L2218">    data_rel_base: ?<span class="tok-type">u64</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L2219">    text_rel_base: ?<span class="tok-type">u64</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L2220">    function_rel_base: ?<span class="tok-type">u64</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L2221">};</span>
<span class="line" id="L2222"><span class="tok-kw">fn</span> <span class="tok-fn">readEhPointer</span>(fbr: *FixedBufferReader, enc: <span class="tok-type">u8</span>, addr_size_bytes: <span class="tok-type">u8</span>, ctx: EhPointerContext) !?<span class="tok-type">u64</span> {</span>
<span class="line" id="L2223">    <span class="tok-kw">if</span> (enc == EH.PE.omit) <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L2224"></span>
<span class="line" id="L2225">    <span class="tok-kw">const</span> value: <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {</span>
<span class="line" id="L2226">        signed: <span class="tok-type">i64</span>,</span>
<span class="line" id="L2227">        unsigned: <span class="tok-type">u64</span>,</span>
<span class="line" id="L2228">    } = <span class="tok-kw">switch</span> (enc &amp; EH.PE.type_mask) {</span>
<span class="line" id="L2229">        EH.PE.absptr =&gt; .{</span>
<span class="line" id="L2230">            .unsigned = <span class="tok-kw">switch</span> (addr_size_bytes) {</span>
<span class="line" id="L2231">                <span class="tok-number">2</span> =&gt; <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u16</span>),</span>
<span class="line" id="L2232">                <span class="tok-number">4</span> =&gt; <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u32</span>),</span>
<span class="line" id="L2233">                <span class="tok-number">8</span> =&gt; <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u64</span>),</span>
<span class="line" id="L2234">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidAddrSize,</span>
<span class="line" id="L2235">            },</span>
<span class="line" id="L2236">        },</span>
<span class="line" id="L2237">        EH.PE.uleb128 =&gt; .{ .unsigned = <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">u64</span>) },</span>
<span class="line" id="L2238">        EH.PE.udata2 =&gt; .{ .unsigned = <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u16</span>) },</span>
<span class="line" id="L2239">        EH.PE.udata4 =&gt; .{ .unsigned = <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u32</span>) },</span>
<span class="line" id="L2240">        EH.PE.udata8 =&gt; .{ .unsigned = <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u64</span>) },</span>
<span class="line" id="L2241">        EH.PE.sleb128 =&gt; .{ .signed = <span class="tok-kw">try</span> fbr.readIleb128(<span class="tok-type">i64</span>) },</span>
<span class="line" id="L2242">        EH.PE.sdata2 =&gt; .{ .signed = <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">i16</span>) },</span>
<span class="line" id="L2243">        EH.PE.sdata4 =&gt; .{ .signed = <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">i32</span>) },</span>
<span class="line" id="L2244">        EH.PE.sdata8 =&gt; .{ .signed = <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">i64</span>) },</span>
<span class="line" id="L2245">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> badDwarf(),</span>
<span class="line" id="L2246">    };</span>
<span class="line" id="L2247"></span>
<span class="line" id="L2248">    <span class="tok-kw">const</span> base = <span class="tok-kw">switch</span> (enc &amp; EH.PE.rel_mask) {</span>
<span class="line" id="L2249">        EH.PE.pcrel =&gt; ctx.pc_rel_base,</span>
<span class="line" id="L2250">        EH.PE.textrel =&gt; ctx.text_rel_base <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PointerBaseNotSpecified,</span>
<span class="line" id="L2251">        EH.PE.datarel =&gt; ctx.data_rel_base <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PointerBaseNotSpecified,</span>
<span class="line" id="L2252">        EH.PE.funcrel =&gt; ctx.function_rel_base <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PointerBaseNotSpecified,</span>
<span class="line" id="L2253">        <span class="tok-kw">else</span> =&gt; <span class="tok-null">null</span>,</span>
<span class="line" id="L2254">    };</span>
<span class="line" id="L2255"></span>
<span class="line" id="L2256">    <span class="tok-kw">const</span> ptr: <span class="tok-type">u64</span> = <span class="tok-kw">if</span> (base) |b| <span class="tok-kw">switch</span> (value) {</span>
<span class="line" id="L2257">        .signed =&gt; |s| <span class="tok-builtin">@intCast</span>(<span class="tok-kw">try</span> math.add(<span class="tok-type">i64</span>, s, <span class="tok-builtin">@as</span>(<span class="tok-type">i64</span>, <span class="tok-builtin">@intCast</span>(b)))),</span>
<span class="line" id="L2258">        <span class="tok-comment">// absptr can actually contain signed values in some cases (aarch64 MachO)</span>
</span>
<span class="line" id="L2259">        .unsigned =&gt; |u| u +% b,</span>
<span class="line" id="L2260">    } <span class="tok-kw">else</span> <span class="tok-kw">switch</span> (value) {</span>
<span class="line" id="L2261">        .signed =&gt; |s| <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-builtin">@intCast</span>(s)),</span>
<span class="line" id="L2262">        .unsigned =&gt; |u| u,</span>
<span class="line" id="L2263">    };</span>
<span class="line" id="L2264"></span>
<span class="line" id="L2265">    <span class="tok-kw">if</span> ((enc &amp; EH.PE.indirect) &gt; <span class="tok-number">0</span> <span class="tok-kw">and</span> ctx.follow_indirect) {</span>
<span class="line" id="L2266">        <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>) != addr_size_bytes) {</span>
<span class="line" id="L2267">            <span class="tok-comment">// See the documentation for `follow_indirect`</span>
</span>
<span class="line" id="L2268">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NonNativeIndirection;</span>
<span class="line" id="L2269">        }</span>
<span class="line" id="L2270"></span>
<span class="line" id="L2271">        <span class="tok-kw">const</span> native_ptr = math.cast(<span class="tok-type">usize</span>, ptr) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PointerOverflow;</span>
<span class="line" id="L2272">        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (addr_size_bytes) {</span>
<span class="line" id="L2273">            <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span> =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">usize</span>, <span class="tok-builtin">@ptrFromInt</span>(native_ptr)).*,</span>
<span class="line" id="L2274">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnsupportedAddrSize,</span>
<span class="line" id="L2275">        };</span>
<span class="line" id="L2276">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2277">        <span class="tok-kw">return</span> ptr;</span>
<span class="line" id="L2278">    }</span>
<span class="line" id="L2279">}</span>
<span class="line" id="L2280"></span>
<span class="line" id="L2281"><span class="tok-comment">/// This represents the decoded .eh_frame_hdr header</span></span>
<span class="line" id="L2282"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ExceptionFrameHeader = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2283">    eh_frame_ptr: <span class="tok-type">usize</span>,</span>
<span class="line" id="L2284">    table_enc: <span class="tok-type">u8</span>,</span>
<span class="line" id="L2285">    fde_count: <span class="tok-type">usize</span>,</span>
<span class="line" id="L2286">    entries: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L2287"></span>
<span class="line" id="L2288">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">entrySize</span>(table_enc: <span class="tok-type">u8</span>) !<span class="tok-type">u8</span> {</span>
<span class="line" id="L2289">        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (table_enc &amp; EH.PE.type_mask) {</span>
<span class="line" id="L2290">            EH.PE.udata2,</span>
<span class="line" id="L2291">            EH.PE.sdata2,</span>
<span class="line" id="L2292">            =&gt; <span class="tok-number">4</span>,</span>
<span class="line" id="L2293">            EH.PE.udata4,</span>
<span class="line" id="L2294">            EH.PE.sdata4,</span>
<span class="line" id="L2295">            =&gt; <span class="tok-number">8</span>,</span>
<span class="line" id="L2296">            EH.PE.udata8,</span>
<span class="line" id="L2297">            EH.PE.sdata8,</span>
<span class="line" id="L2298">            =&gt; <span class="tok-number">16</span>,</span>
<span class="line" id="L2299">            <span class="tok-comment">// This is a binary search table, so all entries must be the same length</span>
</span>
<span class="line" id="L2300">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> badDwarf(),</span>
<span class="line" id="L2301">        };</span>
<span class="line" id="L2302">    }</span>
<span class="line" id="L2303"></span>
<span class="line" id="L2304">    <span class="tok-kw">fn</span> <span class="tok-fn">isValidPtr</span>(</span>
<span class="line" id="L2305">        self: ExceptionFrameHeader,</span>
<span class="line" id="L2306">        ptr: <span class="tok-type">usize</span>,</span>
<span class="line" id="L2307">        isValidMemory: *<span class="tok-kw">const</span> <span class="tok-kw">fn</span> (address: <span class="tok-type">usize</span>) <span class="tok-type">bool</span>,</span>
<span class="line" id="L2308">        eh_frame_len: ?<span class="tok-type">usize</span>,</span>
<span class="line" id="L2309">    ) <span class="tok-type">bool</span> {</span>
<span class="line" id="L2310">        <span class="tok-kw">if</span> (eh_frame_len) |len| {</span>
<span class="line" id="L2311">            <span class="tok-kw">return</span> ptr &gt;= self.eh_frame_ptr <span class="tok-kw">and</span> ptr &lt; self.eh_frame_ptr + len;</span>
<span class="line" id="L2312">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2313">            <span class="tok-kw">return</span> isValidMemory(ptr);</span>
<span class="line" id="L2314">        }</span>
<span class="line" id="L2315">    }</span>
<span class="line" id="L2316"></span>
<span class="line" id="L2317">    <span class="tok-comment">/// Find an entry by binary searching the eh_frame_hdr section.</span></span>
<span class="line" id="L2318">    <span class="tok-comment">///</span></span>
<span class="line" id="L2319">    <span class="tok-comment">/// Since the length of the eh_frame section (`eh_frame_len`) may not be known by the caller,</span></span>
<span class="line" id="L2320">    <span class="tok-comment">/// `isValidMemory` will be called before accessing any memory referenced by</span></span>
<span class="line" id="L2321">    <span class="tok-comment">/// the header entries. If `eh_frame_len` is provided, then these checks can be skipped.</span></span>
<span class="line" id="L2322">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">findEntry</span>(</span>
<span class="line" id="L2323">        self: ExceptionFrameHeader,</span>
<span class="line" id="L2324">        isValidMemory: *<span class="tok-kw">const</span> <span class="tok-kw">fn</span> (address: <span class="tok-type">usize</span>) <span class="tok-type">bool</span>,</span>
<span class="line" id="L2325">        eh_frame_len: ?<span class="tok-type">usize</span>,</span>
<span class="line" id="L2326">        eh_frame_hdr_ptr: <span class="tok-type">usize</span>,</span>
<span class="line" id="L2327">        pc: <span class="tok-type">usize</span>,</span>
<span class="line" id="L2328">        cie: *CommonInformationEntry,</span>
<span class="line" id="L2329">        fde: *FrameDescriptionEntry,</span>
<span class="line" id="L2330">    ) !<span class="tok-type">void</span> {</span>
<span class="line" id="L2331">        <span class="tok-kw">const</span> entry_size = <span class="tok-kw">try</span> entrySize(self.table_enc);</span>
<span class="line" id="L2332"></span>
<span class="line" id="L2333">        <span class="tok-kw">var</span> left: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L2334">        <span class="tok-kw">var</span> len: <span class="tok-type">usize</span> = self.fde_count;</span>
<span class="line" id="L2335"></span>
<span class="line" id="L2336">        <span class="tok-kw">var</span> fbr: FixedBufferReader = .{ .buf = self.entries, .endian = native_endian };</span>
<span class="line" id="L2337"></span>
<span class="line" id="L2338">        <span class="tok-kw">while</span> (len &gt; <span class="tok-number">1</span>) {</span>
<span class="line" id="L2339">            <span class="tok-kw">const</span> mid = left + len / <span class="tok-number">2</span>;</span>
<span class="line" id="L2340"></span>
<span class="line" id="L2341">            fbr.pos = mid * entry_size;</span>
<span class="line" id="L2342">            <span class="tok-kw">const</span> pc_begin = <span class="tok-kw">try</span> readEhPointer(&amp;fbr, self.table_enc, <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>), .{</span>
<span class="line" id="L2343">                .pc_rel_base = <span class="tok-builtin">@intFromPtr</span>(&amp;self.entries[fbr.pos]),</span>
<span class="line" id="L2344">                .follow_indirect = <span class="tok-null">true</span>,</span>
<span class="line" id="L2345">                .data_rel_base = eh_frame_hdr_ptr,</span>
<span class="line" id="L2346">            }) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L2347"></span>
<span class="line" id="L2348">            <span class="tok-kw">if</span> (pc &lt; pc_begin) {</span>
<span class="line" id="L2349">                len /= <span class="tok-number">2</span>;</span>
<span class="line" id="L2350">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2351">                left = mid;</span>
<span class="line" id="L2352">                <span class="tok-kw">if</span> (pc == pc_begin) <span class="tok-kw">break</span>;</span>
<span class="line" id="L2353">                len -= len / <span class="tok-number">2</span>;</span>
<span class="line" id="L2354">            }</span>
<span class="line" id="L2355">        }</span>
<span class="line" id="L2356"></span>
<span class="line" id="L2357">        <span class="tok-kw">if</span> (len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L2358">        fbr.pos = left * entry_size;</span>
<span class="line" id="L2359"></span>
<span class="line" id="L2360">        <span class="tok-comment">// Read past the pc_begin field of the entry</span>
</span>
<span class="line" id="L2361">        _ = <span class="tok-kw">try</span> readEhPointer(&amp;fbr, self.table_enc, <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>), .{</span>
<span class="line" id="L2362">            .pc_rel_base = <span class="tok-builtin">@intFromPtr</span>(&amp;self.entries[fbr.pos]),</span>
<span class="line" id="L2363">            .follow_indirect = <span class="tok-null">true</span>,</span>
<span class="line" id="L2364">            .data_rel_base = eh_frame_hdr_ptr,</span>
<span class="line" id="L2365">        }) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L2366"></span>
<span class="line" id="L2367">        <span class="tok-kw">const</span> fde_ptr = math.cast(<span class="tok-type">usize</span>, <span class="tok-kw">try</span> readEhPointer(&amp;fbr, self.table_enc, <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>), .{</span>
<span class="line" id="L2368">            .pc_rel_base = <span class="tok-builtin">@intFromPtr</span>(&amp;self.entries[fbr.pos]),</span>
<span class="line" id="L2369">            .follow_indirect = <span class="tok-null">true</span>,</span>
<span class="line" id="L2370">            .data_rel_base = eh_frame_hdr_ptr,</span>
<span class="line" id="L2371">        }) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> badDwarf()) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L2372"></span>
<span class="line" id="L2373">        <span class="tok-comment">// Verify the length fields of the FDE header are readable</span>
</span>
<span class="line" id="L2374">        <span class="tok-kw">if</span> (!self.isValidPtr(fde_ptr, isValidMemory, eh_frame_len) <span class="tok-kw">or</span> fde_ptr &lt; self.eh_frame_ptr) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L2375"></span>
<span class="line" id="L2376">        <span class="tok-kw">var</span> fde_entry_header_len: <span class="tok-type">usize</span> = <span class="tok-number">4</span>;</span>
<span class="line" id="L2377">        <span class="tok-kw">if</span> (!self.isValidPtr(fde_ptr + <span class="tok-number">3</span>, isValidMemory, eh_frame_len)) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L2378">        <span class="tok-kw">if</span> (self.isValidPtr(fde_ptr + <span class="tok-number">11</span>, isValidMemory, eh_frame_len)) fde_entry_header_len = <span class="tok-number">12</span>;</span>
<span class="line" id="L2379"></span>
<span class="line" id="L2380">        <span class="tok-comment">// Even if eh_frame_len is not specified, all ranges accssed are checked by isValidPtr</span>
</span>
<span class="line" id="L2381">        <span class="tok-kw">const</span> eh_frame = <span class="tok-builtin">@as</span>([*]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrFromInt</span>(self.eh_frame_ptr))[<span class="tok-number">0</span> .. eh_frame_len <span class="tok-kw">orelse</span> math.maxInt(<span class="tok-type">u32</span>)];</span>
<span class="line" id="L2382"></span>
<span class="line" id="L2383">        <span class="tok-kw">const</span> fde_offset = fde_ptr - self.eh_frame_ptr;</span>
<span class="line" id="L2384">        <span class="tok-kw">var</span> eh_frame_fbr: FixedBufferReader = .{</span>
<span class="line" id="L2385">            .buf = eh_frame,</span>
<span class="line" id="L2386">            .pos = fde_offset,</span>
<span class="line" id="L2387">            .endian = native_endian,</span>
<span class="line" id="L2388">        };</span>
<span class="line" id="L2389"></span>
<span class="line" id="L2390">        <span class="tok-kw">const</span> fde_entry_header = <span class="tok-kw">try</span> EntryHeader.read(&amp;eh_frame_fbr, .eh_frame);</span>
<span class="line" id="L2391">        <span class="tok-kw">if</span> (!self.isValidPtr(<span class="tok-builtin">@intFromPtr</span>(&amp;fde_entry_header.entry_bytes[fde_entry_header.entry_bytes.len - <span class="tok-number">1</span>]), isValidMemory, eh_frame_len)) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L2392">        <span class="tok-kw">if</span> (fde_entry_header.<span class="tok-type">type</span> != .fde) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L2393"></span>
<span class="line" id="L2394">        <span class="tok-comment">// CIEs always come before FDEs (the offset is a subtraction), so we can assume this memory is readable</span>
</span>
<span class="line" id="L2395">        <span class="tok-kw">const</span> cie_offset = fde_entry_header.<span class="tok-type">type</span>.fde;</span>
<span class="line" id="L2396">        <span class="tok-kw">try</span> eh_frame_fbr.seekTo(cie_offset);</span>
<span class="line" id="L2397">        <span class="tok-kw">const</span> cie_entry_header = <span class="tok-kw">try</span> EntryHeader.read(&amp;eh_frame_fbr, .eh_frame);</span>
<span class="line" id="L2398">        <span class="tok-kw">if</span> (!self.isValidPtr(<span class="tok-builtin">@intFromPtr</span>(&amp;cie_entry_header.entry_bytes[cie_entry_header.entry_bytes.len - <span class="tok-number">1</span>]), isValidMemory, eh_frame_len)) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L2399">        <span class="tok-kw">if</span> (cie_entry_header.<span class="tok-type">type</span> != .cie) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L2400"></span>
<span class="line" id="L2401">        cie.* = <span class="tok-kw">try</span> CommonInformationEntry.parse(</span>
<span class="line" id="L2402">            cie_entry_header.entry_bytes,</span>
<span class="line" id="L2403">            <span class="tok-number">0</span>,</span>
<span class="line" id="L2404">            <span class="tok-null">true</span>,</span>
<span class="line" id="L2405">            cie_entry_header.format,</span>
<span class="line" id="L2406">            .eh_frame,</span>
<span class="line" id="L2407">            cie_entry_header.length_offset,</span>
<span class="line" id="L2408">            <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>),</span>
<span class="line" id="L2409">            native_endian,</span>
<span class="line" id="L2410">        );</span>
<span class="line" id="L2411"></span>
<span class="line" id="L2412">        fde.* = <span class="tok-kw">try</span> FrameDescriptionEntry.parse(</span>
<span class="line" id="L2413">            fde_entry_header.entry_bytes,</span>
<span class="line" id="L2414">            <span class="tok-number">0</span>,</span>
<span class="line" id="L2415">            <span class="tok-null">true</span>,</span>
<span class="line" id="L2416">            cie.*,</span>
<span class="line" id="L2417">            <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>),</span>
<span class="line" id="L2418">            native_endian,</span>
<span class="line" id="L2419">        );</span>
<span class="line" id="L2420">    }</span>
<span class="line" id="L2421">};</span>
<span class="line" id="L2422"></span>
<span class="line" id="L2423"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> EntryHeader = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2424">    <span class="tok-comment">/// Offset of the length field in the backing buffer</span></span>
<span class="line" id="L2425">    length_offset: <span class="tok-type">usize</span>,</span>
<span class="line" id="L2426">    format: Format,</span>
<span class="line" id="L2427">    <span class="tok-type">type</span>: <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {</span>
<span class="line" id="L2428">        cie,</span>
<span class="line" id="L2429">        <span class="tok-comment">/// Value is the offset of the corresponding CIE</span></span>
<span class="line" id="L2430">        fde: <span class="tok-type">u64</span>,</span>
<span class="line" id="L2431">        terminator,</span>
<span class="line" id="L2432">    },</span>
<span class="line" id="L2433">    <span class="tok-comment">/// The entry's contents, not including the ID field</span></span>
<span class="line" id="L2434">    entry_bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L2435"></span>
<span class="line" id="L2436">    <span class="tok-comment">/// The length of the entry including the ID field, but not the length field itself</span></span>
<span class="line" id="L2437">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">entryLength</span>(self: EntryHeader) <span class="tok-type">usize</span> {</span>
<span class="line" id="L2438">        <span class="tok-kw">return</span> self.entry_bytes.len + <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-kw">if</span> (self.is_64) <span class="tok-number">8</span> <span class="tok-kw">else</span> <span class="tok-number">4</span>);</span>
<span class="line" id="L2439">    }</span>
<span class="line" id="L2440"></span>
<span class="line" id="L2441">    <span class="tok-comment">/// Reads a header for either an FDE or a CIE, then advances the fbr to the position after the trailing structure.</span></span>
<span class="line" id="L2442">    <span class="tok-comment">/// `fbr` must be a FixedBufferReader backed by either the .eh_frame or .debug_frame sections.</span></span>
<span class="line" id="L2443">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">read</span>(fbr: *FixedBufferReader, dwarf_section: DwarfSection) !EntryHeader {</span>
<span class="line" id="L2444">        assert(dwarf_section == .eh_frame <span class="tok-kw">or</span> dwarf_section == .debug_frame);</span>
<span class="line" id="L2445"></span>
<span class="line" id="L2446">        <span class="tok-kw">const</span> length_offset = fbr.pos;</span>
<span class="line" id="L2447">        <span class="tok-kw">const</span> unit_header = <span class="tok-kw">try</span> readUnitHeader(fbr);</span>
<span class="line" id="L2448">        <span class="tok-kw">const</span> unit_length = math.cast(<span class="tok-type">usize</span>, unit_header.unit_length) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L2449">        <span class="tok-kw">if</span> (unit_length == <span class="tok-number">0</span>) <span class="tok-kw">return</span> .{</span>
<span class="line" id="L2450">            .length_offset = length_offset,</span>
<span class="line" id="L2451">            .format = unit_header.format,</span>
<span class="line" id="L2452">            .<span class="tok-type">type</span> = .terminator,</span>
<span class="line" id="L2453">            .entry_bytes = &amp;.{},</span>
<span class="line" id="L2454">        };</span>
<span class="line" id="L2455">        <span class="tok-kw">const</span> start_offset = fbr.pos;</span>
<span class="line" id="L2456">        <span class="tok-kw">const</span> end_offset = start_offset + unit_length;</span>
<span class="line" id="L2457">        <span class="tok-kw">defer</span> fbr.pos = end_offset;</span>
<span class="line" id="L2458"></span>
<span class="line" id="L2459">        <span class="tok-kw">const</span> id = <span class="tok-kw">try</span> fbr.readAddress(unit_header.format);</span>
<span class="line" id="L2460">        <span class="tok-kw">const</span> entry_bytes = fbr.buf[fbr.pos..end_offset];</span>
<span class="line" id="L2461">        <span class="tok-kw">const</span> cie_id: <span class="tok-type">u64</span> = <span class="tok-kw">switch</span> (dwarf_section) {</span>
<span class="line" id="L2462">            .eh_frame =&gt; CommonInformationEntry.eh_id,</span>
<span class="line" id="L2463">            .debug_frame =&gt; <span class="tok-kw">switch</span> (unit_header.format) {</span>
<span class="line" id="L2464">                .@&quot;32&quot; =&gt; CommonInformationEntry.dwarf32_id,</span>
<span class="line" id="L2465">                .@&quot;64&quot; =&gt; CommonInformationEntry.dwarf64_id,</span>
<span class="line" id="L2466">            },</span>
<span class="line" id="L2467">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L2468">        };</span>
<span class="line" id="L2469"></span>
<span class="line" id="L2470">        <span class="tok-kw">return</span> .{</span>
<span class="line" id="L2471">            .length_offset = length_offset,</span>
<span class="line" id="L2472">            .format = unit_header.format,</span>
<span class="line" id="L2473">            .<span class="tok-type">type</span> = <span class="tok-kw">if</span> (id == cie_id) .cie <span class="tok-kw">else</span> .{ .fde = <span class="tok-kw">switch</span> (dwarf_section) {</span>
<span class="line" id="L2474">                .eh_frame =&gt; <span class="tok-kw">try</span> math.sub(<span class="tok-type">u64</span>, start_offset, id),</span>
<span class="line" id="L2475">                .debug_frame =&gt; id,</span>
<span class="line" id="L2476">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L2477">            } },</span>
<span class="line" id="L2478">            .entry_bytes = entry_bytes,</span>
<span class="line" id="L2479">        };</span>
<span class="line" id="L2480">    }</span>
<span class="line" id="L2481">};</span>
<span class="line" id="L2482"></span>
<span class="line" id="L2483"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> CommonInformationEntry = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2484">    <span class="tok-comment">// Used in .eh_frame</span>
</span>
<span class="line" id="L2485">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> eh_id = <span class="tok-number">0</span>;</span>
<span class="line" id="L2486"></span>
<span class="line" id="L2487">    <span class="tok-comment">// Used in .debug_frame (DWARF32)</span>
</span>
<span class="line" id="L2488">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> dwarf32_id = math.maxInt(<span class="tok-type">u32</span>);</span>
<span class="line" id="L2489"></span>
<span class="line" id="L2490">    <span class="tok-comment">// Used in .debug_frame (DWARF64)</span>
</span>
<span class="line" id="L2491">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> dwarf64_id = math.maxInt(<span class="tok-type">u64</span>);</span>
<span class="line" id="L2492"></span>
<span class="line" id="L2493">    <span class="tok-comment">// Offset of the length field of this entry in the eh_frame section.</span>
</span>
<span class="line" id="L2494">    <span class="tok-comment">// This is the key that FDEs use to reference CIEs.</span>
</span>
<span class="line" id="L2495">    length_offset: <span class="tok-type">u64</span>,</span>
<span class="line" id="L2496">    version: <span class="tok-type">u8</span>,</span>
<span class="line" id="L2497">    address_size: <span class="tok-type">u8</span>,</span>
<span class="line" id="L2498">    format: Format,</span>
<span class="line" id="L2499"></span>
<span class="line" id="L2500">    <span class="tok-comment">// Only present in version 4</span>
</span>
<span class="line" id="L2501">    segment_selector_size: ?<span class="tok-type">u8</span>,</span>
<span class="line" id="L2502"></span>
<span class="line" id="L2503">    code_alignment_factor: <span class="tok-type">u32</span>,</span>
<span class="line" id="L2504">    data_alignment_factor: <span class="tok-type">i32</span>,</span>
<span class="line" id="L2505">    return_address_register: <span class="tok-type">u8</span>,</span>
<span class="line" id="L2506"></span>
<span class="line" id="L2507">    aug_str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L2508">    aug_data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L2509">    lsda_pointer_enc: <span class="tok-type">u8</span>,</span>
<span class="line" id="L2510">    personality_enc: ?<span class="tok-type">u8</span>,</span>
<span class="line" id="L2511">    personality_routine_pointer: ?<span class="tok-type">u64</span>,</span>
<span class="line" id="L2512">    fde_pointer_enc: <span class="tok-type">u8</span>,</span>
<span class="line" id="L2513">    initial_instructions: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L2514"></span>
<span class="line" id="L2515">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isSignalFrame</span>(self: CommonInformationEntry) <span class="tok-type">bool</span> {</span>
<span class="line" id="L2516">        <span class="tok-kw">for</span> (self.aug_str) |c| <span class="tok-kw">if</span> (c == <span class="tok-str">'S'</span>) <span class="tok-kw">return</span> <span class="tok-null">true</span>;</span>
<span class="line" id="L2517">        <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L2518">    }</span>
<span class="line" id="L2519"></span>
<span class="line" id="L2520">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addressesSignedWithBKey</span>(self: CommonInformationEntry) <span class="tok-type">bool</span> {</span>
<span class="line" id="L2521">        <span class="tok-kw">for</span> (self.aug_str) |c| <span class="tok-kw">if</span> (c == <span class="tok-str">'B'</span>) <span class="tok-kw">return</span> <span class="tok-null">true</span>;</span>
<span class="line" id="L2522">        <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L2523">    }</span>
<span class="line" id="L2524"></span>
<span class="line" id="L2525">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mteTaggedFrame</span>(self: CommonInformationEntry) <span class="tok-type">bool</span> {</span>
<span class="line" id="L2526">        <span class="tok-kw">for</span> (self.aug_str) |c| <span class="tok-kw">if</span> (c == <span class="tok-str">'G'</span>) <span class="tok-kw">return</span> <span class="tok-null">true</span>;</span>
<span class="line" id="L2527">        <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L2528">    }</span>
<span class="line" id="L2529"></span>
<span class="line" id="L2530">    <span class="tok-comment">/// This function expects to read the CIE starting with the version field.</span></span>
<span class="line" id="L2531">    <span class="tok-comment">/// The returned struct references memory backed by cie_bytes.</span></span>
<span class="line" id="L2532">    <span class="tok-comment">///</span></span>
<span class="line" id="L2533">    <span class="tok-comment">/// See the FrameDescriptionEntry.parse documentation for the description</span></span>
<span class="line" id="L2534">    <span class="tok-comment">/// of `pc_rel_offset` and `is_runtime`.</span></span>
<span class="line" id="L2535">    <span class="tok-comment">///</span></span>
<span class="line" id="L2536">    <span class="tok-comment">/// `length_offset` specifies the offset of this CIE's length field in the</span></span>
<span class="line" id="L2537">    <span class="tok-comment">/// .eh_frame / .debug_frame section.</span></span>
<span class="line" id="L2538">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">parse</span>(</span>
<span class="line" id="L2539">        cie_bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L2540">        pc_rel_offset: <span class="tok-type">i64</span>,</span>
<span class="line" id="L2541">        is_runtime: <span class="tok-type">bool</span>,</span>
<span class="line" id="L2542">        format: Format,</span>
<span class="line" id="L2543">        dwarf_section: DwarfSection,</span>
<span class="line" id="L2544">        length_offset: <span class="tok-type">u64</span>,</span>
<span class="line" id="L2545">        addr_size_bytes: <span class="tok-type">u8</span>,</span>
<span class="line" id="L2546">        endian: std.builtin.Endian,</span>
<span class="line" id="L2547">    ) !CommonInformationEntry {</span>
<span class="line" id="L2548">        <span class="tok-kw">if</span> (addr_size_bytes &gt; <span class="tok-number">8</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnsupportedAddrSize;</span>
<span class="line" id="L2549"></span>
<span class="line" id="L2550">        <span class="tok-kw">var</span> fbr: FixedBufferReader = .{ .buf = cie_bytes, .endian = endian };</span>
<span class="line" id="L2551"></span>
<span class="line" id="L2552">        <span class="tok-kw">const</span> version = <span class="tok-kw">try</span> fbr.readByte();</span>
<span class="line" id="L2553">        <span class="tok-kw">switch</span> (dwarf_section) {</span>
<span class="line" id="L2554">            .eh_frame =&gt; <span class="tok-kw">if</span> (version != <span class="tok-number">1</span> <span class="tok-kw">and</span> version != <span class="tok-number">3</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnsupportedDwarfVersion,</span>
<span class="line" id="L2555">            .debug_frame =&gt; <span class="tok-kw">if</span> (version != <span class="tok-number">4</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnsupportedDwarfVersion,</span>
<span class="line" id="L2556">            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnsupportedDwarfSection,</span>
<span class="line" id="L2557">        }</span>
<span class="line" id="L2558"></span>
<span class="line" id="L2559">        <span class="tok-kw">var</span> has_eh_data = <span class="tok-null">false</span>;</span>
<span class="line" id="L2560">        <span class="tok-kw">var</span> has_aug_data = <span class="tok-null">false</span>;</span>
<span class="line" id="L2561"></span>
<span class="line" id="L2562">        <span class="tok-kw">var</span> aug_str_len: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L2563">        <span class="tok-kw">const</span> aug_str_start = fbr.pos;</span>
<span class="line" id="L2564">        <span class="tok-kw">var</span> aug_byte = <span class="tok-kw">try</span> fbr.readByte();</span>
<span class="line" id="L2565">        <span class="tok-kw">while</span> (aug_byte != <span class="tok-number">0</span>) : (aug_byte = <span class="tok-kw">try</span> fbr.readByte()) {</span>
<span class="line" id="L2566">            <span class="tok-kw">switch</span> (aug_byte) {</span>
<span class="line" id="L2567">                <span class="tok-str">'z'</span> =&gt; {</span>
<span class="line" id="L2568">                    <span class="tok-kw">if</span> (aug_str_len != <span class="tok-number">0</span>) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L2569">                    has_aug_data = <span class="tok-null">true</span>;</span>
<span class="line" id="L2570">                },</span>
<span class="line" id="L2571">                <span class="tok-str">'e'</span> =&gt; {</span>
<span class="line" id="L2572">                    <span class="tok-kw">if</span> (has_aug_data <span class="tok-kw">or</span> aug_str_len != <span class="tok-number">0</span>) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L2573">                    <span class="tok-kw">if</span> (<span class="tok-kw">try</span> fbr.readByte() != <span class="tok-str">'h'</span>) <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L2574">                    has_eh_data = <span class="tok-null">true</span>;</span>
<span class="line" id="L2575">                },</span>
<span class="line" id="L2576">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">if</span> (has_eh_data) <span class="tok-kw">return</span> badDwarf(),</span>
<span class="line" id="L2577">            }</span>
<span class="line" id="L2578"></span>
<span class="line" id="L2579">            aug_str_len += <span class="tok-number">1</span>;</span>
<span class="line" id="L2580">        }</span>
<span class="line" id="L2581"></span>
<span class="line" id="L2582">        <span class="tok-kw">if</span> (has_eh_data) {</span>
<span class="line" id="L2583">            <span class="tok-comment">// legacy data created by older versions of gcc - unsupported here</span>
</span>
<span class="line" id="L2584">            <span class="tok-kw">for</span> (<span class="tok-number">0</span>..addr_size_bytes) |_| _ = <span class="tok-kw">try</span> fbr.readByte();</span>
<span class="line" id="L2585">        }</span>
<span class="line" id="L2586"></span>
<span class="line" id="L2587">        <span class="tok-kw">const</span> address_size = <span class="tok-kw">if</span> (version == <span class="tok-number">4</span>) <span class="tok-kw">try</span> fbr.readByte() <span class="tok-kw">else</span> addr_size_bytes;</span>
<span class="line" id="L2588">        <span class="tok-kw">const</span> segment_selector_size = <span class="tok-kw">if</span> (version == <span class="tok-number">4</span>) <span class="tok-kw">try</span> fbr.readByte() <span class="tok-kw">else</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L2589"></span>
<span class="line" id="L2590">        <span class="tok-kw">const</span> code_alignment_factor = <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">u32</span>);</span>
<span class="line" id="L2591">        <span class="tok-kw">const</span> data_alignment_factor = <span class="tok-kw">try</span> fbr.readIleb128(<span class="tok-type">i32</span>);</span>
<span class="line" id="L2592">        <span class="tok-kw">const</span> return_address_register = <span class="tok-kw">if</span> (version == <span class="tok-number">1</span>) <span class="tok-kw">try</span> fbr.readByte() <span class="tok-kw">else</span> <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">u8</span>);</span>
<span class="line" id="L2593"></span>
<span class="line" id="L2594">        <span class="tok-kw">var</span> lsda_pointer_enc: <span class="tok-type">u8</span> = EH.PE.omit;</span>
<span class="line" id="L2595">        <span class="tok-kw">var</span> personality_enc: ?<span class="tok-type">u8</span> = <span class="tok-null">null</span>;</span>
<span class="line" id="L2596">        <span class="tok-kw">var</span> personality_routine_pointer: ?<span class="tok-type">u64</span> = <span class="tok-null">null</span>;</span>
<span class="line" id="L2597">        <span class="tok-kw">var</span> fde_pointer_enc: <span class="tok-type">u8</span> = EH.PE.absptr;</span>
<span class="line" id="L2598"></span>
<span class="line" id="L2599">        <span class="tok-kw">var</span> aug_data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = &amp;[_]<span class="tok-type">u8</span>{};</span>
<span class="line" id="L2600">        <span class="tok-kw">const</span> aug_str = <span class="tok-kw">if</span> (has_aug_data) blk: {</span>
<span class="line" id="L2601">            <span class="tok-kw">const</span> aug_data_len = <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">usize</span>);</span>
<span class="line" id="L2602">            <span class="tok-kw">const</span> aug_data_start = fbr.pos;</span>
<span class="line" id="L2603">            aug_data = cie_bytes[aug_data_start..][<span class="tok-number">0</span>..aug_data_len];</span>
<span class="line" id="L2604"></span>
<span class="line" id="L2605">            <span class="tok-kw">const</span> aug_str = cie_bytes[aug_str_start..][<span class="tok-number">0</span>..aug_str_len];</span>
<span class="line" id="L2606">            <span class="tok-kw">for</span> (aug_str[<span class="tok-number">1</span>..]) |byte| {</span>
<span class="line" id="L2607">                <span class="tok-kw">switch</span> (byte) {</span>
<span class="line" id="L2608">                    <span class="tok-str">'L'</span> =&gt; {</span>
<span class="line" id="L2609">                        lsda_pointer_enc = <span class="tok-kw">try</span> fbr.readByte();</span>
<span class="line" id="L2610">                    },</span>
<span class="line" id="L2611">                    <span class="tok-str">'P'</span> =&gt; {</span>
<span class="line" id="L2612">                        personality_enc = <span class="tok-kw">try</span> fbr.readByte();</span>
<span class="line" id="L2613">                        personality_routine_pointer = <span class="tok-kw">try</span> readEhPointer(&amp;fbr, personality_enc.?, addr_size_bytes, .{</span>
<span class="line" id="L2614">                            .pc_rel_base = <span class="tok-kw">try</span> pcRelBase(<span class="tok-builtin">@intFromPtr</span>(&amp;cie_bytes[fbr.pos]), pc_rel_offset),</span>
<span class="line" id="L2615">                            .follow_indirect = is_runtime,</span>
<span class="line" id="L2616">                        });</span>
<span class="line" id="L2617">                    },</span>
<span class="line" id="L2618">                    <span class="tok-str">'R'</span> =&gt; {</span>
<span class="line" id="L2619">                        fde_pointer_enc = <span class="tok-kw">try</span> fbr.readByte();</span>
<span class="line" id="L2620">                    },</span>
<span class="line" id="L2621">                    <span class="tok-str">'S'</span>, <span class="tok-str">'B'</span>, <span class="tok-str">'G'</span> =&gt; {},</span>
<span class="line" id="L2622">                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> badDwarf(),</span>
<span class="line" id="L2623">                }</span>
<span class="line" id="L2624">            }</span>
<span class="line" id="L2625"></span>
<span class="line" id="L2626">            <span class="tok-comment">// aug_data_len can include padding so the CIE ends on an address boundary</span>
</span>
<span class="line" id="L2627">            fbr.pos = aug_data_start + aug_data_len;</span>
<span class="line" id="L2628">            <span class="tok-kw">break</span> :blk aug_str;</span>
<span class="line" id="L2629">        } <span class="tok-kw">else</span> &amp;[_]<span class="tok-type">u8</span>{};</span>
<span class="line" id="L2630"></span>
<span class="line" id="L2631">        <span class="tok-kw">const</span> initial_instructions = cie_bytes[fbr.pos..];</span>
<span class="line" id="L2632">        <span class="tok-kw">return</span> .{</span>
<span class="line" id="L2633">            .length_offset = length_offset,</span>
<span class="line" id="L2634">            .version = version,</span>
<span class="line" id="L2635">            .address_size = address_size,</span>
<span class="line" id="L2636">            .format = format,</span>
<span class="line" id="L2637">            .segment_selector_size = segment_selector_size,</span>
<span class="line" id="L2638">            .code_alignment_factor = code_alignment_factor,</span>
<span class="line" id="L2639">            .data_alignment_factor = data_alignment_factor,</span>
<span class="line" id="L2640">            .return_address_register = return_address_register,</span>
<span class="line" id="L2641">            .aug_str = aug_str,</span>
<span class="line" id="L2642">            .aug_data = aug_data,</span>
<span class="line" id="L2643">            .lsda_pointer_enc = lsda_pointer_enc,</span>
<span class="line" id="L2644">            .personality_enc = personality_enc,</span>
<span class="line" id="L2645">            .personality_routine_pointer = personality_routine_pointer,</span>
<span class="line" id="L2646">            .fde_pointer_enc = fde_pointer_enc,</span>
<span class="line" id="L2647">            .initial_instructions = initial_instructions,</span>
<span class="line" id="L2648">        };</span>
<span class="line" id="L2649">    }</span>
<span class="line" id="L2650">};</span>
<span class="line" id="L2651"></span>
<span class="line" id="L2652"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> FrameDescriptionEntry = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2653">    <span class="tok-comment">// Offset into eh_frame where the CIE for this FDE is stored</span>
</span>
<span class="line" id="L2654">    cie_length_offset: <span class="tok-type">u64</span>,</span>
<span class="line" id="L2655"></span>
<span class="line" id="L2656">    pc_begin: <span class="tok-type">u64</span>,</span>
<span class="line" id="L2657">    pc_range: <span class="tok-type">u64</span>,</span>
<span class="line" id="L2658">    lsda_pointer: ?<span class="tok-type">u64</span>,</span>
<span class="line" id="L2659">    aug_data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L2660">    instructions: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L2661"></span>
<span class="line" id="L2662">    <span class="tok-comment">/// This function expects to read the FDE starting at the PC Begin field.</span></span>
<span class="line" id="L2663">    <span class="tok-comment">/// The returned struct references memory backed by `fde_bytes`.</span></span>
<span class="line" id="L2664">    <span class="tok-comment">///</span></span>
<span class="line" id="L2665">    <span class="tok-comment">/// `pc_rel_offset` specifies an offset to be applied to pc_rel_base values</span></span>
<span class="line" id="L2666">    <span class="tok-comment">/// used when decoding pointers. This should be set to zero if fde_bytes is</span></span>
<span class="line" id="L2667">    <span class="tok-comment">/// backed by the memory of a .eh_frame / .debug_frame section in the running executable.</span></span>
<span class="line" id="L2668">    <span class="tok-comment">/// Otherwise, it should be the relative offset to translate addresses from</span></span>
<span class="line" id="L2669">    <span class="tok-comment">/// where the section is currently stored in memory, to where it *would* be</span></span>
<span class="line" id="L2670">    <span class="tok-comment">/// stored at runtime: section base addr - backing data base ptr.</span></span>
<span class="line" id="L2671">    <span class="tok-comment">///</span></span>
<span class="line" id="L2672">    <span class="tok-comment">/// Similarly, `is_runtime` specifies this function is being called on a runtime</span></span>
<span class="line" id="L2673">    <span class="tok-comment">/// section, and so indirect pointers can be followed.</span></span>
<span class="line" id="L2674">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">parse</span>(</span>
<span class="line" id="L2675">        fde_bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L2676">        pc_rel_offset: <span class="tok-type">i64</span>,</span>
<span class="line" id="L2677">        is_runtime: <span class="tok-type">bool</span>,</span>
<span class="line" id="L2678">        cie: CommonInformationEntry,</span>
<span class="line" id="L2679">        addr_size_bytes: <span class="tok-type">u8</span>,</span>
<span class="line" id="L2680">        endian: std.builtin.Endian,</span>
<span class="line" id="L2681">    ) !FrameDescriptionEntry {</span>
<span class="line" id="L2682">        <span class="tok-kw">if</span> (addr_size_bytes &gt; <span class="tok-number">8</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidAddrSize;</span>
<span class="line" id="L2683"></span>
<span class="line" id="L2684">        <span class="tok-kw">var</span> fbr: FixedBufferReader = .{ .buf = fde_bytes, .endian = endian };</span>
<span class="line" id="L2685"></span>
<span class="line" id="L2686">        <span class="tok-kw">const</span> pc_begin = <span class="tok-kw">try</span> readEhPointer(&amp;fbr, cie.fde_pointer_enc, addr_size_bytes, .{</span>
<span class="line" id="L2687">            .pc_rel_base = <span class="tok-kw">try</span> pcRelBase(<span class="tok-builtin">@intFromPtr</span>(&amp;fde_bytes[fbr.pos]), pc_rel_offset),</span>
<span class="line" id="L2688">            .follow_indirect = is_runtime,</span>
<span class="line" id="L2689">        }) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L2690"></span>
<span class="line" id="L2691">        <span class="tok-kw">const</span> pc_range = <span class="tok-kw">try</span> readEhPointer(&amp;fbr, cie.fde_pointer_enc, addr_size_bytes, .{</span>
<span class="line" id="L2692">            .pc_rel_base = <span class="tok-number">0</span>,</span>
<span class="line" id="L2693">            .follow_indirect = <span class="tok-null">false</span>,</span>
<span class="line" id="L2694">        }) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> badDwarf();</span>
<span class="line" id="L2695"></span>
<span class="line" id="L2696">        <span class="tok-kw">var</span> aug_data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = &amp;[_]<span class="tok-type">u8</span>{};</span>
<span class="line" id="L2697">        <span class="tok-kw">const</span> lsda_pointer = <span class="tok-kw">if</span> (cie.aug_str.len &gt; <span class="tok-number">0</span>) blk: {</span>
<span class="line" id="L2698">            <span class="tok-kw">const</span> aug_data_len = <span class="tok-kw">try</span> fbr.readUleb128(<span class="tok-type">usize</span>);</span>
<span class="line" id="L2699">            <span class="tok-kw">const</span> aug_data_start = fbr.pos;</span>
<span class="line" id="L2700">            aug_data = fde_bytes[aug_data_start..][<span class="tok-number">0</span>..aug_data_len];</span>
<span class="line" id="L2701"></span>
<span class="line" id="L2702">            <span class="tok-kw">const</span> lsda_pointer = <span class="tok-kw">if</span> (cie.lsda_pointer_enc != EH.PE.omit)</span>
<span class="line" id="L2703">                <span class="tok-kw">try</span> readEhPointer(&amp;fbr, cie.lsda_pointer_enc, addr_size_bytes, .{</span>
<span class="line" id="L2704">                    .pc_rel_base = <span class="tok-kw">try</span> pcRelBase(<span class="tok-builtin">@intFromPtr</span>(&amp;fde_bytes[fbr.pos]), pc_rel_offset),</span>
<span class="line" id="L2705">                    .follow_indirect = is_runtime,</span>
<span class="line" id="L2706">                })</span>
<span class="line" id="L2707">            <span class="tok-kw">else</span></span>
<span class="line" id="L2708">                <span class="tok-null">null</span>;</span>
<span class="line" id="L2709"></span>
<span class="line" id="L2710">            fbr.pos = aug_data_start + aug_data_len;</span>
<span class="line" id="L2711">            <span class="tok-kw">break</span> :blk lsda_pointer;</span>
<span class="line" id="L2712">        } <span class="tok-kw">else</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L2713"></span>
<span class="line" id="L2714">        <span class="tok-kw">const</span> instructions = fde_bytes[fbr.pos..];</span>
<span class="line" id="L2715">        <span class="tok-kw">return</span> .{</span>
<span class="line" id="L2716">            .cie_length_offset = cie.length_offset,</span>
<span class="line" id="L2717">            .pc_begin = pc_begin,</span>
<span class="line" id="L2718">            .pc_range = pc_range,</span>
<span class="line" id="L2719">            .lsda_pointer = lsda_pointer,</span>
<span class="line" id="L2720">            .aug_data = aug_data,</span>
<span class="line" id="L2721">            .instructions = instructions,</span>
<span class="line" id="L2722">        };</span>
<span class="line" id="L2723">    }</span>
<span class="line" id="L2724">};</span>
<span class="line" id="L2725"></span>
<span class="line" id="L2726"><span class="tok-kw">fn</span> <span class="tok-fn">pcRelBase</span>(field_ptr: <span class="tok-type">usize</span>, pc_rel_offset: <span class="tok-type">i64</span>) !<span class="tok-type">usize</span> {</span>
<span class="line" id="L2727">    <span class="tok-kw">if</span> (pc_rel_offset &lt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L2728">        <span class="tok-kw">return</span> math.sub(<span class="tok-type">usize</span>, field_ptr, <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(-pc_rel_offset)));</span>
<span class="line" id="L2729">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2730">        <span class="tok-kw">return</span> math.add(<span class="tok-type">usize</span>, field_ptr, <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(pc_rel_offset)));</span>
<span class="line" id="L2731">    }</span>
<span class="line" id="L2732">}</span>
<span class="line" id="L2733"></span>
<span class="line" id="L2734"><span class="tok-comment">// Reading debug info needs to be fast, even when compiled in debug mode,</span>
</span>
<span class="line" id="L2735"><span class="tok-comment">// so avoid using a `std.io.FixedBufferStream` which is too slow.</span>
</span>
<span class="line" id="L2736"><span class="tok-kw">const</span> FixedBufferReader = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2737">    buf: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L2738">    pos: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,</span>
<span class="line" id="L2739">    endian: std.builtin.Endian,</span>
<span class="line" id="L2740"></span>
<span class="line" id="L2741">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Error = <span class="tok-kw">error</span>{ EndOfBuffer, Overflow };</span>
<span class="line" id="L2742"></span>
<span class="line" id="L2743">    <span class="tok-kw">fn</span> <span class="tok-fn">seekTo</span>(fbr: *FixedBufferReader, pos: <span class="tok-type">u64</span>) Error!<span class="tok-type">void</span> {</span>
<span class="line" id="L2744">        <span class="tok-kw">if</span> (pos &gt; fbr.buf.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.EndOfBuffer;</span>
<span class="line" id="L2745">        fbr.pos = <span class="tok-builtin">@intCast</span>(pos);</span>
<span class="line" id="L2746">    }</span>
<span class="line" id="L2747"></span>
<span class="line" id="L2748">    <span class="tok-kw">fn</span> <span class="tok-fn">seekForward</span>(fbr: *FixedBufferReader, amount: <span class="tok-type">u64</span>) Error!<span class="tok-type">void</span> {</span>
<span class="line" id="L2749">        <span class="tok-kw">if</span> (fbr.buf.len - fbr.pos &lt; amount) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.EndOfBuffer;</span>
<span class="line" id="L2750">        fbr.pos += <span class="tok-builtin">@intCast</span>(amount);</span>
<span class="line" id="L2751">    }</span>
<span class="line" id="L2752"></span>
<span class="line" id="L2753">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">readByte</span>(fbr: *FixedBufferReader) Error!<span class="tok-type">u8</span> {</span>
<span class="line" id="L2754">        <span class="tok-kw">if</span> (fbr.pos &gt;= fbr.buf.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.EndOfBuffer;</span>
<span class="line" id="L2755">        <span class="tok-kw">defer</span> fbr.pos += <span class="tok-number">1</span>;</span>
<span class="line" id="L2756">        <span class="tok-kw">return</span> fbr.buf[fbr.pos];</span>
<span class="line" id="L2757">    }</span>
<span class="line" id="L2758"></span>
<span class="line" id="L2759">    <span class="tok-kw">fn</span> <span class="tok-fn">readByteSigned</span>(fbr: *FixedBufferReader) Error!<span class="tok-type">i8</span> {</span>
<span class="line" id="L2760">        <span class="tok-kw">return</span> <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">try</span> fbr.readByte());</span>
<span class="line" id="L2761">    }</span>
<span class="line" id="L2762"></span>
<span class="line" id="L2763">    <span class="tok-kw">fn</span> <span class="tok-fn">readInt</span>(fbr: *FixedBufferReader, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) Error!T {</span>
<span class="line" id="L2764">        <span class="tok-kw">const</span> size = <span class="tok-builtin">@divExact</span>(<span class="tok-builtin">@typeInfo</span>(T).Int.bits, <span class="tok-number">8</span>);</span>
<span class="line" id="L2765">        <span class="tok-kw">if</span> (fbr.buf.len - fbr.pos &lt; size) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.EndOfBuffer;</span>
<span class="line" id="L2766">        <span class="tok-kw">defer</span> fbr.pos += size;</span>
<span class="line" id="L2767">        <span class="tok-kw">return</span> mem.readInt(T, fbr.buf[fbr.pos..][<span class="tok-number">0</span>..size], fbr.endian);</span>
<span class="line" id="L2768">    }</span>
<span class="line" id="L2769"></span>
<span class="line" id="L2770">    <span class="tok-kw">fn</span> <span class="tok-fn">readUleb128</span>(fbr: *FixedBufferReader, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) Error!T {</span>
<span class="line" id="L2771">        <span class="tok-kw">return</span> std.leb.readULEB128(T, fbr);</span>
<span class="line" id="L2772">    }</span>
<span class="line" id="L2773"></span>
<span class="line" id="L2774">    <span class="tok-kw">fn</span> <span class="tok-fn">readIleb128</span>(fbr: *FixedBufferReader, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) Error!T {</span>
<span class="line" id="L2775">        <span class="tok-kw">return</span> std.leb.readILEB128(T, fbr);</span>
<span class="line" id="L2776">    }</span>
<span class="line" id="L2777"></span>
<span class="line" id="L2778">    <span class="tok-kw">fn</span> <span class="tok-fn">readAddress</span>(fbr: *FixedBufferReader, format: Format) Error!<span class="tok-type">u64</span> {</span>
<span class="line" id="L2779">        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (format) {</span>
<span class="line" id="L2780">            .@&quot;32&quot; =&gt; <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u32</span>),</span>
<span class="line" id="L2781">            .@&quot;64&quot; =&gt; <span class="tok-kw">try</span> fbr.readInt(<span class="tok-type">u64</span>),</span>
<span class="line" id="L2782">        };</span>
<span class="line" id="L2783">    }</span>
<span class="line" id="L2784"></span>
<span class="line" id="L2785">    <span class="tok-kw">fn</span> <span class="tok-fn">readBytes</span>(fbr: *FixedBufferReader, len: <span class="tok-type">usize</span>) Error![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L2786">        <span class="tok-kw">if</span> (fbr.buf.len - fbr.pos &lt; len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.EndOfBuffer;</span>
<span class="line" id="L2787">        <span class="tok-kw">defer</span> fbr.pos += len;</span>
<span class="line" id="L2788">        <span class="tok-kw">return</span> fbr.buf[fbr.pos..][<span class="tok-number">0</span>..len];</span>
<span class="line" id="L2789">    }</span>
<span class="line" id="L2790"></span>
<span class="line" id="L2791">    <span class="tok-kw">fn</span> <span class="tok-fn">readBytesTo</span>(fbr: *FixedBufferReader, <span class="tok-kw">comptime</span> sentinel: <span class="tok-type">u8</span>) Error![:sentinel]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L2792">        <span class="tok-kw">const</span> end = <span class="tok-builtin">@call</span>(.always_inline, mem.indexOfScalarPos, .{</span>
<span class="line" id="L2793">            <span class="tok-type">u8</span>,</span>
<span class="line" id="L2794">            fbr.buf,</span>
<span class="line" id="L2795">            fbr.pos,</span>
<span class="line" id="L2796">            sentinel,</span>
<span class="line" id="L2797">        }) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.EndOfBuffer;</span>
<span class="line" id="L2798">        <span class="tok-kw">defer</span> fbr.pos = end + <span class="tok-number">1</span>;</span>
<span class="line" id="L2799">        <span class="tok-kw">return</span> fbr.buf[fbr.pos..end :sentinel];</span>
<span class="line" id="L2800">    }</span>
<span class="line" id="L2801">};</span>
<span class="line" id="L2802"></span>
<span class="line" id="L2803"><span class="tok-kw">test</span> {</span>
<span class="line" id="L2804">    std.testing.refAllDecls(<span class="tok-builtin">@This</span>());</span>
<span class="line" id="L2805">}</span>
<span class="line" id="L2806"></span>
</code></pre></body>
</html>